<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<!-- ▼▼▼ 用这整块代码替换掉你旧的meta和icon链接 ▼▼▼ -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">


<!-- 1. (核心) 为苹果设备设置主屏幕图标 -->
<link rel="apple-touch-icon" href="https://youke1.picui.cn/s1/2025/10/08/68e642ef803b3.jpg">
<link rel="apple-touch-icon" sizes="152x152" href="https://youke1.picui.cn/s1/2025/10/08/68e642ef803b3.jpg">
<link rel="apple-touch-icon" sizes="180x180" href="https://youke1.picui.cn/s1/2025/10/08/68e642ef803b3.jpg">
<link rel="apple-touch-icon" sizes="167x167" href="https://youke1.picui.cn/s1/2025/10/08/68e642ef803b3.jpg">

<!-- 2. (核心) 链接到manifest文件 -->
<link rel="manifest" href="manifest.json">

<!-- 3. (核心) 告诉苹果设备，这是一个Web应用，可以全屏显示 -->
<meta name="apple-mobile-web-app-capable" content="yes">

<!-- 4. (核心) 设置苹果设备全屏模式下的状态栏样式 -->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- 5. (可选) 设置应用在主屏幕上显示的标题 -->
<meta name="apple-mobile-web-app-title" content="EPhone（猫猫宁版）">

<!-- 6. (兼容) 为部分安卓浏览器提供支持 -->
<meta name="mobile-web-app-capable" content="yes">
<!-- 7. (备用) 标准浏览器页签图标 -->
<link rel="icon" type="image/png" href="https://youke1.picui.cn/s1/2025/10/08/68e642ef803b3.jpg">
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- JSZip库 - 用于解压NovelAI返回的ZIP图片 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>


    <title>EPhone（猫猫宁版）</title>



    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <script src="https://phoebeboo.github.io/mewoooo/pp.js" defer></script>
    <style>
        :root { --screen-width: 350px; --screen-height: 650px; --secondary-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #1f1f1f; --text-secondary: #8a8a8a; --accent-color: #007bff;    --status-bar-text-color: var(--accent-color); }
/* ▼▼▼ 用这块终极代码，替换掉你现有的 html 和 body 样式 ▼▼▼ */
html {
    -webkit-text-size-adjust: 100%;
    height: 100%; /* 确保html元素也能撑满 */
}

body {
    margin: 0;
    font-family: 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    font-weight: normal;
    background-color: #f0f2f5;
    height: 100%; /* 让body也撑满父元素(html) */
    overflow: hidden; /* 防止body本身出现滚动条 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* 2. 让 #phone-screen 成为新的“根”容器，撑满整个浏览器窗口 */
/* ▼▼▼ 请用这块【最终修正版】的代码，替换掉你现有的 #phone-screen 样式 ▼▼▼ */
#phone-screen {
    width: 100%;
    height: 100vh;
    position: relative;
    top: 0px; /* 向上移动20px，避免状态栏内容露出 */
    overflow: hidden;
    display: flex;
    flex-direction: column;
    background-color: #ffffff; /* ★ 修改这里为白色 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* 3. 【核心】隐藏掉模拟器的状态栏 */
#status-bar {
    display: none;
}

/* 4. 【核心】让所有页面的头部自动适应iPhone的“刘海”安全区 */
.header, .qzone-header {
    /* 使用 env(safe-area-inset-top) 自动获取顶部安全距离 */
    padding-top: calc(15px + env(safe-area-inset-top));
}

/* 5. 【核心】让聊天输入框和底部导航栏自动适应iPhone底部的"小黑条"安全区 */
#chat-input-area {
    padding-bottom: calc(8px + env(safe-area-inset-bottom));
}

#chat-list-bottom-nav {
     padding-bottom: env(safe-area-inset-bottom);
}

/* ▲▲▲ 替换结束 ▲▲▲ */

      /* 修改后的代码块 */
/* ▼▼▼ 用这整块【可爱圆润版】代码，替换掉所有旧的 status-bar 和 battery 样式 ▼▼▼ */

#status-bar { 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    padding: 12px 20px; 
    display: none; 
    justify-content: space-between; 
    align-items: center; 
    color: var(--accent-color); /* ★ 修改：状态栏文字/图标颜色，现在会跟随主题色！ */
    z-index: 10; 
    font-size: 14px; 
    box-sizing: border-box; 
    pointer-events: none; 
    /* ★ 新增：使用你的自定义字体，并加上柔和的光晕，让它更可爱 */
    font-family: 'bulangni', sans-serif; 
    text-shadow: 0 0 8px rgba(255, 255, 255, 0.5); 
}

#status-bar-time { 
    font-weight: 600; 
}

.battery-container { 
    display: flex; 
    align-items: center; 
    gap: 5px; 
}

.battery-icon { 
    width: 25px; 
    height: 12px; 
    border: 1.5px solid currentColor; /* ★ 边框加粗一点点 */
    border-radius: 5px; /* ★ 修改：增加圆角，让它更圆润可爱 */
    position: relative; 
    padding: 1px; 
}

.battery-icon::after { 
    content: ''; 
    position: absolute; 
    right: -4px; /* 微调位置 */
    top: 2.5px; 
    width: 2px; 
    height: 5px; 
    background-color: currentColor; 
    border-radius: 0 2px 2px 0; /* ★ 头部小块也变圆润 */
}

.battery-level { 
    height: 100%; 
    background-color: currentColor; /* ★ 默认填充色也跟随主题色 */
    border-radius: 3px; /* ★ 内部填充条也变圆润 */
    transition: width 0.5s ease; 
}

/* ★ 核心修改：让充电时也显示主题色！ */
.battery-container.charging .battery-level { 
    animation: charge-breath 2s infinite; 
}
@keyframes charge-breath { 
    0%, 100% { opacity: 1; } 
    50% { opacity: 0.7; } 
}
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 【终极修正版】请用这块代码完整替换掉所有旧的 .screen 样式 ▼▼▼ */
.screen {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;  /* ★ 新增 */
    bottom: 0; /* ★ 新增 */
    width: 100%; /* 保留 */
    /* height: 100%; */ /* ★ 注释或删除掉这一行 */

    display: flex;
    flex-direction: column;
    overflow: hidden;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▲▲▲ 替换结束 ▲▲▲ */

        .screen.active { opacity: 1; visibility: visible; z-index: 1; }
       .header {
    position: relative;
    z-index: 15;
    flex-shrink: 0;
    padding: 15px 15px;
    padding-top: 45px;
    background-color: rgba(247, 247, 247, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    
    /* ▼▼▼ 新增下面这两行 ▼▼▼ */
    height: 110px;               /* ★ 新增：强制设置一个统一的高度 */
    box-sizing: border-box;     /* ★ 新增：确保高度计算包含内边距 */
    /* ▲▲▲ 新增结束 ▲▲▲ */
}

        .header .header-actions { display: flex; align-items: center; gap: 5px; }
        /* ▼▼▼ 【触摸区域优化版】替换旧的 .header .back-btn, .header .action-btn 样式 ▼▼▼ */
.header .back-btn, .header .action-btn {
    font-size: 24px; /* 保持图标大小不变 */
    cursor: pointer;
    color: var(--accent-color);
    display: flex;
    align-items: center;
    justify-content: center;

    /* --- 核心修改从这里开始 --- */
    width: 40px;              /* 1. 将按钮宽度从30px增加到40px */
    height: 40px;             /* 2. 将按钮高度从30px增加到40px */
    border-radius: 50%;       /* 3. (可选但推荐) 让按钮变成圆形，更美观 */
    transition: background-color 0.2s; /* 4. 为悬停效果添加平滑动画 */
}

/* 【新增】为按钮添加悬停/点击时的背景色，给用户明确的反馈 */
.header .back-btn:hover, .header .action-btn:hover {
    background-color: rgba(0, 0, 0, 0.05); /* 鼠标放上去时给一个淡淡的背景 */
}
#phone-screen.dark-mode .header .back-btn:hover,
#phone-screen.dark-mode .header .action-btn:hover {
    background-color: rgba(255, 255, 255, 0.1); /* 夜间模式下的悬停颜色 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

.header .action-btn {
    font-size: 16px; /* 专门为“上传”、“+”等文字按钮缩小字号 */
    font-weight: 600; /* 可以加粗一点让它更清晰 */
}

        .header .action-btn img { height: 26px; }
        .header .save-btn { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; }

/* 管理分类按钮横排显示 */
#manage-world-book-categories-btn {
    writing-mode: horizontal-tb !important;
    width: auto !important;
    white-space: nowrap;
}

/* 世界书标签导航样式 */
.world-book-tabs {
    display: flex;
    background: var(--bg-color);
    border-bottom: 1px solid var(--border-color);
    padding: 0;
}

.tab-button {
    flex: 1;
    padding: 15px 20px;
    text-align: center;
    background: var(--bg-color);
    color: var(--text-color);
    cursor: pointer;
    border: none;
    border-bottom: 3px solid transparent;
    transition: all 0.3s ease;
    font-size: 16px;
    font-weight: 500;
}

.tab-button:hover {
    background: var(--hover-color);
}

.tab-button.active {
    color: var(--accent-color);
    border-bottom-color: var(--accent-color);
    background: var(--bg-color);
    font-weight: 600;
}

/* 世界书页面样式 */
.world-book-page {
    display: none;
    flex-direction: column;
    flex: 1; /* 占据剩余空间 */
    overflow: hidden; /* 不自己滚动，让内部列表滚动 */
    min-height: 0; /* Flex布局滚动兼容性 */
}

.world-book-page.active {
    display: flex;
}

.page-header-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    padding: 15px 20px;
    background: var(--bg-color);
    border-bottom: 1px solid var(--border-color);
}

.page-header-actions .action-btn {
    padding: 8px 15px;
    background: var(--accent-color);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
}

.page-header-actions .action-btn:hover {
    background: var(--accent-hover-color);
    transform: translateY(-1px);
}

#local-world-book-list,
#global-world-book-list {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    min-height: 0; /* Flex布局滚动兼容性 */
}

/* 全局世界书和局部世界书的区分样式 */
.wb-section-header {
    padding: 15px 20px;
    background: var(--accent-color);
    color: white;
    font-weight: 600;
    font-size: 16px;
    text-align: center;
    margin: 10px 0;
    border-radius: 8px;
}

.global-books-header {
    background: linear-gradient(135deg, #4CAF50, #45a049);
}

.global-books-header span {
    color: white !important;
    font-weight: 600;
}

.global-book-label {
    opacity: 0.9;
    background: rgba(76, 175, 80, 0.1);
    border-radius: 6px;
    padding: 8px;
    margin: 4px 0;
}

.global-book-checkbox {
    cursor: not-allowed !important;
}

.global-book-name {
    color: var(--text-color);
    font-style: italic;
}

.global-books-container {
    border-left: 3px solid #4CAF50;
    padding-left: 15px;
    margin-left: 10px;
}
/* ▼▼▼ 【终极合并修正版】请用这块代码完整替换掉旧的 #home-screen, #clock-container, .app-grid 样式 ▼▼▼ */
        
/* 1. (核心) 为锁屏和主屏幕应用相同的全屏布局 (此部分保持不变) */
#lock-screen, 
#home-screen {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    
    /* 用padding把内容挤进来，同时让背景铺满安全区 */
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: 20px;
    padding-right: 20px;
    
    box-sizing: border-box;
}

/* 2. (核心) 单独处理锁屏的文字，让它自动贴底 (这是本次的唯一修改) */
#lock-screen-content {
    margin-top: auto; /* 关键：自动将此元素推到容器底部 */
    margin-bottom: 40px; /* ★ 核心修正：使用 margin-bottom 向上推开，而不是padding */
    text-align: center;
    color: white;
    text-shadow: 0 2px 6px rgba(0,0,0,0.5);
    font-size: 16px;
    font-weight: 500;
}

/* 3. 保持主屏幕的时钟和App图标布局不变 */
#clock-container {
    text-align: center;
    color: white;
    text-shadow: 0 3px 8px rgba(0,0,0,0.4);
    margin-bottom: 20px;
    flex-shrink: 0;
    margin-top: 60px; 
}
.app-grid {
    margin-top: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    width: 100%;
    padding: 20px;
    margin-bottom: 30px; 
}
/* ▲▲▲ 替换结束 ▲▲▲ */



        .app-row { display: flex; justify-content: center; gap: 25px; width: 100%; }
        .app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-size: 14px; font-weight: 500; text-align: center; }
        .app-icon .icon-bg { width: 65px; height: 65px; border-radius: 18px; background-color: var(--secondary-bg); display: flex; justify-content: center; align-items: center; font-size: 32px; margin-bottom: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: transform 0.2s ease; overflow: hidden; }
        .app-icon:active .icon-bg { transform: scale(0.9); }
        .app-icon .icon-bg img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon .label { color: white; }
        .form-container, .list-container { padding: 20px; overflow-y: auto; flex-grow: 1; display:flex; flex-direction: column; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; color: #333 !important; }
        
        /* 红包弹窗和投票弹窗输入框样式修复 */
        #red-packet-modal .form-group label,
        #create-poll-modal .form-group label {
            color: #666 !important;
        }
        
        #red-packet-modal .form-group input,
        #red-packet-modal .form-group select,
        #red-packet-modal .form-group textarea,
        #create-poll-modal .form-group input,
        #create-poll-modal .form-group select,
        #create-poll-modal .form-group textarea {
            color: #333 !important;
            background-color: #f8f9fa !important;
            border: 1px solid #ddd !important;
        }
        
        #red-packet-modal .form-group input::placeholder,
        #red-packet-modal .form-group textarea::placeholder,
        #create-poll-modal .form-group input::placeholder,
        #create-poll-modal .form-group textarea::placeholder {
            color: #999 !important;
        }
        
        /* 投票选项输入框样式修复 */
        .poll-option-input-wrapper input {
            color: #333 !important;
            background-color: #f8f9fa !important;
            border: 1px solid #ddd !important;
        }
        
        .poll-option-input-wrapper input::placeholder {
            color: #999 !important;
        }
        
        /* 红包详情模态框文字颜色修复 */
        #red-packet-details-modal .modal-body {
            color: #333 !important;
        }
        
        #red-packet-details-modal #rp-details-greeting {
            color: #333 !important;
        }
        
        #red-packet-details-modal #rp-details-summary {
            color: #666 !important;
        }
        
        /* 红包和投票弹窗标题颜色修复 */
        #red-packet-modal .modal-header span,
        #create-poll-modal .modal-header span {
            color: #333 !important;
        }
        
        /* 投票弹窗按钮文字颜色修复 */
        #create-poll-modal #add-poll-option-btn {
            color: #333 !important;
        }
        
        /* 红包弹窗金额显示文字颜色修复 */
        #red-packet-modal #rp-group-total,
        #red-packet-modal #rp-direct-total {
            color: #333 !important;
        }
        
        /* 外观设置页面表单元素颜色修复 */
        #wallpaper-screen .form-group label {
            color: #666 !important;
        }
        
        #wallpaper-screen .form-group input,
        #wallpaper-screen .form-group select,
        #wallpaper-screen .form-group textarea {
            color: #333 !important;
            background-color: #f8f9fa !important;
            border: 1px solid #ddd !important;
        }
        
        #wallpaper-screen .form-group input::placeholder,
        #wallpaper-screen .form-group textarea::placeholder {
            color: #999 !important;
        }
        
        /* 外观设置页面特殊元素颜色修复 */
        #wallpaper-screen #theme-css-editor {
            color: #333 !important;
            background-color: #f8f9fa !important;
        }
        
        /* 外观设置页面分区标题颜色修复 */
        #wallpaper-screen label[style*="font-weight: 500"] {
            color: #666 !important;
        }
        
        /* 外观设置页面开关文字颜色修复 */
        #wallpaper-screen .toggle-switch-text {
            color: #333 !important;
        }
        
        /* 外观设置页面按钮文字颜色修复 */
        #wallpaper-screen .form-button,
        #wallpaper-screen .form-button-secondary,
        #wallpaper-screen .preset-btn-capsule {
            color: #333 !important;
        }
        
        /* 世界书分类管理弹窗颜色修复 */
        #world-book-category-manager-modal .form-group label {
            color: #666 !important;
        }
        
        #world-book-category-manager-modal .form-group input,
        #world-book-category-manager-modal .form-group select,
        #world-book-category-manager-modal .form-group textarea {
            color: #333 !important;
            background-color: #f8f9fa !important;
            border: 1px solid #ddd !important;
        }
        
        #world-book-category-manager-modal .form-group input::placeholder,
        #world-book-category-manager-modal .form-group textarea::placeholder {
            color: #999 !important;
        }
        
        /* 发动态弹窗颜色修复 */
        #create-post-modal .form-group label {
            color: #666 !important;
        }
        
        #create-post-modal .form-group input,
        #create-post-modal .form-group select,
        #create-post-modal .form-group textarea {
            color: #333 !important;
            background-color: #f8f9fa !important;
            border: 1px solid #ddd !important;
        }
        
        #create-post-modal .form-group input::placeholder,
        #create-post-modal .form-group textarea::placeholder {
            color: #999 !important;
        }
        
        #create-post-modal .toggle-switch-text {
            color: #333 !important;
        }
        
        /* 添加NPC弹窗（persona编辑器）颜色修复 */
        #persona-editor-modal .form-group label {
            color: #666 !important;
        }
        
        #persona-editor-modal .form-group input,
        #persona-editor-modal .form-group select,
        #persona-editor-modal .form-group textarea {
            color: #333 !important;
            background-color: #f8f9fa !important;
            border: 1px solid #ddd !important;
        }
        
        #persona-editor-modal .form-group input::placeholder,
        #persona-editor-modal .form-group textarea::placeholder {
            color: #999 !important;
        }
        
        /* 管理好友分组弹窗颜色修复 */
        #group-management-modal .form-group label {
            color: #666 !important;
        }
        
        #group-management-modal .form-group input,
        #group-management-modal .form-group select,
        #group-management-modal .form-group textarea {
            color: #333 !important;
            background-color: #f8f9fa !important;
            border: 1px solid #ddd !important;
        }
        
        #group-management-modal .form-group input::placeholder,
        #group-management-modal .form-group textarea::placeholder {
            color: #999 !important;
        }
        .form-group textarea { min-height: 80px; resize: vertical; }
        #world-book-content-input { height: calc(100% - 120px); }
        .form-button { width: 100%; padding: 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-button-secondary { background-color: #f0f0f0; color: var(--text-primary); border: 1px solid var(--border-color); }
        /* API设置输入框占位符样式修复 */
        #proxy-url::placeholder, #api-key::placeholder { color: #999 !important; opacity: 1; }
        #proxy-url::-webkit-input-placeholder, #api-key::-webkit-input-placeholder { color: #999 !important; }
        #proxy-url::-moz-placeholder, #api-key::-moz-placeholder { color: #999 !important; opacity: 1; }
        
        /* API设置页面所有输入框和下拉框统一灰色背景 */
        #api-settings-screen .form-group input,
        #api-settings-screen .form-group select,
        #api-settings-screen .form-group textarea,
        #api-settings-screen input[type="number"] {
            background-color: #f8f9fa !important;
            border: 1px solid #ccc !important;
        }

        /* 外卖代付、分享链接、发送定位弹窗颜色修复 */
        #waimai-request-modal .modal-header span,
        #share-link-modal .modal-header span,
        #send-location-modal .modal-header span {
            color: #333 !important;
        }

        #waimai-request-modal .form-group label,
        #share-link-modal .form-group label,
        #send-location-modal .form-group label {
            color: #555 !important;
        }

        #waimai-request-modal .form-group input,
        #waimai-request-modal .form-group textarea,
        #share-link-modal .form-group input,
        #share-link-modal .form-group textarea,
        #send-location-modal .form-group input,
        #send-location-modal .form-group textarea {
            color: #333 !important;
            background-color: #f8f9fa !important;
            border: 1px solid #ddd !important;
        }

        #waimai-request-modal .form-group input::placeholder,
        #waimai-request-modal .form-group textarea::placeholder,
        #share-link-modal .form-group input::placeholder,
        #share-link-modal .form-group textarea::placeholder,
        #send-location-modal .form-group input::placeholder,
        #send-location-modal .form-group textarea::placeholder {
            color: #999 !important;
        }

        /* 世界书编辑页面字体颜色修复 */
        #world-book-editor-screen .form-group label {
            color: #333 !important;
        }

        #world-book-editor-screen .form-group input,
        #world-book-editor-screen .form-group select,
        #world-book-editor-screen .form-group textarea {
            color: #333 !important;
            background-color: #f8f9fa !important;
            border: 1px solid #ddd !important;
        }

        #world-book-editor-screen .form-group input::placeholder,
        #world-book-editor-screen .form-group textarea::placeholder {
            color: #999 !important;
        }

        #world-book-editor-screen .header span {
            color: #333 !important;
        }
        
        /* 聊天设置模态框样式修复 */
        #chat-settings-modal .modal-content { background-color: #fff !important; }
        #chat-settings-modal .form-group label { color: #333 !important; }
        #chat-settings-modal .form-group input, 
        #chat-settings-modal .form-group select, 
        #chat-settings-modal .form-group textarea { 
            background-color: #fff !important; 
            color: #333 !important; 
            border: 1px solid #ddd !important; 
        }
        #chat-settings-modal .modal-header { color: #333 !important; border-bottom-color: #ddd !important; }
        #chat-settings-modal .modal-body { color: #333 !important; }
        #chat-settings-modal .form-button, #chat-settings-modal button { color: #333 !important; }
        #chat-settings-modal .form-button-secondary { background-color: #f0f0f0 !important; color: #333 !important; border-color: #ddd !important; }
        #chat-settings-modal .custom-multiselect .select-box { background-color: #fff !important; color: #333 !important; border-color: #ddd !important; }
        #chat-settings-modal .checkboxes-container { background-color: #fff !important; color: #333 !important; border-color: #ddd !important; }
        #chat-settings-modal .toggle-switch-text { color: #333 !important; }

        /* 商品编辑器弹窗样式修复 */
        #product-editor-modal .modal-content { background-color: #fff !important; }
        #product-editor-modal .modal-header { color: #333 !important; border-bottom-color: #ddd !important; }
        #product-editor-modal .modal-body { color: #333 !important; }
        #product-editor-modal .form-group label { color: #666 !important; }
        #product-editor-modal .form-group input, 
        #product-editor-modal .form-group textarea { 
            background-color: #fff !important; 
            color: #333 !important; 
            border: 1px solid #999 !important; 
        }
        #product-editor-modal .modal-footer button { color: #333 !important; }
        
        /* 编辑群成员弹窗样式修复 */
        #member-settings-modal .modal-content { background-color: #fff !important; }
        #member-settings-modal .modal-header { color: #333 !important; border-bottom-color: #ddd !important; }
        #member-settings-modal .modal-header span { color: #333 !important; }
        #member-settings-modal .modal-body { color: #333 !important; }
        #member-settings-modal .form-group label { color: #666 !important; }
        #member-settings-modal .form-group input, 
        #member-settings-modal .form-group textarea { 
            background-color: #fff !important; 
            color: #333 !important; 
            border: 1px solid #999 !important; 
        }
        #member-settings-modal .modal-footer button { color: #333 !important; }
        
        #wallpaper-screen .form-container { align-items: center; }
        #wallpaper-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: var(--secondary-bg); margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #wallpaper-upload-input { display: none; }
/* 修改后的 #world-book-list 样式 */
#world-book-list {
    flex-grow: 1;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    padding-top: 80px;
    margin-top: -80px;
}


/* 修改后的 #chat-list 样式，适配了iOS底部安全区 */
#chat-list {
    flex-grow: 1;
    background-color: var(--secondary-bg);
    padding-top: 110px; 
    /* 核心修复：使用 calc() 动态计算底部内边距，
       50px是为底部导航栏预留的高度，
       env(safe-area-inset-bottom)会自动获取iPhone底部小黑条的安全距离。
    */
    padding-bottom: calc(50px + env(safe-area-inset-bottom)); 
    box-sizing: border-box;
}


        .list-item { display: flex; flex-direction: column; padding: 12px 20px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
.list-item:hover { background-color: #f5f5f5; }
.list-item .item-title { font-weight: 500; font-size: 16px; margin-bottom: 5px; }
.list-item .item-content { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

/* 全局世界书开关样式 */
.global-wb-switch {
    position: absolute;
    top: 12px;
    right: 15px;
    width: 44px;
    height: 24px;
    cursor: pointer;
    z-index: 10;
}

.global-wb-switch .switch-track {
    width: 100%;
    height: 100%;
    border-radius: 12px;
    background-color: #ccc;
    transition: background-color 0.3s ease;
    position: relative;
}

.global-wb-switch.enabled .switch-track {
    background-color: #666666;
}

.global-wb-switch .switch-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: white;
    position: absolute;
    top: 2px;
    left: 2px;
    transition: transform 0.3s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.global-wb-switch.enabled .switch-thumb {
    transform: translateX(20px);
}

.global-wb-switch:hover .switch-track {
    opacity: 0.8;
}
        .chat-list-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
        .chat-list-item:hover { background-color: #f5f5f5; }
        .chat-list-item .avatar { width: 45px; height: 45px; border-radius: 50%; margin-right: 12px; object-fit: cover; background-color: #ccc; }
        .chat-list-item .info { flex-grow: 1; overflow: hidden; }
        .chat-list-item .name-line { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
        .chat-list-item .name { font-weight: 500; color: var(--text-primary); }
        .chat-list-item .group-tag { font-size: 10px; color: var(--accent-color); background-color: #e7f3ff; padding: 2px 6px; border-radius: 4px; font-weight: bold; flex-shrink: 0; }
        .chat-list-item .last-msg { font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        /* 修改后的代码 */
#chat-interface-screen { 
    background-size: cover; 
    background-position: center; 
}

        #selection-cancel-btn, #selection-delete-btn { font-size: 16px; color: var(--accent-color); cursor: pointer; padding: 5px; }
        #selection-delete-btn { color: #ff3b30; }

/* ▼▼▼ 用这块代码替换掉你原来的 #chat-messages 样式 ▼▼▼ */
#chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    overflow-x: hidden; /* 核心修正1: 强制禁止水平滚动/拖动 */
    padding: 10px 15px; /* 核心修正2: 将左右内边距增加到15px，提供更多呼吸空间 */
    padding-top: 110px;
    margin-top: -80px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    box-sizing: border-box; /* 确保内边距计算正确 */
}

/* ▲▲▲ 替换结束 ▲▲▲ */
        #load-more-btn { text-align: center; padding: 10px; color: var(--accent-color); font-size: 14px; cursor: pointer; background-color: transparent; border: none; width: 100%; }
        #load-more-btn:hover { text-decoration: underline; }

        .sender-name { font-size: 11px; color: #666; margin-bottom: 3px; }

.message-wrapper.ai .sender-name {
    margin-left: 50px; /* 稍微调整，与头像对齐 */
    margin-bottom: 3px;
    position: absolute; /* 让它脱离流，避免影响气泡对齐 */
    top: -16px;       /* 定位到气泡上方 */
    left: 0;
}

/* === 【全新】消息布局与时间戳样式 === */

/* 1. 消息单元的总容器 (重构) */
.message-wrapper {
    display: flex;          /* 使用Flex布局 */
    gap: 8px;               /* 气泡和时间戳之间的间距 */
    align-items: flex-end;  /* 核心：让气泡和时间戳底部对齐 */
    position: relative;
    max-width: 90%;         /* 可以稍微放宽一点，因为时间戳现在在外面了 */
}

/* 2. AI消息单元靠左 */
.message-wrapper.ai {
    align-self: flex-start;
    flex-direction: row; /* 头像、气泡、时间戳，从左到右排列 */
}

/* 3. 用户消息单元靠右 */
.message-wrapper.user {
    align-self: flex-end;
    flex-direction: row-reverse; /* 时间戳、气泡、头像，从右到左排列 */
}

/* 4. 气泡和头像的直接容器 (保持不变) */
.message-bubble {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    max-width: 100%;
    min-width: 0; /* <-- 核心修复：允许气泡容器自身收缩 */
}

.timestamp {
    /* 移除旧的 position: absolute */
    font-size: 11px;
    color: #999;
    text-shadow: 0 0 3px rgba(255,255,255,0.6);
    white-space: nowrap; /* 防止时间换行 */
    margin-bottom: 5px;  /* 让它和气泡底部有轻微的对齐偏移，更美观 */
    flex-shrink: 0;      /* 防止被压缩 */
}

        .message-bubble.selected::after { content: '✔'; position: absolute; left: -10px; top: 50%; transform: translateY(-50%); background-color: var(--accent-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .message-bubble.user.selected::after { left: auto; right: -10px; }

        .message-bubble.user { flex-direction: row-reverse; }
        #typing-indicator { align-self: flex-start; display: none; margin: 0 10px 10px; color: var(--text-secondary); }
        /* 修改聊天输入框区域的 padding */
#chat-input-area { 
    flex-shrink: 0; 
    /* ▼▼▼ 核心修改1：增加了上、左、右的内边距，让整个区域更"宽敞" ▼▼▼ */
    padding: 10px 12px; 
    background-color: rgba(247, 247, 247, 0.8); 
    backdrop-filter: blur(10px); 
    -webkit-backdrop-filter: blur(10px); 
    border-top: 1px solid var(--border-color); 
    display: flex; 
    flex-direction: column; 
    gap: 5px; 
}

/* 修改iPhone底部安全区的适配 */
#chat-input-area {
    /* ▼▼▼ 核心修改2：将这里的 8px 也同步为 10px，保持一致 ▼▼▼ */
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
}

        #chat-input-main-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; }
        #chat-input { flex-grow: 1; border: none; padding: 10px 15px; border-radius: 20px; background-color: var(--secondary-bg); font-size: 16px; max-height: 100px; resize: none; }
        .action-button { border: none; color: white; border-radius: 20px; cursor: pointer; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        #send-btn { background-color: var(--accent-color); height: 40px; padding: 0 15px;}
        
        /* AI回复状态指示器样式 */
        .ai-typing-indicator {
            display: none;
            align-items: center;
            justify-content: center;
            padding: 8px 0;
            font-size: 14px;
            color: #888;
            gap: 4px;
        }
        
        .ai-typing-indicator.active {
            display: flex;
        }
        
        .typing-text {
            font-weight: 400;
        }
        
        .typing-dots {
            display: inline-flex;
            gap: 2px;
        }
        
        .typing-dots .dot {
            opacity: 0.4;
            animation: typing-dot 1.4s infinite;
        }
        
        .typing-dots .dot:nth-child(1) { animation-delay: 0s; }
        .typing-dots .dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots .dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typing-dot {
            0%, 60%, 100% { opacity: 0.4; }
            30% { opacity: 1; }
        }
        
        /* 通话界面AI回复状态指示器样式 */
        .ai-reply-status {
            display: none;
            align-items: center;
            justify-content: center;
            padding: 10px 0;
            font-size: 14px;
            color: #888;
            gap: 6px;
            position: absolute;
            bottom: 120px;
            left: 0;
            right: 0;
            z-index: 11;
        }
        
        .ai-reply-status.active {
            display: flex;
        }
        
        .reply-status-text {
            font-weight: 400;
        }
        
        .reply-status-dots {
            display: inline-flex;
            gap: 2px;
        }
        
        .reply-status-dots .dot {
            opacity: 0.4;
            animation: reply-dot 1.4s infinite;
        }
        
        .reply-status-dots .dot:nth-child(1) { animation-delay: 0s; }
        .reply-status-dots .dot:nth-child(2) { animation-delay: 0.2s; }
        .reply-status-dots .dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes reply-dot {
            0%, 60%, 100% { opacity: 0.4; }
            30% { opacity: 1; }
        }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal.visible { display: flex; }
        .modal-content { width: 90%; max-height: 90%; background-color: white; border-radius: 15px; display: flex; flex-direction: column; }
        .modal-header { padding: 15px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 15px; overflow-y: auto; }
        .modal-footer { padding: 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; }
        .modal-footer button { width: 45%; padding: 12px; border-radius: 8px; border: 1px solid #333; cursor: pointer; font-size: 16px; }
        .modal-footer .save { background-color: #333; color: white !important; }
        .modal-footer .cancel { background-color: white; color: #333; }
        
        /* 订单预览弹窗样式 - 粉色透明软萌 */
        #order-preview-modal { 
            background-color: rgba(0,0,0,0.2); 
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
        .order-preview-content { 
            width: 90%; 
            max-width: 90%; 
            background: linear-gradient(135deg, rgba(255, 182, 193, 0.1), rgba(255, 192, 203, 0.2), rgba(255, 105, 180, 0.15)); 
            backdrop-filter: blur(25px); 
            -webkit-backdrop-filter: blur(25px); 
            border-radius: 30px; 
            display: flex; 
            flex-direction: column; 
            /* 限制弹窗高度：顶部留60px给标题栏，底部留70px给输入框 */
            max-height: calc(100vh - 200px);
            min-height: 200px; 
            box-shadow: 
                0 15px 30px rgba(255, 182, 193, 0.3),
                0 5px 15px rgba(255, 192, 203, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
            border: 1px solid rgba(255, 182, 193, 0.4);
            transform: translateY(-10px);
            animation: floatIn 0.3s ease-out;
        }
        @keyframes floatIn {
            from { 
                opacity: 0; 
                transform: translateY(20px) scale(0.9); 
            }
            to { 
                opacity: 1; 
                transform: translateY(-10px) scale(1); 
            }
        }
        .order-preview-header { padding: 15px 20px; font-weight: 600; font-size: 18px; text-align: center; border-bottom: 1px solid rgba(128,128,128,0.2); display: flex; justify-content: space-between; align-items: center; color: #666; }
        .order-preview-close { background: none; border: none; font-size: 28px; color: #888; cursor: pointer; line-height: 1; padding: 0; width: 30px; height: 30px; }
        .order-preview-close:hover { color: #666; }
        .order-preview-body { padding: 20px; overflow-y: auto; }
        .order-preview-body .order-preview-sender { font-size: 14px; color: #888; margin-bottom: 15px; text-align: center; }
        .order-preview-body .order-preview-items { display: flex; flex-direction: column; gap: 12px; }
        .order-preview-body .order-preview-item { display: flex; align-items: center; gap: 12px; padding: 10px; background-color: rgba(200, 200, 200, 0.3); border-radius: 12px; }
        .order-preview-body .order-preview-item-image { width: 50px; height: 50px; border-radius: 8px; object-fit: cover; background-color: #d0d0d0; flex-shrink: 0; }
        .order-preview-body .order-preview-item-info { flex: 1; display: flex; flex-direction: column; gap: 4px; }
        .order-preview-body .order-preview-item-name { font-size: 14px; font-weight: 500; color: #666; margin-bottom: 4px; }
        .order-preview-body .order-preview-item-description { font-size: 12px; color: #888; margin-bottom: 2px; line-height: 1.3; }
        .order-preview-body .order-preview-item-style { font-size: 12px; color: #999; margin-bottom: 4px; }
        .order-preview-body .order-preview-item-details { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: #888; }
        .order-preview-body .order-preview-item-quantity { color: #999; }
        .order-preview-body .order-preview-item-price { font-weight: 600; color: #777; }
        .order-preview-body .order-preview-total { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(128,128,128,0.2); display: flex; justify-content: space-between; align-items: center; font-size: 16px; font-weight: 600; }
        .order-preview-body .order-preview-total-label { color: #666; }
        .order-preview-body .order-preview-total-value { color: #777; font-size: 20px; }
        .order-preview-body .order-preview-waiting { text-align: center; color: #666; font-size: 13px; margin-top: 10px; }
        .order-preview-body .order-preview-actions { display: flex; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(128,128,128,0.2); }
        .order-preview-btn { flex: 1; padding: 12px 20px; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; }
        .order-preview-btn-pay { background-color: #6c757d; color: white; }
        .order-preview-btn-pay:hover { background-color: #5a6268; }
        .order-preview-btn-reject { background-color: #868e96; color: white; }
        .order-preview-btn-reject:hover { background-color: #6c757d; }
        
        .avatar-upload { display: flex; align-items: center; gap: 15px; }
        .avatar-upload img { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; }
        #open-persona-library-btn { font-size: 14px; padding: 6px 10px; margin-left: 0; }
        .avatar-upload input[type="file"] { display: none; }
        .theme-selector { display: grid; grid-template-columns: 1fr 1fr; gap: 2px 10px; }
        .theme-selector label { display: flex; align-items: center; gap: 4px; cursor: pointer; margin: 0; padding: 2px 0; }
        #reset-theme-btn { background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px; }
        #group-members-settings { display: flex; overflow-x: auto; padding-bottom: 10px; gap: 15px; }
        .member-editor { text-align: center; cursor: pointer; }
        .member-editor img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; margin-bottom: 5px; }
        .member-editor .member-name { font-size: 12px; }
        #notification-bar { position: absolute; top: 40px; left: 50%; width: 90%; z-index: 500; background-color: rgba(250, 250, 250, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: flex; align-items: center; gap: 12px; cursor: pointer;     transform: translateX(-50%) translateY(-150%); 
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    visibility: hidden;
}
#notification-bar.visible {
    /* 关键：在Y轴回到原位的同时，保持X轴的居中变换 */
    transform: translateX(-50%) translateY(0);
    visibility: visible;
}
        #notification-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; }
        #notification-content .name { font-weight: 600; font-size: 15px; color: #000; }
        #notification-content .message { font-size: 14px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .sticker-image { max-width: 100px; max-height: 100px; display: block; object-fit: contain; }
        .message-bubble.is-sticker .content, .message-bubble.is-voice-message .content { padding: 0; background-color: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        #chat-input-actions-top { display: flex; gap: 8px; padding: 0 5px; }
        .chat-action-icon-btn { font-size: 24px; padding: 0; width: 38px; height: 38px; line-height: 38px; text-align: center; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); color: var(--text-primary); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.05); cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #sticker-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background-color: rgba(242, 242, 247, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #sticker-panel.visible { transform: translateY(0); visibility: visible; }
        #sticker-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
        #sticker-panel-header .title { font-weight: 600; }
        #sticker-panel-header .panel-btn { font-size: 16px; padding: 5px 10px; cursor: pointer; color: var(--accent-color); }
        #sticker-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        .sticker-item { position: relative; aspect-ratio: 1 / 1; background-color: white; border-radius: 10px; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .sticker-item .delete-btn { display: none; position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background-color: #ff3b30; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 14px; cursor: pointer; border: 2px solid white; }
        #input-actions-wrapper { position: static; display: flex; align-items: flex-end; gap: 8px; flex-shrink: 0; }
        #wait-reply-btn { position: static; bottom: auto; right: auto; width: auto; height: 40px; padding: 0 10px; border-radius: 20px; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.2s, transform 0.1s; cursor: pointer;}
        #wait-reply-btn:hover { opacity: 0.8; }
        #wait-reply-btn:active { transform: scale(0.9); }
        #wait-reply-btn img { height: 22px; display: block; margin: auto; }
        .chat-image { max-width: 100%; border-radius: 10px; display: block; }
        .message-bubble.has-image .content { padding: 5px;         }
        
        /* 【新增】AI消息专用简洁照片样式（无底部信息框） */
        .ai-photo-container { 
            margin: 8px 0; 
            border-radius: 10px; 
            overflow: hidden; 
            background-color: #f5f5f5; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: inline-block;
            max-width: 200px;
            vertical-align: top;
            width: fit-content;
        }
        
        .ai-photo-image { 
            max-width: 200px;
            max-height: 200px;
            width: auto;
            height: auto; 
            display: block; 
            border-radius: 10px;
            object-fit: contain;
            background-color: #f8f8f8;
            min-width: 80px;
            min-height: 60px;
        }
        
        /* AI照片加载和错误状态 */
        .ai-photo-loading {
            padding: 12px;
            text-align: center;
            color: #666;
            font-size: 14px;
            background-color: #f5f5f5;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .ai-photo-error {
            margin: 8px 0;
        }
        
        /* RealImag真实图片样式 */
        .realimag-image {
            max-width: 250px;
            max-height: 250px;
            width: auto;
            height: auto;
            display: block;
            border-radius: 10px;
            object-fit: cover;
            background-color: #f8f8f8;
            min-width: 100px;
            min-height: 100px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s ease;
        }
        
        .realimag-image:hover {
            transform: scale(1.02);
        }
        
        .message-bubble.is-realimag .content {
            padding: 5px;
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }
        
        /* 多图布局容器 */
        .realimag-multi-images {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        /* 单张图片：280x280 */
        .realimag-multi-images.layout-1 img {
            width: 280px;
            height: 280px;
            max-width: 280px;
            max-height: 280px;
        }
        
        /* 2张图片：横向并排，每张135x135 */
        .realimag-multi-images.layout-2 {
            justify-content: flex-start;
        }
        .realimag-multi-images.layout-2 img {
            width: 135px;
            height: 135px;
            max-width: 135px;
            max-height: 135px;
        }
        
        /* 3张图片：横向排列，每张90x90 */
        .realimag-multi-images.layout-3 {
            justify-content: flex-start;
        }
        .realimag-multi-images.layout-3 img {
            width: 90px;
            height: 90px;
            max-width: 90px;
            max-height: 90px;
        }
        
        /* 4张图片：2x2方格布局，每张135x135 */
        .realimag-multi-images.layout-4 {
            width: 275px;
        }
        .realimag-multi-images.layout-4 img {
            width: 135px;
            height: 135px;
            max-width: 135px;
            max-height: 135px;
        }
        
        /* 5张图片：上2下3不规则布局 */
        .realimag-multi-images.layout-5 {
            width: 275px;
        }
        .realimag-multi-images.layout-5 img {
            width: 135px;
            height: 135px;
            max-width: 135px;
            max-height: 135px;
        }
        .realimag-multi-images.layout-5 img:nth-child(3) {
            width: 90px;
            height: 90px;
            max-width: 90px;
            max-height: 90px;
        }
        .realimag-multi-images.layout-5 img:nth-child(4) {
            width: 90px;
            height: 90px;
            max-width: 90px;
            max-height: 90px;
        }
        .realimag-multi-images.layout-5 img:nth-child(5) {
            width: 90px;
            height: 90px;
            max-width: 90px;
            max-height: 90px;
        }
        
        /* 6张图片：3x2网格，每张90x90 */
        .realimag-multi-images.layout-6 {
            width: 275px;
        }
        .realimag-multi-images.layout-6 img {
            width: 90px;
            height: 90px;
            max-width: 90px;
            max-height: 90px;
        }
        
        /* 7-9张图片：3x3九宫格，每张90x90 */
        .realimag-multi-images.layout-7,
        .realimag-multi-images.layout-8,
        .realimag-multi-images.layout-9 {
            width: 275px;
        }
        .realimag-multi-images.layout-7 img,
        .realimag-multi-images.layout-8 img,
        .realimag-multi-images.layout-9 img {
            width: 90px;
            height: 90px;
            max-width: 90px;
            max-height: 90px;
        }
        
        /* 多图中的单张图片样式 */
        .realimag-multi-images img {
            border-radius: 8px;
            object-fit: cover;
            background-color: #f8f8f8;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.2s ease;
            cursor: pointer;
        }
        
        .realimag-multi-images img:hover {
            transform: scale(1.05);
        }
        
        /* 【修改】相册照片样式 - 添加居中显示 */
        .album-photo-container { 
            margin: 8px auto; /* 改为auto实现水平居中 */
            border-radius: 10px; 
            overflow: hidden; 
            background-color: #f5f5f5; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: block; /* 改为block以支持margin auto居中 */
            max-width: 200px;
            /* 确保容器宽度适应图片内容 */
            width: fit-content;
            /* 3D翻转效果 */
            perspective: 1000px;
            position: relative;
        }
        
        .album-photo-card {
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        .album-photo-card.flipped {
            transform: rotateY(180deg);
        }
        
        .album-photo-front, 
        .album-photo-back {
            position: relative;
            width: 100%;
            backface-visibility: hidden;
        }
        
        .album-photo-back {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotateY(180deg);
            background: rgba(248, 248, 248, 0.95);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
            overflow: hidden;
            cursor: pointer;
            /* 确保背面有最小高度 */
            min-height: 120px;
        }
        .album-photo-image { 
            max-width: 200px;
            max-height: 200px;
            width: auto;
            height: auto; 
            display: block; 
            border-radius: 10px 10px 0 0;
            object-fit: contain;
            background-color: #f8f8f8;
            /* 确保小图片也有合适的最小尺寸 */
            min-width: 80px;
            min-height: 60px;
        }
        .album-photo-info { 
            padding: 8px 12px; 
            background-color: rgba(255,255,255,0.9); 
            border-top: 1px solid #e0e0e0;
            width: 100%;
            box-sizing: border-box;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }
        
        .album-photo-info:hover {
            background-color: rgba(240,240,240,0.9);
        }
        
        .album-photo-info .flip-icon {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
            color: #666;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .album-photo-info:hover .flip-icon {
            opacity: 1;
        }
        
        .album-photo-info::after {
            content: "点击查看详情";
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
        }
        
        .album-photo-info:hover::after {
            opacity: 1;
        }
        
        .album-photo-back-content {
            color: #555;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .album-photo-back-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        
        .album-photo-back-description {
            margin-bottom: 6px;
        }
        
        .album-photo-back-info {
            font-size: 11px;
            color: #888;
            margin-top: auto;
        }
        
        /* 响应式设计：小屏幕下略微调整尺寸 */
        @media (max-width: 480px) {
            .album-photo-container {
                max-width: 160px;
            }
            .album-photo-image {
                max-width: 160px;
                max-height: 160px;
            }
        }
        .photo-name { 
            font-size: 12px; 
            color: #666; 
            font-weight: 500;
        }
        .album-photo-loading { 
            padding: 20px; 
            text-align: center; 
            color: #888; 
            font-size: 14px; 
            border-radius: 8px; 
            background-color: #f8f8f8;
            margin: 8px 0;
        }
        .album-photo-error { 
            padding: 16px; 
            text-align: center; 
            color: #ff6b6b; 
            font-size: 13px; 
            border-radius: 8px; 
            background-color: #fff5f5; 
            border: 1px solid #ffebee;
            margin: 8px 0;
        }
        #custom-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        #custom-modal-overlay.visible { display: flex; opacity: 1; }
        #custom-modal { background: white; width: 320px; max-width: 90vw; max-height: 80vh; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); display: flex; flex-direction: column; transform: scale(0.9) translateY(20px); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); border: 1px solid #e0e0e0; }
        #custom-modal-overlay.visible #custom-modal { transform: scale(1) translateY(0); }
        
        /* URL输入弹窗样式 */
        #url-input-modal-overlay.visible { display: flex !important; opacity: 1 !important; }
        #url-input-modal-overlay.visible #url-input-modal { transform: scale(1) translateY(0) !important; }
        .custom-modal-header { padding: 16px; font-size: 17px; font-weight: 600; text-align: center; }
        .custom-modal-body { padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5; overflow-y: auto; flex: 1; }
        .custom-modal-body p { margin: 0; margin-bottom: 12px; }
        .custom-modal-body input { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; }
        .custom-modal-footer { border-top: 1px solid #e0e0e0; display: flex; border-radius: 0 0 12px 12px; overflow: hidden; }
        .custom-modal-footer button { flex: 1; background: #f5f5f5; border: none; padding: 14px; font-size: 16px; cursor: pointer; color: #666; font-weight: 500; transition: all 0.2s ease; }
        .custom-modal-footer button:first-child { border-right: 1px solid #e0e0e0; }
        .custom-modal-footer button:hover { background: #e8e8e8; }
        .custom-modal-footer .confirm-btn { font-weight: 600; background: #333; color: white; }
        .custom-modal-footer .confirm-btn:hover { background: #555; }
        .custom-modal-footer .confirm-btn.btn-danger { background: #FF3B30; }
        .custom-modal-footer .confirm-btn.btn-danger:hover { background: #D70015; }
        #preset-actions-modal .custom-modal-footer { flex-direction: column; }
        #preset-actions-modal .custom-modal-footer button { width: 100%; border: none; border-bottom: 1px solid #dbdbdb; padding: 14px; font-size: 18px; }
        #preset-actions-modal .custom-modal-footer button:last-child { border-bottom: none; }
        .custom-multiselect { position: relative; user-select: none; }
        .select-box { display: flex; align-items: center; width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background-color: #fff; cursor: pointer; }
        .select-box .selected-options-text { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
        .select-box .arrow-down { margin-left: auto; font-size: 10px; color: var(--text-secondary); transition: transform 0.2s; }
        .select-box.expanded .arrow-down { transform: rotate(180deg); }

.checkboxes-container {
    display: none;
    position: absolute;
    top: 100%; 
    margin-top: 5px;
    left: 0;
    right: 0;
    max-height: 400px; /* ★★★ 修改点在这里 ★★★ 我把高度从 150px 增加到了 400px */
    overflow-y: auto;
    overflow-x: hidden;
    background-color: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    z-index: 101;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
        .checkboxes-container.visible { display: block; }
        .checkboxes-container label { display: block; padding: 10px 12px; cursor: pointer; font-weight: normal; color: var(--text-primary); }

.checkboxes-container label {
    display: block;
    padding: 12px 15px; /* <-- 修改：增加了上下和左右的内边距，让每一行更高更宽 */
    cursor: pointer;
    font-weight: normal;
    color: var(--text-primary);
    font-size: 15px; /* <-- 新增：将字体大小从默认值放大到15px */
}

        .checkboxes-container input { margin-right: 10px; vertical-align: middle; }
        .bg-upload-container { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .bg-preview-img { max-width: 120px; max-height: 80px; border-radius: 8px; border: 1px solid var(--border-color); object-fit: cover; display: none; }
        #remove-bg-btn { padding: 8px 12px; border: 1px solid #ff3b30; color: #ff3b30; background-color: #fff; border-radius: 5px; cursor: pointer; font-size: 14px; display: none; }
        .message-bubble.is-ai-image .content { padding: 5px; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        .ai-generated-image { max-width: 180px; border-radius: 12px; display: block; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .ai-generated-image:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 8px 12px; min-width: 80px; max-width: 200px; }
        .message-bubble.user .voice-message-body { color: #1a3d00; flex-direction: row-reverse; }
        .message-bubble.ai .voice-message-body { color: var(--text-primary); }
        .voice-waveform { display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px; }
        .voice-waveform div { width: 3px; background-color: currentColor; border-radius: 2px; animation: wave-quiet 1.5s ease-in-out infinite; }
        @keyframes wave-quiet { 0%, 100% { height: 2px; } 50% { height: 10px; } }
        .voice-waveform div:nth-child(2) { animation-delay: 0.2s; } .voice-waveform div:nth-child(3) { animation-delay: 0.4s; } .voice-waveform div:nth-child(4) { animation-delay: 0.6s; } .voice-waveform div:nth-child(5) { animation-delay: 0.8s; }
.voice-duration {
    /* --- 核心修正 --- */
    font-size: var(--chat-font-size, 13px);
    /* --- 修正结束 --- */
    font-weight: 500;
    color: var(--text-secondary);
}

        /* ▼▼▼ Minimax语音系统样式 ▼▼▼ */
        .voice-icon {
            position: absolute;
            top: 8px;
            right: 8px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.8);
            transition: color 0.2s, transform 0.2s;
            z-index: 10;
            width: 16px;
            height: 16px;
        }

        .voice-icon:hover {
            color: rgba(255, 255, 255, 1);
            transform: scale(1.1);
        }

        .message-bubble.loading .voice-icon {
            animation: voice-pulse 1s infinite;
        }

        .message-bubble.playing .voice-icon {
            color: #4ade80;
        }

        @keyframes voice-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.9); }
        }

        /* 智谱语音识别测试弹窗样式 */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        #start-recording-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        #start-recording-btn.recording {
            background: linear-gradient(135deg, #ff4757 0%, #ff3742 100%);
            animation: pulse 1.5s infinite;
        }

        /* 夜间模式适配 */
        #phone-screen.dark-mode .voice-icon {
            color: rgba(255, 255, 255, 0.7);
        }

        #phone-screen.dark-mode .voice-icon:hover {
            color: rgba(255, 255, 255, 0.9);
        }

        #phone-screen.dark-mode .message-bubble.playing .voice-icon {
            color: #4ade80;
        }
        /* ▲▲▲ Minimax语音系统样式结束 ▲▲▲ */
        .message-bubble.user .voice-duration { color: #3e6224; }

/* ▼▼▼ 用这块代码替换掉你原来的 .message-bubble .content 样式 ▼▼▼ */
/* 通用内容区样式，为时间戳和字体大小做准备 */
.message-bubble .content {
    position: relative;
    font-size: var(--chat-font-size, 16px);
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word; /* 核心修正: 强制长单词或URL换行，防止撑破气泡 */

}
/* ▲▲▲ 替换结束 ▲▲▲ */

        /* === 气泡主题样式 === */
        .message-bubble.user .content { background-color: rgba(255, 255, 255, 0.75); color: #585858; border-radius: 8px 2px 8px 8px; }
        .message-bubble.ai .content { background-color: rgba(255, 255, 255, 0.7); color: #585858; border-radius: 2px 8px 8px 8px; }
      
.message-bubble::after {
    content: "";
    position: absolute;
    width: 20px;  
    height: 20px; 
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 1; 
    z-index: 1;
}
      
        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.user .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content { background-color: #fffde4; color: #5C4033; }
        #chat-messages[data-theme="black_white"] .message-bubble.user .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="black_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #343a40; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content { background-color: #FFEB3B; color: #5D4037; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="red_black"] .message-bubble.user .content { background-color: #C62828; color: #FFFFFF; }
        #chat-messages[data-theme="red_black"] .message-bubble.ai .content { background-color: #212121; color: #FFFFFF; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content { background-color: #A0D2EB; color: #153243; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="gray_white"] .message-bubble.user .content { background-color: #e9ecef; color: #495057; }
        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="blue_green"] .message-bubble.user .content { background-color: #d1ecf1; color: #0c5460; }
        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="pink_white"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="pink_black"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="pink_green"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content { background-color: #C8E6C9; color: #1B5E20; }
        #chat-messages[data-theme="green_black"] .message-bubble.user .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="green_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }

        #transfer-btn { font-weight: bold; }
        #transfer-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        #transfer-modal.visible { display: flex; }
        .transfer-content { background-color: #fff0f5; border-radius: 20px; width: 290px; padding: 20px; box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); text-align: center; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>'); background-repeat: no-repeat; background-position: top right; background-size: 80px; }
        .transfer-header { font-size: 20px; font-weight: bold; color: #a35c7b; margin-bottom: 20px; }
        .transfer-input-group { margin-bottom: 15px; text-align: left; }
        .transfer-input-group label { display: block; font-size: 14px; color: #ff85b3; margin-bottom: 5px; font-weight: 500; }
        .transfer-input-group input { width: 100%; padding: 12px; border-radius: 10px; border: 2px solid #ffcce0; background-color: #fff; font-size: 16px; box-sizing: border-box; }
        .transfer-input-group input:focus { border-color: #ff85b3; outline: none; }
        .transfer-actions { display: flex; justify-content: space-between; gap: 10px; }
        .transfer-actions button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        .transfer-actions button:active { transform: scale(0.95); }
        #transfer-cancel-btn { background-color: #ffdde9; color: #a35c7b; }
        #transfer-confirm-btn { background-color: #ff85b3; color: white; }
        .message-bubble.is-transfer .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; cursor: pointer; }
        .transfer-card { width: 200px; border-radius: 12px; padding: 12px; color: white; position: relative; overflow: hidden; }
        .transfer-card::before { content: '🐾'; position: absolute; right: 10px; top: 5px; font-size: 30px; opacity: 0.2; transform: rotate(15deg); }
        .message-bubble.user .transfer-card { background: radial-gradient(circle at top left, #ffc5d5, #ff85b3); }
        .message-bubble.ai .transfer-card { background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb); }
        .transfer-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
        .transfer-amount { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .transfer-note { font-size: 13px; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px; margin-top: 8px; word-break: break-all; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #listen-together-btn img.rotating { animation: spin 2s linear infinite; }
        #listen-together-btn img.paused { animation-play-state: paused; }
        #music-player-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.3); }
        #music-player-overlay.visible { display: flex; }
        .music-player-window { width: 90%; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18); padding: 25px; display: flex; flex-direction: column; align-items: center; color: #1f1f1f; position: relative; }
        #music-playlist-btn { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; color: #333; }
        #music-time-counter { font-size: 12px; color: #555; margin-bottom: 20px; }
        #music-player-song-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; text-align: center; }
        #music-player-artist { font-size: 14px; color: #666; margin-bottom: 25px; }
        .music-controls { display: flex; align-items: center; justify-content: center; gap: 20px; width: 100%; margin-bottom: 30px; }
        .music-controls button { background: none; border: none; font-size: 16px; font-weight: bold; cursor: pointer; color: #333; width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .music-controls button:active { transform: scale(0.9); }
        .music-controls .play-pause-btn { font-size: 24px; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(0,0,0,0.05); }
        .music-bottom-actions { display: flex; justify-content: space-between; width: 100%; }
        .music-bottom-actions button { flex: 1; padding: 12px 0; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; }
        #music-exit-btn { background-color: rgba(255, 100, 100, 0.7); color: white; margin-right: 5px; }
        #music-return-btn { background-color: rgba(0, 123, 255, 0.7); color: white; margin-left: 5px; }
        
        #music-playlist-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 70%; background-color: rgba(242, 242, 247, 0.9); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 210; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #music-playlist-panel.visible { transform: translateY(0); visibility: visible; }
        .playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        .playlist-header .panel-btn { font-size: 16px; cursor: pointer; color: var(--accent-color); }
        .playlist-body { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .playlist-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-bottom: 1px solid #eee; }
        .playlist-item.playing { background-color: rgba(0, 123, 255, 0.1); }
        .playlist-item-info .title { font-weight: 500; font-size: 15px; }
        .playlist-item-info .artist { font-size: 12px; color: #666; }
        .playlist-item .delete-track-btn { color: #ff3b30; font-size: 20px; padding: 5px; }

        /* Persona Library Styles */
        #persona-library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px; }
        .persona-preset-item { aspect-ratio: 1 / 1; border-radius: 12px; background-size: cover; background-position: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid rgba(0,0,0,0.1); }
        .persona-preset-item:hover { transform: scale(1.08); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header .action-button { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; background: none; border: none; padding: 5px; }
        
        /* Battery Alert Modal Styles */
        #battery-alert-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; }
        #battery-alert-modal.visible { display: flex; opacity: 1; }
        .battery-alert-content { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width: 280px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; padding: 20px; cursor: pointer; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        #battery-alert-modal.visible .battery-alert-content { transform: scale(1); }
        #battery-alert-image { max-width: 100px; max-height: 100px; margin-bottom: 15px; }
        #battery-alert-text { font-size: 16px; font-weight: 500; color: #333; margin: 0; line-height: 1.4; }

/* 这是你要添加的新样式 */
#font-preview {
    transition: font-family 0.3s ease;}

/* === 聊天列表界面新增样式 (这是新添加的) === */
#chat-list-screen {
}

.chat-list-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
    z-index: 1; 
}
.chat-list-view.active {
    opacity: 1;
    visibility: visible;
    z-index: 2; 
}

#messages-view {
    overflow-y: auto; 
}

/* 底部导航栏样式 */
#chat-list-bottom-nav {
    position: absolute; /* 让它固定在底部 */
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 15; /* 确保它在视图之上 */
    border-top: 1px solid var(--border-color);
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

/* 修复：导航栏显示逻辑 */
#chat-list-bottom-nav {
    display: none; /* 默认隐藏 */
}

/* 只在QQ主页面时显示导航栏 */
body.on-chat-list-screen #chat-list-bottom-nav {
    display: flex !important;
}

/* 【新增】当chat-list-screen处于active状态时显示导航栏 */
#chat-list-screen.active #chat-list-bottom-nav {
    display: flex !important;
}

/* 收藏编辑模式下隐藏导航栏 */
body.favorites-edit-mode #chat-list-bottom-nav {
    display: none !important;
}

.nav-item {
    flex: 1;
    text-align: center;
    padding: 13px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s;
}

.nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}

/* === 动态界面 (QZone) 样式 (这是新添加的) === */
#qzone-screen {
    background-color: #f0f2f5;
}

.qzone-header {
    /* position: absolute;  <-- 把这个改成 relative */
    position: relative;
    z-index: 10; /* z-index 保持，或者可以更高 */
    flex-shrink: 0; /* 防止被压缩 */
    padding: 15px 20px;
    padding-top: 45px;
    background-color: rgba(247, 247, 247, 0.7); 
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    text-align: center;
}

.qzone-header .back-btn {
    font-size: 24px;
    cursor: pointer;
    color: #000000;
}

.qzone-header span:nth-child(2) { /* "好友动态"文字 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.qzone-content {
    flex-grow: 1;
    overflow-y: auto;
    /* padding-top: 80px;  <-- 删除这个，因为header不再是absolute了 */
}

.qzone-profile-header {
    position: relative;
    margin-bottom: 20px;
}

.qzone-banner-container {
    width: 100%;
    height: 180px; /* 背景板高度 */
    position: relative;
}

#qzone-banner-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.qzone-user-info {
    position: absolute;
    bottom: -30px; /* 让头像和昵称区域向下偏移，一半在背景板内，一半在外 */
    left: 20px;
    display: flex;
    align-items: flex-end; /* 让昵称和头像底部对齐 */
    gap: 10px;
}

.qzone-avatar-container {
    position: relative;
}

#qzone-avatar-img {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    object-fit: cover;
}

#qzone-nickname {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    padding-bottom: 5px; /* 微调位置 */
}

/* 编辑按钮的通用样式 */
.qzone-edit-btn {
    position: absolute;
    background-color: rgba(0,0,0,0.4);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

#change-qzone-banner-btn {
    bottom: 10px;
    right: 10px;
}

#change-qzone-avatar-btn {
    bottom: 5px;
    right: 5px;
}

#change-qzone-nickname-btn {
    font-size: 14px;
    padding: 2px 6px;
    margin-left: 5px; /* 与昵称的间距 */
    color: var(--text-primary);
    background-color: rgba(255,255,255,0.7);
    border-radius: 5px;
    position: relative; /* 脱离flex布局的对齐 */
    bottom: 5px; /* 微调垂直位置 */
}

/* === 让编辑功能更“隐形” === */
#qzone-banner-container,
#qzone-avatar-container,
#qzone-nickname {
    cursor: pointer; /* 鼠标悬停时显示为可点击手势 */
    transition: opacity 0.2s;
}
#qzone-banner-container:hover,
#qzone-avatar-container:hover,
#qzone-nickname:hover {
    opacity: 0.85; /* 悬停时稍微变暗，给用户反馈 */
}
/* 隐藏掉旧的、独立的编辑按钮 */
.qzone-edit-btn {
    display: none;
}

/* === 控制 Header 和 Bottom Nav 的显隐 === */
/* 默认隐藏动态界面的 Header */
#qzone-screen .qzone-header {
    display: none;
}
/* 当动态视图激活时，显示它的Header */
#qzone-screen.active .qzone-header {
    display: flex;
}

/* 当进入动态视图时，隐藏主Header和底部导航栏 */
#chat-list-screen.in-qzone-view > .header,
#chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
    display: none;
}

.chat-group-container:first-child {
    margin-top: 10px; 
}

/* ▲▲▲ 新样式替换结束 ▲▲▲ */

/* ▼▼▼ 把所有这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 动态功能栏样式 === */
.qzone-actions-bar {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;
    margin: 40px 15px 15px 15px; /* 上边距更大，为浮动的头像留出空间 */
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.action-item {
    flex: 1;
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-primary);
    cursor: pointer;
    padding: 8px 0;
    position: relative;
}

/* 用伪元素创建分隔线 */
.action-item:not(:last-child)::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 1px;
    height: 20px;
    background-color: var(--border-color);
}

/* === 动态帖子列表样式 === */
#qzone-posts-list {
    padding: 0 15px 20px 15px; /* 左右和底部留出边距 */
    display: flex;
    flex-direction: column;
    gap: 20px; /* 帖子之间的间距 */
}

.qzone-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}

.post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.post-header .post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.post-info {
    display: flex;
    flex-direction: column;
}

.post-info .post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.post-info .post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.post-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap; /* 让换行符生效 */
    word-break: break-word; /* 防止长单词溢出 */
}

/* 【新增】动态中的照片居中显示 */
.post-content .album-photo-container {
    text-align: center;
    margin: 12px auto;
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* ▼▼▼ 新样式粘贴到末尾 ▼▼▼ */

/* === 发布动态模态框样式 === */
#post-public-text {
    min-height: 80px; /* 确保文本域有足够的高度 */
    resize: vertical;
}

.post-image-preview-container {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9; /* 保持16:9的预览比例 */
    background-color: #f0f2f5;
    border: 2px dashed var(--border-color);
    border-radius: 8px;
    margin-bottom: 15px;
    display: none; /* 默认隐藏 */
    justify-content: center;
    align-items: center;
}
.post-image-preview-container.visible {
    display: flex; /* 上传后显示 */
}

#post-image-preview {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 6px;
}

#post-remove-image-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #ff3b30;
    color: white;
    border: 2px solid white;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
}

.post-image-upload-options {
    display: flex;
    gap: 10px;
}

.post-image-upload-options button {
    flex: 1;
    margin-top: 0;
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* ▼▼▼ 新样式 ▼▼▼ */

/* === 发布动态模态框 - 模式切换样式 === */
.post-mode-switcher {
    display: flex;
    margin-bottom: 20px;
    background-color: #e9ecef;
    border-radius: 8px;
    padding: 4px;
}

.mode-btn {
    flex: 1;
    padding: 8px;
    border: none;
    background-color: transparent;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.mode-btn.active {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.post-mode-content {
    display: none; /* 默认都隐藏 */
}

.post-mode-content.active {
    display: block; /* 激活的才显示 */
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* === 相册页面背景色 === */
#album-screen {
    background-color: #f0f2f5; /* 使用一个柔和的浅灰色，比纯白更护眼 */
}

/* === 相册页面网格布局 === */
#album-grid-page {
    padding: 15px;
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 每行显示2个相册 */
    gap: 15px;
}

/* === 相册项目样式 (美化) === */
.album-item {
    display: flex;
    flex-direction: column;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-radius: 8px; /* 给整个项目也加个圆角 */
}

.album-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
}

.album-cover {
    aspect-ratio: 1 / 1; /* 保持封面为正方形 */
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    margin-bottom: 8px;
    background-color: #f0f2f5; /* 封面加载前的占位颜色 */
}

.album-info {
    text-align: center;
}

.album-name {
    font-weight: 500;
    margin: 0 0 4px 0;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 防止长名字换行 */
}

.album-count {
    font-size: 12px;
    color: var(--text-secondary);
    margin: 0;
}

/* ▲▲▲ 新的 CSS 粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 相册照片详情页 === */
#album-photos-screen {
    background-color: #f0f2f5;
}

#photos-grid-page {
    padding: 15px;
    column-count: auto;
    column-width: 220px;
    column-gap: 20px;
    column-fill: balance;
}

.photo-item {
    position: relative;
    background: rgba(248, 248, 248, 0.95);
    border-radius: 12px;
    padding: 8px;
    margin-bottom: 15px;
    break-inside: avoid;
    display: inline-block;
    width: 100%;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    perspective: 1000px;
}

.photo-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
}

.photo-item .photo-card {
    position: relative;
    width: 100%;
    transition: transform 0.6s;
    transform-style: preserve-3d;
}

.photo-item .photo-card.flipped {
    transform: rotateY(180deg);
}

.photo-item .photo-front, 
.photo-item .photo-back {
    position: relative;
    width: 100%;
    backface-visibility: hidden;
}

.photo-item .photo-back {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform: rotateY(180deg);
    background: rgba(248, 248, 248, 0.95);
    border-radius: 8px;
    padding: 8px;
    display: flex;
    flex-direction: column;
    text-align: center;
    box-sizing: border-box;
    overflow: hidden;
}

.photo-item .photo-back-content {
    color: #666;
    font-size: 12px;
    line-height: 1.3;
    word-break: break-word;
    max-height: 100%;
    overflow-y: auto;
    width: 100%;
}

.photo-item .photo-title {
    margin-top: 8px;
    padding: 6px 8px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 6px;
    font-size: 12px;
    color: #555;
    text-align: center;
    word-break: break-word;
    line-height: 1.3;
}

.photo-item .photo-thumb {
    width: 100%;
    height: auto;
    border-radius: 8px;
    display: block;
}

/* 删除按钮的样式 */
.photo-item .photo-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease;
}

/* 鼠标悬停在照片上时显示删除按钮 */
.photo-item:hover .photo-delete-btn {
    opacity: 1;
}

/* 主页面photos-grid手机端适配 */
@media (max-width: 768px) {
    #photos-grid-page {
        column-width: 160px;
        column-gap: 12px;
        padding: 8px;
    }
    
    .photo-item {
        margin-bottom: 12px;
    }
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* === 图片查看器模态框样式 === */
#photo-viewer-modal {
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 1002;
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
}

.photo-viewer-content {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}

#photo-viewer-image {
    max-width: 90vw;  /* 图片最大宽度为视口的90% */
    max-height: 85vh; /* 图片最大高度为视口的85% */
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    /* 为图片的切换添加一点平滑的淡入淡出效果 */
    transition: opacity 0.2s ease-in-out;
}

/* 关闭按钮 */
#photo-viewer-close-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    color: white;
    font-size: 40px;
    font-weight: 200;
    cursor: pointer;
    line-height: 1;
    text-shadow: 0 0 5px black;
}

/* 左右导航箭头 */
#photo-viewer-modal .nav-arrow {
    position: absolute; /* 现在我们用绝对定位来控制箭头 */
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 50px; /* 在手机屏幕上，可以稍微小一点 */
    font-weight: 100;
    cursor: pointer;
    padding: 10px; /* 调整内边距 */
    user-select: none;
    transition: color 0.2s;
    z-index: 1003; /* 确保箭头在最上层 */
}

#photo-viewer-prev-btn {
    left: 5px; /* 定位左箭头 */
}

#photo-viewer-next-btn {
    right: 5px; /* 定位右箭头 */
}

#photo-viewer-modal .nav-arrow:hover {
    color: white;
}

/* 当箭头被禁用时（比如第一张或最后一张） */
#photo-viewer-modal .nav-arrow:disabled {
    color: rgba(255, 255, 255, 0.2);
    cursor: default;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 请用这块新CSS替换掉上一版的交互区CSS ▼▼▼ */

/* === 帖子内容区 - 相对定位容器 === */
/* === 帖子内容区 === */
.post-main-content {
    /* 它现在只是一个普通的内容容器，不再需要特殊样式了 */
}

/* === 帖子互动图标区 (新样式) === */
.post-feedback-icons {
    display: flex;
    justify-content: flex-end; /* 让图标靠右对齐 */
    align-items: center;
    gap: 12px;
    padding: 8px 0; /* 核心修改：给图标区域上下各8px的留白 */
}

.action-icon {
    cursor: pointer;
    color: var(--text-secondary); /* 默认灰色 */
    transition: all 0.2s ease-in-out;
}

.action-icon svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* 图标激活(点赞/收藏后)的样式 */
.action-icon.active {
    color: #ff5252; /* 激活后变红色 */
    transform: scale(1.1); /* 轻微放大 */
}

.action-icon.active.favorite {
    color: #ffc107; /* 收藏用黄色 */
}

.action-icon.active svg {
    fill: currentColor; /* 激活后填充颜色 */
}

/* 点击时的动画效果 */
.animate-like {
    animation: like-bounce 0.4s ease-in-out;
}

@keyframes like-bounce {
    0%   { transform: scale(1); }
    25%  { transform: scale(0.8); }
    50%  { transform: scale(1.2); }
    75%  { transform: scale(1.05); }
    100% { transform: scale(1.1); }
}


/* === 帖子底部评论区样式 (现在是独立部分) === */
.post-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0; /* 用一条浅色线分隔 */
    display: flex;
    align-items: center;
    gap: 8px; /* 调整整体间距 */
}

/* 评论区容器 */
.comment-section {
    flex-grow: 1; /* 占据大部分空间 */
    display: flex;
    align-items: center;
    gap: 8px;
}

.comment-section .comment-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

.comment-section .comment-input {
    width: 100%;
    padding: 8px 12px;
    border: none;
    background-color: #f0f2f5;
    border-radius: 14px;
    font-size: 13px;
    outline: none;
}

/* 新增的发送按钮样式 */
.comment-send-btn {
    flex-shrink: 0; /* 防止被压缩 */
    padding: 8px 15px;
    border: none;
    background-color: var(--accent-color);
    color: white;
    border-radius: 14px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 未读消息小红点通用样式 === */
.unread-indicator {
    position: absolute;
    top: -8px;      
    right: -15px;    
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #ff3b30;
    color: white;
    font-size: 11px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    border-radius: 9px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    display: none;
    z-index: 1;
}

/* 聊天界面返回按钮上的小红点 (只显示点，不显示数字) */
.back-btn-indicator {
    top: 0;
    right: -8px; /* 放到返回箭头右上角 */
    width: 10px;
    height: 10px;
    min-width: 10px;
    padding: 0;
    border-radius: 50%;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 评论列表容器 === */
.post-comments-container {
    padding: 10px 0; /* 上下留白 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 评论之间的间距 */
    font-size: 13px; /* 统一评论区字体大小 */
}

/* 每一条评论 */
.comment-item {
    line-height: 1.5;
}

/* 评论者的名字，加粗并使用主题色 */
.comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px; /* 和评论内容之间留点空隙 */
}

/* 评论内容 */
.comment-item .comment-text {
    color: var(--text-primary);
    word-break: break-word;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 帖子点赞区域样式 === */
.post-likes-section {
    display: flex;
    align-items: center;
    gap: 6px; /* 图标和文字的间距 */
    padding: 8px 10px; /* 内边距 */
    font-size: 13px;
    color: var(--accent-color); /* 使用主题蓝色 */
    background-color: #f0f5fa; /* 给一个淡淡的背景色 */
    border-top: 1px solid #e9eef3;
    border-bottom: 1px solid #e9eef3;
    margin-top: 5px; /* 和上方的图标保持一点距离 */
}

.post-likes-section .like-icon {
    width: 16px;
    height: 16px;
    fill: currentColor; /* 让SVG图标继承父元素的颜色 */
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === @提及 弹出菜单样式 === */
.at-mention-popup {
    position: absolute; /* 相对于父元素定位 */
    bottom: 100%; /* 显示在输入框的上方 */
    left: 40px; /* 和输入框左侧对齐 (考虑了头像宽度) */
    width: calc(100% - 40px); /* 宽度和输入框差不多 */
    max-height: 120px;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
    z-index: 10;
    display: none; /* 默认隐藏 */
}

.at-mention-item {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    color: var(--text-primary);
    border-bottom: 1px solid #f0f0f0;
}

.at-mention-item:last-child {
    border-bottom: none;
}

.at-mention-item:hover {
    background-color: #f5f5f5;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 请用下面这段【新样式】替换掉你现有的 #favorites-list 样式 ▼▼▼ */

/* 让收藏视图成为一个flex容器, 从上到下排列 */
#favorites-view {
    display: flex;
    flex-direction: column;
}

/* 确保收藏页的header高度固定，不被压缩 */
#favorites-view > .header {
    flex-shrink: 0;
}

/* === 收藏列表样式 (修正后) === */
#favorites-list {
    flex-grow: 1; 
    overflow-y: auto; 
    overflow-x: hidden; /* <-- 新增这行，禁止水平滚动 */
    padding: 15px; 
    display: flex;
    flex-direction: column;
    gap: 15px; 
}

/* ▲▲▲ 替换结束 ▲▲▲ */

.favorite-item-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    position: relative; /* 为了定位删除按钮 */
}

/* 卡片头部，包含头像、名字和来源 */
.fav-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.fav-card-header .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
}

.fav-card-header .info {
    flex-grow: 1;
}

.fav-card-header .name {
    font-weight: 600;
    font-size: 15px;
}

.fav-card-header .source {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 卡片内容 */
.fav-card-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
}

.fav-card-content .chat-image {
    margin-top: 8px; /* 图片和文字的间距 */
}

/* 删除按钮 */
.fav-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    background: #f0f2f5;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-secondary);
    line-height: 28px;
    text-align: center;
}

.fav-delete-btn:hover {
    background-color: #e9ecef;
    color: #ff3b30;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 搜索栏样式 === */
.search-bar-container {
    padding: 10px 15px;
    background-color: #f9f9f9; /* 和列表背景色保持一致 */
    position: relative; /* 为了定位清除按钮 */
    flex-shrink: 0;
}

#favorites-search-input {
    width: 100%;
    padding: 10px 30px 10px 15px; /* 右侧留出清除按钮的位置 */
    font-size: 14px;
    border: 1px solid var(--border-color);
    border-radius: 18px; /* 圆角矩形，更现代化 */
    background-color: var(--secondary-bg);
    box-sizing: border-box;
    outline: none;
}
#favorites-search-input:focus {
    border-color: var(--accent-color);
}

.search-clear-btn {
    position: absolute;
    right: 25px;
    top: 50%;
    transform: translateY(-50%);
    background: #ccc;
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    font-size: 16px;
    cursor: pointer;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* === 聊天界面多选操作栏优化 === */
#chat-interface-screen .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

#chat-interface-screen .selection-controls .action-btn {
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    padding: 5px;
}

/* === 收藏页面多选模式样式 === */
#favorites-view.selection-mode .favorite-item-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* 选择框的样式 */
.favorite-item-card::before {
    content: '';
    position: absolute;
    left: -25px; /* 把它放在卡片左边外面 */
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background-color: white;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 进入选择模式时，卡片向右移动，露出选择框 */
#favorites-view.selection-mode .favorite-item-card {
    transform: translateX(35px);
}
#favorites-view.selection-mode .favorite-item-card::before {
    opacity: 1;
}

/* 选中后的样式 */
#favorites-view.selection-mode .favorite-item-card.selected::before {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}

/* 底部操作栏 (终极修正版) */
#favorites-action-bar {
    position: absolute; /* ★ 改为 absolute，相对于 #phone-screen 定位 */
    bottom: 0;
    left: 0;
    right: 0;           /* ★ 新增 right: 0，和 left: 0 一起撑满宽度 */
    width: auto;        /* ★ 改为 auto，让 left/right 决定宽度 */
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* 适配iPhone底部安全区 */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    box-sizing: border-box;
    z-index: 5;
    display: none;
    /* max-width 已经不需要了，因为父元素已经限制了宽度 */
}

#favorites-action-bar .action-bar-btn {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    background-color: #ff3b30;
    color: white;
}

/* === 【修正】聊天界面头部控件切换逻辑 === */

/* 默认状态：隐藏多选控件 */
#chat-interface-screen .header .selection-controls {
    display: none;
}

/* 默认状态：显示默认控件，并让它撑满整个头部 */
#chat-interface-screen .header .default-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    position: relative; /* <--- 新增这一行！ */
}


/* 当进入多选模式时：隐藏默认控件 */
#chat-interface-screen.selection-mode .header .default-controls {
    display: none;
}

/* 当进入多选模式时：显示多选控件，并让它撑满整个头部 */
#chat-interface-screen.selection-mode .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 修正：放大所有主要的“+”号按钮 === */
#add-chat-btn,
#add-world-book-btn,
#create-album-btn-page {
    font-size: 28px;   /* 显著增大字体大小，使其视觉上与旁边的图标匹配 */
    font-weight: 300;  /* 使用更细的字重，让加号看起来更清爽，不显粗笨 */
    position: relative;/* 允许进行位置微调 */
    top: -1px;         /* 字体放大后，通常需要稍微向上移动一点，使其视觉上更居中 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 预览区容器样式 */
#settings-preview-area {
    width: 100%;
    height: 180px; /* 给一个固定的高度 */
    background-color: #f0f2f5;
    border-radius: 8px;
    padding: 15px;
    box-sizing: border-box;
    overflow: hidden; /* 防止内容溢出 */
    display: flex;
    flex-direction: column;
    gap: 10px; /* 预览气泡之间的间距 */
    border: 1px solid var(--border-color);
    position: relative; /* 为了定位背景 */
}

/* 预览区的背景，可以和真实聊天界面同步 */
#settings-preview-area::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 1;
    opacity: 0.8;
}

/* 让预览气泡在背景之上 */
#settings-preview-area .message-wrapper {
    position: relative;
    z-index: 2;
}

/* 预览区内使用的头像要小一点 */
#settings-preview-area .message-bubble .avatar {
    width: 30px;
    height: 30px;
}

#settings-preview-area .message-bubble .timestamp {
    display: none; /* 预览区不需要显示时间戳 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.existing-group-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.existing-group-item .group-name {
    font-weight: 500;
}

.existing-group-item .delete-group-btn {
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-child {
    border-top: 1px solid var(--border-color);
}

.chat-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: var(--secondary-bg); /* <-- 修改这里，使用变量 */
}


.chat-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

.chat-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}

.chat-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}

.chat-group-content {
    max-height: 1000px; /* 一个足够大的值 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

.chat-group-content.collapsed {
    max-height: 0;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 格式助手按钮的容器 */
.format-helpers {
    display: flex;
    gap: 10px;
    margin-bottom: 15px; /* 与下方的文本框拉开距离 */
    flex-wrap: wrap; /* 如果按钮太多可以换行 */
}

/* 单个格式助手按钮的样式 */
.format-btn {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: none;
    padding: 6px 12px;
    border-radius: 16px; /* 胶囊形状，更友好 */
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

.format-btn:hover {
    background-color: #dcdfe3;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* “…”按钮的样式 */
.post-actions-btn {
    margin-left: auto; /* 关键：让它自动靠到最右边 */
    padding: 5px 10px;
    font-size: 20px;
    font-weight: bold;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 50%;
    line-height: 1;
}
.post-actions-btn:hover {
    background-color: #f0f0f0;
}

/* 动态编辑模态框的样式 (它将复用现有的操作菜单样式) */
#post-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none;
    border-bottom: 1px solid #dbdbdb;
    padding: 14px;
    font-size: 18px;
}
#post-actions-modal .custom-modal-footer button:last-child {
    border-bottom: none;
}
#post-actions-modal #cancel-post-action-btn {
    margin-top: 8px;
    border-radius: 8px;
    background-color: #f0f0f0;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* 统一重置转账卡片内所有文字的特效和颜色 */
#chat-messages .transfer-card .transfer-title,
#chat-messages .transfer-card .transfer-amount,
#chat-messages .transfer-card .transfer-note {
    text-shadow: none !important; /* 强制移除任何发光或阴影效果 */
    color: white !important;      /* 强制锁定文字颜色为白色 */
}

/* 分别锁定各自的字体大小和字重，防止被篡改 */
#chat-messages .transfer-card .transfer-title {
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .transfer-card .transfer-amount {
    font-size: 28px !important;
    font-weight: bold !important;
}

#chat-messages .transfer-card .transfer-note {
    font-size: 13px !important;
    opacity: 0.9 !important;
}

/* ▼▼▼ 恋爱空间邀请卡片样式 ▼▼▼ */
.love-space-invite-card {
    width: 200px;
    border-radius: 16px;
    padding: 12px;
    color: white;
    position: relative;
    overflow: hidden;
    background: linear-gradient(135deg, #ff6b9d, #ffa8cc, #ff85b3);
    box-shadow: 0 8px 25px rgba(255, 107, 157, 0.3);
}

.love-space-invite-card::before {
    content: '💕';
    position: absolute;
    right: 12px;
    top: 8px;
    font-size: 24px;
    opacity: 0.3;
    transform: rotate(15deg);
}

.invite-card-title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 8px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
    text-align: center;
}

.invite-card-subtitle {
    font-size: 13px;
    opacity: 0.9;
    margin-bottom: 12px;
    line-height: 1.3;
}

.invite-card-user {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 12px;
}

.invite-card-user img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.3);
}

.invite-card-user .name {
    font-size: 14px;
    font-weight: 500;
}

/* 新的邀请卡片头像布局 */
.invite-card-avatars {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    margin: 16px 0;
}

.invite-sender, .invite-receiver {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
}

.invite-sender img, .invite-receiver img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.4);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.invite-sender .name, .invite-receiver .name {
    font-size: 12px;
    font-weight: 500;
    color: rgba(255,255,255,0.9);
    text-align: center;
}

.invite-heart {
    font-size: 20px;
    animation: heartbeat 1.5s ease-in-out infinite;
}

@keyframes heartbeat {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

/* 回复卡片头像布局 */
.invite-reply-avatars {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin: 12px 0;
}

.reply-sender, .reply-receiver {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}

.reply-sender img, .reply-receiver img {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.3);
}

.reply-receiver .name {
    font-size: 11px;
    font-weight: 500;
    color: rgba(255,255,255,0.8);
    text-align: center;
}

.reply-heart {
    font-size: 16px;
    opacity: 0.8;
}

.invite-card-status {
    text-align: center;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 500;
    margin-top: 8px;
}

.invite-card-status.pending {
    background: rgba(255,255,255,0.2);
    color: white;
}

.invite-card-status.accepted {
    background: rgba(46, 204, 113, 0.9);
    color: white;
}

.invite-card-status.rejected {
    background: rgba(231, 76, 60, 0.9);
    color: white;
}

/* 恋爱空间预览弹窗样式 */
.love-space-preview-modal {
    max-width: 500px;
    margin: 0 auto;
}

.love-space-preview {
    padding: 20px;
}

.preview-section {
    margin-bottom: 25px;
}

.preview-section h4 {
    color: #333;
    margin-bottom: 12px;
    font-size: 16px;
    font-weight: 600;
}

.preview-section ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.preview-section li {
    padding: 8px 0;
    border-bottom: 1px solid #f0f0f0;
    color: #666;
    font-size: 14px;
}

.preview-section li:last-child {
    border-bottom: none;
}

.decision-buttons {
    display: flex;
    gap: 12px;
    margin-top: 15px;
}

.accept-btn, .reject-btn {
    flex: 1;
    padding: 12px 20px;
    border: none;
    border-radius: 12px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.accept-btn {
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
}

.accept-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
}

.reject-btn {
    background: linear-gradient(135deg, #f44336, #d32f2f);
    color: white;
    box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
}

.reject-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(244, 67, 54, 0.4);
}

/* 邀请卡片点击效果 */
.love-space-invite-card {
    cursor: pointer;
    transition: transform 0.2s ease;
}

.love-space-invite-card:hover {
    transform: scale(1.02);
}

/* 用户的邀请回复卡片样式 */
.love-space-invite-reply-card {
    width: 180px;
    border-radius: 16px;
    padding: 14px;
    background: linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 50%, #ffa8a8 100%);
    color: white;
    box-shadow: 0 6px 20px rgba(255, 107, 107, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
    position: relative;
    overflow: hidden;
}

.love-space-invite-reply-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.3) 100%);
}

.invite-reply-message {
    font-size: 15px;
    line-height: 1.5;
    margin-bottom: 12px;
    font-weight: 500;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.invite-reply-status {
    font-size: 13px;
    font-weight: 600;
    padding: 10px 14px;
    background: rgba(255, 255, 255, 0.25);
    border-radius: 10px;
    text-align: center;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

/* 拒绝邀请时的样式 */
.love-space-invite-reply-card.rejected {
    background: linear-gradient(135deg, #74b9ff 0%, #81ecec 50%, #a8e6cf 100%);
    box-shadow: 0 6px 20px rgba(116, 185, 255, 0.3);
}

/* AI回复卡片样式 */
.bubble.ai .love-space-invite-reply-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
}

.bubble.ai .love-space-invite-reply-card.rejected {
    background: linear-gradient(135deg, #636e72 0%, #74b9ff 50%, #81ecec 100%);
    box-shadow: 0 6px 20px rgba(99, 110, 114, 0.3);
}



/* ▲▲▲ 恋爱空间邀请卡片样式结束 ▲▲▲ */

/* ▼▼▼ 打卡成功卡片样式 ▼▼▼ */
.message-bubble.is-checkin-card .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.checkin-success-card {
    width: 150px;
    border-radius: 12px;
    padding: 12px;
    background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
    color: white;
    text-align: center;
    box-shadow: 0 4px 15px rgba(255, 154, 158, 0.3);
    position: relative;
    overflow: hidden;
}

.checkin-success-card::before {
    content: '💕';
    position: absolute;
    right: 8px;
    top: 5px;
    font-size: 20px;
    opacity: 0.3;
    transform: rotate(15deg);
}

.checkin-card-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin-bottom: 10px;
}

.checkin-icon {
    font-size: 18px;
    animation: bounce 1s ease-in-out infinite;
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
}

.checkin-title {
    font-size: 16px;
    font-weight: 600;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

.checkin-card-content {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.checkin-message {
    font-size: 13px;
    opacity: 0.9;
    line-height: 1.3;
}

.checkin-stats {
    font-size: 14px;
    font-weight: 500;
    background: rgba(255, 255, 255, 0.2);
    padding: 8px 12px;
    border-radius: 8px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #666 !important; /* 改为灰色，更清晰可见 */
}

.checkin-stats strong {
    font-size: 16px;
    font-weight: 700;
}
/* ▲▲▲ 打卡成功卡片样式结束 ▲▲▲ */

/* ▼▼▼ 解除恋爱空间关系卡片样式 ▼▼▼ */
.message-bubble.is-love-space-unbind-card .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.love-space-unbind-card {
    width: 200px;
    border-radius: 12px;
    padding: 15px;
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 50%, #d63031 100%);
    color: white;
    text-align: center;
    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    position: relative;
    overflow: hidden;
}

.love-space-unbind-card::before {
    content: '💔';
    position: absolute;
    right: 10px;
    top: 8px;
    font-size: 24px;
    opacity: 0.3;
    transform: rotate(-15deg);
}

.unbind-card-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin-bottom: 12px;
}

.unbind-icon {
    font-size: 20px;
    animation: heartbreak 2s ease-in-out infinite;
}

@keyframes heartbreak {
    0%, 100% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(1.1) rotate(-5deg); }
    75% { transform: scale(0.9) rotate(5deg); }
}

.unbind-title {
    font-size: 16px;
    font-weight: 600;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.unbind-card-content {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.unbind-message {
    font-size: 13px;
    opacity: 0.9;
    line-height: 1.4;
    margin-bottom: 8px;
}

.unbind-details {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.unbind-detail-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    background: rgba(255, 255, 255, 0.15);
    padding: 6px 10px;
    border-radius: 6px;
    backdrop-filter: blur(10px);
}

.detail-label {
    opacity: 0.8;
    font-weight: 500;
}

.detail-value {
    font-weight: 600;
    color: #fff;
}

.unbind-warning {
    font-size: 11px;
    background: rgba(0, 0, 0, 0.2);
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #ffeb3b;
    font-weight: 500;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    line-height: 1.3;
}
/* ▲▲▲ 解除恋爱空间关系卡片样式结束 ▲▲▲ */

/* ▼▼▼ 这是新增的样式，用于修正所有头部标题的居中问题 ▼▼▼ */
/* ▼▼▼ 这是新增的样式，用于修正所有头部标题的居中问题 ▼▼▼ */
.header > span:nth-child(2) {
    position: absolute;
    left: 50%;
    transform: translateX(calc(-50% - 2px)); /* 在-50%的基础上，再向左推2像素 */
    
    /* (可选但推荐) 防止长标题与两边按钮重叠 */
    max-width: 60%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */


/* ▼▼▼ 【全新】可视化消息编辑器样式 ▼▼▼ */
#message-editor-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message-editor-block {
    background-color: #f9f9f9;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
}

.message-editor-block textarea {
    width: 100%;
    min-height: 60px;
    resize: vertical;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 8px;
    font-size: 14px;
    box-sizing: border-box;
}

.message-editor-block .format-helpers {
    margin-top: 8px;
    margin-bottom: 0; /* 覆盖默认的 margin-bottom */
}

.message-editor-block .delete-block-btn {
    float: right;
    margin-top: -5px;
    background: none;
    border: none;
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【新增】线下模式头部按钮样式 ▼▼▼ */
#offline-mode-header-btn {
    position: absolute;
    left: 50px; /* 放在左侧，避开返回按钮 */
    top: 50%;
    transform: translateY(-50%);
    background-color: transparent;
    color: var(--text-primary);
    border-radius: 0;
    padding: 6px; /* 减小内边距 */
    z-index: 10; /* 确保在最上层 */
}

/* ▼▼▼ 【新增】长期记忆按钮样式 - 固定跟随线下按钮 ▼▼▼ */
#open-memory-screen-btn {
    position: absolute;
    left: 90px; /* 固定在线下按钮右侧，保持40px间距 */
    top: 50%;
    transform: translateY(-50%);
    background-color: transparent;
    color: var(--text-primary);
    border-radius: 0;
    padding: 6px;
    z-index: 10;
}

#open-memory-screen-btn:hover {
    color: #007AFF; /* 悬停时变为蓝色 */
}

/* ▼▼▼ 【新增】确保聊天界面返回按钮为黑色 ▼▼▼ */
#chat-interface-screen .back-btn {
    color: #000000 !important;
}

#offline-mode-header-btn.active {
    background-color: transparent;
    color: #000000;
    border-radius: 0;
}

/* 线下模式时SVG内部白色区域变灰色 */
#offline-mode-header-btn.active svg path,
#offline-mode-header-btn.active svg circle {
    fill: #888888;
}

/* 恢复原始样式 */

/* 屏幕底部状态提示样式 */
.status-toast {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 12px 24px;
    border-radius: 25px;
    font-size: 14px;
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.status-toast.show {
    opacity: 1;
}

/* 线下模式消息布局样式 - 针对单个消息 */
.message-wrapper.offline-message {
    flex-direction: column;
    align-items: center;
    max-width: 95%;
    align-self: center !important;
}

.message-wrapper.offline-message .message-bubble {
    flex-direction: column;
    align-items: center;
    text-align: center;
    max-width: 100%;
}

.message-wrapper.offline-message .message-bubble .avatar {
    margin-bottom: 8px;
    margin-right: 0;
    order: -1;
}

.message-wrapper.offline-message .message-bubble .content {
    margin-top: 0;
}

.message-wrapper.offline-message .timestamp {
    margin-top: 5px;
    margin-bottom: 0;
    order: 1;
}

/* 线下模式发送者名称居中 */
.message-wrapper.offline-message .sender-name {
    text-align: center;
    margin-left: 0 !important;
    position: static !important;
    top: auto !important;
    left: auto !important;
    margin-bottom: 5px;
}
/* ▲▲▲ 线下模式样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】联系人选择器样式 ▼▼▼ */
.contact-picker-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.contact-picker-item .checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
}
.contact-picker-item.selected .checkbox {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}
.contact-picker-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}
.contact-picker-item .name {
    font-weight: 500;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 相册联系人选择样式 ▼▼▼ */
.album-contact-list {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    margin-top: 5px;
}

.album-contact-list .contact-loading {
    padding: 20px;
    text-align: center;
    color: #888;
    font-size: 14px;
}

.album-contact-item {
    display: flex;
    align-items: center;
    padding: 12px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    cursor: pointer;
    transition: background-color 0.2s;
}

.album-contact-item:hover {
    background-color: rgba(102, 126, 234, 0.05);
}

.album-contact-item:last-child {
    border-bottom: none;
}

.album-contact-item .checkbox {
    width: 16px;
    height: 16px;
    border: 2px solid #ddd;
    border-radius: 3px;
    margin-right: 12px;
    position: relative;
}

.album-contact-item.selected .checkbox {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-color: #667eea;
}

.album-contact-item.selected .checkbox::after {
    content: '✓';
    color: white;
    font-size: 10px;
    position: absolute;
    top: -1px;
    left: 2px;
}

.album-contact-item .avatar {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    margin-right: 10px;
    object-fit: cover;
}

.album-contact-item .name {
    flex: 1;
    font-size: 14px;
    color: #333;
}

/* 相册绑定角色显示样式 */
.album-bound-contacts {
    margin-top: 8px;
    font-size: 12px;
    color: #666;
    line-height: 1.4;
}

.bound-label {
    color: #888;
}

.bound-contact {
    color: #667eea;
    font-weight: 500;
}
/* ▲▲▲ 相册联系人选择样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】群成员管理界面样式 ▼▼▼ */
#member-management-list {
    padding: 0; /* 移除默认padding，让列表项撑满 */
}

.member-management-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
}

.member-management-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}

.member-management-item .name {
    flex-grow: 1;
    font-weight: 500;
}

.member-management-item .remove-member-btn {
    background-color: #ff3b30;
    color: white;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 20px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    flex-shrink: 0;
}

#member-management-actions {
    flex-shrink: 0;
    padding: 15px;
    border-top: 1px solid var(--border-color);
    background-color: #f7f7f7;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#member-management-actions button {
    width: 100%;
    padding: 15px;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}
#member-management-actions #create-new-member-btn {
    background-color: #4cd964; /* 新建用绿色，以示区分 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖代付卡片样式 ▼▼▼ */
.message-bubble.is-waimai-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.waimai-card {
    width: 220px; /* 与正常小票卡片一致 */
    border-radius: 12px;
    overflow: hidden;
    background-color: #fff;
    box-shadow: 0 2px 8px rgba(0,0,0,0.07); /* 与正常小票卡片一致 */
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    border: 1px solid #eee; /* 与正常小票卡片一致 */
    padding: 12px; /* 与正常小票卡片一致 */
    box-sizing: border-box; /* 与正常小票卡片一致 */
}

.waimai-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0 0 8px 0; /* 调整padding与正常小票卡片一致 */
    border-bottom: 1px solid #f0f0f0;
    margin-bottom: 8px; /* 添加底部间距 */
}

.waimai-header .icon {
    width: 20px;
    height: 20px;
}

.waimai-header .title-group {
    display: flex;
    align-items: baseline;
    font-size: 14px;
    color: #8a8a8a;
}
.waimai-header .title-group .brand {
    font-weight: 600;
    color: #555;
    margin-right: 5px;
}
.waimai-header .title-group .separator {
    margin: 0 5px;
}

.waimai-catchphrase {
    font-size: 13px;
    color: #1f1f1f;
    padding: 0 0 8px 0; /* 调整padding与正常小票卡片一致 */
    margin-bottom: 8px; /* 添加底部间距 */
}

.waimai-main {
    background-color: #FFD66B; /* 橙黄色背景 */
    padding: 8px; /* 调整padding与正常小票卡片一致 */
    text-align: center;
    border-radius: 8px; /* 添加圆角 */
    margin-bottom: 8px; /* 添加底部间距 */
}

.waimai-main .request-title {
    font-size: 12px;
    color: #856404;
    margin-bottom: 8px;
}

.waimai-main .payment-box {
    background-color: #fff;
    border-radius: 8px;
    padding: 15px 10px;
}

.waimai-main .payment-label {
    font-size: 13px;
    color: #8a8a8a;
}

.waimai-main .amount {
    font-size: 32px;
    font-weight: 700;
    color: #1f1f1f;
    margin: 4px 0 12px 0;
}

.waimai-main .countdown-label {
    font-size: 13px;
    color: #8a8a8a;
}
.waimai-main .countdown-timer {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    margin-left: 5px;
}
.waimai-main .countdown-timer span {
    background-color: #333;
    color: white;
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
    font-size: 12px;
}

.waimai-details-btn {
    width: 100%;
    padding: 10px 0;
    margin-top: 15px;
    border: none;
    border-radius: 6px;
    background-color: #FFC33A;
    color: #49380a;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖响应状态样式 ▼▼▼ */

/* === 同意支付后的样式 === */
.message-bubble.status-paid .waimai-card {
    border: 2px solid #28a745; /* 绿色边框 */
}
.message-bubble.status-paid .waimai-main .request-title::before {
    content: '✅  ';
}
.message-bubble.status-paid .waimai-main .request-title {
    color: #155724;
    font-weight: 600;
    /* 重写 request-title 的内容 */
    content: "我已为您买单，请尽情享用吧～" !important;
    display: block;
    margin-bottom: 15px;
}

.message-bubble.status-paid .payment-box {
    display: none; /* 隐藏支付详情 */
}
.message-bubble.status-paid .waimai-details-btn {
    background-color: #28a745;
    color: white;
}

/* === 拒绝支付后的样式 === */
.message-bubble.status-rejected .waimai-card {
    border: 2px solid #dc3545; /* 红色边框 */
    opacity: 0.8;
}
.message-bubble.status-rejected .waimai-main {
    background-color: #e9ecef;
}
.message-bubble.status-rejected .waimai-main .request-title::before {
    content: '❌ ';
}
.message-bubble.status-rejected .waimai-main .request-title {
    color: #721c24;
    font-weight: 600;
    /* 重写 request-title 的内容 */
    content: "我拒绝了您的代付请求" !important;
    display: block;
    margin-bottom: 15px;
}
.message-bubble.status-rejected .payment-box {
    display: none; /* 隐藏支付详情 */
}
 .message-bubble.status-rejected .waimai-details-btn {
    background-color: #6c757d;
    color: white;
}

/* 强制重写 request-title 内容的技巧 */
.message-bubble[class*="status-"] .request-title {
    font-size: 0; /* 隐藏原始文本 */
}
.message-bubble[class*="status-"] .request-title::after {
    font-size: 14px; /* 让伪元素显示新文本 */
}
.message-bubble.status-paid .request-title::after {
    content: "我已为您买单，请尽情享用吧～";
}
.message-bubble.status-rejected .request-title::after {
    content: "我拒绝了您的代付请求";
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖请求的用户操作按钮样式 ▼▼▼ */
.waimai-user-actions {
    display: flex;
    gap: 10px;
    padding: 0 12px 12px 12px; /* 在卡片底部留出空间 */
    background-color: #fff;
}

.waimai-user-actions button {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    border: 1.5px solid;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.waimai-pay-btn {
    background-color: #28a745;
    border-color: #1f7a33;
    color: white;
}
.waimai-pay-btn:hover {
    background-color: #218838;
}

.waimai-decline-btn {
    background-color: #f8f9fa;
    border-color: #ced4da;
    color: #495057;
}
.waimai-decline-btn:hover {
    background-color: #e2e6ea;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* 确保这些页面的内容区能正确滚动，同时背景透明以显示父级颜色 */
#api-settings-screen .form-container,
#font-settings-screen .form-container,
#wallpaper-screen .form-container {
    padding-top: 100px;
    margin-top: -80px;
    /* 不再需要背景色，让父元素决定 */
}
#font-settings-screen,
#wallpaper-screen {
    /* 将背景色设置为变量，这样夜间模式才能覆盖它 */
    background-color: var(--secondary-bg);
}
/* 壁纸设置页面的预览区比较特殊，需要额外调整 */
#wallpaper-screen .form-container {
    align-items: center; /* 保持内容居中 */
}

/* ▼▼▼ 【全新】来电请求与视频通话界面样式 ▼▼▼ */

/* --- 通话类型选择模态框 --- */
#call-type-selection-modal .call-type-selection-content {
    background-color: rgba(40, 40, 40, 0.9);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 20px;
    width: 300px;
    padding: 25px;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.call-type-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 25px;
    color: white;
}

.call-type-actions {
    display: flex;
    justify-content: space-around;
    margin-bottom: 25px;
}

.call-type-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

.call-type-btn:active {
    transform: scale(0.9);
}

.call-type-btn.video-call-btn {
    background-color: #007aff;
}

.call-type-btn.voice-call-btn {
    background-color: #4cd964;
}

.call-type-btn svg {
    color: white;
}

.cancel-call-type-btn {
    width: 100%;
    padding: 12px;
    border-radius: 12px;
    border: none;
    background-color: rgba(255,255,255,0.1);
    color: white;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.cancel-call-type-btn:hover {
    background-color: rgba(255,255,255,0.15);
}

/* --- 来电请求模态框 --- */
#incoming-call-modal .incoming-call-content {
    background-color: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 20px;
    width: 280px;
    padding: 30px 20px;
    text-align: center;
    color: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.caller-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 12px;
    border: 3px solid rgba(255,255,255,0.5);
}

.caller-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 5px;
}

.caller-text {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 30px;
}

.incoming-call-actions {
    display: flex;
    justify-content: space-around;
    align-items: center;
}

.action-button-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}

.call-action-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-size: 50%;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    pointer-events: auto; /* 确保按钮可以接收点击事件 */
    position: relative; /* 确保按钮在正确的层级 */
    z-index: 100; /* 提高z-index确保在最上层 */
}
.call-action-btn:active {
    transform: scale(0.9);
}

.call-action-btn.decline {
    background-color: #ff3b30;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
}

.call-action-btn.accept {
    background-color: #4cd964;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7); }
    70% { box-shadow: 0 0 0 15px rgba(76, 217, 100, 0); }
    100% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0); }
}

/* ▼▼▼ 请用这一整块【最终结构重写版】的代码，替换所有旧的 video-call 相关CSS ▼▼▼ */

/* 1. 通话屏幕总容器 (保持不变) */
#video-call-screen {
    background-color: #1c1c1e;
    color: white;
    display: flex; /* ★ 核心：它依然是flex容器 */
    flex-direction: column;
    overflow: hidden;
}

/* 2. 顶部栏和底部控制栏 (保持不变) */
.video-call-top-bar, .video-call-controls {
    position: absolute;
    left: 0;
    width: 100%;
    z-index: 10;
    box-sizing: border-box;
    pointer-events: none; /* 让它们不影响下方内容的点击 */
}
.video-call-top-bar {
    top: 0;
    padding: 15px 20px 30px; /* 增加底部padding */
    padding-top: 50px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    text-align: center;
}
.video-call-controls {
    bottom: 0;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px;
    padding-bottom: 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
    pointer-events: all; /* 控制按钮需要能点击 */
}
#call-timer {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
}

/* 3. 【核心重构】默认文字通话的总容器 */
#text-call-interface {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    overflow: hidden;
}

/* 4. 【核心重构】头像区域 */
.video-call-avatar-area {
    flex-shrink: 0; /* ★ 核心：高度雷打不动，绝不压缩 */
    display: flex;
    justify-content: center;
    align-items: center;
    padding-top: 100px; /* ★ 核心：与顶部状态栏拉开距离 */
    padding-bottom: 20px; /* ★ 核心：与下方气泡区拉开距离 */
}

/* 5. 【核心重构】气泡区域 */
#video-call-main {
    flex-grow: 1; /* ★ 核心：占据所有剩余的垂直空间 */
    min-height: 0; /* ★ 核心：一个防止flex溢出的重要保险丝 */
    margin: 0 15px 130px 15px; /* ★ 核心：定义四周边界，底部留足空间给按钮 */
    overflow-y: auto;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.08); /* 稍微调亮一点背景 */
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

/* 6. 头像网格和头像本身样式 (微调) */
#participant-avatars-grid {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
}
.participant-avatar-wrapper {
    text-align: center;
}
.participant-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
}
.participant-name {
    margin-top: 8px;
    font-size: 13px;
    color: #ccc;
}
.participant-avatar.speaking {
    border-color: #4cd964;
    box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
    transform: scale(1.05);
}

/* 7. 控制按钮样式 (保持不变) */
.control-btn {
    width: 70px; height: 70px; border-radius: 50%; border: none; cursor: pointer;
    background-repeat: no-repeat; background-position: center;
    transition: transform 0.2s, background-color 0.2s;
    pointer-events: all;
}
.control-btn:active { transform: scale(0.9); }
.control-btn.speak-btn { background-color: rgba(255,255,255,0.2); background-size: 55%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>'); }
.control-btn.hangup-btn { background-color: #ff3b30; background-size: 50%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>'); }
.control-btn.join-btn { background-color: #007bff; background-size: 50%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>'); }

/* ▲▲▲ 新CSS替换结束 ▲▲▲ */

/* ▼▼▼ 【全新】语音通话界面样式 ▼▼▼ */

/* 语音通话屏幕总容器 */
#voice-call-screen {
    background-color: #1c1c1e;
    color: white;
    display: flex;
    flex-direction: column;
}

/* 语音通话顶部栏和控制栏 */
.voice-call-top-bar, .voice-call-controls {
    position: absolute;
    left: 0;
    width: 100%;
    z-index: 100;
    box-sizing: border-box;
    pointer-events: none; /* 让它们不影响下方内容的点击 */
}

.voice-call-top-bar {
    top: 0;
    padding: 15px 20px 30px;
    padding-top: 50px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    text-align: center;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.voice-call-controls {
    bottom: 0;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px 40px 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
    pointer-events: all; /* 控制按钮需要能点击 */
}

#voice-call-timer {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
    flex: 1;
    text-align: center;
}

/* 语音识别开关样式 */
.voice-recognition-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    pointer-events: all;
}

/* 自动语音播放开关样式 */
.auto-voice-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    pointer-events: all;
    margin-top: 8px;
}

/* 语音识别控制面板样式 */
.voice-recognition-controls {
    position: fixed;
    top: 50%;
    right: -220px; /* 增加隐藏距离，让收缩时露出更少 */
    background: rgba(0, 0, 0, 0.9);
    border-radius: 8px 0 0 8px;
    padding: 10px;
    min-width: 200px;
    z-index: 1000;
    pointer-events: all;
    transform: translateY(-50%);
    transition: right 0.3s ease-in-out;
    cursor: pointer;
}

/* 展开状态 */
.voice-recognition-controls.expanded {
    right: 10px;
}

/* 收起状态时隐藏所有内部控件 */
.voice-recognition-controls:not(.expanded) > * {
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease-in-out;
}

/* 展开状态时显示所有内部控件 */
.voice-recognition-controls.expanded > * {
    opacity: 1;
    pointer-events: all;
    transition: opacity 0.2s ease-in-out;
}

/* 麦克风图标 - 始终可见的触发区域 */
.voice-recognition-controls::before {
    content: '🖤'; /* 改为黑色爱心 */
    position: absolute;
    left: -30px; /* 调整位置让收缩时露出更少 */
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.6); /* 调整透明度：从0.9改为0.6，更透明 */
    color: white;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 16px;
    pointer-events: all;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    /* 移除边框 */
}

/* 麦克风图标悬停效果 */
.voice-recognition-controls::before:hover {
    background: rgba(0, 0, 0, 0.85); /* 悬停时也保持一定透明度 */
    /* 悬停时也不显示边框 */
    transform: translateY(-50%) scale(1.1);
}

/* 消息队列显示样式 */
.message-queue-display {
    margin-bottom: 10px;
}

.queue-header {
    color: #fff;
    font-size: 12px;
    margin-bottom: 5px;
    padding-bottom: 3px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

.queue-messages {
    max-height: 150px;
    overflow-y: auto;
}

.queue-message-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    padding: 6px 8px;
    margin-bottom: 3px;
    font-size: 11px;
    color: #fff;
}

.queue-message-text {
    flex: 1;
    margin-right: 8px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 120px;
}

.queue-message-delete {
    background: #ff4757;
    border: none;
    color: white;
    border-radius: 3px;
    padding: 2px 6px;
    cursor: pointer;
    font-size: 10px;
    flex-shrink: 0;
}

.queue-message-delete:hover {
    background: #ff3742;
}

/* 语音锁定开关样式 */
.voice-lock-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
}

.toggle-switch.small {
    transform: scale(0.8);
}

.toggle-label.small {
    font-size: 11px;
    color: #ccc;
}

.toggle-switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

/* Slider 样式 - 让开关更明显 */
.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: 0.4s;
    border-radius: 24px;
}

.slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.4s;
    border-radius: 50%;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

input:checked + .slider {
    background-color: #4CAF50;
}

input:checked + .slider:before {
    transform: translateX(20px);
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.3);
    transition: 0.3s;
    border-radius: 24px;
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.3s;
    border-radius: 50%;
}

input:checked + .toggle-slider {
    background-color: #666666;
}

input:checked + .toggle-slider:before {
    transform: translateX(20px);
}

.toggle-label {
    font-size: 12px;
    color: white;
    white-space: nowrap;
}

/* 语音输入指示器样式 */
.voice-input-indicator {
    color: #007AFF;
    font-weight: bold;
    margin-right: 5px;
}

/* 语音识别状态指示器 */
.voice-recognition-status {
    position: fixed;
    top: 45px;
    left: 20px;
    transform: none;
    background: transparent;
    color: #333;
    padding: 0;
    border-radius: 0;
    display: none;
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
    z-index: 10000;
    backdrop-filter: none;
}

.voice-recognition-status.active {
    display: flex;
}

/* 音频波动效果 */
.audio-waveform {
    display: flex;
    align-items: center;
    gap: 3px;
    height: 20px;
}

.audio-bar {
    width: 4px;
    background: #666;
    border-radius: 2px;
    animation: audioWave 1.2s ease-in-out infinite;
}

.audio-bar:nth-child(1) { animation-delay: 0s; }
.audio-bar:nth-child(2) { animation-delay: 0.1s; }
.audio-bar:nth-child(3) { animation-delay: 0.2s; }
.audio-bar:nth-child(4) { animation-delay: 0.3s; }
.audio-bar:nth-child(5) { animation-delay: 0.4s; }
.audio-bar:nth-child(6) { animation-delay: 0.2s; }
.audio-bar:nth-child(7) { animation-delay: 0.1s; }

@keyframes audioWave {
    0%, 100% { 
        height: 6px; 
        opacity: 0.4;
    }
    50% { 
        height: 16px; 
        opacity: 1;
    }
}

/* 识别中文字 */
.recognition-text {
    font-size: 12px;
    color: #666;
    margin-top: 0;
    font-weight: 500;
}

/* 语音通话头像区域 */
.voice-call-avatar-area {
    flex-shrink: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 80px 20px 30px;
    min-height: 120px;
}

/* 语音通话气泡区域 */
.voice-call-main {
    flex-grow: 1;
    min-height: 0;
    margin: 0 15px 130px 15px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 15px;
    padding: 15px 0;
}

/* ▲▲▲ 语音通话界面样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】视频通话对话气泡样式 ▼▼▼ */
.call-message-bubble {
    padding: 10px 15px;
    border-radius: 12px;
    max-width: 85%;
    line-height: 1.6;
    word-break: break-word;
    white-space: pre-wrap;
    position: relative;
}

.call-message-bubble.ai-speech {
    /* ★ 精致黑灰色晕染效果：中间深，两边虚化 */
    background: linear-gradient(90deg, 
        rgba(30, 30, 30, 0) 0%,           /* 左边缘透明 */
        rgba(45, 45, 45, 0.6) 8%,         /* 左侧渐入 */
        rgba(60, 60, 60, 0.85) 20%,       /* 中间偏左 */
        rgba(70, 70, 70, 0.95) 50%,       /* 中心最深 */
        rgba(60, 60, 60, 0.85) 80%,       /* 中间偏右 */
        rgba(45, 45, 45, 0.6) 92%,        /* 右侧渐出 */
        rgba(30, 30, 30, 0) 100%          /* 右边缘透明 */
    );
    color: rgba(255, 255, 255, 0.95);
    align-self: flex-start; /* AI发言靠左 */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

/* 具备语音功能的消息气泡样式 */
.call-message-bubble.ai-speech[data-has-voice="true"] {
    position: relative;
    transition: all 0.3s ease;
    cursor: pointer;
}

.call-message-bubble.ai-speech[data-has-voice="true"]:hover {
    /* hover时中心更亮一些 */
    background: linear-gradient(90deg, 
        rgba(30, 30, 30, 0) 0%, 
        rgba(55, 55, 55, 0.7) 8%, 
        rgba(75, 75, 75, 0.9) 20%, 
        rgba(85, 85, 85, 1) 50%, 
        rgba(75, 75, 75, 0.9) 80%, 
        rgba(55, 55, 55, 0.7) 92%, 
        rgba(30, 30, 30, 0) 100%
    );
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

.call-message-bubble.ai-speech[data-has-voice="true"]::after {
    content: "▶";
    color: rgba(255, 255, 255, 0.7);
    position: absolute;
    top: 4px;
    right: 8px;
    font-size: 10px;
    opacity: 0.6;
}

.call-message-bubble.ai-speech[data-has-voice="true"]:hover::after {
    opacity: 1;
    color: rgba(255, 255, 255, 0.95);
}

.call-message-bubble.user-speech {
    /* ★ 柔和白色渐变，不刺眼，左右边缘虚化 */
    background: linear-gradient(90deg, 
        rgba(245, 245, 245, 0) 0%,        /* 左边缘透明 */
        rgba(250, 250, 250, 0.6) 8%,      /* 左侧渐入 */
        rgba(252, 252, 252, 0.85) 20%,    /* 中间偏左 */
        rgba(255, 255, 255, 0.92) 50%,    /* 中心最亮（但不刺眼） */
        rgba(252, 252, 252, 0.85) 80%,    /* 中间偏右 */
        rgba(250, 250, 250, 0.6) 92%,     /* 右侧渐出 */
        rgba(245, 245, 245, 0) 100%       /* 右边缘透明 */
    );
    color: rgba(30, 30, 30, 0.95);
    align-self: flex-end;   /* 用户发言靠右 */
    text-align: left; /* 确保用户气泡内的文字是左对齐的 */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【全新添加】正在呼叫界面样式 ▼▼▼ */
#outgoing-call-screen {
    background-color: #1c1c1e;
    color: white;
    justify-content: center; /* 垂直居中 */
    align-items: center;   /* 水平居中 */
    pointer-events: auto; /* 确保整个屏幕可以接收事件 */
}

.outgoing-call-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.outgoing-call-actions {
    margin-top: 50px; /* 和上方文字拉开距离 */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
    pointer-events: auto; /* 确保容器可以接收点击事件 */
    position: relative; /* 确保容器在正确的层级 */
    z-index: 50; /* 提高z-index */
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* 1. 动态帖子的外层容器，我们需要它来定位和裁剪 */
.qzone-post-container {
    position: relative; /* 让内部的删除按钮可以相对于它定位 */
    overflow: hidden;   /* 隐藏掉超出部分的删除按钮 */
    border-radius: 12px;/* 和内部卡片保持一致的圆角 */
}

/* 2. 可滑动的内容卡片，增加一个平滑的过渡效果 */
.qzone-post-item {
    transition: transform 0.3s ease;
    background-color: var(--secondary-bg); /* 确保它有背景色，能盖住下面的删除按钮 */
    position: relative; /* 确保它在最上层 */
    z-index: 2;
}

/* 3. 【核心】这就是那个“删除”按钮的样式！*/
.qzone-post-delete-action {
    position: absolute; /* 绝对定位，脱离文档流 */
    top: 0;
    right: 0;
    bottom: 0;
    width: 90px; /* 删除按钮的宽度 */
    background-color: #ff3b30; /* 您想要的红色背景 */
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    cursor: pointer;
    z-index: 1; /* 确保它在卡片下面 */
}

/* 4. 当卡片左滑时，把它向左移动，露出删除按钮 */
.qzone-post-item.swiped {
    transform: translateX(-90px); /* 移动的距离和删除按钮的宽度一致 */
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这【一整块】全新的“拍一拍”样式，粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. “拍一拍”的屏幕震动动画 */
@keyframes pat-shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
    20%, 40%, 60%, 80% { transform: translateX(3px); }
}

.pat-animation {
    animation: pat-shake 0.4s ease-in-out;
}

/* 2. “拍一拍”系统提示消息的样式 */
.system-message {
    align-self: center; /* 居中显示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* 让“拍一拍”类型的 wrapper 居中 */
.message-wrapper.system-pat {
    justify-content: center;
    align-self: center;
    margin: 5px 0;
    max-width: 80%;
}
/* “拍一-拍”消息气泡的样式 */
.message-bubble.system-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* === 修正：让顶部操作栏可以横向滚动 === */
#chat-input-actions-top {
    display: flex;
    gap: 8px;
    padding: 0 5px;

    /* --- 核心代码开始 --- */
    overflow-x: auto;      
    flex-wrap: nowrap;     
    -webkit-overflow-scrolling: touch; 

    scrollbar-width: none; 
    -ms-overflow-style: none;  
}

#chat-input-actions-top::-webkit-scrollbar {
    display: none; 
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【全新】聊天界面头部状态栏样式 === */

/* === 【全新】聊天界面头部状态栏样式 === */

#chat-header-title-wrapper {
    /* 核心修改：使用绝对定位来脱离flex流并实现完美居中 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    
    /* 为了防止长标题与两边的按钮重叠，可以设置一个最大宽度 */
    max-width: 60%;
    
    /* 保留原有的内部布局样式 */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
}


/* 【新增】这是我们新加的样式，用于将标题和心形按钮横向排列 */
#chat-header-main-line {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px; /* 标题和心形按钮之间的间距 */
}


/* ▼▼▼ 请用这块【终极修复版】代码，替换掉你旧的 #chat-header-title 样式 ▼▼▼ */
#chat-header-title {
    font-size: 16px;
    font-weight: 600;
    
    /* (这两行是上次修复定位问题的，必须保留！) */
    position: static !important;
    transform: none !important;

    /* ★★★ 核心修复：我们已经把导致省略号的四行代码全部删掉了！ ★★★ */
}
/* ▲▲▲ 替换结束 ▲▲▲ */




/* 3. 状态栏容器 */
#chat-header-status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-secondary);
    transition: all 0.3s ease;
}

/* 4. 状态小圆点 */
.status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background-color: #4cd964; /* 默认绿色，代表在线 */
    transition: background-color 0.3s ease;
}

/* 当AI状态为“忙碌”或“离开”时，让圆点变灰色 */
#chat-header-status.busy .status-dot {
    background-color: #cccccc;
}

/* 5. 状态文本 */
.status-text {
    font-weight: 500;
}

/* === 【全新美化版】回忆卡片样式 === */

/* 1. 卡片总容器：这里负责定义整体的背景色和边框 */
.memory-card {
    background-color: #fffaf0; /* 统一的、温暖的米黄色背景 */
    border-radius: 12px;
    padding: 15px; /* 在卡片四周留出内边距 */
    box-shadow: 0 2px 6px rgba(0,0,0,0.07);
    border-left: 5px solid #ffb74d; 
    display: flex; /* 让它成为flex容器，方便内部元素排列 */
    flex-direction: column; /* 让头部和内容垂直堆叠 */
    gap: 8px; /* 在头部和内容之间创造一个自然的间距 */
}

/* 2. 头部容器：现在只负责布局和分割线 */
.memory-card .header {
    border-bottom: 1px solid rgba(217, 129, 0, 0.15); /* 分割线颜色可以稍微加深一点 */
    padding-bottom: 8px; 
}

/* 3. 日期样式 (保持不变) */
.memory-card .header .date {
    font-size: 11px;
    color: #a1887f;
    margin-bottom: 4px; 
}

/* 4. 作者样式 (保持不变) */
.memory-card .header .author {
    font-weight: 600;
    color: #d98100;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. 内容区样式 (保持不变) */
.memory-card .content {
    font-size: 14px;
    line-height: 1.7;
    color: #5d4037;
    white-space: pre-wrap;
}

/* === 【全新】约定/倒计时卡片样式 === */
.countdown-card {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
    text-align: center;
    position: relative;
    overflow: hidden;
    flex-shrink: 0;
}
.countdown-card::before {
    content: '✨';
    position: absolute;
    top: -10px;
    left: -10px;
    font-size: 50px;
    opacity: 0.1;
    transform: rotate(-15deg);
}
.countdown-card .title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
}
.countdown-card .timer {
    font-size: 28px;
    font-weight: 300;
    letter-spacing: 2px;
    margin-bottom: 15px;
}
.countdown-card .target-date {
    font-size: 12px;
    opacity: 0.8;
    border-top: 1px solid rgba(255,255,255,0.2);
    padding-top: 10px;
}

/* === 【全新】聊天锁定遮罩层样式 === */
#chat-lock-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 150; /* 比输入框高，比贴纸面板低 */
    display: none; /* 默认隐藏 */
    align-items: center;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
    border-top: 1px solid var(--border-color);
    text-align: center;
}
#chat-lock-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
#chat-lock-content .lock-text {
    color: var(--text-secondary);
    font-size: 14px;
}
#chat-lock-content .lock-action-btn {
    padding: 10px 20px;
    border-radius: 20px;
    border: 1px solid var(--accent-color);
    background-color: var(--accent-color);
    color: white;
    cursor: pointer;
}
#chat-lock-content .lock-action-btn.secondary {
    background-color: transparent;
    color: var(--accent-color);
}

/* ▼▼▼ 【全新】红包卡片样式 ▼▼▼ */
.message-bubble.is-red-packet .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.red-packet-card {
    width: 220px;
    border-radius: 8px;
    background: linear-gradient(160deg, #F96259, #E44D44);
    color: #ffd700; /* 金色文字 */
    padding: 12px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.red-packet-card.opened {
    background: linear-gradient(160deg, #d3c4a0, #c4b693);
    cursor: default;
}

.red-packet-card::before {
    content: '🧧';
    position: absolute;
    top: -5px;
    left: -5px;
    font-size: 30px;
    opacity: 0.2;
    transform: rotate(-10deg);
}

.rp-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.rp-icon {
    width: 20px;
    height: 20px;
}

.rp-greeting {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.rp-type {
    font-size: 11px;
    color: white;
    opacity: 0.8;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 8px;
    margin-top: 8px;
}

.rp-claimed-info {
    font-size: 13px;
    color: white;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.3);
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】红包详情列表样式 ▼▼▼ */
.rp-details-item {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}
.rp-details-item:last-child {
    border-bottom: none;
}
.rp-details-item .name {
    flex-grow: 1;
    font-weight: 500;
    color: #333;
}
.rp-details-item .amount {
    font-weight: 500;
    color: #555;
}
.rp-details-item .lucky-king-tag {
    font-size: 10px;
    background-color: #ffd700;
    color: #a67c00;
    padding: 2px 5px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: bold;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】投票功能样式 ▼▼▼ */

/* 投票卡片在消息气泡中的样式 */
.message-bubble.is-poll .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 投票卡片主体 */
.poll-card {
    width: 250px;
    background-color: #f9f9f9;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.poll-card.closed {
    background-color: #e9ecef; /* 结束后变灰 */
}

/* 投票问题 */
.poll-question {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 12px;
    line-height: 1.4;
    word-break: break-word;
}

/* 投票选项列表 */
.poll-options-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* 单个投票选项 */
.poll-option-item {
    background-color: white;
    border: 1px solid #dcdcdc;
    border-radius: 8px;
    padding: 10px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: background-color 0.2s;
}

.poll-card:not(.closed) .poll-option-item:hover {
    background-color: #f0f8ff;
}

/* 用户已投票的选项样式 */
.poll-option-item.voted {
    border-color: var(--accent-color);
    background-color: #e7f3ff;
    font-weight: 500;
}

/* 投票进度条 */
.poll-option-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background-color: rgba(0, 123, 255, 0.1);
    z-index: 1;
    transition: width 0.3s ease-in-out;
}

/* 选项内容（文字和票数），确保在进度条之上 */
.poll-option-content {
    position: relative;
    z-index: 2;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.poll-option-text {
    font-size: 14px;
}

.poll-option-votes {
    font-size: 13px;
    color: #8a8a8a;
    font-weight: 500;
}

/* 投票卡片底部 */
.poll-footer {
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #e9e9e9;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.poll-total-votes {
    font-weight: 500;
}

.poll-action-btn {
    background: none;
    border: 1px solid var(--accent-color);
    color: var(--accent-color);
    padding: 4px 10px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 12px;
}
.poll-card.closed .poll-action-btn {
    background-color: #6c757d;
    color: white;
    border-color: #6c757d;
}

/* 创建投票模态框的选项输入 */
.poll-option-input-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
}
.poll-option-input-wrapper input {
    flex-grow: 1;
}
.poll-option-input-wrapper .remove-option-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #ff3b30;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    flex-shrink: 0;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【全新】聊天头部“正在输入”状态样式 === */
#chat-header-title.typing-status {
    color: var(--text-secondary);
    animation: typing-pulse 1.5s infinite;
    font-style: italic;
}

@keyframes typing-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

#chat-header-title {
    transition: opacity 0.2s ease-in-out;
}

@keyframes message-pop-in {
  from {
    opacity: 0;
    transform: translateY(15px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-wrapper.animate-in {
  animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
  }

/* ▼▼▼ 【全新】回忆页面粉色主题样式 ▼▼▼ */

/* 回忆页面整体粉色背景 */
#memories-view {
    background: linear-gradient(135deg, #ffeef4, #fff0f5, #fdf2f8);
    min-height: 100vh;
}

/* 主选择界面容器 */
.memories-selection-container {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    height: 100vh;
    padding: 0;
}

/* 按钮容器 */
.memories-selection-buttons {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
}

/* 空间选择按钮样式 */
.memory-space-btn {
    border: none;
    border-radius: 0;
    padding: 0;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
    height: 50%;
    width: 100%;
    position: relative;
    overflow: hidden;
}

/* 恋爱空间按钮 - 白色模糊晕染 */
.memory-space-btn.love-space {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.9), 
        rgba(255, 255, 255, 0.7), 
        rgba(255, 240, 245, 0.8)
    );
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
}

.memory-space-btn.love-space::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at center, 
        rgba(255, 255, 255, 0.4) 0%, 
        rgba(255, 240, 245, 0.2) 50%, 
        transparent 70%
    );
    pointer-events: none;
}

/* 私人空间按钮 - 黑色模糊晕染 */
.memory-space-btn.private-space {
    background: linear-gradient(135deg, 
        rgba(0, 0, 0, 0.7), 
        rgba(30, 30, 30, 0.6), 
        rgba(50, 50, 50, 0.5)
    );
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    color: white;
}

.memory-space-btn.private-space::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at center, 
        rgba(0, 0, 0, 0.3) 0%, 
        rgba(30, 30, 30, 0.2) 50%, 
        transparent 70%
    );
    pointer-events: none;
}

.memory-space-btn:hover {
    transform: scale(1.02);
}

.memory-space-btn:active {
    transform: scale(0.98);
}

/* 按钮图标 */
.btn-icon {
    font-size: 48px;
    margin-bottom: 10px;
    position: relative;
    z-index: 1;
}

/* 按钮文字 */
.btn-text {
    font-size: 24px;
    font-weight: 600;
    position: relative;
    z-index: 1;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

/* 恋爱空间按钮文字颜色 */
.memory-space-btn.love-space .btn-text {
    color: #333;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* 私人空间按钮文字颜色 */
.memory-space-btn.private-space .btn-text {
    color: white;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* 空间界面样式 */
.memory-space-view {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    max-width: 100%;
    overflow-x: hidden; /* 防止左右滑动 */
    box-sizing: border-box;
    position: relative;
    z-index: 10;
}

/* 恋爱空间默认背景 */
#love-space-view {
    background: linear-gradient(135deg, #ffeef4, #fff0f5, #fdf2f8);
    /* 壁纸设置时会覆盖此背景 */
}

/* 相册详情页面需要更高的层级 */
#album-detail-view {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 20;
    background: var(--bg-color);
    padding-top: 30px; /* 为状态栏留出空间 */
}

/* 适配不同设备的状态栏高度 */
@media (max-width: 768px) {
    #album-detail-view {
        padding-top: 25px; /* 手机端状态栏空间 */
    }
}

/* 新的相册导航栏 - 16:9磨砂玻璃框 */
.space-header {
    position: relative;
    z-index: 15;
    flex-shrink: 0;
    padding: 25px 15px 15px 15px;
    background: none;
    border: none;
    box-sizing: border-box;
}

/* 16:9磨砂玻璃上传框 */
.upload-nav-frame {
    position: relative;
    width: 100%;
    aspect-ratio: 16/9;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 80px;
}

.upload-nav-frame:hover {
    background: rgba(255, 255, 255, 0.25);
    border-color: rgba(255, 192, 203, 0.4);
    transform: translateY(-1px);
}

/* 封面图片容器 */
.cover-image-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 12px;
    overflow: hidden;
    pointer-events: none;
}

/* 封面图片 */
.cover-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
}

/* 上传提示文字 */
.upload-hint {
    color: rgba(255, 255, 255, 0.8);
    font-size: 14px;
    font-weight: 500;
    text-align: center;
    pointer-events: none;
    position: relative;
    z-index: 2;
    background: rgba(0, 0, 0, 0.3);
    padding: 8px 12px;
    border-radius: 8px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    transition: all 0.3s ease;
}

/* 导航按钮容器 */
.nav-buttons {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 8px;
}

/* 左侧返回按钮 */
.nav-back-btn {
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    color: white;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.nav-back-btn:hover {
    background: rgba(0, 0, 0, 0.5);
    transform: scale(1.1);
}

/* 右侧按钮组 */
.nav-right-buttons {
    display: flex;
    gap: 8px;
    align-items: center;
}

/* 通用按钮样式 */
.nav-collapse-btn,
.nav-add-btn,
.nav-settings-btn {
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    color: white;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
}

/* 折叠按钮 */
.nav-collapse-btn {
    font-size: 18px;
    font-weight: bold;
}

/* 添加按钮 */
.nav-add-btn {
    font-size: 18px;
}

/* 设置按钮 */
.nav-settings-btn {
    font-size: 14px;
}

/* 按钮悬停效果 */
.nav-collapse-btn:hover,
.nav-add-btn:hover,
.nav-settings-btn:hover {
    background: rgba(0, 0, 0, 0.5);
    transform: scale(1.1);
}

/* 折叠状态下的头部样式 */
.upload-nav-frame.collapsed {
    height: 50px !important;
    aspect-ratio: unset !important;
    min-height: 50px !important;
    transition: all 0.3s ease;
}

.upload-nav-frame.collapsed .upload-hint,
.upload-nav-frame.collapsed .cover-image-container {
    opacity: 0;
    pointer-events: none;
}

/* 空间头部按钮样式适配 - 保持兼容 */
.space-header .back-btn,
.space-header .action-btn {
    display: none; /* 隐藏原始按钮 */
}

/* 背景设置弹窗样式 */
.background-upload-area {
    padding: 40px 20px;
    border: 2px dashed rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-bottom: 20px;
}

.background-upload-area:hover {
    border-color: rgba(255, 192, 203, 0.5);
    background: rgba(255, 255, 255, 0.05);
}

.background-upload-icon {
    font-size: 48px;
    margin-bottom: 12px;
}

.background-upload-text {
    color: rgba(255, 255, 255, 0.9);
    font-size: 16px;
    font-weight: 500;
    margin-bottom: 8px;
}

.background-upload-hint {
    color: rgba(255, 255, 255, 0.6);
    font-size: 14px;
}

.background-preview {
    text-align: center;
}

.background-preview img {
    max-width: 100%;
    max-height: 200px;
    border-radius: 8px;
    margin-bottom: 15px;
}

.background-preview-actions {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.btn-apply,
.btn-reset {
    padding: 8px 16px;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
}

.btn-apply {
    background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
    color: white;
}

.btn-apply:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(255, 154, 158, 0.3);
}

.btn-reset {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.btn-reset:hover {
    background: rgba(255, 255, 255, 0.2);
}

/* 响应式优化 */
@media (max-width: 480px) {
    .space-header {
        padding: 20px 10px 10px 10px;
    }
    
    .upload-nav-frame {
        border-radius: 8px;
        min-height: 60px;
    }
    
    .upload-hint {
        font-size: 12px;
    }
    
    .nav-back-btn,
    .nav-add-btn {
        width: 24px;
        height: 24px;
        font-size: 14px;
    }
    
    .nav-add-btn {
        font-size: 16px;
    }
}

/* 绑定按钮样式 */
.bind-char-button {
    background: linear-gradient(135deg, #ff69b4, #ff1493);
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 15px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(255, 20, 147, 0.3);
    transition: all 0.2s ease;
}

.bind-char-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(255, 20, 147, 0.4);
}

.bind-char-button.bound {
    background: linear-gradient(135deg, #32cd32, #228b22);
    box-shadow: 0 2px 8px rgba(34, 139, 34, 0.3);
}

.bind-char-button.bound:hover {
    box-shadow: 0 4px 12px rgba(34, 139, 34, 0.4);
}

/* 新的简化导航区域 */
.love-space-nav {
    position: absolute;
    top: 20px;
    left: 20px;
    right: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 10;
}

/* 导航右侧按钮组 */
.nav-right-buttons {
    display: flex;
    align-items: center;
    gap: 15px;
}

/* DIY开关按钮样式 */
.diy-toggle-btn {
    background: transparent;
    color: white;
    border: none;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 18px;
    transition: all 0.3s ease;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.diy-toggle-btn:hover {
    transform: scale(1.1);
    text-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
}

.diy-toggle-btn:active,
.diy-toggle-btn.active {
    color: #ffd700;
    transform: scale(1.05);
    text-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700, 0 0 30px #ffd700;
    filter: brightness(1.5) saturate(1.5);
}

/* 设置按钮样式 */
.settings-btn {
    background: transparent;
    color: white;
    border: none;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 20px;
    transition: all 0.3s ease;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.settings-btn:hover {
    transform: scale(1.1);
    text-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
}

/* 设置菜单样式 */
.love-settings-menu {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
}

.settings-menu-content {
    background: white;
    border-radius: 12px;
    width: 280px;
    max-width: 90vw;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.settings-menu-header {
    background: #f8f9fa;
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #e9ecef;
}

.settings-menu-header h3 {
    margin: 0;
    color: #333;
    font-size: 18px;
}

.close-settings {
    cursor: pointer;
    font-size: 24px;
    color: #666;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.close-settings:hover {
    background: #e9ecef;
    color: #333;
}

.settings-menu-list {
    padding: 0;
}

.settings-menu-item {
    padding: 15px 20px;
    cursor: pointer;
    border-bottom: 1px solid #f1f3f4;
    transition: background-color 0.2s ease;
    color: #333;
}

.settings-menu-item:hover {
    background: #f8f9fa;
}

.settings-menu-item:last-child {
    border-bottom: none;
}

/* 设置弹窗样式 */
.love-settings-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1001;
    display: flex;
    justify-content: center;
    align-items: center;
}

.settings-modal-content {
    background: white;
    border-radius: 12px;
    width: 400px;
    max-width: 90vw;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.settings-modal-header {
    background: #f8f9fa;
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #e9ecef;
}

.settings-modal-header h3 {
    margin: 0;
    color: #333;
    font-size: 18px;
}

.close-settings-modal {
    cursor: pointer;
    font-size: 24px;
    color: #666;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.close-settings-modal:hover {
    background: #e9ecef;
    color: #333;
}

.settings-modal-body {
    padding: 20px;
    max-height: 60vh;
    overflow-y: auto;
}

/* DIY装饰上传弹窗样式 */
.diy-upload-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1002;
    display: flex;
    justify-content: center;
    align-items: center;
}

.diy-upload-content {
    background: white;
    border-radius: 12px;
    width: 450px;
    max-width: 90vw;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.diy-upload-header {
    background: #f8f9fa;
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #e9ecef;
}

.diy-upload-header h3 {
    margin: 0;
    color: #333;
    font-size: 18px;
}

.close-diy-upload {
    cursor: pointer;
    font-size: 24px;
    color: #666;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.close-diy-upload:hover {
    background: #e9ecef;
    color: #333;
}

.diy-upload-body {
    padding: 20px;
}

.url-input-group, .size-input-group {
    margin-bottom: 20px;
}

.url-input-group label, .size-input-group label {
    display: block;
    margin-bottom: 8px;
    color: #333;
    font-weight: 500;
}

.url-input-group input {
    width: 100%;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 14px;
    box-sizing: border-box;
}

.size-inputs {
    display: flex;
    align-items: center;
    gap: 10px;
}

.size-inputs input {
    width: 80px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 14px;
    text-align: center;
}

.preview-area {
    margin-top: 15px;
    text-align: center;
    padding: 20px;
    border: 2px dashed #ddd;
    border-radius: 8px;
    background: #f9f9f9;
}

.preview-area img {
    max-width: 200px;
    max-height: 150px;
    border-radius: 6px;
}

.diy-upload-footer {
    padding: 15px 20px;
    background: #f8f9fa;
    border-top: 1px solid #e9ecef;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.diy-upload-footer button {
    padding: 8px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
}

.btn-cancel {
    background: #f8f9fa;
    color: #666;
    border: 1px solid #ddd;
}

.btn-cancel:hover {
    background: #e9ecef;
}

.btn-confirm {
    background: #ff6b9d;
    color: white;
}

.btn-confirm:hover {
    background: #ff5a8a;
}

/* DIY装饰层样式 */
.diy-decoration-layer {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 5;
}

.diy-decoration-layer.edit-mode {
    pointer-events: auto;
}

/* 装饰图片样式 */
.decoration-item {
    position: absolute;
    cursor: move;
    user-select: none;
    transition: box-shadow 0.2s ease;
    border: 2px solid transparent;
}

.decoration-item:hover {
    box-shadow: 0 0 10px rgba(255, 107, 157, 0.5);
}

.decoration-item.selected {
    box-shadow: 0 0 15px rgba(255, 107, 157, 0.8);
    border: 2px solid rgba(255, 107, 157, 0.8);
}

.decoration-item img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    border-radius: 6px;
    pointer-events: none;
}

/* 调整大小控制点 */
.resize-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    background: #ff6b9d;
    border: 2px solid white;
    border-radius: 50%;
    display: none;
    z-index: 15;
}

.decoration-item.selected .resize-handle {
    display: block;
}

.resize-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
.resize-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
.resize-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
.resize-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }

/* 旋转控制点 */
.rotate-handle {
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    width: 16px;
    height: 16px;
    background: #ff6b9d;
    border: 2px solid white;
    border-radius: 50%;
    cursor: grab;
    display: none;
    z-index: 15;
}

.decoration-item.selected .rotate-handle {
    display: block;
}

.rotate-handle:active {
    cursor: grabbing;
}

/* 装饰图片控制按钮 */
.decoration-controls {
    position: absolute;
    top: -35px;
    right: -10px;
    display: none;
    flex-direction: row;
    gap: 5px;
    z-index: 10;
}

.decoration-item.selected .decoration-controls {
    display: flex;
}

.control-btn {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    transition: all 0.2s ease;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.layer-up-btn {
    background: #4CAF50;
    color: white;
}

.layer-down-btn {
    background: #2196F3;
    color: white;
}

.flip-h-btn {
    background: #FF9800;
    color: white;
}

.flip-v-btn {
    background: #9C27B0;
    color: white;
}

.rotate-btn {
    background: #607D8B;
    color: white;
}

.delete-btn {
    background: #f44336;
    color: white;
}

.control-btn:hover {
    transform: scale(1.1);
}

/* 新的透明绑定按钮 */
.bind-char-button-new {
    background: transparent;
    color: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 6px 12px;
    border-radius: 0;
    font-size: 12px;
    font-weight: 400;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
}

.bind-char-button-new:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.5);
    color: white;
}

.bind-char-button-new.bound {
    background: rgba(50, 205, 50, 0.2);
    border-color: rgba(50, 205, 50, 0.5);
    color: #32cd32;
}

.bind-char-button-new.bound:hover {
    background: rgba(50, 205, 50, 0.3);
    border-color: rgba(50, 205, 50, 0.7);
}

/* 绑定角色按钮区域样式 - 已删除，不再需要 */
/* .bind-char-section 相关样式已移除，因为按钮已删除 */

/* 顶部打卡统计样式 */
.checkin-info-top {
    width: 100%;
    margin-bottom: 25px; /* 增加底部距离，避免挡住设置按钮 */
    margin-top: 45px; /* 增加顶部距离，整体往下移 */
    position: relative;
    z-index: 10; /* 确保顶部框在最上层 */
}

.checkin-info-top .checkin-stats {
    display: flex !important;
    justify-content: center;
    gap: 30px; /* 减少间距，让两个框更紧凑 */
    background: rgba(255, 255, 255, 0.15);
    padding: 12px 25px; /* 减少左右padding，让整体更紧凑 */
    border-radius: 30px;
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.25);
    box-shadow: 0 8px 32px rgba(255, 107, 157, 0.2);
    flex-wrap: nowrap !important; /* 强制不换行 */
    white-space: nowrap !important; /* 强制文字不换行 */
    min-width: 0 !important; /* 防止flex项目被挤压 */
    overflow: hidden !important; /* 防止溢出 */
    width: 85%; /* 横向拉长框的宽度，适应屏幕但不太短 */
    min-width: 280px; /* 设置最小宽度，防止太短 */
    max-width: 400px; /* 设置合适的最大宽度 */
    margin: 0 auto; /* 水平居中显示 */
    /* 🔥 超级强制防止分行的样式 🔥 */
    flex-direction: row !important; /* 强制水平排列 */
    align-items: center !important; /* 垂直居中 */
    height: auto !important; /* 自动高度但不允许换行 */
    line-height: 1 !important; /* 固定行高 */
}

.checkin-info-top .stat-item {
    display: flex !important;
    flex-direction: row !important; /* 改为水平排列 */
    align-items: center !important; /* 垂直居中对齐 */
    gap: 6px; /* 标签、数值、单位之间的间距 */
    flex-shrink: 0 !important; /* 防止被压缩 */
    white-space: nowrap !important; /* 强制不换行 */
    min-width: 0 !important; /* 防止被挤压 */
    /* 🔥 超级强制防止内部分行 🔥 */
    flex-wrap: nowrap !important; /* 绝对不允许换行 */
    overflow: hidden !important; /* 隐藏溢出内容而不是换行 */
    text-overflow: ellipsis !important; /* 如果太长就显示省略号 */
    max-width: none !important; /* 不限制最大宽度 */
    width: auto !important; /* 自动宽度 */
}

.checkin-info-top .stat-label {
    font-size: 14px;
    color: #C0C0C0;
    font-weight: 500;
    white-space: nowrap !important;
    flex-shrink: 0 !important;
    /* 🔥 强制防止换行 🔥 */
    display: inline-block !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    word-break: keep-all !important;
    word-wrap: normal !important;
}

.checkin-info-top .stat-value {
    font-size: 20px; /* 减小字体大小，适应水平排列 */
    font-weight: bold;
    color: #ff6b9d;
    text-shadow: 0 2px 4px rgba(255, 107, 157, 0.3);
    white-space: nowrap !important;
    flex-shrink: 0 !important;
    /* 🔥 强制防止换行 🔥 */
    display: inline-block !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    word-break: keep-all !important;
    word-wrap: normal !important;
}

.checkin-info-top .stat-unit {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.7);
    font-weight: 300;
    white-space: nowrap !important;
    flex-shrink: 0 !important;
    /* 🔥 强制防止换行 🔥 */
    display: inline-block !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    word-break: keep-all !important;
    word-wrap: normal !important;
}

/* 🔥🔥🔥 超级强制防止顶部打卡框分行的终极规则 🔥🔥🔥 */
.checkin-info-top, 
.checkin-info-top *, 
.checkin-info-top .checkin-stats, 
.checkin-info-top .checkin-stats *, 
.checkin-info-top .stat-item, 
.checkin-info-top .stat-item * {
    white-space: nowrap !important;
    flex-wrap: nowrap !important;
    word-break: keep-all !important;
    word-wrap: normal !important;
    overflow-wrap: normal !important;
    hyphens: none !important;
    line-break: strict !important;
    text-wrap: nowrap !important;
}

/* 底部导航栏样式 */
.love-bottom-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 70px;
    background: rgba(255, 255, 255, 0.4);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border-top: 1px solid rgba(255, 255, 255, 0.5);
    display: none; /* 默认隐藏，只在恋爱空间显示 */
    justify-content: space-around;
    align-items: center;
    z-index: 100;
    padding-bottom: env(safe-area-inset-bottom);
}

/* 恋爱空间显示时显示底部导航栏 - 只有当恋爱空间真正可见时才显示 */
#love-space-view:not([style*="display: none"]) .love-bottom-nav,
#love-space-view[style*="display: flex"] .love-bottom-nav,
#love-space-view[style*="display: block"] .love-bottom-nav {
    display: flex;
}

.love-bottom-nav .nav-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    padding: 8px 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    border-radius: 12px;
    min-width: 60px;
}

.love-bottom-nav .nav-item:hover {
    background: rgba(255, 255, 255, 0.1);
}

.love-bottom-nav .nav-item.active {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-2px);
}

.love-bottom-nav .nav-icon {
    font-size: 24px;
    color: #C0C0C0;
    transition: transform 0.2s ease, color 0.3s ease;
}

.love-bottom-nav .nav-item.active .nav-icon {
    transform: scale(1.1);
    color: #FFFFFF;
}

.love-bottom-nav .nav-label {
    font-size: 12px;
    font-weight: 500;
    color: #C0C0C0;
    transition: color 0.3s ease;
}

.love-bottom-nav .nav-item.active .nav-label {
    color: #FFFFFF;
    font-weight: 600;
}

/* 当相册详情页面显示时，隐藏底部导航栏 - CSS版本（兼容现代浏览器） */
body:has(#album-detail-view[style*="display: flex"]) .love-bottom-nav,
body:has(#album-detail-view[style*="display: block"]) .love-bottom-nav {
    display: none !important;
}

/* 当相册详情页面激活时隐藏导航栏 - 备用类名版本（兼容所有浏览器） */
body.album-detail-active .love-bottom-nav {
    display: none !important;
}

/* 原图查看器样式 */
.image-viewer-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.9);
    z-index: 999999; /* 提高z-index确保在最上层 */
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    backdrop-filter: blur(5px);
    animation: fadeIn 0.3s ease-out;
}

.image-viewer-overlay.show {
    display: flex;
}

.image-viewer-content {
    max-width: 95vw;
    max-height: 95vh;
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    animation: zoomIn 0.3s ease-out;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes zoomIn {
    from { 
        transform: scale(0.8);
        opacity: 0;
    }
    to { 
        transform: scale(1);
        opacity: 1;
    }
}

/* 相册页面样式 */
.gallery-header {
    text-align: center;
    margin-bottom: 30px;
    margin-top: 20px;
}

.gallery-header h2 {
    color: rgba(255, 255, 255, 0.9);
    font-size: 28px;
    font-weight: 600;
    text-shadow: 0 2px 4px rgba(255, 107, 157, 0.3);
    margin: 0;
    background: linear-gradient(45deg, #ff6b9d, #ff9ec5);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* 创建相册按钮样式 - 纯粹的灰色➕号 */
.create-album-btn {
    position: fixed;
    bottom: 100px;
    right: 20px;
    width: auto;
    height: auto;
    background: transparent;
    border: none;
    border-radius: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: none;
    transition: all 0.3s ease;
    z-index: 1000;
    padding: 0;
}

.create-album-btn:hover {
    transform: scale(1.1);
    box-shadow: none;
    background: transparent;
}

.create-album-btn span {
    color: #888888;
    font-size: 48px;
    font-weight: normal;
    line-height: 1;
}

.gallery-content {
    width: 100%;
    max-width: 90%; /* 从600px改为90%，更接近屏幕边缘 */
    margin: 0 auto;
    padding-bottom: 100px; /* 为底部按钮留出空间 */
}

.gallery-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
    padding: 0 10px; /* 从20px减少到10px，让内容更接近边缘 */
}

.gallery-placeholder {
    text-align: center;
    padding: 60px 20px;
    color: rgba(255, 255, 255, 0.7);
}

/* 相册卡片样式 */
.album-card {
    display: flex;
    background: rgba(255, 255, 255, 0.25);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 15px;
    padding: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.album-card:hover {
    background: rgba(255, 255, 255, 0.35);
    transform: translateY(-2px);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
}

.album-cover {
    width: 120px;
    height: 67.5px; /* 16:9 比例 */
    border-radius: 10px;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 15px;
    flex-shrink: 0;
    border: 1px solid rgba(255, 255, 255, 0.4);
}

.album-cover img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.album-cover .default-cover {
    font-size: 30px;
    color: rgba(255, 255, 255, 0.6);
}

.album-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.album-name {
    color: rgba(255, 255, 255, 0.95);
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 5px;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.album-description {
    color: rgba(255, 255, 255, 0.8);
    font-size: 14px;
    line-height: 1.4;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

/* 弹窗样式 */
.dialog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(5px);
}

.dialog-content {
    background: rgba(45, 45, 65, 0.95);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    width: 90%;
    max-width: 400px;
    max-height: 80vh;
    overflow: hidden;
    position: relative;
    z-index: 10001;
    display: flex;
    flex-direction: column;
}

.dialog-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.dialog-header h3 {
    color: rgba(255, 255, 255, 0.9);
    font-size: 18px;
    font-weight: 600;
    margin: 0;
}

.dialog-close {
    color: rgba(255, 255, 255, 0.6);
    font-size: 24px;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.dialog-close:hover {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.9);
}

.dialog-body {
    padding: 20px;
    overflow-y: auto;
    flex: 1;
    max-height: calc(80vh - 140px); /* 减去header和footer的高度 */
}

/* 美化滚动条 */
.dialog-body::-webkit-scrollbar {
    width: 6px;
}

.dialog-body::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
}

.dialog-body::-webkit-scrollbar-thumb {
    background: rgba(255, 107, 157, 0.6);
    border-radius: 3px;
}

.dialog-body::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 107, 157, 0.8);
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    color: rgba(255, 255, 255, 0.8);
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 8px;
}

.form-group input,
.form-group textarea {
    width: 100%;
    padding: 12px 15px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    color: rgba(255, 255, 255, 0.9);
    font-size: 14px;
    transition: all 0.2s ease;
    box-sizing: border-box;
    pointer-events: auto;
    user-select: text;
}

.form-group input:focus,
.form-group textarea:focus {
    outline: none;
    border-color: #ff6b9d;
    background: rgba(255, 255, 255, 0.15);
}

.form-group textarea {
    resize: vertical;
    min-height: 80px;
    pointer-events: auto;
    user-select: text;
}

.dialog-footer {
    display: flex;
    gap: 10px;
    padding: 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0; /* 防止footer被压缩 */
}

.dialog-btn {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 10px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.cancel-btn {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.7);
}

.cancel-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

.confirm-btn {
    background: linear-gradient(45deg, #ff6b9d, #ff9ec5);
    color: white;
}

.confirm-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
}

/* 子相册设置菜单样式 - 白色主题 */
.album-settings-content {
    background: white;
    backdrop-filter: none;
    border: 1px solid #e0e0e0;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.album-settings-content .dialog-header {
    border-bottom: 1px solid #f0f0f0;
}

.album-settings-content .dialog-header h3 {
    color: #333;
}

.album-settings-content .dialog-close {
    color: #666;
}

.album-settings-content .dialog-close:hover {
    background: #f5f5f5;
    color: #333;
}

.settings-menu-list {
    padding: 0;
}

.settings-menu-item {
    padding: 16px 20px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.settings-menu-item:last-child {
    border-bottom: none;
}

.settings-menu-item:hover {
    background: #f8f9fa;
}

.settings-item-text {
    color: #333;
    font-size: 16px;
    font-weight: 500;
}

/* 联系人绑定设置弹窗样式 - 白色主题 */
#contact-binding-dialog .dialog-content {
    background: white;
    backdrop-filter: none;
    border: 1px solid #e0e0e0;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    max-width: 500px;
}

#contact-binding-dialog .dialog-header {
    border-bottom: 1px solid #f0f0f0;
}

#contact-binding-dialog .dialog-header h3 {
    color: #333;
}

#contact-binding-dialog .dialog-close {
    color: #666;
}

#contact-binding-dialog .dialog-close:hover {
    background: #f5f5f5;
    color: #333;
}

#contact-binding-dialog .dialog-body h4 {
    color: #333;
    font-size: 16px;
    font-weight: 600;
    margin: 0 0 15px 0;
    padding-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
}

.current-binding-section {
    margin-bottom: 25px;
}

.binding-contact-list {
    max-height: 200px;
    overflow-y: auto;
}

.binding-contact-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 15px;
    background: #f8f9fa;
    border-radius: 8px;
    margin-bottom: 8px;
    border: 1px solid #e9ecef;
}

.binding-contact-info {
    display: flex;
    align-items: center;
    gap: 12px;
}

.binding-contact-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.binding-contact-name {
    color: #333;
    font-weight: 500;
}

.binding-contact-action {
    padding: 6px 12px;
    border: none;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.unbind-btn {
    background: #ff4757;
    color: white;
}

.unbind-btn:hover {
    background: #ff3742;
}

.bind-btn {
    background: #2ed573;
    color: white;
}

.bind-btn:hover {
    background: #26d0ce;
}

.no-contacts-message {
    text-align: center;
    color: #666;
    font-style: italic;
    padding: 20px;
}

/* 删除相册确认弹窗样式 - 白色主题 */
#delete-album-confirm .dialog-content {
    background: white;
    backdrop-filter: none;
    border: 1px solid #e0e0e0;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

#delete-album-confirm .dialog-header {
    border-bottom: 1px solid #f0f0f0;
}

#delete-album-confirm .dialog-header h3 {
    color: #333;
}

#delete-album-confirm .dialog-close {
    color: #666;
}

#delete-album-confirm .dialog-close:hover {
    background: #f5f5f5;
    color: #333;
}

#delete-album-confirm .dialog-body p {
    color: #333;
    margin: 8px 0;
    line-height: 1.5;
}

#delete-album-confirm .dialog-footer {
    border-top: 1px solid #f0f0f0;
}

/* 背景设置弹窗白色主题样式 */
#background-settings-dialog .dialog-body {
    color: #333;
}

.background-upload-area {
    border: 2px dashed #ddd;
    background: #f8f9fa;
    color: #666;
}

.background-upload-area:hover {
    border-color: #007bff;
    background: #f0f8ff;
}

.background-upload-text {
    color: #333;
    font-weight: 500;
}

.background-upload-hint {
    color: #666;
    font-size: 12px;
}

.background-preview-actions .btn-apply {
    background: #28a745;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    margin-right: 8px;
}

.background-preview-actions .btn-apply:hover {
    background: #218838;
}

.background-preview-actions .btn-reset {
    background: #dc3545;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
}

.background-preview-actions .btn-reset:hover {
    background: #c82333;
}

/* 子相册详情页面样式 */
.album-detail-content {
    padding: 10px; /* 从20px减少到10px，让相册详情内容更宽 */
    height: calc(100vh - 60px); /* 只减去顶部标题栏高度，底部导航已隐藏 */
    overflow-y: auto;
    -webkit-overflow-scrolling: touch; /* 启用iOS流畅滚动 */
    position: relative;
    z-index: 1;
}

.album-photos-grid {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 一行两列 */
    gap: 15px;
    padding: 5px; /* 从15px减少到5px，让照片网格更宽 */
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    overflow-x: hidden; /* 防止左右滑动 */
}

/* 聊天消息中的照片卡片样式 */
.message-content .album-photo-item {
    display: inline-block !important;
    margin: 5px !important;
    vertical-align: top;
}

.message-content .photo-card {
    transition: transform 0.6s !important;
    transform-style: preserve-3d !important;
}

.message-content .photo-card.flipped {
    transform: rotateY(180deg) !important;
}

.message-content .photo-front,
.message-content .photo-back {
    backface-visibility: hidden !important;
}

.message-content .photo-back {
    transform: rotateY(180deg) !important;
}

/* 手机端适配 */
@media (max-width: 768px) {
    .album-detail-content {
        padding: 8px; /* 从15px减少到8px，手机端也让内容更宽 */
        height: calc(100vh - 60px);
        overflow-y: scroll !important;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
    }
    
    /* 手机端聊天消息中的照片适配 */
    .message-content .album-photo-item {
        width: 120px !important;
        margin: 3px !important;
    }
    
    .album-photos-grid {
        grid-template-columns: 1fr 1fr; /* 手机端也是一行两列 */
        gap: 10px;
        padding: 3px; /* 从10px减少到3px，手机端让照片更接近边缘 */
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        overflow-x: hidden; /* 防止左右滑动 */
    }
    
    .album-photo-item {
        margin-bottom: 12px;
        touch-action: pan-y; /* 允许垂直滑动 */
    }
}

.album-photos-placeholder {
    grid-column: 1 / -1;
    text-align: center;
    padding: 60px 20px;
    color: rgba(255, 255, 255, 0.7);
}

.album-photos-placeholder .placeholder-icon {
    font-size: 48px;
    margin-bottom: 16px;
}

.album-photos-placeholder p {
    margin: 8px 0;
    font-size: 16px;
    line-height: 1.5;
}

.album-photo-item {
    position: relative;
    background: rgba(248, 248, 248, 0.95);
    border-radius: 12px;
    padding: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    perspective: 1000px;
    width: 100%;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
}

.album-photo-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
}

.photo-card {
    position: relative;
    width: 100%;
    aspect-ratio: 1 / 1.1; /* 进一步减少底部空间 */
    transition: transform 0.6s;
    transform-style: preserve-3d;
    flex-shrink: 0; /* 不收缩 */
}

.photo-card.flipped {
    transform: rotateY(180deg);
}

.photo-front, .photo-back {
    position: relative;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
}

.photo-front {
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.photo-back {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform: rotateY(180deg);
    background: rgba(248, 248, 248, 0.95);
    border-radius: 8px;
    padding: 8px;
    display: flex;
    flex-direction: column;
    text-align: center;
    box-sizing: border-box;
    overflow: hidden;
}

.photo-back-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
    position: relative;
}

.photo-edit-btn {
    background: none;
    border: none;
    font-size: 14px;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 3px;
    opacity: 0.7;
    transition: all 0.2s ease;
    position: absolute;
    top: 2px;
    right: 2px;
}

.photo-edit-btn:hover {
    opacity: 1;
    background-color: rgba(0,0,0,0.1);
}

.photo-back-delete-btn {
    background: none;
    border: none;
    font-size: 14px;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 3px;
    opacity: 0.7;
    transition: all 0.2s ease;
    position: absolute;
    top: 2px;
    left: 2px;
    color: #ff3b30;
}

.photo-back-delete-btn:hover {
    opacity: 1;
    background-color: rgba(255, 59, 48, 0.1);
}

.photo-timestamp {
    position: absolute;
    bottom: 4px;
    right: 4px;
    font-size: 9px;
    color: #999;
    opacity: 0.6;
    z-index: 1;
}

.photo-back-content {
    color: #666;
    font-size: 12px;
    line-height: 1.3;
    word-break: break-word;
    flex: 1;
    overflow-y: auto;
    width: 100%;
    margin-bottom: 8px;
    padding: 4px 0;
    min-height: 0;
}

.photo-back-name {
    color: #333;
    font-size: 11px;
    font-weight: 500;
    text-align: center;
    border-top: 1px solid #eee;
    padding-top: 4px;
    margin-top: auto;
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.photo-back-name::-webkit-scrollbar {
    display: none;
}

.photo-back-content.editing,
.photo-back-name.editing,
.private-photo-back-content.editing,
.private-photo-back-name.editing {
    border: 1px solid #007AFF;
    border-radius: 4px;
    padding: 4px;
    background: #fff;
    color: #333 !important;
    outline: none;
    resize: none;
}

.photo-save-btn {
    background: #007AFF;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 10px;
    cursor: pointer;
    margin-top: 4px;
    transition: background-color 0.2s ease;
}

.photo-save-btn:hover {
    background: #0056CC;
}

.save-success-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 30px;
    color: #28a745;
    animation: saveSuccess 2s ease-in-out;
    pointer-events: none;
    z-index: 1000;
}

@keyframes saveSuccess {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
}

.album-photo-item img {
    width: 100%;
    flex: 1; /* 占用剩余空间 */
    aspect-ratio: 1/1; /* 强制1:1正方形 */
    object-fit: cover; /* 保持图片比例，裁剪多余部分 */
    border-radius: 8px 8px 0 0; /* 只有上方圆角 */
    display: block;
    cursor: pointer; /* 指示可点击 */
}

.photo-title {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 10%; /* 降低到10%，更窄的底部区域 */
    background: rgba(255, 255, 255, 0.95);
    border-radius: 0 0 8px 8px; /* 只有下方圆角 */
    font-size: 11px;
    color: #555;
    text-align: center;
    word-break: break-word;
    line-height: 1.2;
    display: flex;
    align-items: center;
    justify-content: space-between; /* 改为space-between，让文字和图标分开 */
    flex-shrink: 0;
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 2px 6px;
    box-sizing: border-box;
}

/* 文字容器样式 */
.photo-title .title-text-container {
    flex: 1;
    overflow-x: auto;
    overflow-y: hidden;
    margin-right: 24px; /* 给右侧图标留出空间 */
    position: relative;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge */
}

.photo-title .title-text-container::-webkit-scrollbar {
    display: none; /* Chrome/Safari */
}

/* 文字区域样式 */
.photo-title .title-text {
    display: block;
    white-space: nowrap;
    text-align: center;
    width: max-content;
    margin: 0 auto;
    min-width: 100%;
}

/* 翻转图标固定在最右侧 */
.photo-title .flip-icon {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 12px;
    color: #999;
    opacity: 0.8;
    cursor: pointer;
    transition: all 0.2s ease;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.8);
}

/* 悬停效果 */
.photo-title:hover {
    background: rgba(255, 255, 255, 1);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.photo-title:hover .flip-icon {
    opacity: 1;
    background: rgba(255, 255, 255, 1);
    color: #666;
}

/* 手机端适配 */
@media (max-width: 768px) {
    .album-photo-item {
        padding: 6px;
    }
    
    .photo-title {
        font-size: 11px;
        padding: 4px 6px;
        margin-top: 6px;
    }
    
    .photo-title .title-text-container {
        margin-right: 20px; /* 手机端给右侧图标留出空间 */
    }
    
    .photo-title .flip-icon {
        width: 14px;
        height: 14px;
        font-size: 11px;
        right: 4px;
    }
    
    .photo-back {
        padding: 12px;
        height: 100%;
        box-sizing: border-box;
    }
    
    .photo-back-content {
        font-size: 11px;
        line-height: 1.2;
        max-height: 100%;
        overflow-y: auto;
    }
    
    /* 手机端恋爱空间主页优化 */
    .checkin-info-top {
        margin-top: 35px; /* 手机端也需要足够的顶部间距 */
        margin-bottom: 20px; /* 手机端底部间距也需要足够 */
    }
    
    .checkin-info-top .checkin-stats {
        padding: 10px 25px; /* 手机端状态框更矮 */
        gap: 30px; /* 手机端间距适当减少 */
        flex-wrap: nowrap !important; /* 强制不换行 */
        white-space: nowrap !important; /* 强制文字不换行 */
        min-width: 0 !important; /* 防止flex项目被挤压 */
        overflow: hidden !important; /* 防止溢出 */
    }
    
    .couple-avatars-section {
        margin-top: 12px; /* 手机端头像区域也需要适当距离 */
        display: flex !important; /* 强制显示头像区域 */
        align-items: center !important;
        justify-content: center !important;
        gap: 40px !important;
    }
    
    .avatar-container {
        display: flex !important; /* 强制显示头像容器 */
        flex-direction: column !important;
        align-items: center !important;
        gap: 10px !important;
    }
    
    .couple-avatar {
        display: block !important; /* 强制显示头像 */
        width: 70px !important; /* 手机端头像稍小 */
        height: 70px !important;
        border-radius: 50% !important;
        border: 3px solid #fff !important;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1) !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        object-fit: cover !important;
    }
    
    /* .bind-char-section 已删除，不再需要 */
    
    .checkin-ball-container {
        height: 30px; /* 手机端横条更扁平 */
        width: 180px; /* 手机端进一步缩短宽度 */
        padding: 8px 10px; /* 手机端内边距进一步减少 */
        bottom: 70px; /* 手机端向上移动位置 */
        left: 15px; /* 手机端距离左侧更近 */
    }
    
    .checkin-ball {
        width: 30px; /* 手机端圆球更小 */
        height: 30px;
        margin-right: 10px; /* 手机端间距减少 */
    }
    
    .ball-text {
        font-size: 9px; /* 手机端文字更小 */
    }
    
    .checkin-title {
        font-size: 12px; /* 手机端标题文字更小 */
    }
    
    .checkin-subtitle {
        font-size: 10px; /* 手机端副标题文字更小 */
    }
    
    .love-space-content {
        gap: 10px; /* 手机端整体间距更小 */
        padding: 5px 10px 90px 10px; /* 手机端内边距减少 */
    }
}

.photo-delete-btn {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 24px;
    height: 24px;
    background: rgba(255, 0, 0, 0.8);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    opacity: 0;
    transition: all 0.2s ease;
    z-index: 10;
}

.album-photo-item:hover .photo-delete-btn {
    opacity: 1;
}

.photo-delete-btn:hover {
    background: rgba(255, 0, 0, 1);
    transform: scale(1.1);
}

/* 添加照片弹窗样式 */
.photo-upload-tabs {
    display: flex;
    margin-bottom: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    padding: 4px;
}

.tab-item {
    flex: 1;
    text-align: center;
    padding: 10px;
    color: rgba(255, 255, 255, 0.6);
    cursor: pointer;
    border-radius: 8px;
    transition: all 0.2s ease;
    font-size: 14px;
    font-weight: 500;
}

.tab-item.active {
    background: rgba(255, 107, 157, 0.3);
    color: rgba(255, 255, 255, 0.9);
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

.upload-area {
    border: 2px dashed rgba(255, 255, 255, 0.3);
    border-radius: 15px;
    padding: 40px 20px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.upload-area:hover {
    border-color: #ff6b9d;
    background: rgba(255, 107, 157, 0.05);
}

.upload-area .upload-icon {
    font-size: 36px;
    margin-bottom: 12px;
    color: rgba(255, 255, 255, 0.6);
}

.upload-area p {
    color: rgba(255, 255, 255, 0.8);
    font-size: 16px;
    margin: 8px 0;
}

.upload-area small {
    color: rgba(255, 255, 255, 0.5);
    font-size: 12px;
}

/* 上传区域图片预览样式 */
.upload-area.has-image {
    padding: 0;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    position: relative;
}

.upload-area.has-image::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 15px;
    z-index: 1;
}

.upload-area.has-image:hover::before {
    background: rgba(0, 0, 0, 0.5);
}

.upload-area.has-image > * {
    position: relative;
    z-index: 2;
    color: white;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
}

.upload-area.has-image .upload-text {
    display: block;
    padding: 20px;
    text-align: center;
    font-weight: bold;
}

.upload-area .upload-text {
    display: none;
}

/* 背景上传区域图片预览样式 */
.background-upload-area.has-image {
    padding: 0;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    position: relative;
    min-height: 120px;
}

.background-upload-area.has-image::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 12px;
    z-index: 1;
}

.background-upload-area.has-image:hover::before {
    background: rgba(0, 0, 0, 0.6);
}

.background-upload-area.has-image > * {
    position: relative;
    z-index: 2;
    color: white;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
}

.background-upload-area.has-image .background-upload-text {
    display: block;
    padding: 20px;
    text-align: center;
    font-weight: bold;
}

.preview-btn {
    width: 100%;
    padding: 10px;
    background: rgba(255, 107, 157, 0.2);
    border: 1px solid rgba(255, 107, 157, 0.4);
    border-radius: 8px;
    color: rgba(255, 255, 255, 0.9);
    cursor: pointer;
    transition: all 0.2s ease;
    margin-top: 10px;
}

.preview-btn:hover {
    background: rgba(255, 107, 157, 0.3);
}

.photo-preview {
    margin-top: 20px;
    text-align: center;
}

.photo-preview img {
    max-width: 100%;
    max-height: 200px;
    border-radius: 10px;
}

.gallery-placeholder p {
    margin: 8px 0;
    font-size: 16px;
    line-height: 1.5;
}

/* 旧的gallery-item样式已删除，使用新的相册系统 */

/* 恋爱空间内部样式 */
.love-space-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px; /* 从30px减少到15px，整体元素间距变小 */
    padding: 10px 10px 90px 10px; /* 左右padding从20px减少到10px，让内容更宽 */
    height: calc(100vh - 120px); /* 改为height而不是min-height，固定高度 */
    overflow: hidden; /* 禁止滚动 */
}

/* 双人头像区域 */
.couple-avatars-section {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 40px;
    margin-top: 15px; /* 增加上边距，与打卡框保持适当距离 */
}

.avatar-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
}

.couple-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 4px solid #fff;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    object-fit: cover;
}

.couple-avatar:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
}

.love-heart {
    font-size: 32px;
    animation: heartbeat 1.5s ease-in-out infinite;
}

@keyframes heartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
}

.avatar-status {
    background: linear-gradient(135deg, #ff6b9d, #ff8fab);
    color: white;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    box-shadow: 0 2px 8px rgba(255, 107, 157, 0.3);
}

/* 左下角横条打卡区域 */
.checkin-ball-container {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    padding: 8px 15px; /* 减少上下内边距以适应更小的高度 */
    margin: 0; /* 移除外边距 */
    background: linear-gradient(135deg, rgba(255, 107, 157, 0.1), rgba(255, 139, 171, 0.1));
    border-radius: 20px; /* 稍微减少圆角 */
    box-shadow: 0 4px 15px rgba(255, 107, 157, 0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    height: 35px; /* 缩短高度，更扁平 */
    position: fixed; /* 固定定位 */
    bottom: 80px; /* 向上移动，距离底部80px */
    left: 20px; /* 距离左侧20px */
    width: 200px; /* 缩短宽度 */
    z-index: 100; /* 只在恋爱空间主页显示，不覆盖弹窗 */
    overflow: hidden;
    transition: all 0.3s ease;
}

.checkin-ball-container::before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 100px;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 107, 157, 0.05));
    pointer-events: none;
}

.checkin-ball-container:hover {
    transform: translateX(5px);
    box-shadow: 0 6px 20px rgba(255, 107, 157, 0.3);
}

.checkin-ball {
    position: relative;
    width: 35px; /* 减小尺寸适配扁平横条 */
    height: 35px;
    border-radius: 50%;
    background: linear-gradient(135deg, #ff6b9d, #ff8fab, #ffa8c5);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
    animation: pulse 2s ease-in-out infinite;
    margin-right: 12px; /* 减少右边距 */
    flex-shrink: 0;
}

.checkin-ball:hover {
    transform: scale(1.15);
    box-shadow: 0 8px 25px rgba(255, 107, 157, 0.6);
}

.checkin-ball:active {
    transform: scale(0.9);
}

.checkin-ball.checked {
    background: linear-gradient(135deg, #9ca3af, #d1d5db);
    cursor: not-allowed;
    animation: none;
    box-shadow: 0 6px 20px rgba(156, 163, 175, 0.4);
}

.checkin-ball.checked:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 25px rgba(156, 163, 175, 0.5);
}

.checkin-ball.checked .ball-text {
    opacity: 0.5;
}

@keyframes pulse {
    0%, 100% { 
        transform: scale(1);
        box-shadow: 0 6px 20px rgba(255, 107, 157, 0.4);
    }
    50% { 
        transform: scale(1.05);
        box-shadow: 0 8px 25px rgba(255, 107, 157, 0.6);
    }
}

.ball-text {
    color: white;
    font-size: 10px; /* 减小字体适配小圆圈 */
    font-weight: bold;
    z-index: 2;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.ball-glow {
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255, 107, 157, 0.3), transparent);
    animation: glow 2s ease-in-out infinite alternate;
}

@keyframes glow {
    from { opacity: 0.5; transform: scale(1); }
    to { opacity: 0.8; transform: scale(1.1); }
}

/* 横条内的文字信息 */
.checkin-info-text {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.checkin-title {
    font-size: 14px; /* 减小标题字体 */
    font-weight: bold;
    color: #ff6b9d;
    margin-bottom: 2px; /* 减少间距 */
    text-shadow: 0 1px 2px rgba(255, 107, 157, 0.2);
    line-height: 1.2; /* 紧凑行高 */
}

.checkin-subtitle {
    font-size: 11px; /* 减小副标题字体 */
    color: #666;
    opacity: 0.8;
    line-height: 1.2; /* 紧凑行高 */
}

/* 打卡信息区域 */
.checkin-info {
    width: 100%;
    max-width: 400px;
}

.checkin-stats {
    display: flex;
    justify-content: space-around;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

.stat-label {
    font-size: 14px;
    color: #666;
}

.stat-value {
    font-size: 24px;
    font-weight: bold;
    color: #ff6b9d;
}

.stat-unit {
    font-size: 12px;
    color: #999;
}

/* 空间内容区域 */
.space-content {
    flex-grow: 1;
    /* 移除固定背景，让父容器的壁纸背景透过来 */
    background: transparent;
    overflow: hidden; /* 禁止滚动，固定主页屏幕 */
    padding: 0 20px 20px 20px; /* 顶部不需要padding，因为有绝对定位的导航 */
}

/* 恋爱空间内容 */
/* 原有的love-space-content样式已被新样式覆盖
.love-space-content {
    text-align: center;
    padding: 40px 20px;
    color: #8b5a7a;
    font-size: 16px;
    line-height: 1.6;
}
*/

/* ▼▼▼ 全新私人空间样式 ▼▼▼ */

/* 私人空间顶部透明导航栏 */
.private-space-top-nav {
    position: absolute;
    top: 30px;
    left: 0;
    right: 0;
    height: 60px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 20px;
    background: transparent;
    z-index: 100;
}

.private-space-top-nav .back-btn,
.private-space-top-nav .settings-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
}

.private-space-top-nav .back-btn:hover,
.private-space-top-nav .settings-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

/* 私人空间主要内容区域 */
.private-space-main {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
}

/* 16:9 蓝色背景框 */
.private-space-header-box {
    width: 100%;
    height: 0;
    padding-bottom: 56.25%; /* 16:9 比例 */
    background: #e0f6ff;
    position: relative;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}

/* 头像容器 */
.private-space-avatar-container {
    position: absolute;
    bottom: -30px; /* 让头像的1/3部分延伸到下面 */
    left: 50%;
    transform: translateX(-50%);
    z-index: 50;
}

/* 头像样式 */
.private-space-avatar {
    width: 90px;
    height: 90px;
    border-radius: 50%;
    overflow: hidden;
    border: 4px solid white;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    background: white;
}

.private-space-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* 小导航栏框 */
.private-space-nav-box {
    background: white;
    padding: 25px 20px 10px !important; /* 进一步缩短高度 */
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
}

.private-space-nav-box::before,
.private-space-nav-box::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    height: 10px;
    z-index: 1;
    pointer-events: none;
}

.private-space-nav-box::before {
    top: 0;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0.4), transparent);
    backdrop-filter: blur(3px);
}

.private-space-nav-box::after {
    bottom: 0;
    background: linear-gradient(to top, rgba(255, 255, 255, 0.4), transparent);
    backdrop-filter: blur(3px);
}

/* 导航栏标签 */
.private-space-nav-tabs {
    display: flex;
    justify-content: space-around;
    align-items: center;
    position: relative;
    z-index: 2;
}

.private-space-nav-tabs::before,
.private-space-nav-tabs::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    height: 8px;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), transparent);
    backdrop-filter: blur(4px);
    z-index: 1;
    pointer-events: none;
}

.private-space-nav-tabs::before {
    top: 0;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), transparent);
}

.private-space-nav-tabs::after {
    bottom: 0;
    background: linear-gradient(to top, rgba(255, 255, 255, 0.3), transparent);
}

.private-nav-tab {
    flex: 1;
    text-align: center;
    padding: 8px 0 !important;
    font-size: 16px;
    font-weight: 500;
    color: #666;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    z-index: 2;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
}

.private-nav-tab.active {
    color: #e0f6ff;
}

.private-nav-tab.active::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 3px;
    background: #e0f6ff;
    border-radius: 2px;
}

.private-nav-tab:hover {
    color: #e0f6ff;
}

/* 内容页面区域 */
.private-space-content {
    background: white;
    flex: 1;
    overflow-y: auto; /* 允许垂直滚动 */
    position: relative;
    padding-bottom: 20px; /* 底部留空 */
}

.private-content-page {
    display: none;
    height: 100%;
    overflow-y: auto;
    background: rgba(255, 255, 255, 0.1); /* 微微不透明的白色背景 */
    backdrop-filter: blur(5px); /* 添加模糊效果 */
}

.private-content-page.active {
    display: block;
}

.private-page-content {
    padding: 10px 20px 20px 20px;
    min-height: calc(100vh - 300px);
}

/* 设置弹窗样式 */
.private-settings-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.private-settings-content {
    background: white;
    border-radius: 15px;
    width: 90%;
    max-width: 400px;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.private-settings-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 1px solid #eee;
}

.private-settings-header h3 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
}

.close-private-settings {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background: #f5f5f5;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 18px;
    color: #666;
    transition: all 0.3s ease;
}

.close-private-settings:hover {
    background: #e5e5e5;
    color: #333;
}

.private-settings-menu {
    padding: 12px 0;
}

.private-settings-item {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px 24px;
    cursor: pointer;
    transition: all 0.2s ease;
    color: #333;
}

.private-settings-item:hover {
    background: #f8f9fa;
}

.private-settings-item span {
    font-size: 16px;
    font-weight: 500;
    text-align: center;
}

/* 私人空间整体布局调整 */
#private-space-view {
    background: #f8f9fa;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
    position: relative;
}

/* 修复私人空间主要内容区域布局 */
.private-space-main {
    display: flex;
    flex-direction: column;
    flex: 1;
    overflow: hidden;
}

/* 私人空间页面头部样式 */
.private-page-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 20px 10px 20px;
    border-bottom: 1px solid #eee;
    margin-bottom: 15px;
}

.private-page-header .action-btn {
    width: auto;
    height: auto;
    border-radius: 0;
    background: transparent;
    color: #888;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 24px;
    font-weight: 300;
    transition: all 0.3s ease;
    border: none;
    padding: 4px;
}

.private-page-header .action-btn:hover {
    color: #666;
    transform: scale(1.1);
}

/* 物品页面按钮组样式 */
.items-actions {
    display: flex;
    align-items: center;
}

.delete-mode-btn {
    font-size: 14px !important;
    padding: 6px 12px !important;
    border: 1px solid #ddd !important;
    border-radius: 4px !important;
    background: #f8f9fa !important;
    color: #666 !important;
}

.delete-mode-btn:hover {
    background: #e9ecef !important;
    color: #495057 !important;
}

.delete-mode-btn.active {
    background: #dc3545 !important;
    color: white !important;
    border-color: #dc3545 !important;
}

/* 私人相册样式 */
.private-album-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 1px solid #eee;
    margin-bottom: 15px;
}



.private-album-grid {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 一行两列 */
    gap: 15px;
    padding: 20px;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    overflow-x: hidden;
}

/* 手机端适配 */
@media (max-width: 768px) {
    .private-album-grid {
        grid-template-columns: 1fr 1fr; /* 手机端也是一行两列 */
        gap: 10px;
        padding: 15px;
    }
}

.private-album-placeholder {
    grid-column: 1 / -1;
    text-align: center;
    padding: 60px 20px;
    color: #666;
}

.private-album-placeholder p {
    margin: 8px 0;
    font-size: 16px;
    line-height: 1.5;
}

.private-photo-item {
    position: relative;
    background: rgba(248, 248, 248, 0.95);
    border-radius: 12px;
    padding: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    transition: all 0.3s ease;
    perspective: 1000px;
    width: 100%;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
}

.private-photo-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
}

.private-photo-card {
    position: relative;
    width: 100%;
    aspect-ratio: 1 / 1.1;
    transition: transform 0.6s;
    transform-style: preserve-3d;
    flex-shrink: 0;
}

.private-photo-card.flipped {
    transform: rotateY(180deg);
}

.private-photo-front, .private-photo-back {
    position: relative;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
}

.private-photo-front {
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.private-photo-back {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform: rotateY(180deg);
    background: rgba(248, 248, 248, 0.95);
    border-radius: 8px;
    padding: 8px;
    display: flex;
    flex-direction: column;
    text-align: center;
    box-sizing: border-box;
    overflow: hidden;
}

.private-photo-item img {
    width: 100%;
    flex: 1;
    aspect-ratio: 1/1;
    object-fit: cover;
    border-radius: 8px 8px 0 0;
    display: block;
    cursor: pointer;
}

.private-photo-title {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 10%;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 0 0 8px 8px;
    font-size: 11px;
    color: #555;
    text-align: center;
    word-break: break-word;
    line-height: 1.2;
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 2px 6px;
    box-sizing: border-box;
}

.private-photo-title .title-text-container {
    flex: 1;
    overflow-x: auto;
    overflow-y: hidden;
    margin-right: 24px;
    position: relative;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.private-photo-title .title-text-container::-webkit-scrollbar {
    display: none;
}

.private-photo-title .title-text {
    display: block;
    white-space: nowrap;
    text-align: center;
    width: max-content;
    margin: 0 auto;
    min-width: 100%;
}

.private-photo-title .flip-icon {
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 12px;
    color: #999;
    opacity: 0.8;
    cursor: pointer;
    transition: all 0.2s ease;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.8);
}

.private-photo-title:hover {
    background: rgba(255, 255, 255, 1);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.private-photo-title:hover .flip-icon {
    opacity: 1;
    background: rgba(255, 255, 255, 1);
    color: #666;
}

.private-photo-back-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
    position: relative;
}

.private-photo-edit-btn {
    background: none;
    border: none;
    font-size: 14px;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 3px;
    opacity: 0.7;
    transition: all 0.2s ease;
    position: absolute;
    top: 2px;
    right: 2px;
}

.private-photo-edit-btn:hover {
    opacity: 1;
    background-color: rgba(0,0,0,0.1);
}

.private-photo-back-delete-btn {
    background: none;
    border: none;
    font-size: 14px;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 3px;
    opacity: 0.7;
    transition: all 0.2s ease;
    position: absolute;
    top: 2px;
    left: 2px;
    color: #ff3b30;
}

.private-photo-back-delete-btn:hover {
    opacity: 1;
    background-color: rgba(255, 59, 48, 0.1);
}

.private-photo-back-content {
    color: #666;
    font-size: 12px;
    line-height: 1.3;
    word-break: break-word;
    flex: 1;
    overflow-y: auto;
    width: 100%;
    margin-bottom: 8px;
    padding: 4px 0;
    min-height: 0;
}

.private-photo-back-name {
    color: #333;
    font-size: 11px;
    font-weight: 500;
    text-align: center;
    border-top: 1px solid #eee;
    padding-top: 4px;
    margin-top: auto;
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.private-photo-back-name::-webkit-scrollbar {
    display: none;
}

/* 物品表格容器样式 */
.items-table-container {
    padding: 0 20px;
    overflow: auto; /* 允许水平和垂直滚动 */
    flex: 1;
    max-height: calc(100vh - 200px);
    min-width: 0; /* 允许容器收缩 */
}

/* 物品表格样式 */
.items-table {
    width: 100%;
    min-width: 800px; /* 设置最小表格宽度，确保所有列都能显示 */
    border-collapse: collapse;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-bottom: 20px;
    table-layout: auto; /* 改回auto，让列宽能够动态调整 */
}

.items-table th,
.items-table td {
    padding: 0; /* 移除默认padding，让textarea完全控制 */
    text-align: left;
    border-bottom: 1px solid #eee;
    border-right: 1px solid #eee; /* 添加右边框作为分隔线 */
    vertical-align: top; /* 改为顶部对齐，适应多行内容 */
    word-wrap: break-word; /* 允许长单词换行 */
    word-break: break-word; /* 改为break-word，避免过度换行 */
    white-space: normal; /* 允许换行 */
}

/* 最后一列不需要右边框 */
.items-table th:last-child,
.items-table td:last-child {
    border-right: none;
}

.items-table th {
    background: linear-gradient(135deg, #f8fffe, #e8f5f3);
    color: #2d5a4a;
    font-weight: 600;
    font-size: 14px;
    position: sticky;
    top: 0;
    z-index: 10;
    padding: 12px 8px; /* 表头保留padding */
}

/* 数据单元格样式 - 初始宽度较小，根据内容自动扩展 */
.items-table td:not(.serial-number):not(.operation-column) {
    width: 120px; /* 初始宽度较小 */
    min-width: 120px; /* 最小宽度 */
    max-width: none; /* 移除最大宽度限制，允许根据内容扩展 */
    padding: 0; /* 移除单元格padding，让textarea填满 */
    vertical-align: top; /* 顶部对齐，不居中 */
    position: relative;
    cursor: text; /* 整个单元格都显示文本光标 */
    border: 1px solid #ddd; /* 添加边框便于区分 */
}

.items-table tr:hover {
    background-color: #f8f9fa;
}

/* 表格输入框样式 - 根据内容动态调整宽度和高度 */
.items-table textarea {
    width: 100%; /* 填满整个单元格 */
    height: auto; /* 高度自动，根据内容行数调整 */
    min-height: 36px; /* 最小高度（一行） */
    min-width: 120px; /* 最小宽度 */
    border: none;
    background: transparent;
    padding: 8px; /* 内边距 */
    font-size: 14px; /* 稍大字体 */
    color: #333;
    outline: none;
    resize: none; /* 禁用手动调整大小 */
    overflow: hidden; /* 隐藏滚动条 */
    word-wrap: break-word;
    word-break: normal; /* 改为normal，避免过度换行 */
    white-space: pre-wrap; /* 保持换行和空格 */
    box-sizing: border-box;
    font-family: 'Microsoft YaHei', Arial, sans-serif; /* 中文字体 */
    line-height: 20px; /* 固定行高 */
    vertical-align: top; /* 文字从顶部开始 */
    text-align: left; /* 左对齐 */
}

/* 完全去掉focus状态的样式 */
.items-table textarea:focus {
    background: transparent;
    border: none;
    outline: none;
    box-shadow: none;
}

/* 让整个单元格都可以点击 */
.items-table td:not(.serial-number):not(.operation-column) {
    cursor: text;
}

.items-table td:not(.serial-number):not(.operation-column):hover {
    background-color: #f8f9fa;
}

/* 序号列样式 */
.items-table .serial-number {
    text-align: center;
    font-weight: 600;
    color: #666;
    background: #f8f9fa;
    width: 60px;
    min-width: 60px;
    max-width: 60px;
    padding: 8px 4px;
    vertical-align: middle; /* 序号列居中对齐 */
    cursor: default; /* 普通光标 */
}

/* 操作列样式 */
.operation-column {
    width: 80px;
    min-width: 80px;
    text-align: center;
}

.delete-row-btn {
    background: #dc3545;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.3s ease;
}

.delete-row-btn:hover {
    background: #c82333;
    transform: scale(1.05);
}

/* 私人空间约定容器样式 */
.private-agreements-container {
    padding: 0 20px;
    overflow-y: auto;
    flex: 1;
}

/* 私人空间约定卡片样式 */
.private-agreement-card {
    background: linear-gradient(135deg, #f8fffe, #e8f5f3);
    color: #2d5a4a;
    border: 1px solid #c8e6c9;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
    box-shadow: 0 2px 8px rgba(76, 175, 80, 0.08);
    text-align: center;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
}

.private-agreement-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(76, 175, 80, 0.15);
}

.private-agreement-card::before {
    content: '🌿';
    position: absolute;
    top: 12px;
    right: 12px;
    font-size: 20px;
    opacity: 0.6;
}

.private-agreement-card .title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 12px;
    color: #1b5e20;
    line-height: 1.3;
}

.private-agreement-card .timer {
    font-size: 22px;
    font-weight: 500;
    letter-spacing: 0.5px;
    margin-bottom: 10px;
    color: #2e7d32;
    background: rgba(76, 175, 80, 0.1);
    padding: 6px 12px;
    border-radius: 16px;
    display: inline-block;
}

.private-agreement-card .target-date {
    font-size: 12px;
    color: #4a7c59;
    border-top: 1px solid rgba(76, 175, 80, 0.2);
    padding-top: 8px;
    margin-top: 6px;
}

/* 已到期约定的特殊样式 */
.private-agreement-card.expired {
    background: linear-gradient(135deg, #f1f8e9, #e8f5e8);
    border-color: #a5d6a7;
    color: #2e7d32;
}

.private-agreement-card.expired::before {
    content: '✅';
    color: #4caf50;
}

.private-agreement-card.expired .timer {
    background: rgba(76, 175, 80, 0.2);
    color: #1b5e20;
}

/* 删除按钮hover效果 */
.delete-agreement-btn:hover {
    background: rgba(244, 67, 54, 0.2) !important;
    border-color: rgba(244, 67, 54, 0.5) !important;
    transform: scale(1.05);
}

/* 壁纸设置弹窗样式 */
.wallpaper-settings-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.wallpaper-settings-content {
    background: white;
    border-radius: 12px;
    padding: 0;
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.wallpaper-settings-header {
    padding: 20px 24px;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.wallpaper-settings-header h3 {
    margin: 0;
    color: #333;
    font-size: 18px;
    font-weight: 600;
}

.close-wallpaper-settings {
    background: none;
    border: none;
    font-size: 24px;
    color: #999;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.close-wallpaper-settings:hover {
    background: #f5f5f5;
    color: #666;
}

.wallpaper-settings-body {
    padding: 24px;
}

.wallpaper-section {
    margin-bottom: 24px;
}

.wallpaper-section:last-child {
    margin-bottom: 0;
}

.wallpaper-section h4 {
    margin: 0 0 12px 0;
    color: #333;
    font-size: 16px;
    font-weight: 500;
}

.wallpaper-input-group {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
}

.wallpaper-input {
    flex: 1;
    padding: 10px 12px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 14px;
    color: #333;
    background: white;
}

.wallpaper-input:focus {
    outline: none;
    border-color: #4a90e2;
    box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.1);
}

.wallpaper-btn {
    padding: 10px 16px;
    background: #4a90e2;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
}

.wallpaper-btn:hover {
    background: #357abd;
}

.wallpaper-btn.secondary {
    background: #f5f5f5;
    color: #666;
}

.wallpaper-btn.secondary:hover {
    background: #e8e8e8;
}

.wallpaper-preview {
    margin-top: 8px;
    padding: 8px;
    background: #f9f9f9;
    border-radius: 6px;
    font-size: 12px;
    color: #666;
    word-break: break-all;
}

/* 约定创建弹窗输入框样式修复 */
#create-countdown-modal .form-group input {
    background-color: white !important;
    color: #333 !important;
    border: 1px solid #ccc !important;
}

#create-countdown-modal .form-group input::placeholder {
    color: #999 !important;
}

#create-countdown-modal .form-group label {
    color: #333 !important;
}

/* ▲▲▲ 全新私人空间样式结束 ▲▲▲ */

/* ▼▼▼ 好友选择弹窗样式 ▼▼▼ */
#friends-selector-modal .modal-content {
    max-width: 400px;
    max-height: 80vh; /* 增加到80vh给更多显示空间 */
    margin: 20px; /* 添加边距确保不贴边 */
}

.friends-list {
    max-height: calc(60vh - 120px); /* 动态计算高度，减去头部和说明文字的高度 */
    overflow-y: auto;
    /* 确保滚动区域有明显的滚动条 */
    scrollbar-width: thin;
    /* 移动设备滚动优化 */
    -webkit-overflow-scrolling: touch;
}

/* 为好友列表添加滚动指示器 */
.friends-list::before {
    content: '';
    position: sticky;
    top: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent 0%, rgba(0,123,255,0.5) 50%, transparent 100%);
    display: block;
    z-index: 1;
}

.friends-list::after {
    content: '';
    position: sticky;
    bottom: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent 0%, rgba(0,123,255,0.5) 50%, transparent 100%);
    display: block;
    z-index: 1;
}

/* 确保模态框始终在屏幕范围内 */
#friends-selector-modal {
    padding: 20px; /* 给整个模态框添加内边距 */
    box-sizing: border-box;
}

/* 移动设备上的额外安全距离 */
@media screen and (max-width: 500px) {
    #friends-selector-modal {
        padding: 10px; /* 移动设备上更小的边距 */
    }
    
    #friends-selector-modal .modal-content {
        max-height: 85vh; /* 移动设备上更大的显示区域 */
        margin: 0; /* 移除margin，使用父容器的padding */
        width: 100%; /* 确保充分利用空间 */
        max-width: 100%; /* 防止超出屏幕 */
    }
    
    .friends-list {
        max-height: calc(70vh - 150px); /* 移动设备上给更多空间给好友列表 */
    }
}

/* 极小屏幕设备（如iPhone SE）特殊优化 */
@media screen and (max-width: 400px) {
    #friends-selector-modal .modal-content {
        max-height: 90vh; /* 极小屏幕上最大化显示区域 */
    }
    
    .friends-list {
        max-height: calc(75vh - 140px); /* 给好友列表更多空间 */
    }
    
    .friend-item {
        padding: 10px 12px; /* 减少内边距以容纳更多内容 */
    }
}

/* ▼▼▼ 恋爱空间好友选择弹窗样式 ▼▼▼ */
/* 当弹窗内容为好友选择时的特殊样式 */
#custom-modal-body .char-option {
    cursor: pointer; 
    padding: 12px; 
    display: flex; 
    align-items: center; 
    border-radius: 8px; 
    transition: background-color 0.2s; 
    margin-bottom: 8px;
}

#custom-modal-body .char-option:hover {
    background-color: #f0f0f0;
}

#custom-modal-body .char-option img {
    width: 40px; 
    height: 40px; 
    border-radius: 50%; 
    margin-right: 12px;
}

/* 移动设备上的恋爱空间好友选择弹窗优化 */
@media screen and (max-width: 500px) {
    #custom-modal {
        max-height: 85vh; /* 移动设备上更大的显示区域 */
        margin: 10px; /* 移动设备上更小的边距 */
    }
    
    #custom-modal-body {
        max-height: calc(70vh - 120px); /* 给好友列表更多空间 */
        -webkit-overflow-scrolling: touch; /* iOS滚动优化 */
    }
}

/* 极小屏幕设备（如iPhone SE）恋爱空间弹窗优化 */
@media screen and (max-width: 400px) {
    #custom-modal {
        max-height: 90vh; /* 极小屏幕上最大化显示区域 */
        margin: 5px; /* 更小的边距 */
    }
    
    #custom-modal-body {
        max-height: calc(75vh - 100px); /* 给好友列表更多空间 */
    }
    
    #custom-modal-body .char-option {
        padding: 10px 8px; /* 减少内边距以容纳更多内容 */
    }
}
/* 恋爱空间好友选择弹窗滚动指示器 */
#custom-modal-body::-webkit-scrollbar {
    width: 4px;
}

#custom-modal-body::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 2px;
}

#custom-modal-body::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #007bff, #0056b3);
    border-radius: 2px;
}

#custom-modal-body::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #0056b3, #004085);
}

/* 恋爱空间好友选择弹窗滚动渐变指示器 */
#custom-modal-body::after {
    content: '';
    position: sticky;
    bottom: 0;
    left: 0;
    right: 0;
    height: 20px;
    background: linear-gradient(0deg, rgba(255,255,255,0.9) 0%, transparent 100%);
    pointer-events: none;
    margin: 0 -16px -16px -16px;
}

/* ▲▲▲ 恋爱空间好友选择弹窗样式结束 ▲▲▲ */

.friend-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
    transition: background-color 0.2s;
}

.friend-item:hover {
    background-color: #f8f9fa;
}

.friend-item.active {
    background-color: #e3f2fd;
    border-left: 3px solid var(--accent-color);
}

.friend-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    margin-right: 12px;
}

.friend-name {
    font-size: 16px;
    font-weight: 500;
    color: var(--text-primary);
}

.friend-item.active .friend-name {
    color: var(--accent-color);
    font-weight: 600;
}

/* 让私人空间头像可点击 */
.private-space-avatar {
    cursor: pointer;
    transition: transform 0.2s ease;
}

.private-space-avatar:hover {
    transform: scale(1.05);
}

.private-space-avatar img {
    transition: opacity 0.2s ease;
}

.private-space-avatar:hover img {
    opacity: 0.9;
}
/* ▲▲▲ 好友选择弹窗样式结束 ▲▲▲ */

/* ▲▲▲ 回忆页面粉色主题样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】App图标设置样式 ▼▼▼ */
#icon-settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
}

.icon-setting-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.icon-preview {
    width: 60px;
    height: 60px;
    border-radius: 15px;
    background-size: cover;
    background-position: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.change-icon-btn {
    padding: 4px 10px;
    font-size: 12px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外观设置页面布局修正 ▼▼▼ */

/* 1. 修正滚动问题 */
#wallpaper-screen .form-container {
    /* 核心修正1: 解决flex布局下的滚动冲突，让滚动条能正常出现 */
    min-height: 0; 
}

/* 2. 修正壁纸预览被压扁的问题 */
#wallpaper-preview {
    /* 核心修正2: 防止预览框被过多的内容挤压变形，让它保持自己的高度 */
    flex-shrink: 0; 
}
/* ▲▲▲ 修正结束 ▲▲▲ */

/* ▼▼▼ 【全新】分享链接功能样式 (无图版) ▼▼▼ */

/* 1. 浏览器界面背景色和内容区样式 (保持不变) */
#browser-screen {
    background-color: #f8f9fa;
}
#browser-content {
    padding: 20px;
    font-size: 16px;
    line-height: 1.8;
    color: #333;
    overflow-y: auto;
    background-color: #f8f9fa;
}
#browser-content .article-title {
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 10px;
}
#browser-content .article-meta {
    font-size: 13px;
    color: #8a8a8a;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
}
#browser-content .article-body {
    white-space: pre-wrap;
    word-break: break-word;
}
#browser-content .article-body p {
    margin-bottom: 1em;
}

/* 2. 聊天气泡中的链接卡片样式 (无图版) */
.message-bubble.is-link-share .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.link-share-card {
    width: 210px; 
    background-color: #fff;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.link-share-card:hover {
    background-color: #f9f9f9;
}

.link-share-card .title {
    font-weight: 600;
    font-size: 15px;
    line-height: 1.4;
    color: #1f1f1f;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .description {
    font-size: 13px;
    color: #8a8a8a;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .footer {
    display: flex; /* 让图标和文字水平对齐 */
    align-items: center;
    gap: 6px; /* 图标和文字的间距 */
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px; /* 和上面的描述拉开一点距离 */
}
.link-share-card .footer-icon {
    width: 14px;
    height: 14px;
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 单条评论的容器，现在需要相对定位 */
.comment-item {
    position: relative;
    padding-right: 25px; /* 在右侧留出删除按钮的空间 */
}

/* 评论删除按钮的样式 */
.comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    font-size: 18px;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 鼠标悬停在评论上时，显示删除按钮 */
.comment-item:hover .comment-delete-btn {
    opacity: 1;
}

.comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #ff3b30;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【请求7】主屏幕预设保存按钮主题色适配 (请将这块代码也粘贴到 <style> 的末尾) ▼▼▼ */
#save-home-preset-btn {
    background-color: var(--accent-color);
    color: white;
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */


/* ▼▼▼ 【全新】引用回复功能样式 ▼▼▼ */

/* 1. 输入框上方的“回复预览栏” */
#reply-preview-bar {
    display: none; /* 默认隐藏 */
    padding: 8px 12px;
    margin: 0 8px 8px 8px; /* 和输入框周围的边距保持一致 */
    background-color: rgba(0, 0, 0, 0.05);
    border-left: 3px solid var(--accent-color);
    border-radius: 6px;
    position: relative;
    font-size: 13px;
    color: var(--text-secondary);
}

#phone-screen.dark-mode #reply-preview-bar {
    background-color: rgba(255, 255, 255, 0.1);
}

.reply-preview-content .sender {
    font-weight: 600;
    color: var(--text-primary);
}

.reply-preview-content .text {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: block; /* 确保省略号生效 */
    max-width: 95%;
}

#cancel-reply-btn {
    position: absolute;
    top: 50%;
    right: 8px;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    border-radius: 50%;
    background-color: rgba(0,0,0,0.1);
    cursor: pointer;
    font-size: 14px;
}

/* 2. 消息气泡内部的“引用消息块” */
.quoted-message {
    padding: 6px 10px;
    margin-bottom: 6px;
    background-color: rgba(0, 0, 0, 0.04);
    border-left: 2px solid var(--accent-color);
    border-radius: 4px;
    font-size: 0.9em; /* 字体比正文小一点 */
    opacity: 0.8;
    /* (已移除 overflow: hidden;) */
}

#phone-screen.dark-mode .quoted-message {
    background-color: rgba(255, 255, 255, 0.08);
    border-left-color: #a0cff1;
}

.quoted-message .quoted-sender {
    font-weight: 600;
    color: var(--accent-color);
}
#phone-screen.dark-mode .quoted-message .quoted-sender {
    color: #a0cff1;
}

.quoted-message .quoted-content {
    color: var(--text-secondary);
    white-space: normal;     /* 核心修正1: 允许文本正常换行 */
    word-break: break-word;  /* 核心修正2: 强制长单词或连续字符断开，防止溢出 */
    display: block;
    /* (已移除 overflow 和 text-overflow，因为我们需要多行显示而不是单行省略号) */
}

/* === 字体预览框样式 (修正后) === */

/* 将它修改为 ▼▼▼ */
#font-preview {
    padding: 20px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: #f0f2f5; /* 统一为更浅的灰色，然后让夜间模式CSS去覆盖 */
    transition: background-color 0.3s, border-color 0.3s;
}

/* 预览框里的文字颜色，默认是黑色 */
#font-preview p {
    color: var(--text-primary);
}

/* 夜间模式下的修正样式 */
#phone-screen.dark-mode #font-preview {
    background-color: #1c1c1e; /* 深灰色背景 */
    border-color: #38383a;     /* 暗色边框 */
}

/* 夜间模式下，预览框里的文字变为白色 */
#phone-screen.dark-mode #font-preview p {
    color: #ffffff;
}

/* ▼▼▼ 【全新】精致版转账操作弹窗样式 ▼▼▼ */
.transfer-actions-content {
    background-color: #fff0f5; /* 粉嫩的背景色 */
    border-radius: 20px;
    width: 290px;
    padding: 20px;
    box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); /* 粉色阴影 */
    text-align: center;
    position: relative;
    border: 1px solid #ffcce0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.transfer-actions-header {
    font-size: 20px;
    font-weight: bold;
    color: #a35c7b; /* 深粉色标题 */
    margin-bottom: 15px;
}

.transfer-actions-body p {
    font-size: 15px;
    color: #555;
    margin: 0 0 25px 0;
    line-height: 1.5;
}

.transfer-actions-footer {
    display: flex;
    justify-content: space-between;
    gap: 15px;
}

.transfer-actions-footer .action-btn {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    color: white;
}

.transfer-actions-footer .action-btn:active {
    transform: scale(0.95);
}

.transfer-actions-footer .action-btn.accept {
    background: linear-gradient(135deg, #ff85b3, #ff69b4);
    box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4);
}

.transfer-actions-footer .action-btn.decline {
    background: linear-gradient(135deg, #c2c2c2, #a0a0a0);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.transfer-actions-content .cancel-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0, 0, 0, 0.1);
    color: #a35c7b;
    font-size: 20px;
    line-height: 28px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 未读消息红点样式 === */
.unread-count-wrapper {
    flex-shrink: 0;
    width: 40px;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 20px; /* 让红点和名字差不多高 */
}

.unread-count {
    min-width: 20px;
    height: 20px;
    padding: 0 6px;
    background-color: #ff3b30; /* iOS 风格的红色 */
    color: white;
    font-size: 13px;
    font-weight: 500;
    line-height: 20px;
    text-align: center;
    border-radius: 10px; /* 圆角矩形 */
    box-shadow: 0 1px 2px rgba(0,0,0,0.15);
    display: none; /* 默认隐藏 */
    justify-content: center;
    align-items: center;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】通话记录页面与卡片样式 ▼▼▼ */

/* 确保页面背景色统一 */
#call-history-screen {
    background-color: #f0f2f5;
}

/* 通话记录卡片样式 */
.call-record-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-left: 5px solid var(--accent-color);
}
.call-record-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.1);
}

/* 卡片头部：包含日期和时长 */
.call-record-card .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}
.call-record-card .card-header .duration {
    font-weight: 500;
    color: var(--text-primary);
}

/* 卡片主体：参与者头像 */
.call-record-card .card-body {
    display: flex;
    align-items: center;
}
.call-record-card .participants-avatars {
    display: flex;
    align-items: center;
}
.call-record-card .participant-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* 让头像有一个漂亮的堆叠效果 */
.call-record-card .participant-avatar:not(:first-child) {
    margin-left: -12px;
}
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 15px;
}

/* --- 通话详情弹窗样式 --- */
#transcript-modal-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 15px;
}
.transcript-entry {
    padding: 8px 12px;
    border-radius: 10px;
    max-width: 85%;
    line-height: 1.5;
    word-break: break-word;
}
.transcript-entry.user {
    background-color: #dcf8c6; /* 类似微信的绿色 */
    align-self: flex-end;
}
.transcript-entry.assistant {
    background-color: #ffffff;
    align-self: flex-start;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

#chat-list-title {
    cursor: pointer;
}

/* ▼▼▼ 【全新】通话记录卡片美化样式 ▼▼▼ */

.call-record-card .card-body {
    /* 将 body 改为 flex 布局，让标题和参与者信息垂直排列 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 标题和参与者信息之间的间距 */
}

.call-record-card .custom-title {
    font-size: 16px;
    font-weight: 600; /* 加粗，让它像个标题 */
    color: var(--text-primary);
    padding-bottom: 8px; /* 标题下的留白 */
    border-bottom: 1px solid var(--border-color); /* 在标题下加一条分割线 */
    margin-bottom: 4px; /* 和下面的参与者信息拉开一点距离 */
}

.call-record-card .participants-info {
    /* 这个新容器让头像和“与xx”能水平对齐 */
    display: flex;
    align-items: center;
}

/* 参与者名字的样式微调，让它不那么突出 */
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 500; /* 不再加粗 */
    font-size: 14px; /* 稍微小一点 */
    color: var(--text-secondary); /* 使用次要文字颜色 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】语音转文字功能样式 ▼▼▼ */

/* 1. 语音文字内容的样式 */
.voice-transcript {
    font-size: 14px;         /* 文字大小 */
    line-height: 1.6;        /* 行高，让多行文本更易读 */
    color: var(--text-secondary); /* 使用次要文字颜色，与语音条区分 */
    padding: 8px 12px;       /* 内边距 */
    margin-top: 6px;         /* 和上方的语音条拉开一点距离 */
    background-color: rgba(0, 0, 0, 0.04); /* 给一个淡淡的背景，更有层次感 */
    border-radius: 6px;      /* 圆角 */
    word-break: break-word;  /* 确保长文本能正常换行 */
    display: none;           /* 默认隐藏 */
}

#phone-screen.dark-mode .voice-transcript {
    background-color: rgba(255, 255, 255, 0.1); /* 夜间模式下的背景色 */
}

/* 2. 旋转加载动画的样式 */
.loading-spinner {
    display: none; /* 默认隐藏 */
    width: 16px;
    height: 16px;
    border: 2px solid rgba(0, 0, 0, 0.2);
    border-top-color: var(--accent-color); /* 旋转部分的颜色 */
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 8px; /* 和波形图、时长保持一点间距 */
}

/* 3. 定义旋转动画 */
@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】分享记录查看器样式修正 ▼▼▼ */
#shared-history-viewer-content {
    display: flex;
    flex-direction: column; /* 让气泡垂直排列 */
    gap: 20px; /* 在每个气泡之间增加20像素的间距 */
    padding: 15px; /* 在容器四周也增加一些内边距，避免气泡贴边 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】播放器和歌词样式 ▼▼▼ */
#music-player-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 60px;
    background-color: rgba(0,0,0,0.3);
    opacity: 0;
    visibility: hidden;
    transform: translateY(-50px);
    transition: opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

#music-player-overlay.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

.music-player-window { 
    width: 70%; 
    min-height: 420px;
    background-color: rgba(255, 255, 255, 0.6); 
    backdrop-filter: blur(20px); 
    -webkit-backdrop-filter: blur(20px); 
    border-radius: 25px; 
    box-shadow: 0 8px 32px 0 rgba(25, 25, 25, 0.37); 
    border: 1px solid rgba(255, 255, 255, 0.18); 
    padding: 25px; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    color: #1f1f1f; 
    position: relative;
    justify-content: space-between;
    padding-bottom: 15px;
}

.music-player-top-actions {
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    width: calc(100% - 30px);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.top-left-cluster {
    display: flex;
    align-items: center;
    gap: 15px;
}
#music-return-btn, #music-exit-btn {
    background: none;
    border: none;
    font-size: 28px;
    font-weight: 300;
    cursor: pointer;
    color: #555;
    padding: 5px;
    line-height: 1;
}
#music-exit-btn {
    font-size: 24px;
    font-weight: 400;
}

.music-progress-bar-container {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 25px;
    margin-bottom: 10px;
}
.time-display {
    font-size: 11px;
    color: #888;
    width: 35px;
    text-align: center;
    flex-shrink: 0;
    font-family: 'SF Mono', 'Menlo', monospace;
}
.progress-bar {
    flex-grow: 1;
    height: 5px;
    background-color: #e5e5e5;
    border-radius: 2.5px;
    cursor: pointer;
}
.progress-bar-fill {
    width: 0%;
    height: 100%;
    background-color: #333;
    border-radius: 2.5px;
}

#music-lyrics-container {
    width: 100%;
    height: 192px;
    overflow: hidden;
    position: relative;
    -webkit-mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
    mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
}

#music-lyrics-list {
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
}

.lyric-line {
    padding: 4px 0;
    font-size: 14px;
    color: #666;
    text-align: center;
    line-height: 1.5;
    transition: all 0.5s ease;
    opacity: 0.7;
    transform: scale(0.95);
}

.lyric-line.active {
    font-size: 16px;
    color: #000;
    opacity: 1;
    transform: scale(1);
}

.music-player-controls-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.music-controls {
    margin-top: 0;
}

#music-return-btn, #music-exit-btn, #music-playlist-btn {
    position: relative;
}

#music-return-btn { top: -2px; }
#music-playlist-btn { top: -3px; }

.playlist-item-actions {
    display: flex;
    align-items: center;
    gap: 15px;
}
.playlist-action-btn {
    font-size: 18px;
    color: #888;
    cursor: pointer;
    transition: color 0.2s;
}
.playlist-action-btn:hover { color: #000; }
.delete-track-btn { font-size: 24px; color: #ff3b30; }
.delete-track-btn:hover { color: #c00; }
.lyrics-btn { font-weight: 500; }

/* --- 【核心修正】确保头像尺寸 --- */
.message-bubble .avatar {
    width: 34px;
    height: 34px;
    border-radius: 20%;
    object-fit: cover;
    flex-shrink: 0; /* 防止被压缩 */
}

/* ▼▼▼ 【全新】撤回消息样式 ▼▼▼ */

/* 1. 撤回消息的占位符样式 */
.recalled-message-placeholder {
    align-self: center; /* 居中显示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
    cursor: pointer; /* 让它看起来可以点击 */
}

/* 2. 夜间模式下的适配 */
#phone-screen.dark-mode .recalled-message-placeholder {
    background-color: rgba(255, 255, 255, 0.15);
}

/* 3. AI撤回消息时的动画效果 */
@keyframes recall-animation {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}

.message-wrapper.recalled-animation {
  animation: recall-animation 0.3s ease-out forwards;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】撤回消息样式修正 ▼▼▼ */

/* 强制撤回消息的占位符不换行，并保持内容居中 */
.recalled-message-placeholder {
    white-space: nowrap; /* 核心：禁止文本换行 */
    display: inline-block; /* 让背景根据内容自适应宽度 */
    padding: 4px 12px;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】世界书分类列表样式 ▼▼▼ */
.world-book-group-container {
    border-bottom: 1px solid var(--border-color);
}
.world-book-group-container:first-child {
    border-top: 1px solid var(--border-color);
}
.world-book-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: #f7f7f7;
}
.world-book-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}
.world-book-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}
.world-book-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}
.world-book-group-content {
    max-height: none; /* 移除高度限制，允许显示所有书籍 */
    overflow: visible; /* 改为可见，不裁剪内容 */
    transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
}
.world-book-group-content.collapsed {
    max-height: 0;
    overflow: hidden; /* 折叠时才隐藏溢出 */
    opacity: 0;
}
#phone-screen.dark-mode .world-book-group-header {
    background-color: #1c1c1e;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】红包/转账模态框页签样式 ▼▼▼ */
.frame-tabs {
    display: flex;
    background-color: #f0f0f0;
    padding: 4px;
    margin: 15px;
    border-radius: 8px;
}
.frame-tab {
    flex: 1;
    text-align: center;
    padding: 8px;
    font-size: 14px;
    font-weight: 500;
    color: #666 !important;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease-in-out;
}
.frame-tab.active {
    background-color: #ffffff;
    color: #333 !important;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段全新的CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 分类文件夹的样式 */
.wb-category-header {
    display: flex;
    align-items: center;
    padding: 10px 12px;
    cursor: pointer;
    background-color: #f0f2f5; /* 给文件夹一个淡淡的背景色以区分 */
    font-weight: 600; /* 加粗字体 */
}
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e; /* 夜间模式下的背景色 */
}


/* 2. 展开/收起的小箭头 */
.wb-category-header .arrow {
    font-size: 12px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

/* 3. 当文件夹收起时，箭头旋转 */
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 4. 存放书籍条目的容器 */
.wb-book-container {
    padding-left: 20px; /* 核心：让书籍条目向内缩进，看起来像在文件夹里 */
    max-height: 1000px; /* 一个足够大的值，用于动画 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

/* 5. 当文件夹收起时，书籍容器的高度变为0，实现动画效果 */
.wb-book-container.collapsed {
    max-height: 0;
}

/* 6. 单个书籍条目（覆盖默认的label样式，微调间距） */
.wb-book-container label {
    padding: 8px 12px;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】世界书关联选择器 - 视觉优化 ▼▼▼ */

/* 1. 让分类标题更突出 */
.wb-category-header > span:last-of-type {
    font-size: 14px;
    font-weight: 700; /* 加粗 */
    color: var(--text-primary);
}

/* 2. 为箭头设置一个漂亮的颜色循环 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+1) .arrow { color: #007bff; } /* 蓝色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+2) .arrow { color: #28a745; } /* 绿色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+3) .arrow { color: #fd7e14; } /* 橙色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+4) .arrow { color: #6f42c1; } /* 紫色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+5) .arrow { color: #dc3545; } /* 红色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+6) .arrow { color: #ffc107; } /* 黄色 */

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 头像框选择模态框样式 (这是新添加的) === */
.change-frame-btn {
    padding: 6px 10px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
    margin-left: 10px;
}

#avatar-frame-modal .modal-content {
    height: 70%; /* 让窗口高一点 */
}

#avatar-frame-modal .modal-body {
    padding: 0;
    display: flex;
    flex-direction: column;
}
      
.frame-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.frame-tab {
    flex: 1;
    padding: 12px;
    text-align: center;
    font-weight: 500;
    cursor: pointer;
    color: var(--text-secondary);
    border-bottom: 2px solid transparent;
}

.frame-tab.active {
    color: var(--accent-color);
    border-bottom-color: var(--accent-color);
}

.frame-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
}

.frame-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); /* 每行自动填充，最小70px宽 */
    gap: 15px;
}

.frame-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    background-color: #f0f0f0;
    background-size: cover;
    background-position: center;
    padding: 5px;
    transition: all 0.2s ease;
    position: relative; /* 为预览图做准备 */
}

.frame-item.selected {
    border-color: var(--accent-color);
    transform: scale(1.05);
}

.frame-item .preview-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

.frame-item .preview-frame {
    position: absolute;
    top: -7px;
    left: 0;
    width: 100%;
    height: 100%;
}

/* ▼▼▼ 把这些CSS加回去 ▼▼▼ */
.avatar-with-frame {
    position: relative;
    width: 34px; /* 和普通头像一样大 */
    height: 34px;
    flex-shrink: 0;
}
.avatar-with-frame .avatar-img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%; /* 带框的头像通常是圆的 */
    object-fit: cover;
    z-index: 1;
}
.avatar-with-frame .avatar-frame {
    position: absolute;
    /* 核心修改1：使用百分比来定义大小 */
    /* 这会让头像框的尺寸永远是其父容器（也就是头像大小）的1.5倍 */
    /* 如果你觉得框太大了或太小了，可以微调这里的数值，比如 140% 或 160% */
    width: 135%; 
    height: 135%;

    /* 核心修改2：使用transform变换来实现完美居中 */
    top: 43%; /* 先把框的左上角移动到父容器的中心点 */
    left: 50%;
    /* 再把框向左、向上移动自己宽高的一半，这样框的中心就和父容器的中心完全对齐了 */
    transform: translate(-50%, -50%); 
    
    z-index: 2;
    pointer-events: none; /* 让框不影响鼠标事件 */
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* ▼▼▼ 【最终美化版】聊天列表左滑置顶功能样式 (已修复Bug) ▼▼▼ */

/* 1. 外层包裹容器 (已移除 display:flex) */
.chat-list-item-swipe-container {
    position: relative;
    overflow: hidden;
}

/* 2. 可滑动的内容区 (保持不变) */
.chat-list-item-content {
    position: relative;
    z-index: 2;
    background-color: var(--secondary-bg);
    transition: transform 0.3s ease, background-color 0.3s ease;
    width: 100%;
    flex-shrink: 0;
}

/* 3. 【核心修改1】置顶聊天时，使用对比度更强的背景色 */
.chat-list-item-content.pinned {
    background-color: #f0f2f5; /* 日间模式下的置顶颜色 (已加深) */
}
#phone-screen.dark-mode .chat-list-item-content.pinned {
    background-color: #3a3a3c; /* 夜间模式下的置顶颜色 (已加深) */
}

/* 4. 隐藏的操作按钮区域 (保持不变) */
.swipe-actions {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
    display: flex;
}

/* 5. 单个操作按钮的样式 (保持不变) */
.swipe-action-btn {
    height: 100%;
    padding: 0 20px;
    border: none;
    color: white;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 80px;
}

.swipe-action-btn.pin { background-color: #f0ad4e; }
.swipe-action-btn.unpin { background-color: #777; }
.swipe-action-btn.delete { background-color: #ff3b30; }

/* 6. 当内容区被滑开时 (保持不变) */
.chat-list-item-content.swiped {
    transform: translateX(-160px);
}

/* 7. 分割线的正确逻辑 (保持不变) */
.chat-list-item {
    border-bottom: none;
}
.chat-list-item-swipe-container:not(:last-child) {
     border-bottom: 1px solid var(--border-color);
}
.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-of-type {
    border-top: 1px solid var(--border-color);
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 用下面这段【新样式】，替换掉你旧的 .date-stamp 样式 ▼▼▼ */

/* 日期戳的外层包裹，让它像系统消息一样居中 */
.date-stamp-wrapper {
    justify-content: center;
    align-self: center;
    margin: 10px 0;
    max-width: 80%;
}

/* 日期戳的气泡本身 */
.date-stamp-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

/* 适配夜间模式 */
#phone-screen.dark-mode .date-stamp-bubble {
    background-color: rgba(255, 255, 255, 0.15);
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.chat-list-time {
    font-size: 12px;
    color: var(--text-secondary);
    text-align: right;
    margin-left: 8px; /* 和中间的信息区拉开一点距离 */
    flex-shrink: 0;   /* 防止在空间不足时被压缩 */
    align-self: flex-start; /* 让它和顶部的名字对齐 */
    padding-top: 2px; /* 微调垂直位置 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.chat-list-right-column {
    display: flex;
    flex-direction: column;
    align-items: flex-end; /* 让内容靠右对齐 */
    gap: 4px; /* 在时间和红点之间加一点点间距 */
    flex-shrink: 0;
    margin-left: 8px;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】锁屏与密码界面样式 ▼▼▼ */

/* 1. 锁屏界面的总容器 */
#lock-screen {
    /* 核心：用一个非常高的 z-index 确保它能覆盖所有其他屏幕 */
    z-index: 999; 
    background-size: cover;
    background-position: center;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: space-between; /* 让时钟和提示语上下分布 */
    align-items: center;
    padding: 80px 20px 50px 20px;
    box-sizing: border-box;
    transition: transform 0.3s ease-out;
}

/* 2. 锁屏时钟 (复用主屏幕时钟的样式) */
#lock-clock-container {
    text-align: center;
    text-shadow: 0 3px 8px rgba(0,0,0,0.4);
    flex-shrink: 0;
}
#lock-main-time {
    font-size: 80px;
    font-weight: 200;
}
#lock-main-date {
    font-size: 18px;
    font-weight: 500;
}

/* 3. “向上轻扫”的提示文字和动画 */
#unlock-hint {
    font-size: 16px;
    font-weight: 500;
    text-shadow: 0 1px 4px rgba(0,0,0,0.3);
    /* 添加一个呼吸动画，吸引用户注意 */
    animation: hint-pulse 2s infinite ease-in-out;
}
@keyframes hint-pulse {
    0%, 100% { opacity: 0.7; transform: translateY(0); }
    50% { opacity: 1; transform: translateY(-5px); }
}

/* 4. 密码输入弹窗的遮罩层 */
#password-modal-overlay {
    /* 使用一个半透明的毛玻璃效果背景 */
    background-color: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 1000; /* 比锁屏更高，确保在最上层 */
}

/* 5. 密码输入弹窗的内容区 */
.password-modal-content {
    background-color: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    width: 280px;
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 15px;
    color: #333;
}
.password-modal-content p {
    font-size: 17px;
    font-weight: 600;
    margin: 0;
}

/* 6. 密码输入框 */
#password-input-field {
    width: 100%;
    padding: 12px;
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 8px;
    font-size: 16px;
    text-align: center;
    box-sizing: border-box;
    background-color: rgba(255,255,255,0.7);
}
#password-input-field:focus {
    outline: none;
    border-color: var(--accent-color);
}

/* 7. 密码弹窗的按钮区域 */
.password-actions {
    display: flex;
    gap: 10px;
    margin-top: 5px;
}
.password-actions button {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
}
#password-cancel-btn {
    background-color: #e9ecef;
    color: #495057;
}
#password-confirm-btn {
    background-color: var(--accent-color);
    color: white;
}

/* 8. 密码错误时的晃动动画 */
@keyframes shake-error {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}
.password-modal-content.error {
    animation: shake-error 0.4s ease-in-out;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】气泡/API样式预设功能CSS ▼▼▼ */
.bubble-preset-manager {
    display: flex;
    align-items: center;
    gap: 10px; /* 元素之间的间距 */
}

/* 下拉框的样式，让它占据大部分空间 */
.bubble-preset-manager select {
    flex-grow: 1; /* 占据所有剩余空间 */
}

/* 管理按钮的样式，让它小巧精致 */
.bubble-preset-manager .action-btn {
    flex-shrink: 0; /* 防止按钮被压缩 */
    padding: 8px 10px;
    font-size: 13px;
    background-color: #e9ecef;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 让锁屏和主屏幕可以堆叠 */
/* 核心：把锁屏和主屏幕都设为绝对定位，这样它们才能重叠 */
#lock-screen, #home-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* 2. 定义毛玻璃背景层的样式 */
#lock-screen-background-blur {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* 【核心修改1】它的层级现在和主屏幕一样低 */
    
    background-size: cover;
    background-position: center;

    /* 【核心修改2】魔法在这里！我们直接模糊这个元素本身 */
    filter: blur(20px);
    -webkit-filter: blur(20px);
    
    /* (可选但推荐) 轻微放大可以避免模糊后边缘变暗，效果更好 */
    transform: scale(1.1); 

    /* 【核心修改3】默认隐藏，且带有淡入淡出效果 */
    display: none;
    opacity: 0;
    transition: opacity 0.3s ease-out;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 从这里开始复制 ▼▼▼ */

/* === 【最终修复版】世界书选择器列表样式 === */

/* 1. 分类文件夹行样式：用flex和gap创建固定间距，非常稳定 */
.wb-category-header {
    display: flex;
    align-items: center;
    gap: 8px; /* 箭头、复选框、文字之间的固定间距 */
    padding: 10px 12px;
    cursor: pointer;
    background-color: #f0f2f5;
    font-weight: 600;
    overflow: hidden; /* 防止任何意外溢出 */
}

/* 2. 分类文件夹里的文字样式：只负责截断，不负责布局 */
.wb-category-header > span:last-of-type {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-shrink: 1; /* 允许文字部分在空间不足时被压缩 */
}

/* 3. 【核心修复】为分类和书目里的复选框“解绑”全局样式！ */
.wb-category-header input[type="checkbox"],
.wb-book-container input[type="checkbox"] {
    width: auto !important; /* 让它恢复自己的天然大小，!important确保最高优先级 */
    flex-shrink: 0;         /* 防止它被压缩，保持完整 */
}

/* 4. 具体书目行的样式：强制从左边开始排列，解决不同设备的显示差异 */
.wb-book-container label {
    display: flex;
    align-items: center;
    justify-content: flex-start; /* 强制所有内容从左边开始对齐 */
    padding: 8px 12px;
    gap: 10px; /* 复选框和文字的间距 */
    overflow: hidden;
}

/* 5. 具体书目的文字样式 */
.wb-book-container label .wb-book-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: left;
    flex-shrink: 1; /* 同样允许它被压缩 */
}

/* 6. 夜间模式适配 (保持不变) */
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e;
}

/* 7. 小箭头的样式 (保持不变) */
.wb-category-header .arrow {
    font-size: 12px;
    transition: transform 0.2s ease;
    flex-shrink: 0; /* 防止箭头被压缩 */
}
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 8. 书籍容器的样式 (已修复：移除高度限制) */
.wb-book-container {
    padding-left: 20px;
    max-height: none; /* 移除高度限制，允许显示所有书籍 */
    overflow: visible; /* 改为可见，不裁剪内容 */
    transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
}
.wb-book-container.collapsed {
    max-height: 0;
    overflow: hidden; /* 折叠时才隐藏溢出 */
    opacity: 0;
}


/* ▼▼▼ 【全新】鼠标拖动工具栏时的手势样式 ▼▼▼ */
#chat-input-actions-top.grabbing {
    cursor: grabbing;
    cursor: -webkit-grabbing;
    user-select: none; /* 防止拖动时选中文本 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【SVG终极版】发送定位功能样式 ▼▼▼ */

/* 1. 基础卡片和气泡样式 (保持不变) */
.message-bubble.is-location .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
.location-card { width: 230px; background-color: #f7f7f7; border-radius: 12px; overflow: hidden; border: 1px solid #e0e0e0; box-shadow: 0 2px 5px rgba(0,0,0,0.08); }

/* 2. 【核心升级】地图区域现在直接用于容纳SVG */
.location-map-area {
    height: 90px;
    background-color: #f0f2f5;
    background-image:
        linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
    background-size: 20px 20px;
    padding: 5px; /* 给SVG一点呼吸空间 */
    box-sizing: border-box;
}
.location-map-area svg {
    width: 100%;
    height: 100%;
}

/* 3. 【全新】SVG内部元素的样式 */
/* 轨迹曲线 */
.svg-trajectory-path {
    stroke-width: 2px;
    stroke: rgba(180, 180, 180, 0.8);
    stroke-dasharray: 3 3; /* 虚线效果 */
    fill: none;
}
/* 定位点 (起点/终点) */
.svg-pin {
    stroke-width: 2px;
    stroke: white;
}
.svg-pin.user-pin { fill: #4CAF50; } /* 绿色用户点 */
.svg-pin.ai-pin { fill: #ff5252; } /* 红色AI点 */

/* 脚印图标 */
.svg-footprint {
    font-size: 14px;
    fill: rgba(0, 0, 0, 0.4);
}
/* 途经点地名标签 */
.svg-location-label {
    font-size: 10px;
    font-weight: 500;
    fill: #555;
    /* 给文字一点白色的描边，让它在复杂背景下更清晰 */
    stroke: white;
    stroke-width: 2px;
    paint-order: stroke;
}

/* 4. 卡片底部信息区域 (已升级) */
.location-info { padding: 12px; }
.location-address {
    font-size: 13px;
    line-height: 1.6;
    margin-bottom: 8px;
    color: #333;
}
.location-address .name-tag {
    font-weight: 600;
    color: var(--text-primary);
}
.location-address p.hidden { display: none; }
.location-distance {
    font-size: 12px;
    color: var(--text-secondary);
    border-top: 1px solid #e9e9e9;
    padding-top: 8px;
    text-align: center;
}
/* ▲▲▲ 升级版CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】“一键重roll”按钮样式 ▼▼▼ */
#reroll-btn {
    position: static;
    width: 37px;
    height: 37px;
    padding: 0;
    border-radius: 20px;
    background-color: rgba(255, 255, 255, 0.6);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border: 1px solid rgba(0,0,0,0.08);
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.2s, transform 0.1s;
    cursor: pointer;
    color: var(--text-primary); /* 使用全局主题的主文本颜色 */
}
#reroll-btn:hover {
    opacity: 0.8;
}
#reroll-btn:active {
    transform: scale(0.9);
}
#reroll-btn svg {
    width: 20px;
    height: 20px;
}

/* 表情按钮样式 */
#emoji-btn {
    position: static;
    width: 37px;
    height: 37px;
    padding: 0;
    border-radius: 20px;
    background-color: rgba(255, 255, 255, 0.6);
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.2s, transform 0.1s;
    cursor: pointer;
    color: var(--text-primary);
}
#emoji-btn:hover {
    opacity: 0.8;
}
#emoji-btn:active {
    transform: scale(0.9);
}
#emoji-btn svg {
    width: 20px;
    height: 20px;
}

/* 表情弹窗样式 */
.emoji-modal-content {
    width: 350px;
    height: 400px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
}

.emoji-modal-body {
    padding: 0;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
}

/* 表情内容区域 */
.emoji-content {
    flex: 1;
    padding: 15px;
    overflow-y: auto;
}

.emoji-category {
    display: none;
}

.emoji-category.active {
    display: block;
}

.emoji-row {
    display: flex;
    justify-content: flex-start;
    gap: 8px;
    margin-bottom: 8px;
}

.emoji-item {
    font-size: 22px;
    padding: 6px;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    user-select: none;
}

.emoji-item:hover {
    background-color: rgba(0, 0, 0, 0.1);
    transform: scale(1.1);
}

.emoji-item:active {
    transform: scale(0.95);
}

/* 底部分类栏样式 */
.emoji-categories {
    display: flex;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    background-color: rgba(248, 248, 248, 0.9);
    padding: 8px 4px;
    gap: 2px;
}

.category-tab {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px 4px;
    cursor: pointer;
    border-radius: 6px;
    transition: background-color 0.2s;
    font-size: 12px;
}

.category-tab:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

.category-tab.active {
    background-color: rgba(24, 144, 255, 0.1);
    color: #1890ff;
}

.category-tab span:first-child {
    font-size: 18px;
    margin-bottom: 2px;
}

.category-name {
    font-size: 10px;
    color: inherit;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【最终美化版】悬浮歌词栏样式 ▼▼▼ */
#floating-lyrics-bar {
    position: absolute;
    /* 【问题1修复】默认位置改为顶部 */
    top: 50px; 
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    
    display: none;
    align-items: center;
    justify-content: center;
    gap: 10px; /* 在歌词和按钮间增加间距 */

    width: 90%; 
    max-width: 320px; /* 同时设一个最大像素宽度，避免在宽屏上过长 */
    padding: 8px 12px; /* 稍微增加一点内边距以适应新宽度 */
    background-color: rgba(0, 0, 0, 0); 
    
    /* 【问题3需要】为字体颜色和背景透明度添加过渡动画 */
    transition: background-color 0.3s, opacity 0.3s;

    color: white;
    font-size: 14px;
    font-weight: 500; /* 字体稍微加粗 */
    text-align: center;
    border-radius: 12px;
    
    /* 文字阴影，让它在任何背景下都清晰 */
    text-shadow: 0 1px 3px rgba(0,0,0,0.5); 
    
    cursor: pointer;
    user-select: none;
    
    /* 【问题4需要】为关闭按钮准备 */
    overflow: visible; /* 允许按钮超出范围 */
}

/* 【问题4需要】关闭按钮的样式 */
#floating-lyrics-bar .close-btn,
#floating-lyrics-bar #lyrics-settings-btn {
    position: absolute;
    top: -8px;
    width: 20px;
    height: 20px;
    background-color: rgba(0,0,0,0.6);
    color: white;
    border-radius: 50%;
    border: 1px solid white;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s;
    display: flex; /* 确保SVG能居中 */
    align-items: center;
    justify-content: center;
}

/* 把关闭按钮和设置按钮分开放置 */
#floating-lyrics-bar .close-btn { right: -8px; line-height: 18px; font-size: 14px; }
#floating-lyrics-bar #lyrics-settings-btn { right: 22px; } /* 放在关闭按钮旁边 */

/* 鼠标悬停在整个歌词栏上时，一起显示它们 */
#floating-lyrics-bar:hover .close-btn,
#floating-lyrics-bar:hover #lyrics-settings-btn {
    opacity: 1;
}

#floating-lyrics-bar.dragging {
    cursor: grabbing;
    cursor: -webkit-grabbing;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】“查角色手机”功能相关样式 ▼▼▼ */

/* 角色选择列表项 */
.character-select-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
}
.character-select-item:hover {
    background-color: #f5f5f5;
}
.character-select-item img {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    margin-right: 12px;
}
.character-select-item .name {
    font-weight: 500;
}

/* 角色手机的聊天气泡 (简化版) */
.character-chat-bubble {
    padding: 8px 12px;
    border-radius: 12px;
    max-width: 80%;
    word-break: break-word;
    line-height: 1.5;
}
.character-chat-bubble.sent {
    background-color: #dcf8c6;
    align-self: flex-end; /* 自己发的靠右 */
}
.character-chat-bubble.received {
    background-color: #ffffff;
    align-self: flex-start; /* 收到的靠左 */
}

/* ▼▼▼ 【美化版】角色手机数据列表项样式 ▼▼▼ */
.character-data-item {
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0; /* 边框颜色变浅 */
    margin: 8px 10px; /* 增加外边距，形成卡片感 */
    border-radius: 8px; /* 增加圆角 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* 增加非常淡的阴影 */
    transition: transform 0.2s, box-shadow 0.2s; /* 增加悬浮动画 */
    background-color: var(--secondary-bg);
}

.character-data-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.08);
}

.character-data-item .title {
    font-weight: 600;
    margin-bottom: 5px;
    color: #333; /* 标题颜色加深 */
}
.character-data-item .content {
    font-size: 14px;
    color: #555;
    line-height: 1.6;
    white-space: pre-wrap;
}
.character-data-item .meta {
    font-size: 12px;
    color: #888;
    margin-top: 10px;
    padding-top: 8px; /* 在meta上方增加一点距离和分割线 */
    border-top: 1px solid #f5f5f5;
    display: flex;
    justify-content: space-between;
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▼▼▼ 【V3修正版】角色手机“画中画”样式修正 ▼▼▼ */

/* 1. 【核心修正1】让手机外壳容器占据整个屏幕，并用内边距把手机框“推”下来 */
#character-phone-container {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #ffffff; /* ★★★ 把这里改为纯白色 ★★★ */
    padding-top: 50px; 
    box-sizing: border-box; /* 确保内边距计算正确 */
}


/* 2. 手机边框样式 (保持不变) */
.character-phone-frame {
    width: 95%;
    height: 98%;
    background-color: #111;
    border-radius: 30px;
    padding: 10px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    box-sizing: border-box;
    position: relative;
    display: flex;
}

/* ▼▼▼ 用下面这块【已修复】的代码替换旧的 #character-app-grid .app-icon .icon-bg 规则 ▼▼▼ */
#character-app-grid .app-icon .icon-bg {
    width: 65px;  /* 恢复原来的尺寸 */
    height: 65px; /* 恢复原来的尺寸 */
    border-radius: 18px; /* 恢复原来的圆角 */
    background-color: #fff5f7; /* 设置为你想要的淡粉色背景 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* 3. 【核心修正2】缩小APP图标内的SVG */
#character-app-grid .app-icon .icon-bg svg {
    width: 60%;  /* ★★★ 将SVG的宽度缩小到其容器的60% ★★★ */
    height: 60%; /* ★★★ 高度也同步缩小 ★★★ */
}

/* 4. 其余样式保持不变 */
.character-phone-inner-screen {
    flex-grow: 1;
    border-radius: 20px;
    overflow: hidden;
    position: relative;
    background-color: var(--secondary-bg) !important; /* 使用变量 */
}
.character-phone-notch {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 20px;
    border-radius: 0 0 10px 10px;
    z-index: 10;
}
.character-phone-page {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
.character-phone-page.active {
    opacity: 1;
    visibility: visible;
    z-index: 5;
}
.character-phone-header {
    flex-shrink: 0;
    margin: 10px 12px 10px; /* ★ 修改点1: 将上边距 35px 改为 0，让它贴顶 */
    height: 50px;           /* ★ 修改点2: 将高度从 48px 增加到 56px，让它更高一点 */

    /* ★ 核心修改1：变成一个更圆润的胶囊形状 */
    border-radius: 24px; /* 将圆角从16px增加到24px，看起来更圆润 */

    /* ★ 核心修改2：设置一个几乎透明的、带有毛玻璃效果的背景 */
    background-color: rgba(180, 180, 180, 0.2); /* 降低不透明度，营造透明感 */
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);

    /* ★ 核心修改3：让边框和阴影更精致，以适应透明感 */
    border: 1px solid rgba(255, 255, 255, 0.2); /* 边框也调得更透明 */
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);   /* 阴影稍微调整，更柔和 */

    /* ★ 核心修改4：强制文字和图标颜色变为白色，并加上阴影以保证清晰 */
    color: #ffffff; /* 标题文字变为白色 */
    text-shadow: 0 1px 3px rgba(0,0,0,0.3); /* 给文字加一点阴影，防止背景太亮看不清 */

    /* 布局部分保持不变 */
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 12px;
    box-sizing: border-box;
    font-size: 16px;
}


/* ★★★【重要】为了确保所有图标都变成白色，请把下面这段新代码也加到<style>里 ★★★ */
.character-phone-header .action-btn svg,
.character-phone-header .back-btn svg {
    color: #ffffff !important;
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* ★★★【重要】为了确保所有图标都变成白色，请把下面这段新代码也加到<style>里 ★★★ */
.character-phone-header .action-btn svg,
.character-phone-header .back-btn svg {
    color: #ffffff !important;
}

/* ▲▲▲ 替换结束 ▲▲▲ */

.character-phone-header .action-btn svg,
.character-phone-header .back-btn svg {
    color: var(--accent-color);
}
#character-chat-history-messages {
     background-color: var(--secondary-bg) !important; /* 使用变量 */      /* ★★★ 移除背景图片 ★★★ */
}
/* ▲▲▲ 样式修正结束 ▲▲▲ */

/* ▼▼▼ 【V5最终修复版】角色手机APP图标布局修正 ▼▼▼ */
#character-app-grid.app-grid-standard {
    display: grid; /* ★★★ 核心修复：告诉浏览器这是一个网格布局！ ★★★ */
    grid-template-columns: repeat(3, 1fr); /* 保持三列的设置 */
    gap: 20px 15px;  /* ★★★ 新增：为图标之间添加合适的 垂直 和 水平 间距 ★★★ */
    padding: 20px; /* ★★★ 修改：统一设置内边距，让布局更规整 ★★★ */
    padding-top: 50px; /* 覆盖一下顶部内边距，离刘海远一点 */
    box-sizing: border-box; /* 确保内边距不会撑破容器 */
    width: 100%;
    
    /* 覆盖掉旧flex布局的影响 */
    flex-direction: initial; 
    align-items: initial;
}
/* ▲▲▲ 样式修正结束 ▲▲▲ */


/* ▼▼▼ 【全新】角色手机微信风格聊天气泡样式 ▼▼▼ */

/* 1. 聊天记录界面的背景色 */
#character-chat-history-messages {
    /* 移除之前版本可能存在的背景图片 */
    background-image: none;
}

/* 2. 消息气泡的通用容器样式 */
.character-chat-bubble-container {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    margin-bottom: 12px;
    max-width: 80%; /* 限制气泡最大宽度 */
}

/* 3. 气泡的内容区域 */
.character-chat-bubble {
    position: relative;
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word;
    border-radius: 6px;
    font-size: 15px;
}

/* 4. 头像样式 */
.character-chat-avatar {
    width: 36px;
    height: 36px;
    border-radius: 6px; /* 微信风格的圆角矩形头像 */
    flex-shrink: 0;
}

/* --- 我方（角色自己）的气泡 --- */
.character-chat-bubble-container.sent {
    align-self: flex-end; /* 整体靠右 */
    flex-direction: row-reverse; /* 布局反转：内容 -> 头像 */
}
.character-chat-bubble-container.sent .character-chat-bubble {
    background-color: #95ec69; /* 微信绿 */
    color: #000;
}
/* 我方气泡的小尾巴 */
.character-chat-bubble-container.sent .character-chat-bubble::after {
    content: "";
    position: absolute;
    right: -4px;
    top: 10px;
    width: 0;
    height: 0;
    border: 4px solid transparent;
    border-left-color: #95ec69;
    border-right: 0;
}

/* --- 对方（NPC或用户）的气泡 --- */
.character-chat-bubble-container.received {
    align-self: flex-start; /* 整体靠左 */
}
/* 对方气泡的小尾巴 */
.character-chat-bubble-container.received .character-chat-bubble::before {
    content: "";
    position: absolute;
    left: -4px;
    top: 10px;
    width: 0;
    height: 0;
    border: 4px solid transparent;
    border-right-color: #ffffff;
    border-left: 0;
}
/* ▼▼▼ 在这里添加下面这块新代码 ▼▼▼ */
.character-chat-bubble-container.received .character-chat-bubble {
    background-color: #ffffff; /* 微信白 */
    color: #000;
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* --- 功能性重置：针对图片/表情包，让气泡“消失” --- */
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image) {
    background: transparent !important;
    padding: 0 !important;
    border-radius: 0;
}
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image)::before,
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image)::after {
    content: none !important;
}
/* ▲▲▲ 样式添加结束 ▲▲▲ */
/* ▼▼▼ 【全新】角色手机新增APP页面样式 ▼▼▼ */

/* 1. 相册页面的网格布局 */
#character-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 每行3张图 */
    gap: 4px;
    padding: 4px;
}
.character-album-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    background-color: #e0e0e0;
    cursor: pointer;
}
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* 2. 银行页面的余额显示 */
.character-bank-balance-card {
    margin: 15px;
    padding: 20px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}
.character-bank-balance-card .label {
    font-size: 14px;
    opacity: 0.8;
}
.character-bank-balance-card .amount {
    font-size: 32px;
    font-weight: 600;
    margin-top: 5px;
    /* 添加水平滚动条支持 */
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;
    max-width: 100%;
    padding: 5px 0;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,0.6) rgba(255,255,255,0.2);
}

/* 角色银行余额滚动条样式（白色主题） */
.character-bank-balance-card .amount::-webkit-scrollbar {
    height: 6px;
}

.character-bank-balance-card .amount::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.2);
    border-radius: 3px;
}

.character-bank-balance-card .amount::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.6);
    border-radius: 3px;
}

.character-bank-balance-card .amount::-webkit-scrollbar-thumb:hover {
    background: rgba(255,255,255,0.8);
}

/* 3. 银行交易记录的颜色 */
.character-data-item .transaction-amount {
    font-weight: 600;
}
.character-data-item .transaction-amount.income {
    color: #4CAF50; /* 收入为绿色 */
}
.character-data-item .transaction-amount.expense {
    color: #F44336; /* 支出为红色 */
}

/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【V5修正版】角色手机相册网格布局 ▼▼▼ */
#character-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 每行3张图 */
    gap: 4px;
    padding: 4px;
}
.character-album-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    background-color: #e0e0e0;
    cursor: pointer;
}
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
/* ▲▲▲ 样式修正结束 ▲▲▲ */

/* ▼▼▼ 【全新】Markdown渲染增强样式 ▼▼▼ */

/* 1. 为角色手机里的所有Markdown内容设置基础样式 */
.character-data-item .content h1,
.character-data-item .content h2,
.character-data-item .content h3,
.character-data-item .content p {
    margin: 0 0 10px 0; /* 统一标题和段落的下边距 */
}
.character-data-item .content h1 { font-size: 1.5em; font-weight: 600; }
.character-data-item .content h2 { font-size: 1.3em; font-weight: 600; }
.character-data-item .content h3 { font-size: 1.1em; font-weight: 600; }

/* 2. 删除线样式 */
.character-data-item .content del {
    color: #8a8a8a;
}

/* 3. 遮挡/剧透效果 */
.character-data-item .content .spoiler {
    background-color: #333;
    color: #333; /* 文字和背景一个色，实现隐藏 */
    padding: 0 4px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}
/* 点击或鼠标悬停时显示内容 */
.character-data-item .content .spoiler:hover,
.character-data-item .content .spoiler:active {
    background-color: #f0f0f0;
    color: #000;
}

/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【全新】角色手机日记美化与删除功能样式 ▼▼▼ */

/* 1. 让日记列表有更好的边距 */
#character-diary-list {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 12px; /* 增加日记之间的间距 */
}

/* 2. 美化单篇日记卡片 */
#character-diary-list .character-data-item {
    background-color: #fffaf0; /* 温暖的米黄色背景 */
    border-left: 4px solid #ffc107; /* 左侧加一条装饰线 */
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    position: relative; /* 为了定位删除按钮 */
    padding-bottom: 35px; /* 为底部的日期留出空间 */
}

/* 3. 美化日期显示，把它放到右下角 */
#character-diary-list .character-data-item .meta {
    position: absolute;
    bottom: 8px;
    right: 12px;
    border-top: none; /* 移除原来的上边框 */
    padding-top: 0;
    font-size: 11px;
    color: #bfa87a;
}

/* 4. 删除按钮的样式 */
.diary-delete-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    background-color: rgba(0,0,0,0.05);
    color: #bfa87a;
    border: none;
    cursor: pointer;
    font-size: 20px;
    line-height: 26px;
    text-align: center;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease-in-out;
}
/* 鼠标悬停在日记上时显示按钮 */
#character-diary-list .character-data-item:hover .diary-delete-btn {
    opacity: 1;
}
.diary-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【V6最终修复版】角色手机相册布局防溢出 ▼▼▼ */

/* 1. 【核心】为相册网格的容器强制禁止水平滚动 */
#character-album-grid.list-container {
    overflow-x: hidden;
}

/* 2. 重新定义网格布局 */
#character-album-grid {
    display: grid;
    /* 【核心】每行3个，但这次我们用calc()精确计算宽度 */
    grid-template-columns: repeat(3, calc(33.333% - 4px)); 
    gap: 6px; /* 稍微增大间隙，让calc有计算空间 */
    padding: 6px; /* 内边距和间隙保持一致 */
    box-sizing: border-box; /* 确保内边距和边框被包含在总宽度内 */
    align-content: start; /* <--- 就是加上这一行！ */
}

/* 3. 稍微缩小图片，确保它们不会撑破容器 */
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block; /* 移除图片下方的微小空隙 */
}

/* ▲▲▲ 样式修正结束 ▲▲▲ */

/* ▼▼▼ 【V6独家定制】角色手机信纸风格日记样式 ▼▼▼ */

/* 1. 【核心】重塑日记卡片，让它像一张信纸 */
#character-diary-list .character-data-item {
    background-color: #fdfaf2; /* 温暖、柔和的米白/浅黄色，模拟信纸 */
    border: 1px solid #eaddc7;  /* 淡淡的纸张边缘色 */
    border-left: 3px solid #d4bda5; /* 左侧加一条稍深的线，像装订线 */
    box-shadow: 2px 2px 6px rgba(0,0,0,0.06); /* 更柔和的阴影 */
    position: relative;
    padding: 20px 15px 15px 20px; /* 调整内边距，给“小东西”留出空间 */
    font-family: Georgia, 'Times New Roman', 'Kaiti TC', 'STKaiti', serif; /* 使用更典雅的衬线字体 */
}

/* 2. 【小东西】用伪元素在左上角添加一个精致的纸夹 */
#character-diary-list .character-data-item::before {
    content: '📎'; /* 这是一个Emoji纸夹，简单又有效 */
    position: absolute;
    top: -12px;
    left: 15px;
    font-size: 24px;
    transform: rotate(-25deg); /* 让纸夹有一个随意的角度 */
    opacity: 0.8;
}

/* 3. 【核心】重置Markdown内容的字体，确保它们继承信纸的字体 */
#character-diary-list .character-data-item .content,
#character-diary-list .character-data-item .content h1,
#character-diary-list .character-data-item .content h2,
#character-diary-list .character-data-item .content h3 {
    font-family: inherit; /* 强制继承父元素的字体 */
    color: #4a443b; /* 使用深棕色文字，更有质感 */
}

#character-diary-list .character-data-item .content p {
    margin: 0 0 12px 0;
}

/* 4. 将日期移动到右上角，像信纸的落款日期 */
#character-diary-list .character-data-item .meta {
    position: absolute;
    top: 10px;
    right: 12px;
    font-size: 11px;
    color: #ae9c82; /* 匹配信纸风格的日期颜色 */
    font-style: italic; /* 斜体更有手写感 */
    border-top: none;
    padding-top: 0;
}

/* 5. 美化删除按钮，让它更融入信纸风格 */
#character-diary-list .character-data-item .diary-delete-btn {
    background-color: transparent;
    color: #c9bbae;
    font-size: 22px;
    transition: all 0.2s ease;
}

#character-diary-list .character-data-item .diary-delete-btn:hover {
    background-color: #e44d44;
    color: white;
    transform: scale(1.1);
}

/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【全新】角色手机全APP美化样式 ▼▼▼ */

/* --- 1. 购物车样式 --- */
.character-cart-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.character-cart-item:last-child {
    border-bottom: none;
}
.cart-item-icon {
    width: 40px;
    height: 40px;
    flex-shrink: 0;
    background-color: #f0f2f5;
    border-radius: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: var(--text-secondary);
}
.cart-item-info {
    flex-grow: 1;
}
.cart-item-info .title {
    font-weight: 500;
}
.cart-item-info .store {
    font-size: 12px;
    color: var(--text-secondary);
}
.cart-item-price {
    font-weight: 600;
    font-size: 15px;
}

/* --- 2. 浏览器历史样式 --- */
.character-browser-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px 15px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: background-color 0.2s;
}
.character-browser-item:hover {
    background-color: #f9f9f9;
}
.browser-item-icon {
    font-size: 20px;
    color: var(--text-secondary);
}

/* --- 3. 银行交易明细样式 --- */
.character-bank-transaction {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.transaction-details {
    display: flex;
    align-items: center;
    gap: 12px;
}
.transaction-icon {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 18px;
    color: white;
}

/* --- 4. 行动轨迹 (时间线) 样式 --- */
.character-trajectory-list {
    padding: 20px 15px 20px 30px; /* 左侧留出时间线的空间 */
}
.character-trajectory-item {
    position: relative;
    padding-bottom: 25px;
}
/* 时间轴的竖线 */
.character-trajectory-item::before {
    content: '';
    position: absolute;
    top: 5px;
    left: -18px;
    width: 2px;
    height: 100%;
    background-color: #e0e0e0;
}
.character-trajectory-item:last-child::before {
    display: none; /* 最后一个条目没有线 */
}
/* 时间轴的圆点 */
.character-trajectory-item::after {
    content: '';
    position: absolute;
    top: 5px;
    left: -23px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: var(--accent-color);
    border: 2px solid white;
    box-shadow: 0 0 0 2px var(--accent-color);
}
.trajectory-item-content .meta {
    margin-top: 4px; /* 让时间和地点离标题近一点 */
}

/* --- 5. APP使用记录 (进度条) 样式 --- */
.character-app-usage-item {
    padding: 15px;
    border-bottom: 1px solid #f0f0f0;
}
.app-usage-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 14px;
}
.app-usage-header .name {
    font-weight: 500;
}
.app-usage-header .duration {
    color: var(--text-secondary);
}
.app-usage-bar-container {
    width: 100%;
    height: 6px;
    background-color: #e9ecef;
    border-radius: 3px;
    overflow: hidden;
}
.app-usage-bar {
    height: 100%;
    background-color: var(--accent-color);
    border-radius: 3px;
    transition: width 0.5s ease-in-out;
}
/* ▼▼▼ 【全新】后台活动设置界面样式 ▼▼▼ */
.char-list-item {
    display: flex;
    align-items: center;
    padding: 8px 5px;
    border-bottom: 1px solid #eee;
}
.char-list-item:last-child {
    border-bottom: none;
}
.char-list-item input[type="checkbox"] {
    margin-right: 10px;
    width: 18px;
    height: 18px;
}
.char-list-item .char-name {
    flex-grow: 1;
}
.char-list-item .char-freq-badge {
    font-size: 11px;
    font-weight: bold;
    padding: 3px 8px;
    border-radius: 10px;
    color: white;
}
.char-freq-badge.low { background-color: #28a745; }
.char-freq-badge.medium { background-color: #fd7e14; }
.char-freq-badge.high { background-color: #dc3545; }
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】视频通话可视化界面样式 === */

/* 1. 可视化界面的总容器，确保它能覆盖整个屏幕 */
#visual-call-interface {
    width: 100%;
    height: 100%;
    position: relative; /* 让内部元素可以相对于它定位 */
    overflow: hidden; /* 防止内容溢出 */
    background-color: #1c1c1e; /* 深色背景 */
    display: flex; /* 使用flex布局，方便内容排列 */
    flex-direction: column;
}

/* 2. 视频背景层，用于放置大小图 */
.video-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* 确保它在最底层 */
}

/* 3. 大小图的通用容器样式 */
.video-container {
    position: absolute;
    background-color: #000;
    overflow: hidden;
    transition: all 0.3s ease-in-out; /* 为切换镜头添加动画 */
}
.video-container img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 保证图片填满容器且不变形 */
}

/* 4. 大图样式 (默认占满全屏) */
#video-main-view {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* 5. 小图样式 (画中画) */
#video-pip-view {
    top: 60px; /* 距离顶部一段距离 */
    right: 15px;
    width: 100px; /* 小窗宽度 */
    height: 178px; /* 小窗高度 (保持竖屏比例) */
    border-radius: 10px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    cursor: pointer; /* 提示用户可以点击 */
}

/* 6. 聊天气泡区域 (覆盖在视频之上) */
#video-call-messages-visual {
    position: relative;
    z-index: 5; /* 层级比视频高 */
    flex-grow: 1; /* 占据除了顶部和底部栏之外的所有空间 */
    padding: 15px;
    overflow-y: auto; /* 内容多了可以滚动 */
    display: flex;
    flex-direction: column;
    gap: 15px;
    /* 关键：为了不让滚动条影响美观，把它隐藏掉 */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE 10+ */
}
#video-call-messages-visual::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera*/
}

/* ▼▼▼ 用这【一小块】代码，替换掉旧的气泡样式，实现【无模糊】效果 ▼▼▼ */

/* 7. 【精致渐变】高清透明聊天气泡 */
.visual-call-bubble {
    padding: 10px 14px;
    border-radius: 18px;
    max-width: 80%;
    line-height: 1.5;
    word-break: break-word;
    position: relative;
}

.visual-call-bubble.ai {
    /* ★ 精致黑灰色晕染效果：中间深，两边虚化 */
    background: linear-gradient(90deg, 
        rgba(25, 25, 25, 0) 0%,           /* 左边缘透明 */
        rgba(40, 40, 40, 0.5) 8%,         /* 左侧渐入 */
        rgba(55, 55, 55, 0.75) 20%,       /* 中间偏左 */
        rgba(65, 65, 65, 0.9) 50%,        /* 中心最深 */
        rgba(55, 55, 55, 0.75) 80%,       /* 中间偏右 */
        rgba(40, 40, 40, 0.5) 92%,        /* 右侧渐出 */
        rgba(25, 25, 25, 0) 100%          /* 右边缘透明 */
    );
    color: rgba(255, 255, 255, 0.95);
    align-self: flex-start; /* AI的发言靠左 */
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.25);
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
}

.visual-call-bubble.user {
    /* ★ 柔和白色渐变，不刺眼，左右边缘虚化 */
    background: linear-gradient(90deg, 
        rgba(240, 240, 240, 0) 0%,        /* 左边缘透明 */
        rgba(248, 248, 248, 0.55) 8%,     /* 左侧渐入 */
        rgba(250, 250, 250, 0.8) 20%,     /* 中间偏左 */
        rgba(253, 253, 253, 0.9) 50%,     /* 中心最亮（但不刺眼） */
        rgba(250, 250, 250, 0.8) 80%,     /* 中间偏右 */
        rgba(248, 248, 248, 0.55) 92%,    /* 右侧渐出 */
        rgba(240, 240, 240, 0) 100%       /* 右边缘透明 */
    );
    color: rgba(30, 30, 30, 0.95);
    align-self: flex-end;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.12);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* 具备语音功能的视觉模式消息气泡样式 */
.visual-call-bubble.ai[data-has-voice="true"] {
    position: relative;
    transition: all 0.3s ease;
    cursor: pointer;
}

.visual-call-bubble.ai[data-has-voice="true"]:hover {
    /* hover时中心更亮一些 */
    background: linear-gradient(90deg, 
        rgba(25, 25, 25, 0) 0%, 
        rgba(50, 50, 50, 0.6) 8%, 
        rgba(70, 70, 70, 0.85) 20%, 
        rgba(80, 80, 80, 0.95) 50%, 
        rgba(70, 70, 70, 0.85) 80%, 
        rgba(50, 50, 50, 0.6) 92%, 
        rgba(25, 25, 25, 0) 100%
    );
    box-shadow: 0 4px 14px rgba(0, 0, 0, 0.35);
    transform: scale(1.01);
}

.visual-call-bubble.ai[data-has-voice="true"]::after {
    content: "▶";
    color: rgba(255, 255, 255, 0.75);
    position: absolute;
    top: 4px;
    right: 8px;
    font-size: 11px;
    opacity: 0.6;
}

.visual-call-bubble.ai[data-has-voice="true"]:hover::after {
    opacity: 1;
    color: rgba(255, 255, 255, 0.95);
}

/* 语音播放状态样式 */
.visual-call-bubble.ai[data-has-voice="true"].playing {
    /* 播放时使用黑灰暗银色渐变 - 低调优雅 */
    background: linear-gradient(90deg, 
        rgba(40, 40, 40, 0) 0%, 
        rgba(65, 65, 70, 0.65) 8%, 
        rgba(80, 82, 88, 0.85) 20%, 
        rgba(95, 98, 105, 0.95) 50%, 
        rgba(80, 82, 88, 0.85) 80%, 
        rgba(65, 65, 70, 0.65) 92%, 
        rgba(40, 40, 40, 0) 100%
    );
    box-shadow: 0 2px 14px rgba(120, 125, 135, 0.25);
}

.visual-call-bubble.ai[data-has-voice="true"].playing::after {
    content: "||";
    color: white;
    opacity: 1;
}

.call-message-bubble.ai-speech[data-has-voice="true"].playing {
    /* 播放时使用黑灰暗银色渐变 - 低调优雅 */
    background: linear-gradient(90deg, 
        rgba(40, 40, 40, 0) 0%, 
        rgba(65, 65, 70, 0.7) 8%, 
        rgba(80, 82, 88, 0.9) 20%, 
        rgba(95, 98, 105, 1.0) 50%, 
        rgba(80, 82, 88, 0.9) 80%, 
        rgba(65, 65, 70, 0.7) 92%, 
        rgba(40, 40, 40, 0) 100%
    );
    box-shadow: 0 2px 14px rgba(120, 125, 135, 0.3);
    transform: none !important;
}

.call-message-bubble.ai-speech[data-has-voice="true"].playing::after {
    content: "||";
    color: white;
    opacity: 1;
}

.call-message-bubble.ai-speech[data-has-voice="true"].loading::after {
    display: none;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* 8. 顶部和底部栏的层级要最高 */
#visual-call-interface .video-call-top-bar,
#visual-call-interface .video-call-controls {
    z-index: 10;
}

/* 9. 新增的控制按钮图标 (使用SVG) */
.control-btn.reroll-btn {
    background-color: rgba(255,255,255,0.2);
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>');
    background-size: 50%;
}
.control-btn.switch-camera-btn {
    background-color: rgba(255,255,255,0.2);
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>');
    background-size: 50%;
}

/* 10. 挂断按钮需要一个新ID来区分 */
#hang-up-btn-visual {
    /* 样式继承自 .hangup-btn，无需额外添加 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修复版】世界书选择器列表样式 ▼▼▼ */

/* 1. 分类文件夹行样式：用gap创建固定间距，超稳定 */
.wb-category-header {
    display: flex;
    align-items: center;
    gap: 8px; /* 箭头、复选框、文字之间的固定间距 */
    padding: 10px 12px;
    cursor: pointer;
    background-color: #f0f2f5;
    font-weight: 600;
    overflow: hidden; /* 防止任何意外 */
}

/* 2. 分类文件夹里的文字样式：只负责截断，不负责布局 */
.wb-category-header > span:last-of-type {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 3. 【核心修复】为分类文件夹和书目里的复选框“解绑”全局样式！ */
.wb-category-header input[type="checkbox"],
.wb-book-container input[type="checkbox"] {
    width: auto !important; /* 让它恢复自己的天然大小，!important确保最高优先级 */
    flex-shrink: 0;         /* 防止它被压缩 */
}

/* 4. 具体书目行的样式：强制从左边开始排列，解决iOS问题 */
.wb-book-container label {
    display: flex;
    align-items: center;
    justify-content: flex-start; /* 强制所有内容从左边开始！*/
    padding: 8px 12px;
    gap: 10px; /* 复选框和文字的间距 */
    overflow: hidden;
}

/* 5. 具体书目的文字样式 */
.wb-book-container label .wb-book-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: left;
}

/* 6. 夜间模式适配 */
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e;
}

/* 7. 小箭头的样式（保持不变） */
.wb-category-header .arrow {
    font-size: 12px;
    transition: transform 0.2s ease;
}
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 8. 书籍容器的样式（保持不变） */
.wb-book-container {
    padding-left: 20px;
    max-height: 1000px;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.wb-book-container.collapsed {
    max-height: 0;
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】字体预设功能样式 ▼▼▼ */

#font-preset-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 15px; /* 卡槽之间的间距 */
}

.font-preset-slot {
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

#phone-screen.dark-mode .font-preset-slot {
    border-color: #38383a;
}

.font-preset-slot.empty {
    justify-content: center;
    align-items: center;
    min-height: 80px;
    border-style: dashed;
}

.font-preview-text {
    font-size: 22px;
    padding: 10px;
    border-radius: 8px;
    text-align: center;
    min-height: 30px;
    transition: font-family 0.3s ease;
}

#phone-screen.dark-mode .font-preview-text {
    background-color: #2c2c2e;
    color: #fff;
}

.font-preset-info {
    font-size: 14px;
    color: var(--text-secondary);
    font-weight: 500;
}

.font-preset-actions {
    display: flex;
    gap: 10px;
    width: 100%;
}

.preset-btn {
    flex: 1;
    padding: 10px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    background-color: var(--accent-color);
    color: white;
}

.preset-btn.secondary {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .preset-btn.secondary {
    background-color: #3e3e42;
    border-color: #545458;
}

.preset-btn.delete {
    background-color: #ffdde5;
    color: #ff3b30;
    border: 1px solid #ffc2d1;
    max-width: 80px; /* 让删除按钮窄一点 */
    flex: 0 0 auto;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* 【美化 V2】让后台活动设置的按钮更圆润、更立体 */
#background-activity-details .form-button-secondary {
    border-radius: 20px; /* 大幅增加圆角，形成胶囊形状 */
    padding-top: 10px;   /* 增加顶部内边距，让按钮更高 */
    padding-bottom: 10px;/* 增加底部内边距，让按钮更高 */
    font-weight: 500;    /* 字体稍微加粗一点 */
    transition: all 0.2s ease; /* 添加平滑的过渡效果 */
}

/* 为按钮添加一个微妙的点击效果 */
#background-activity-details .form-button-secondary:active {
    transform: scale(0.96); /* 点击时轻微缩小 */
    opacity: 0.8;         /* 点击时稍微变淡 */
}
/* ▼▼▼ 【全新】BGM搜索结果弹窗样式 ▼▼▼ */

/* ▼▼▼ 在这里添加下面这段新样式 ▼▼▼ */
#music-search-results-modal .modal-content {
    z-index: 220; /* 这个值比播放列表的 210 要高 */
}
/* ▲▲▲ 添加结束 ▲▲▲ */

.search-result-item {
    display: flex;
    flex-direction: column;
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

/* ▼▼▼ 【全新】BGM搜索结果弹窗样式 ▼▼▼ */

.search-result-item {
    display: flex;
    flex-direction: column;
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

.search-result-item:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

#phone-screen.dark-mode .search-result-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.search-result-item .title {
    font-weight: 500;
    font-size: 15px;
    color: var(--text-primary);
}

.search-result-item .artist {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}

.search-result-item .source {
    font-size: 10px;
    color: var(--accent-color);
    background-color: rgba(0, 123, 255, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: bold;
    margin-left: 8px;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】BGM搜索源选择弹窗样式 ▼▼▼ */
#music-source-selector-modal .modal-body label {
    font-size: 16px;
    display: flex;
    align-items: center;
    gap: 10px;
}
#music-source-selector-modal .modal-body input[type="radio"] {
    width: 18px;
    height: 18px;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 统一结算弹窗美化层级样式 ▼▼▼ */
#checkout-card {
    position: relative;
    transition: all 0.3s ease;
}


/* ▲▲▲ 统一结算弹窗美化层级样式结束 ▲▲▲ */
/* ▼▼▼ 用这整块【布局微调版】样式，替换掉上一次的旧样式 ▼▼▼ */

/* 1. 闪烁动画 (保持不变) */
@keyframes flash-char {
    0%, 100% { opacity: 1; transform: scale(1); box-shadow: 0 0 3px rgba(255,192,203, 0); }
    50% { opacity: 0.8; transform: scale(1.08); box-shadow: 0 0 12px rgba(255,192,203, 0.9); }
}
@keyframes flash-user {
    0%, 100% { opacity: 1; transform: scale(1); box-shadow: 0 0 3px rgba(173,216,230, 0); }
    50% { opacity: 0.8; transform: scale(1.08); box-shadow: 0 0 12px rgba(173,216,230, 0.9); }
}

/* 2. 【核心修改】调整头像容器的下边距 */
#music-avatars-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 8px; /* <<<< 从 25px 减小到 8px，让它和下面的文字更近 */
    position: relative;
    z-index: 5;
}

/* 3. 单个头像样式 (保持不变) */
#music-avatars-container img {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

/* 4. 分开闪烁动画 (保持不变) */
#music-avatars-container.flashing #music-char-avatar {
    animation: flash-char 2.2s infinite ease-in-out;
}
#music-avatars-container.flashing #music-user-avatar {
    animation: flash-user 2.2s infinite ease-in-out 0.3s;
}

/* 5. 心电图样式 (保持不变) */
#heartbeat-line {
    width: 80px;
    height: 30px;
    overflow: visible;
    margin: 0 -15px;
    opacity: 0;
    transition: opacity 0.5s;
}
#music-avatars-container.flashing #heartbeat-line {
    opacity: 1;
}
.heartbeat-path {
    stroke: #FFC0CB;
    stroke-width: 1.5;
    fill: none;
    stroke-dasharray: 100;
    stroke-dashoffset: 100;
    animation: draw-line 2.2s infinite linear;
    filter: drop-shadow(0 0 3px #FFC0CB); 
}
.heartbeat-heart {
    display: none;
}
@keyframes draw-line {
    to { stroke-dashoffset: 0; }
}

/* 6. 【核心修改】调整“一起听了”文字的样式和边距 */
#music-time-counter {
    margin-bottom: 20px; /* <<<< 现在由它来负责和下面的封面拉开距离 */
    font-size: 11px;
    color: #666; /* 颜色稍微加深一点 */
    text-align: center;
}

/* 7. 唱片旋转动画 (保持不变) */
@keyframes spin-record {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* 8. 封面和歌词的切换容器 (保持不变) */
#music-display-area {
    width: 192px;
    height: 192px;
    margin-bottom: 15px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: transform 0.3s ease;
}
#music-display-area:active {
    transform: scale(0.98);
}

/* 9. 歌曲封面 (保持不变) */
#music-album-cover {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: block;
}
#music-album-cover.rotating {
    animation: spin-record 10s linear infinite;
}
#music-album-cover.paused {
    animation-play-state: paused;
}

/* 10. 其他样式 (保持不变) */
#music-lyrics-container { display: none; }
#music-display-area.show-lyrics #music-album-cover { display: none; }
#music-display-area.show-lyrics #music-lyrics-container { display: block; }
#music-player-song-title { margin-bottom: 2px; }
#music-player-artist { margin-bottom: 10px; }
.music-player-window { min-height: 480px; }

/* ▲▲▲ 布局微调版样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修复版】提升搜索相关弹窗的层级 ▼▼▼ */
#music-source-selector-modal,
#custom-modal-overlay {
    z-index: 250 !important; /* 这个值必须高于播放列表(210)，!important确保它拥有最高优先级 */
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 步骤 1：把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* --- 1. 隐藏旧的主屏幕元素 --- */
/* 我们不再需要旧的锁屏时钟和图标网格了，新的布局会完全取代它们 */
#home-screen #clock-container,
#home-screen .app-grid {
    display: none !important;
}

/* --- 2. 【核心】重新定义主屏幕布局 --- */
/* 
   这将把你的主屏幕从一个简单的垂直列表，变成一个撑满全屏、
   使用Flexbox布局的强大容器，为新的“桌面式”布局打下基础。
*/
#home-screen {
    /* 使用一个漂亮的线性渐变作为默认背景，当然你可以在“外观设置”里随时换掉它 */
    background: linear-gradient(135deg, #2c2c2c, #c0c0c0);
    background-size: cover;
    background-position: center;
    
    /* 适配iPhone刘海和底部安全区 */
    padding-top: calc(20px + env(safe-area-inset-top));
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
    
    /* 使用Flexbox让内容区和Dock栏上下分离 */
    display: flex;
    flex-direction: column;
    justify-content: space-between; 
    align-items: center;
    height: 100%; /* 确保它撑满屏幕 */
}

/* --- 3. 中间主要内容区 (个人资料卡 + 小组件 + App图标) --- */
#main-content-area {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 30px; /* 卡片和下方图标的间距 */
    align-items: center;
    margin-top: 20px; /* 距离屏幕顶部一点距离 */
}

/* --- 4. 个人资料卡片 (这是视觉核心) --- */

/* 4a. 卡片外层容器：这是所有内部元素定位的“锚点” */
#profile-widget {
    position: relative; /* 关键：让内部的头像和伪元素可以相对于它进行绝对定位 */
    width: 100%;
    max-width: 380px;
    flex-shrink: 0;
}

/* 4b. 背景头图：只给顶部设置圆角 */
#profile-banner-img {
    display: block; 
    width: 100%;
    height: 150px;
    object-fit: cover;
    border-radius: 24px 24px 0 0; /* 只给顶部设置圆角 */
    position: relative;
    z-index: 1; /* 层级1：在最下方 */
}

/* 4c. 头像容器：精确定位，使其中心线与头图底部对齐 */
#profile-widget .profile-avatar-container {
    position: absolute;
    top: 80px; /* 从顶部向下偏移，让它一半在头图上，一半在下面 */
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: white; /* 白色背景板，让头像更突出 */
    padding: 4px; /* 白色边框的效果 */
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 3; /* 层级3：最高层，压住一切 */
}

#profile-avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* 4d. 白色信息卡片：使用负外边距实现无缝拼接 */
#profile-widget .profile-info {
  /* 【修改后】白色到透明的渐变背景，并加上一层柔和的阴影 */
background: linear-gradient(to bottom, rgba(255, 255, 255, 0.85) 20%, rgba(255, 255, 255, 0));
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    border-radius: 24px;
    
    /* 核心魔法：使用负外边距，将卡片向上移动，与头图和头像重叠 */
    margin-top: -24px; 
    
    /* 同时，为上移的头像留出精确的空间，避免文字压住头像 */
    padding-top: 54px; /* 头像半径(40px) + 额外间距(14px) */
    
    min-height: 120px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding-left: 15px;
    padding-right: 15px;
    padding-bottom: 15px;
    text-align: center;
    color: #1c1c1e;
    position: relative;
    z-index: 2; /* 层级2：在头图之上，但在头像之下 */
}

/* 4e. 个人资料内部的文字样式 */
#profile-username { font-size: 18px; font-weight: 600; margin: 0 0 2px 0; }
#profile-sub-username { font-size: 13px; color: #8a8a8a; margin: 0 0 10px 0; }
#profile-bio { font-size: 14px; margin: 0 0 12px 0; color: #333; }
#profile-location {
    font-size: 12px; color: #8a8a8a; margin: 0 auto; display: inline-flex;
    align-items: center; gap: 4px; background-color: rgba(0,0,0,0.05);
    padding: 3px 9px; border-radius: 10px;
}

/* --- 5. 桌面式布局 (小组件 + App图标) --- */
#desktop-layout {
    display: grid; /* 使用Grid布局，轻松实现两列 */
    grid-template-columns: 1fr 1.1fr; /* 左窄右宽的两列 */
    gap: 12px; /* 从20px减少到12px，缩短胶片组件与应用图标的距离 */
    width: 100%;
    align-items: start;
}
#desktop-widget-column {
    display: flex;
    flex-direction: row;
    justify-content: space-between; /* 【核心修改】将 space-around 改为 space-between */
    align-items: start;
    width: 100%;
}

/* 右侧App图标容器 */
#desktop-app-container {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 两列图标 */
    grid-template-rows: 1fr 1fr; /* 两行图标 */
    gap: 5px; /* 进一步缩短列间距到5px */
    align-content: center;
    justify-content: center;
    max-width: 200px;
    margin: 0 auto;
}
.desktop-app-icon {
    display: flex; flex-direction: column; align-items: center; gap: 6px; cursor: pointer; text-align: center; /* 减少gap从8px到6px */
}
.icon-bg-desktop {
    width: 42px; height: 42px; /* 进一步缩小到42px */
    border-radius: 10px; /* 调整圆角到10px */
    background-color: #f0f2f5; 
    display: flex; /* 添加flex布局 */
    justify-content: center; 
    align-items: center; /* 添加垂直居中 */
    box-shadow: 0 4px 10px rgba(0,0,0,0.1); 
    transition: transform 0.2s ease; 
    overflow: hidden;
}
.icon-bg-desktop img { width: 100%; height: 100%; object-fit: cover; border-radius: 0; }
.desktop-app-icon .label { color: #333; font-size: 11px; font-weight: 500; } /* 进一步缩小字体到11px */
.desktop-app-icon:active .icon-bg-desktop { transform: scale(0.9); }


/* --- 6. 底部 Dock 栏 --- */
#desktop-dock {
    background-color: rgba(255, 255, 255, 0.15); /* 玻璃拟态背景 */
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 15px 25px;
    display: flex;
    justify-content: center;
    gap: 30px;
    width: fit-content; /* 宽度自适应内容 */
    flex-shrink: 0;
}

/* --- 7. 【核心功能】为可编辑元素添加视觉反馈 --- */
.editable-text, .editable-image {
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

/* 鼠标悬停时，显示一个半透明的虚线外框，并轻微变暗，提示用户这里可以点 */
.editable-text:hover, .editable-image:hover {
    outline: 2px dashed rgba(0, 0, 0, 0.4);
    opacity: 0.85;
    border-radius: 4px; /* 让外框也有一点圆角 */
}

/* --- 8. 【锁屏兼容】让锁屏和主屏幕可以堆叠 --- */
#lock-screen, #home-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
#lock-screen {
    z-index: 999; /* 确保锁屏在最上层 */
}

/* ▼▼▼ 双页面桌面分页系统样式 ▼▼▼ */

/* 1. 让主屏幕成为Flex容器，方向改为垂直，为翻页做准备 */
#home-screen {
    flex-direction: column;
    padding: 0; /* 移除旧的内边距，由内部页面自己控制 */
}

/* 2. 页面容器，负责横向排列所有页面 */
#home-screen-pages-container {
    flex-grow: 1; /* 占据除了Dock栏和分页指示器外的所有空间 */
    width: 100%;
    overflow: hidden; /* 隐藏横向滚动条 */
    position: relative;
}

#home-screen-pages {
    display: flex;
    width: 200%; /* 假设有两页，宽度设为200% */
    height: 100%;
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); /* 平滑的翻页动画 */
}

/* 3. 单个页面的样式 */
.home-screen-page {
    width: 50%; /* 每页占据一半宽度 */
    height: 100%;
    padding: 20px;
    padding-top: calc(20px + env(safe-area-inset-top));
    padding-bottom: 0; /* 底部由分页指示器和dock控制 */
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* 4. 分页指示器 (小圆点) */
#home-screen-pagination {
    display: flex;
    justify-content: center;
    gap: 8px;
    padding: 10px 0;
    flex-shrink: 0;
}

.pagination-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.4);
    transition: all 0.3s ease;
}

.pagination-dot.active {
    background-color: white;
    transform: scale(1.1);
}

/* 5. 第二页的内容区域 */
#page-2-content-area {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
}

#page-2-placeholder {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

/* 6. 确保dock栏在分页系统之外，底部固定 */
#desktop-dock {
    flex-shrink: 0;
    margin-bottom: calc(10px + env(safe-area-inset-bottom));
}

/* ▲▲▲ 双页面桌面分页系统样式结束 ▲▲▲ */

/* ▼▼▼ 这是新增的桌面小组件样式 ▼▼▼ */

/* 单个小组件的总容器 */
.custom-widget-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px; /* 各个元素之间的垂直间距 */
}

.widget-bubble {
    position: relative;
    background-color: rgba(255, 255, 255, 0.9);
    color: #333;
    padding: 8px 12px;
    border-radius: 20px; /* 【核心修改】增加圆角，实现胶囊感 */
    font-size: 13px;
    font-weight: 500;
    /* 【核心修改】移除 min-width，让宽度自适应内容 */
    text-align: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}


/* 用伪元素给气泡加一个小尾巴，指向下面的圆形图片 */
.widget-bubble::after {
    content: '';
    position: absolute;
    bottom: -6px; /* 尾巴在气泡下方 */
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px 6px 0;
    border-style: solid;
    border-color: rgba(255, 255, 255, 0.9) transparent transparent transparent;
}

.widget-circle-uploader {
    width: 65px; /* 从 80px 缩小 */
    height: 65px; /* 从 80px 缩小 */
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    padding: 3px;
    background-color: transparent; /* 【核心修改】将背景色改为透明 */ 
    box-sizing: border-box;
}


/* 这是替换后的第二块 */
.widget-circle-uploader img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%; /* 【核心】让图片也变成圆形，完美适应内边距 */
}


/* 下方的透明文字区域 */
.widget-subtext {
    background: transparent;
    border: none;
    color:  #333;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5); /* 加一点文字阴影更清晰 */
    font-size: 13px;
    font-weight: 500;
    text-align: center;
}

/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 【V3最终美化版】主屏幕美化预设功能样式 ▼▼▼ */
.preset-manager-container {
    width: 100%;
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid var(--border-color);
}
#phone-screen.dark-mode .preset-manager-container {
    border-top-color: #3a3a3c;
}
.preset-manager-container .form-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.preset-manager-controls {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 【核心】2x2 网格布局 */
    gap: 12px; /* 按钮间距 */
    width: 100%;
}
.preset-btn-capsule {
    padding: 12px 15px; /* 增加垂直内边距，让按钮更高更可爱 */
    border: none;
    border-radius: 25px; /* 更大的圆角，胶囊感更强 */
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 6px rgba(0,0,0,0.08); /* 增加一点立体阴影 */
}
.preset-btn-capsule:active {
    transform: scale(0.96);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.preset-btn-capsule:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
    background-color: #e9ecef !important; /* 禁用时统一用灰色 */
    color: #adb5bd !important;
    border-color: #dee2e6 !important;
}
#phone-screen.dark-mode .preset-btn-capsule:disabled {
    background-color: #3a3a3c !important;
    color: #545458 !important;
}
.preset-btn-apply {
    background-color: var(--accent-color); /* 应用按钮使用主题色 */
    color: white;
    grid-column: 1 / -1; /* 【核心】让应用按钮独占一行，更突出 */
}
.preset-btn-save {
    background-color: #4cd964; /* 保存用绿色，代表创建 */
    color: white;
}
.preset-btn-secondary {
    background-color: #f8f9fa;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .preset-btn-secondary {
    background-color: #3a3a3c;
    border-color: #545458;
}
.preset-btn-delete {
    background-color: #ffdde5;
    color: #ff3b30;
}
#phone-screen.dark-mode .preset-btn-delete {
    background-color: #5c2b2b;
    color: #ff8a80;
}
/* ▲▲▲ 样式粘贴结束 ▲▲▲ */



/* ▼▼▼ 【V6最终修复版】夜间模式终极适配 (已修复所有页面适配问题) ▼▼▼ */

/* 核心：当 #phone-screen 拥有 .dark-mode 类时，激活以下所有样式 */

/* 1. 全局重新定义颜色变量 */
#phone-screen.dark-mode {
  --secondary-bg: #1c1c1e;
  --border-color: #38383a;
  --text-primary: #ffffff;
  --text-secondary: #8e8e93;
  --status-bar-text-color: #ffffff;
}

/* 2. 【基础】为所有屏幕和主要容器设置基础深色背景 */
#phone-screen.dark-mode,
#phone-screen.dark-mode .screen,
#phone-screen.dark-mode #chat-list,
#phone-screen.dark-mode #world-book-list,
#phone-screen.dark-mode .list-container,
#phone-screen.dark-mode .form-container,
#phone-screen.dark-mode #chat-messages {
    background-color: #000000 !important;
}

/* 3. 【主屏幕】专属样式 (从被删除的代码中恢复并整合) */
#phone-screen.dark-mode #home-screen {
    background: #111827; /* 深蓝色背景 */
}
#phone-screen.dark-mode #desktop-dock {
    background-color: rgba(55, 65, 81, 0.5); /* Dock栏深灰色玻璃效果 */
}
#phone-screen.dark-mode .desktop-app-icon .label,
#phone-screen.dark-mode .widget-subtext {
    color: #e5e7eb; /* 桌面文字变为浅灰色 */
    text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* 加强阴影 */
}
#phone-screen.dark-mode #profile-widget .profile-info {
    background: linear-gradient(to bottom, rgba(28, 28, 30, 0.85) 20%, rgba(28, 28, 30, 0)); /* 信息卡片深灰色渐变 */
    color: #f9fafb;
}
#phone-screen.dark-mode #profile-username,
#phone-screen.dark-mode #profile-bio,
#phone-screen.dark-mode #profile-location span {
    color: #f9fafb; /* 信息卡片主文字白色 */
}
#phone-screen.dark-mode #profile-sub-username,
#phone-screen.dark-mode #profile-location {
    color: #9ca3af; /* 信息卡片次要文字灰色 */
}
#phone-screen.dark-mode #profile-location {
    background-color: rgba(255,255,255,0.1); /* 地点背景变亮 */
}
#phone-screen.dark-mode .widget-bubble {
    background-color: rgba(55, 65, 81, 0.9); /* 小组件气泡深灰色 */
    color: #e5e7eb; /* 小组件文字浅灰色 */
}
#phone-screen.dark-mode .widget-bubble::after {
    border-top-color: rgba(55, 65, 81, 0.9); /* 小尾巴颜色同步 */
}

/* 4. 【修复】适配所有页面的头部Header */
#phone-screen.dark-mode .header,
#phone-screen.dark-mode .qzone-header {
    background-color: rgba(28, 28, 30, 0.85) !important;
    border-bottom-color: var(--border-color) !important;
    color: var(--text-primary) !important; 
}

/* 5. 【修复】适配所有通用组件 (弹窗、输入框等) */
#phone-screen.dark-mode #chat-input-area,
#phone-screen.dark-mode #chat-list-bottom-nav {
    background-color: rgba(28, 28, 30, 0.85);
    border-top-color: var(--border-color);
}
#phone-screen.dark-mode #chat-input {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
}
#phone-screen.dark-mode .modal-content,
#phone-screen.dark-mode #custom-modal {
    background-color: #2c2c2e;
}
#phone-screen.dark-mode .modal-header, 
#phone-screen.dark-mode .modal-footer,
#phone-screen.dark-mode .custom-modal-footer {
    border-color: var(--border-color);
}
#phone-screen.dark-mode .form-group input,
#phone-screen.dark-mode .form-group select,
#phone-screen.dark-mode .form-group textarea {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
    border-color: var(--border-color);
}
#phone-screen.dark-mode .list-item,
#phone-screen.dark-mode .chat-list-item-swipe-container:not(:last-child) {
    border-bottom-color: var(--border-color);
}
#phone-screen.dark-mode .list-item:hover,
#phone-screen.dark-mode .chat-list-item:hover {
    background-color: #2c2c2e;
}

/* 暗色模式下的全局世界书开关样式 */
#phone-screen.dark-mode .global-wb-switch .switch-track {
    background-color: #555;
}

#phone-screen.dark-mode .global-wb-switch.enabled .switch-track {
    background-color: #666666;
}

/* 6. 【解决】字体预设 & 外观设置页面深度适配 */
#phone-screen.dark-mode #font-settings-screen,
#phone-screen.dark-mode #wallpaper-screen {
    background-color: #000000;
}
#phone-screen.dark-mode .font-preset-slot,
#phone-screen.dark-mode #font-preview,
#phone-screen.dark-mode #wallpaper-preview {
    background-color: var(--secondary-bg);
    border-color: var(--border-color);
}
#phone-screen.dark-mode .preset-btn.secondary {
    background-color: #3e3e42;
    border-color: #545458;
}

/* 7. 【解决】“查手机”功能所有内部页面深度适配 */
#phone-screen.dark-mode #character-phone-container {
    background-color: #000000;
}
#phone-screen.dark-mode .character-phone-frame {
    background-color: #111;
}
#phone-screen.dark-mode .character-phone-inner-screen,
#phone-screen.dark-mode .character-phone-page {
    background-color: #000000;
}
#phone-screen.dark-mode .character-phone-header {
    background-color: rgba(28, 28, 30, 0.85) !important;
    border-bottom: 1px solid #38383a !important;
}
#phone-screen.dark-mode #character-app-grid .label {
    color: #e5e7eb;
}
#phone-screen.dark-mode .character-chat-list .chat-list-item:hover {
    background-color: #1c1c1e;
}
#phone-screen.dark-mode #character-chat-history-messages {
    background-color: #0e0e0e !important;
}
#phone-screen.dark-mode .character-chat-bubble.received {
    background-color: #2c2c2e;
}
#phone-screen.dark-mode .character-data-item,
#phone-screen.dark-mode .character-bank-transaction,
#phone-screen.dark-mode .character-cart-item,
#phone-screen.dark-mode .character-browser-item {
    background-color: #1c1c1e;
    border-color: #38383a;
}
#phone-screen.dark-mode .character-data-item .title,
#phone-screen.dark-mode .character-data-item .content,
#phone-screen.dark-mode .cart-item-price {
    color: var(--text-primary);
}
#phone-screen.dark-mode .character-bank-balance-card {
    background: linear-gradient(135deg, #3a3a3c, #1c1c1e);
}
#phone-screen.dark-mode #character-diary-list .character-data-item {
    background-color: #1a1510;
    border-color: #4a443b;
    border-left-color: #8c7d6b;
}
#phone-screen.dark-mode #character-select-item .name {
    color: #80CBC4 !important; /* 柔和的青色 */
}

/* 8. 【新增】修复聊天列表分组标题的背景色 */
#phone-screen.dark-mode .chat-group-header {
    background-color: #1c1c1e;
}
#phone-screen.dark-mode .chat-list-item-content.pinned {
    background-color: #3a3a3c;
}

/* ▲▲▲ CSS 代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 步骤 1.1：将这整块【终极修复版】CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 核心修复：使用 !important 强制提升优先级，覆盖掉所有捣乱的内联样式 */

/* 1. 为所有需要适配的屏幕强制设置纯黑背景 */
#phone-screen.dark-mode #wallpaper-screen,
#phone-screen.dark-mode #font-settings-screen,
#phone-screen.dark-mode #api-settings-screen,
#phone-screen.dark-mode #character-selection-screen,
#phone-screen.dark-mode #world-book-screen,
#phone-screen.dark-mode #world-book-editor-screen,
#phone-screen.dark-mode .form-container, /* 确保所有表单容器也适配 */
#phone-screen.dark-mode .list-container { /* 确保所有列表容器也适配 */
    background-color: #000000 !important;
}

/* 2. 为“查手机”内部的所有页面强制设置纯黑背景 */
#phone-screen.dark-mode .character-phone-inner-screen,
#phone-screen.dark-mode .character-phone-page {
    background-color: #000000 !important;
}
#phone-screen.dark-mode #character-chat-history-messages {
    background-color: #0e0e0e !important; /* 聊天记录用深灰色 */
}

/* 3. 修复页面内部组件的背景色 */
#phone-screen.dark-mode #font-preview,
#phone-screen.dark-mode #wallpaper-preview {
    background-color: #1c1c1e !important;
    border-color: #38383a !important;
}

/* 4. 修复“查手机”里对方的聊天气泡颜色 */
#phone-screen.dark-mode .character-chat-bubble.received {
    background-color: #2c2c2e !important;
}
/* ▼▼▼ 【最终修复版】提升所有弹窗的层级 ▼▼▼ */
#music-source-selector-modal,
#music-search-results-modal {
    z-index: 250 !important; /* 这个值高于播放列表(210)，!important确保它拥有最高优先级 */
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* 【全新美化版】通用操作菜单按钮 */
#preset-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none; /* 移除边框 */
    border-radius: 12px; /* 【核心】设置圆角 */
    padding: 14px;
    font-size: 16px; /* 字体稍微缩小一点，更精致 */
    font-weight: 500;
    margin-bottom: 8px; /* 按钮之间的垂直间距 */
    background-color: #f0f0f0; /* 统一的浅灰色背景 */
    color: var(--text-primary);
    transition: background-color 0.2s, transform 0.1s; /* 添加动画 */
}

/* 鼠标悬停和点击效果 */
#preset-actions-modal .custom-modal-footer button:hover {
    background-color: #e0e0e0;
}
#preset-actions-modal .custom-modal-footer button:active {
    transform: scale(0.98); /* 点击时轻微缩小 */
}

/* 单独美化“删除”按钮 */
#preset-actions-modal .custom-modal-footer button.btn-danger {
    background-color: #ffe5e5;
    color: #ff3b30;
}
#preset-actions-modal .custom-modal-footer button.btn-danger:hover {
    background-color: #ffcccc;
}

/* 美化“取消”按钮 */
#preset-actions-modal .custom-modal-footer button:last-child {
    background-color: #e9ecef;
    margin-top: 4px; /* 和上面的按钮稍微拉开一点距离 */
}
#preset-actions-modal .custom-modal-footer button:last-child:hover {
    background-color: #dcdfe3;
}

/* 移除按钮之间的分割线 */
#preset-actions-modal .custom-modal-footer button {
    border-bottom: none !important;
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* 【核心修正】提升通用操作菜单的层级，确保它能覆盖播放列表 */
#preset-actions-modal {
    z-index: 220; /* 这个值比播放列表(210)更高，就不会被挡住了 */
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为“查手机”内容添加的删除按钮样式 ▼▼▼ */
.character-data-item, .character-cart-item, .character-browser-item, .character-bank-transaction, .character-trajectory-item, .character-app-usage-item, .character-album-item {
    position: relative; /* 让删除按钮可以相对于它定位 */
    padding-right: 35px; /* 在右边给删除按钮留出位置 */
}

.item-delete-btn {
    position: absolute;
    top: 50%;
    right: 10px;
    transform: translateY(-50%);
    width: 24px;
    height: 24px;
    background-color: #f0f0f0;
    color: #888;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    transition: all 0.2s ease;
}

.item-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】角色手机微信消息删除按钮样式 ▼▼▼ */
.character-chat-bubble-container {
    position: relative; /* 让删除按钮可以相对于它定位 */
}

.message-delete-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.1);
    color: #555;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    opacity: 0; /* 默认隐藏 */
    transition: all 0.2s ease;
}

.character-chat-bubble-container:hover .message-delete-btn {
    opacity: 1; /* 鼠标悬停时显示 */
}

.message-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}

/* 根据消息是左是右，调整删除按钮的位置 */
.character-chat-bubble-container.sent .message-delete-btn {
    left: -28px;
}
.character-chat-bubble-container.received .message-delete-btn {
    right: -28px;
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */

/* ▲▲▲ CSS 粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新添加】强制修正所有设置页面的底部安全区 ▼▼▼ */
#font-settings-screen .form-container,
#wallpaper-screen .form-container,
#api-settings-screen .form-container,
#css-editor-screen .form-container {
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
}
/* ▲▲▲ 添加结束 ▲▲▲ */


/* ▼▼▼ 【全新】iOS风格的滑动开关样式 ▼▼▼ */

.toggle-switch-label {
    display: flex;
    align-items: center;
    justify-content: space-between; /* 让文字和开关两端对齐 */
    cursor: pointer;
    user-select: none;
    width: 100%;
    padding: 10px 0; /* 增加一点上下间距 */
    margin-bottom: 0 !important; /* 覆盖form-group label的margin-bottom */
}

.toggle-switch-text {
    font-weight: 500;
    color: var(--text-primary);
    flex: 1; /* 让文本区域占据剩余空间 */
}

/* 修复群聊后台实时活动开关内的p标签布局问题 */
.toggle-switch-text p {
    margin: 5px 0 0 0; /* 重置p标签的margin，避免影响flex布局 */
    display: block; /* 确保p标签正常显示 */
}

/* 确保包含群聊后台实时活动开关的form-group不会影响整体布局 */
#group-background-activity-group {
    position: relative; /* 确保定位正常 */
    overflow: hidden; /* 防止内容溢出 */
}

#group-background-activity-group .toggle-switch-label {
    align-items: flex-start; /* 让开关和文字顶部对齐，而不是居中对齐 */
}

/* 确保模态框内容不会因为开关变化而移动 */
#chat-settings-modal .modal-body {
    position: relative;
    overflow-x: hidden; /* 防止水平滚动 */
}

/* 修复群聊后台实时活动开关的间隔设置区域动态显示问题 */
#group-background-interval-settings {
    transition: none !important; /* 移除任何过渡动画 */
    overflow: hidden; /* 防止内容溢出 */
}

/* 确保开关切换时不会影响整体布局 */
#group-background-activity-group .toggle-switch-label {
    min-height: 60px; /* 给开关区域设置一个最小高度，防止布局跳动 */
}

/* 隐藏原始的 checkbox */
.toggle-switch-label input[type="checkbox"] {
    opacity: 0;
    width: 0;
    height: 0;
    position: absolute;
}

/* 开关的轨道 */
.toggle-switch-slider {
    position: relative;
    display: inline-block;
    width: 51px;
    height: 31px;
    background-color: #e9e9eb;
    border-radius: 34px;
    transition: background-color 0.2s;
    flex-shrink: 0; /* 防止被压缩 */
}

/* 开关的滑块 (那个白色圆点) */
.toggle-switch-slider::before {
    content: "";
    position: absolute;
    height: 27px;
    width: 27px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    border-radius: 50%;
    transition: transform 0.2s;
    box-shadow: 0 1px 3px rgba(0,0,0,0.15);
}

/* 当 checkbox 被选中时，改变轨道的颜色 */
.toggle-switch-label input:checked + .toggle-switch-slider {
    background-color: #34c759; /* iOS 风格的绿色 */
}

/* 当 checkbox 被选中时，移动滑块 */
.toggle-switch-label input:checked + .toggle-switch-slider::before {
    transform: translateX(20px);
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 这是为你新增的颜色样式 ▼▼▼ */

/* 1. 把时间的颜色强制设置为黑色 */
#status-bar-time {
    color: #000000 !important; /* !important 确保它优先级最高 */
}

/* 2. 把电池容器内的所有东西（图标边框、电量条、百分比文字）都设置为绿色 */
#status-bar-battery {
    color: #4CAF50 !important; /* 这是一个很好看的绿色 */
}

/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 这是步骤1需要粘贴的新样式 ▼▼▼ */

/* 让每一条评论都变成可点击的 */
.comment-item {
    cursor: pointer; /* 鼠标悬停时显示为小手形状 */
    transition: background-color 0.2s; /* 添加一个平滑的背景色过渡动画 */
    border-radius: 4px; /* 给一点点圆角，更好看 */
    padding: 2px 5px; /* 增加一点内边距，让点击区域更大 */
    margin: 0 -5px; /* 把上面的内边距抵消掉，保持对齐 */
}
.comment-item:hover {
    background-color: #f0f2f5; /* 鼠标放上去时，给一个淡淡的背景色 */
}
#phone-screen.dark-mode .comment-item:hover {
    background-color: #2c2c2e; /* 夜间模式下的悬停颜色 */
}

/* “回复”这两个字的样式 */
.comment-item .reply-text {
    color: var(--text-secondary);
    margin: 0 4px; /* 和两边的名字拉开一点距离 */
}

/* 被回复者的名字样式 */
.comment-item .reply-target-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px;
}
/* ▼▼▼ 【全新】聊天记录搜索功能样式 ▼▼▼ */

/* 搜索结果列表 */
#chat-search-results-list {
    flex-grow: 1; /* 占据剩余所有空间 */
    overflow-y: auto; /* 内容多了可以滚动 */
}

/* 单条搜索结果的样式 */
.search-result-item {
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    display: flex;
    gap: 12px; /* 头像和内容的间距 */
    align-items: flex-start;
}
.search-result-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode .search-result-item:hover {
    background-color: #2c2c2e;
}

/* 结果中的头像 */
.search-result-item .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    flex-shrink: 0;
}

/* 结果右侧信息（名字、时间、内容） */
.search-result-info {
    display: flex;
    flex-direction: column;
    gap: 4px; /* 信息内部的垂直间距 */
    overflow: hidden; /* 防止内容过长溢出 */
}

/* 名字和时间的容器 */
.search-result-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.search-result-meta .name {
    font-weight: 600;
    color: var(--text-primary);
    font-size: 14px;
}

/* 消息内容 */
.search-result-content {
    font-size: 14px;
    line-height: 1.5;
    word-break: break-all; /* 确保长文本能换行 */
}

/* 【核心】关键词高亮样式 */
.highlight {
    background-color: #FFDE5C; /* 亮黄色背景 */
    color: #5D4037; /* 深棕色文字，对比更清晰 */
    font-weight: bold;
    padding: 1px 3px;
    border-radius: 3px;
}

/* 跳转后消息的闪烁动画 */
@keyframes flash-highlight {
    0% { background-color: transparent; }
    25% { background-color: rgba(255, 222, 92, 0.7); }
    100% { background-color: transparent; }
}
.message-bubble.flash {
    animation: flash-highlight 1.5s ease-out;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修复】解决搜索结果看不见的问题 ▼▼▼ */
#chat-search-screen .form-container {
    padding-bottom: 20px; /* 给底部一点空间 */
}

#search-results-list {
    flex-grow: 1; /* 核心：让结果列表占据所有剩余的垂直空间 */
    overflow-y: auto; /* 核心：如果结果太多，让它自己出现滚动条 */
    min-height: 0; /* 一个神奇的CSS属性，用于解决flex布局下的溢出问题 */
    border-top: 1px solid var(--border-color); /* 在结果和按钮之间加一条分割线，更美观 */
    margin-top: 15px; /* 和上面的按钮拉开距离 */
    padding-top: 10px; /* 列表顶部的内边距 */
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 把这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 统一样式，让图标和文字按钮对齐 */
#music-playlist-panel .playlist-header .panel-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

/* ▼▼▼ 用这块新代码替换旧的垃圾桶样式 ▼▼▼ */

/* 设置垃圾桶图标的默认样式 */
#delete-expired-songs-btn svg {
    color: inherit; /* 核心修改1: 平时颜色继承父元素，和"本地"等文字颜色一样，保持低调 */
    transition: color 0.2s, transform 0.2s; /* 添加transform过渡效果 */
    transform: translateY(3px); /* 核心修改2: 让图标整体下移3像素，视觉上更对齐 */
}

/* 设置鼠标悬停/点击时的样式 */
#delete-expired-songs-btn:hover svg,
#delete-expired-songs-btn:active svg {
    color: #ff3b30; /* 核心修改3: 鼠标放上去或点击时，才变为醒目的红色 */
}

/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* 【核心】专门为角色手机里的日记删除按钮，重新定义位置 */
#character-diary-list .character-data-item .item-delete-btn {
    top: auto;         /* 解除顶部的定位 */
    right: auto;       /* 解除右侧的定位 */
    bottom: 8px;       /* 定位到距离底部8像素 */
    left: 8px;         /* 定位到距离左侧8像素 */
    opacity: 0;        /* 保持默认隐藏 */
    transition: opacity 0.2s ease; /* 保持淡入淡出动画 */
}

/* 【美化】鼠标悬停在整张日记卡片上时，才显示这个按钮 */
#character-diary-list .character-data-item:hover .item-delete-btn {
    opacity: 1;
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】心声功能样式 ▼▼▼ */

/* 1. 跳动的心动画 */
@keyframes heartbeat {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}
#char-heart-btn svg {
    animation: heartbeat 1.5s infinite ease-in-out;
}

/* 2. 心声面板主内容样式 */
#inner-voice-avatar-wrapper::after {
    content: '';
    position: absolute;
    top: -3px;
    left: -3px;
    right: -3px;
    bottom: -3px;
    border: 1.5px solid #ffc1cc; /* 粉色的轮廓线 */
    border-radius: 50%;
    pointer-events: none; /* 让它不影响点击 */
}

#inner-voice-content-area p {
    white-space: pre-wrap; /* 让换行符和空格生效 */
    word-break: break-word; /* 防止长单词溢出 */
}

/* 3. 历史记录面板样式 */
.inner-voice-history-item {
    background-color: #fff;
    margin: 10px;
    padding: 12px;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
}
.history-item-timestamp {
    font-size: 11px;
    color: #999;
    border-bottom: 1px solid #eee;
    padding-bottom: 8px;
    margin-bottom: 8px;
}
.history-item-content p {
    margin: 0 0 8px 0;
    font-size: 13px;
    line-height: 1.5;
    color: #444;
}
.history-item-content strong {
    font-size: 12px;
}
/* ▲▲▲ 心声功能样式结束 ▲▲▲ */
/* 【全新】心声历史记录单条删除按钮样式 */
.inner-voice-history-item {
    position: relative; /* 让删除按钮可以相对于它定位 */
}

.history-item-delete-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #888;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    transition: all 0.2s ease;
}

.history-item-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▼▼▼ 在这里开始复制：【主题色版】可爱圆润按钮样式 ▼▼▼ */

/* --- 1. 再次设置通用的“可爱基础” --- */
#save-theme-btn,
#save-as-new-theme-btn,
#export-theme-btn,
#import-theme-btn,
#rename-theme-btn,
#delete-theme-btn {
    border: none;
    border-radius: 25px; /* 可爱的胶囊形状 */
    padding: 12px 18px;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
    transition: all 0.2s ease-in-out;
    margin-top: 5px !important;
}

/* --- 2. 可爱的“按下”效果 --- */
#save-theme-btn:active,
#save-as-new-theme-btn:active,
#export-theme-btn:active,
#import-theme-btn:active,
#rename-theme-btn:active,
#delete-theme-btn:active {
    transform: scale(0.97);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* --- 3. 【核心修改】为不同功能的按钮设置配套颜色 --- */

/* “保存” 和 “另存为”：使用全局主题色！ */
#save-theme-btn,
#save-as-new-theme-btn {
    background-color: var(--accent-color); /* 这就是你的主题色！ */
    color: white;
}

/* “导出”、“导入”、“重命名”：使用柔和的次要样式 */
#export-theme-btn,
#import-theme-btn,
#rename-theme-btn {
    background-color: #f0f2f5;           /* 淡淡的灰色背景 */
    color: var(--accent-color);          /* 文字使用主题色 */
    border: 1px solid var(--accent-color); /* 再加一个主题色的边框，更精致 */
}

/* “删除”按钮：还是用可爱的粉红色来提醒，防止误触 */
#delete-theme-btn {
    background-color: #ffdde5; /* 淡淡的樱花粉背景 */
    color: #ff3b30;           /* 文字用醒目的红色 */
    border: 1px solid #ffc2d1;
}

/* --- 4. 鼠标放到不同按钮上时的颜色变化 --- */
#save-theme-btn:hover,
#save-as-new-theme-btn:hover {
    opacity: 0.85; /* 主题色按钮变淡一点点 */
}

#export-theme-btn:hover,
#import-theme-btn:hover,
#rename-theme-btn:hover {
    background-color: #e9ecef; /* 次要按钮背景加深一点点 */
}

#delete-theme-btn:hover {
    background-color: #ffc2d1; /* 删除按钮背景加深一点点 */
}

/* ▲▲▲ 复制到这里结束 ▲▲▲ */
/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.action-icon.summon-npc svg {
    stroke-width: 1.5; /* 让图标线条稍微粗一点，更清晰 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的微博页面样式，粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 把这一整块全新的微博页面布局样式，粘贴到 <style> 标签的最末尾 ▼▼▼ */
/* ▼▼▼ 把这一整块全新的、修复后的微博布局样式，粘贴到 <style> 标签中 ▼▼▼ */

/* 个人主页内容区，确保可以滚动 */
#weibo-profile-page {
    flex-grow: 1; /* 占据剩余所有空间 */
    overflow-y: auto; /* 内容多了可以滚动 */
    background-color: #f0f2f5;
}

/* 1. 【核心】重塑头部容器 */
.weibo-profile-header {
    position: relative; /* 作为内部所有元素的定位基准 */
    width: 100%;
    height: 250px; /* 增加高度以容纳所有内容 */
    display: flex; /* 使用Flex布局 */
    flex-direction: column; /* 垂直排列 */
    justify-content: center; /* 垂直居中 */
    align-items: center; /* 水平居中 */
    padding: 20px;
    box-sizing: border-box;
    color: white; /* 统一设置文字颜色为白色，因为在背景图上 */
    text-shadow: 0 1px 3px rgba(0,0,0,0.5); /* 给所有文字加阴影，保证清晰 */
}

/* ▼▼▼ 请用下面这【正确】的代码替换 ▼▼▼ */
.weibo-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    /* z-index: -1;  <-- 我们已经把错误的那行删掉了！ */
    z-index: 1; /* 【修正】设置一个正数的层级，确保它在父容器内 */
    filter: brightness(0.9); 
}
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 请将这块【新代码】粘贴到 .weibo-background 的正下方 ▼▼▼ */
/* 【新增】为前景内容设置更高的层级 */
.weibo-avatar-container,
.weibo-nickname,
.weibo-stats {
    position: relative; /* 激活z-index */
    z-index: 2;         /* 确保它们在背景图之上 */
}
/* ▲▲▲ 新代码粘贴结束 ▲▲▲ */


/* 3. 【核心】重置头像容器的样式 */
.weibo-avatar-container {
    /* 移除所有绝对定位相关的代码 */
    position: static;
    transform: none;
    bottom: auto;
    left: auto;
    
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    margin-bottom: 12px; /* 与下方的昵称拉开距离 */
}

.weibo-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* 4. 【核心】重置昵称和各项数据的样式 */
.weibo-nickname {
    margin: 0 0 10px 0; /* 调整间距 */
    font-size: 18px;
    font-weight: 600;
}

.weibo-stats {
    margin: 0;
    padding: 0;
    display: flex;
    gap: 30px; /* 调整项目间距 */
}

.weibo-stat-item {
    display: flex;
    align-items: center; /* 改为水平排列，数字在左，文字在右 */
    gap: 6px; /* 数字和文字的间距 */
}

.weibo-stat-number {
    font-size: 15px;
    font-weight: 600;
}

.weibo-stat-label {
    margin-top: 0; /* 移除旧的上边距 */
    font-size: 14px;
    opacity: 0.9; /* 让标签文字稍微柔和一点 */
}

/* 5. 确保微博Feed列表正确显示在头部下方 */
#my-weibo-feed-list {
    background-color: #f0f2f5;
}

/* ▲▲▲ 微博样式粘贴结束 ▲▲▲ */


/* ▼▼▼ 【全新】微博页面框架和底部导航样式 ▼▼▼ */
#weibo-screen {
    display: flex;
    flex-direction: column;
}
.weibo-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none; /* 默认隐藏所有页面 */
    flex-direction: column;
    background-color: #f0f2f5;
}
.weibo-view.active {
    display: flex; /* 只显示激活的页面 */
}
#weibo-bottom-nav {
    display: flex;
    border-top: 1px solid var(--border-color);
    background-color: #f7f7f7;
    flex-shrink: 0;
    padding-bottom: env(safe-area-inset-bottom); /* 适配iPhone底部安全区 */
}
.weibo-nav-item {
    flex: 1;
    text-align: center;
    padding: 12px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
}
.weibo-nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}
/* ▲▲▲ 微博框架样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】微博关注列表弹窗样式 ▼▼▼ */
#weibo-following-list-container {
    height: 100%;
    overflow-y: auto; /* 【核心】内容超出时显示垂直滚动条 */
}
.weibo-following-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.weibo-following-item:last-child {
    border-bottom: none;
}
.weibo-following-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
    object-fit: cover;
}
.weibo-following-name {
    font-weight: 500;
    color: var(--text-primary);
}
/* ▲▲▲ 关注列表样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】让个人主页可编辑的元素有点击手势 ▼▼▼ */
#weibo-avatar-img,
#weibo-nickname,
#weibo-posts-item, /* 我们让整个“微博”区域可点击 */
#weibo-fans-item,  /* 整个“粉丝”区域可点击 */
#weibo-background-img /* 背景图也可点击 */ {
    cursor: pointer;
    transition: opacity 0.2s;
}
#weibo-avatar-img:hover,
#weibo-nickname:hover,
#weibo-posts-item:hover,
#weibo-fans-item:hover,
#weibo-background-img:hover {
    opacity: 0.8; /* 鼠标放上去时变淡一点，给用户反馈 */
}
/* ▲▲▲ 点击手势样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】微博页面布局修复CSS ▼▼▼ */
#weibo-page-container {
    flex-grow: 1; /* 【核心】让这个容器占据所有可用的垂直空间 */
    position: relative;
    overflow: hidden; /* 防止内容溢出 */
}

/* 确保个人主页的内容可以滚动 */
#weibo-profile-page {
    overflow-y: auto;
    height: 100%;
}
/* ▲▲▲ 修复CSS结束 ▲▲▲ */

/* ▲▲▲ 修复CSS结束 ▲▲▲ */
/* ▼▼▼ 【最终修复】提升微博关注列表弹窗的层级 ▼▼▼ */
#weibo-following-modal {
    z-index: 1001; /* 确保它能覆盖在其他页面之上 */
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的微博帖子样式，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* ▼▼▼ 把这一整块全新的微博帖子样式，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* === 微博帖子专属样式 (已和动态分离) === */
.weibo-post-item {
    background-color: var(--secondary-bg);
    border-radius: 0; /* 微博风格，通常没有圆角 */
    padding: 15px;
    border-bottom: 8px solid #f0f2f5; /* 用厚一点的分割线代替阴影 */
}
.weibo-post-item:last-child {
    border-bottom: none;
}

.weibo-post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.weibo-post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.weibo-post-info {
    display: flex;
    flex-direction: column;
}

.weibo-post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.weibo-post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.weibo-post-content {
    font-size: 15px; /* 微博正文字体稍大 */
    line-height: 1.7;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
    margin-bottom: 10px;
}

.weibo-post-image {
    width: 100%;
    max-height: 400px;
    object-fit: cover;
    border-radius: 8px;
    margin-bottom: 10px;
}

.weibo-post-footer {
    border-top: 1px solid #f0f0f0;
    padding-top: 8px;
    margin-top: 10px;
}

.weibo-post-actions {
    display: flex;
    justify-content: space-around; /* 三个按钮均分空间 */
    margin-bottom: 10px;
}

.weibo-action-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 14px;
}
.weibo-action-btn.liked {
    color: #ff5252; /* 点赞后变红 */
}
.weibo-action-btn svg {
    width: 20px;
    height: 20px;
}

.weibo-comments-container {
    padding: 10px;
    background-color: #f7f7f7;
    border-radius: 8px;
    font-size: 13px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 10px;
}

.weibo-comment-item .weibo-commenter-name {
    font-weight: 600;
    color: var(--accent-color);
}
.weibo-comment-item .weibo-comment-reply-tag {
    color: var(--text-secondary);
    margin: 0 4px;
}

.weibo-comment-input-area {
    display: flex;
    gap: 8px;
}

.weibo-comment-input {
    flex-grow: 1;
    border: none;
    background-color: #f0f2f5;
    border-radius: 14px;
    padding: 8px 12px;
    font-size: 13px;
}

.weibo-comment-send-btn {
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 14px;
    padding: 0 15px;
    font-size: 13px;
    cursor: pointer;
}
/* ▲▲▲ 微博专属样式结束 ▲▲▲ */
/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 单条评论的容器，现在需要相对定位，并为删除按钮留出空间 */
.weibo-comment-item {
    position: relative;
    padding-right: 25px; 
}

/* 评论删除按钮的样式 */
.comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    background-color: transparent; /* 背景透明 */
    border: none; /* 无边框 */
    font-size: 20px; /* 放大"×"号 */
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 鼠标悬停在整条评论上时，才显示删除按钮 */
.weibo-comment-item:hover .comment-delete-btn {
    opacity: 1;
}

/* 鼠标悬停在删除按钮上时，给一点反馈效果 */
.comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #ff3b30; /* 变红色 */
}

#phone-screen.dark-mode .comment-delete-btn:hover {
    background-color: #3a3a3c; /* 夜间模式下的悬停背景色 */
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的微博热搜样式，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* === 微博热搜列表样式 === */
#weibo-hot-search-list {
    background-color: var(--secondary-bg);
}

.hot-search-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

.hot-search-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode .hot-search-item:hover {
    background-color: #2c2c2e;
}

.hot-search-rank {
    width: 30px;
    font-size: 16px;
    font-weight: bold;
    color: var(--text-secondary);
    text-align: center;
    flex-shrink: 0;
}
/* 前三名用不同的颜色突出显示 */
.hot-search-item[data-rank="1"] .hot-search-rank { color: #f44336; }
.hot-search-item[data-rank="2"] .hot-search-rank { color: #ff9800; }
.hot-search-item[data-rank="3"] .hot-search-rank { color: #ffc107; }

.hot-search-content {
    flex-grow: 1;
    display: flex;
    align-items: center;
    gap: 8px;
    overflow: hidden;
}

.hot-search-topic {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.hot-search-tag {
    font-size: 10px;
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    flex-shrink: 0;
}
.hot-search-tag.hot { background-color: #f44336; }
.hot-search-tag.new { background-color: #ff9800; }
.hot-search-tag.rec { background-color: #2196f3; }

/* ▲▲▲ 微博热搜样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 购物系统样式 ▼▼▼ */

/* ==================== 购物中心主页面样式 ==================== */

/* 购物中心内容容器 */
#shopping-content-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* 商城页面容器 */
.mall-page {
    display: none;
    flex: 1;
    overflow: hidden;
}

.mall-page.active {
    display: flex;
    flex-direction: column;
}

/* 商城内容区域 */
.mall-content {
    flex: 1;
    display: flex;
    overflow: hidden;
}

/* 系统商城样式 */
#system-mall-page .mall-content {
    padding: 15px;
    padding-bottom: 80px; /* 为底部导航栏留出空间 */
}

/* 商城左侧分类导航 */
.mall-sidebar {
    width: 100px;
    background-color: #f8f9fa;
    border-right: 1px solid #e9ecef;
    display: flex;
    flex-direction: column;
    padding: 12px 0;
    padding-bottom: 80px; /* 为底部导航栏留出空间 */
    overflow-y: auto;
}

.sidebar-category {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 14px 10px;
    margin: 3px 10px;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    text-align: center;
    position: relative;
}

.sidebar-category:active {
    animation: cuteClick 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.sidebar-category::before {
    content: '💖';
    position: absolute;
    top: -8px;
    right: -8px;
    font-size: 14px;
    opacity: 0;
    pointer-events: none;
    z-index: 1000;
}

.sidebar-category:active::before {
    animation: sparkle 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.sidebar-category:hover {
    background-color: #e9ecef;
}

.sidebar-category.active {
    background: linear-gradient(135deg, rgba(255, 182, 193, 0.8), rgba(173, 216, 230, 0.8));
    color: white;
    border-radius: 12px;
    box-shadow: 
        0 4px 12px rgba(255, 182, 193, 0.3),
        0 2px 6px rgba(173, 216, 230, 0.2);
}

.category-icon {
    font-size: 24px;
    margin-bottom: 6px;
    filter: drop-shadow(0 0 8px rgba(255, 182, 193, 0.6)) drop-shadow(0 0 16px rgba(173, 216, 230, 0.4));
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    animation: gentleFloat 3s ease-in-out infinite;
}

.category-icon:hover {
    transform: scale(1.1) translateY(-2px);
    filter: drop-shadow(0 0 12px rgba(255, 182, 193, 0.8)) drop-shadow(0 0 24px rgba(173, 216, 230, 0.6));
}

@keyframes gentleFloat {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-3px); }
}

/* 可爱的点击效果 */
@keyframes cuteClick {
    0% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(0.95) rotate(-1deg); }
    50% { transform: scale(1.05) rotate(1deg); }
    75% { transform: scale(0.98) rotate(-0.5deg); }
    100% { transform: scale(1) rotate(0deg); }
}

@keyframes sparkle {
    0%, 100% { opacity: 0; transform: scale(0) rotate(0deg); }
    50% { opacity: 1; transform: scale(1) rotate(180deg); }
}

.cute-clickable {
    position: relative;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    cursor: pointer;
}

.cute-clickable:active {
    animation: cuteClick 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.cute-clickable::before {
    content: '✨';
    position: absolute;
    top: -10px;
    right: -10px;
    font-size: 16px;
    opacity: 0;
    pointer-events: none;
    z-index: 1000;
}

.cute-clickable:active::before {
    animation: sparkle 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.category-name {
    font-size: 12px;
    font-weight: 600;
    line-height: 1.3;
}

/* 个人商城主要内容区域 */
.mall-main {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* 个人商城头部操作栏 */
.personal-mall-header {
    background-color: white;
    border-bottom: 1px solid #e9ecef;
    padding: 10px 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.personal-mall-header .header-actions {
    display: flex;
    gap: 15px;
}

/* 系统商城头部操作栏 */
.system-mall-header {
    background-color: white;
    border-bottom: 1px solid #e9ecef;
    padding: 10px 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.system-mall-header .header-info {
    display: flex;
    align-items: center;
}

.system-mall-header .header-actions {
    display: flex;
    gap: 15px;
}

.cart-total-display {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 16px;
    font-weight: 500;
}

.total-label {
    color: var(--text-secondary);
}

.total-amount {
    color: #666;
    font-weight: 600;
}

.cart-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background-color: #ff4757;
    color: white;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    min-width: 18px;
}

/* 商品网格布局 - 响应式auto-fill布局 */
.product-grid {
    flex: 1; 
    overflow-y: auto; 
    overflow-x: hidden; /* 禁止水平滚动 */
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); /* 响应式布局，最小160px宽度 */
    gap: 20px !important; /* 增加间距到20px */
    row-gap: 25px !important; /* 单独控制行间距，防止垂直重叠 */
    column-gap: 15px !important; /* 单独控制列间距 */
    padding: 15px;
    padding-bottom: 80px; /* 为底部导航栏留出空间 */
    align-items: start; /* 确保所有卡片顶部对齐 */
    min-height: 0; /* 解决flex布局滚动问题 */
    box-sizing: border-box; /* 确保padding计算正确 */
    grid-auto-rows: minmax(auto, max-content); /* 确保行高度自适应内容 */
}

/* 系统商城的商品网格 */
#system-product-grid {
    padding-bottom: 80px; /* 为底部导航栏留出空间，避免遮挡商品 */
    gap: 20px !important; /* 继承主网格的间距设置 */
    row-gap: 25px !important; /* 单独控制行间距，防止垂直重叠 */
    column-gap: 15px !important; /* 单独控制列间距 */
    grid-auto-rows: minmax(auto, max-content); /* 确保行高度自适应内容 */
}

/* 个人商城的商品网格 - 确保底部留空生效 */
#product-grid {
    padding-bottom: 80px !important; /* 为底部导航栏留出空间，避免遮挡商品 */
}

/* 底部标签导航样式 - 悬浮发光效果 */
.shopping-bottom-nav {
    position: absolute;
    bottom: 15px;
    left: 15px;
    right: 15px;
    height: 60px;
    background: linear-gradient(135deg, rgba(255, 182, 193, 0.9), rgba(173, 216, 230, 0.9));
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 25px;
    display: flex;
    align-items: center;
    padding-bottom: env(safe-area-inset-bottom);
    z-index: 10;
    box-shadow: 
        0 8px 32px rgba(255, 182, 193, 0.3),
        0 4px 16px rgba(173, 216, 230, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.shopping-bottom-nav:hover {
    transform: translateY(-2px);
    box-shadow: 
        0 12px 40px rgba(255, 182, 193, 0.4),
        0 6px 20px rgba(173, 216, 230, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.5);
}

.shopping-nav-item {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    padding: 8px;
    position: relative;
}

.shopping-nav-item:active {
    animation: cuteClick 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.shopping-nav-item::after {
    content: '🌟';
    position: absolute;
    top: -5px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 12px;
    opacity: 0;
    pointer-events: none;
    z-index: 1000;
}

.shopping-nav-item:active::after {
    animation: sparkle 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.shopping-nav-item:hover {
    background-color: rgba(255, 182, 193, 0.15);
}

.shopping-nav-item.active {
    color: rgba(255, 182, 193, 1);
    transform: scale(1.05);
    background: linear-gradient(135deg, rgba(255, 182, 193, 0.1), rgba(173, 216, 230, 0.1));
    border-radius: 15px;
    box-shadow: 
        0 4px 12px rgba(255, 182, 193, 0.3),
        0 2px 6px rgba(173, 216, 230, 0.2);
}

.shopping-nav-item .nav-icon {
    font-size: 24px;
    margin-bottom: 4px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    filter: drop-shadow(0 0 6px rgba(255, 182, 193, 0.5)) drop-shadow(0 0 12px rgba(173, 216, 230, 0.3));
    animation: gentleFloat 4s ease-in-out infinite;
}

.shopping-nav-item.active .nav-icon {
    font-size: 20px;
    transform: scale(1.15) translateY(-2px);
    filter: drop-shadow(0 0 10px rgba(255, 182, 193, 0.8)) drop-shadow(0 0 20px rgba(173, 216, 230, 0.6));
}

.shopping-nav-item .nav-label {
    font-size: 12px;
    font-weight: 500;
    transition: color 0.2s ease;
}

.shopping-nav-item.active .nav-label {
    font-size: 10px;
    font-weight: 600;
}

/* 系统商品按钮样式 */
.system-product-btn {
    background-color: #6c757d !important;
    border-color: #6c757d !important;
}

.system-product-btn:hover {
    background-color: #5a6268 !important;
    border-color: #545b62 !important;
}

/* 商品卡片样式 */
.product-item {
    background-color: white;
    border-radius: 12px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.06), 
                0 2px 4px rgba(0,0,0,0.04);
    display: flex;
    flex-direction: column;
    cursor: pointer;
    position: relative; /* 为管理模式遮罩层定位 */
    aspect-ratio: 3 / 4; /* 修改为3:4比例 */
    overflow: hidden; /* 防止内容溢出 */
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid rgba(0, 0, 0, 0.02);
    margin: 0 !important; /* 强制确保没有外边距 */
    margin-bottom: 5px !important; /* 额外的底部边距防止重叠 */
    box-sizing: border-box; /* 确保边框包含在尺寸内 */
    min-width: 0; /* 防止flex项目溢出 */
    width: 100%; /* 确保占满网格单元格 */
    height: auto; /* 让高度自适应 */
    min-height: 200px; /* 设置最小高度确保一致性 */
    max-height: 300px; /* 设置最大高度防止过高 */
}

/* 商品卡片悬停效果 */
.product-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.1), 
                0 4px 8px rgba(0,0,0,0.06);
    border-color: rgba(0, 0, 0, 0.08);
}

/* 纯文字卡片样式 */
.text-only-card {
    aspect-ratio: auto !important; /* 移除固定比例 */
    height: 200px; /* 固定高度 */
    width: 100%; /* 固定宽度 */
    padding: 16px;
    justify-content: space-between;
    box-sizing: border-box; /* 确保padding包含在尺寸内 */
}

.product-info-full {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 8px;
    height: 100%;
}

/* 商品名称样式 */
.text-only-card .product-name {
    font-size: 16px;
    font-weight: 600;
    color: #333;
    line-height: 1.4;
    text-align: center;
    margin-bottom: 0px; /* 缩短与分割线的间距 */
}

/* 分隔线样式 */
.product-divider {
    font-size: 14px;
    color: #ccc;
    text-align: center;
    margin: 0px 0; /* 缩短上下间距 */
    letter-spacing: 1px;
}

/* 商品描述样式 */
.text-only-card .product-description {
    font-size: 12px;
    color: #666;
    line-height: 1.4;
    margin-top: 0px; /* 缩短与分割线的间距 */
    word-wrap: break-word;
    display: block; /* 确保描述显示 */
    min-height: 1.4em; /* 至少显示一行 */
    margin-bottom: 4px; /* 缩短底部间距 */
}

/* 系统商城商品卡片特殊样式 */
.system-product-card .product-info-full {
    display: flex;
    flex-direction: column;
    height: 100%;
}

/* 可滚动的商品名称和描述区域 */
.system-product-card .product-scrollable-content {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 2px;
    margin-bottom: 8px;
    /* 隐藏滚动条但保持滚动功能 */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}

.system-product-card .product-scrollable-content::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera */
}

/* 固定的底部区域 */
.system-product-card .product-fixed-bottom {
    flex-shrink: 0;
    background-color: white;
    border-top: 1px solid #f0f0f0;
    padding-top: 8px;
}

/* 确保系统商城的商品名称和描述在滚动区域内正确显示 */
.system-product-card .product-name {
    font-size: 16px;
    font-weight: 600;
    color: #333;
    line-height: 1.4;
    text-align: center;
    margin-bottom: 0px;
}

.system-product-card .product-description {
    font-size: 12px;
    color: #666;
    line-height: 1.4;
    margin-top: 0px;
    word-wrap: break-word;
    display: block;
    min-height: 1.4em;
    margin-bottom: 0px;
}

/* 款式选择器样式 */
.product-style-selector {
    margin: 4px 0; /* 缩短上下间距 */
    padding: 0px; /* 移除内边距 */
}

.style-select {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 11px;
    color: #333;
    background-color: #fff;
    cursor: pointer;
    transition: border-color 0.2s ease;
}

.style-select:hover {
    border-color: #007bff;
}

.style-select:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1);
}

/* 底部区域样式 */
.product-bottom {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: auto;
    padding-top: 4px; /* 缩短与款式选择器的间距 */
}

/* 价格样式 */
.text-only-card .product-price {
    font-size: 16px;
    font-weight: 700;
    color: #e74c3c;
}

/* 购物车按钮样式 */
.cart-icon-btn {
    background: linear-gradient(90deg, #ff9800, #ff5722);
    color: white;
    border: none;
    border-radius: 6px;
    padding: 6px 12px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 2px;
    box-shadow: 0 2px 4px rgba(255, 87, 34, 0.3);
}

.cart-icon-btn:hover {
    background: linear-gradient(90deg, #f57c00, #e64a19);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(255, 87, 34, 0.4);
}

.cart-icon-btn:active {
    transform: translateY(0);
}

/* 商品图片 */
.product-image {
    width: 100%;
    height: 50%; /* 图片占卡片高度的50% */
    object-fit: cover;
    object-position: center; /* 确保图片居中显示 */
    border-radius: 8px 8px 0 0;
    flex-shrink: 0; /* 防止图片被压缩 */
    aspect-ratio: 1 / 1; /* 强制1:1比例 */
}

/* 占位图片样式 */
.placeholder-image {
    width: 100%;
    height: 50%;
    border-radius: 8px 8px 0 0;
    flex-shrink: 0;
    aspect-ratio: 1 / 1;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: bold;
    color: white;
    text-align: center;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    position: relative;
    overflow: hidden;
}

.placeholder-image::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: inherit;
    opacity: 0.8;
}

.placeholder-image span {
    position: relative;
    z-index: 1;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}

/* 商品信息区域 */
.product-info {
    padding: 6px 10px 12px 10px; /* 增加下边距，为底部操作区留出更多空间 */
    height: 42%; /* 增加信息区域高度，让底部操作区往下移动 */
    display: flex;
    flex-direction: column;
    justify-content: space-between; /* 内容区域和底部操作区分开 */
    flex-shrink: 0; /* 防止信息区域被压缩 */
}

/* 商品内容区域（包含名称和描述） */
.product-content {
    flex: 1; /* 占用剩余空间 */
    overflow-y: auto; /* 允许垂直滚动 */
    padding-right: 2px; /* 为滚动条留出空间 */
    position: relative; /* 为分割线定位 */
    max-height: calc(100% - 40px); /* 调整最大高度，适应缩短的信息区域 */
}

/* 商品名称 */
.product-name {
    font-size: 12px;
    color: #333;
    font-weight: 600; /* 加粗显示 */
    line-height: 1.3;
    margin-bottom: 0px; /* 缩短与分割线的间距 */
}

/* 商品名称下方的分割线已移除，现在使用HTML分隔线 */

/* 商品描述 */
.product-description {
    font-size: 11px;
    color: #666;
    line-height: 1.4;
    margin-top: 0px; /* 缩短与分割线的间距 */
    word-wrap: break-word; /* 长单词换行 */
    white-space: pre-wrap; /* 保留换行符 */
    display: block; /* 确保描述显示 */
    min-height: 1.4em; /* 至少显示一行 */
}

/* 商品底部操作区 - 已移除，个人商城现在使用 .product-bottom */

/* 商品价格 */
.product-price {
    font-size: 14px;
    font-weight: 700;
    color: #ff5722; /* 橙红色价格 */
}
.product-price::before { 
    content: '¥'; 
    font-size: 12px; 
}

/* 加入购物车按钮 */
.add-to-cart-btn {
    padding: 4px 8px;
    border: none;
    border-radius: 12px;
    background: linear-gradient(90deg, #ff9800, #ff5722);
    color: white;
    font-size: 10px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 4px rgba(255, 87, 34, 0.3);
    position: relative;
    overflow: hidden;
}

.add-to-cart-btn:active {
    animation: cuteClick 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

.add-to-cart-btn::before {
    content: '💕';
    position: absolute;
    top: -8px;
    right: -8px;
    font-size: 12px;
    opacity: 0;
    pointer-events: none;
    z-index: 1000;
}

.add-to-cart-btn:active::before {
    animation: sparkle 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

/* ==================== 顶部通知样式 ==================== */
.top-notification {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(-100px);
    background: linear-gradient(135deg, rgba(255, 182, 193, 0.95), rgba(173, 216, 230, 0.95));
    color: white;
    padding: 12px 24px;
    border-radius: 25px;
    font-size: 14px;
    font-weight: 600;
    z-index: 10000;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    box-shadow: 
        0 8px 32px rgba(255, 182, 193, 0.4),
        0 4px 16px rgba(173, 216, 230, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.5);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    opacity: 0;
    pointer-events: none;
}

.top-notification.show {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
}

.top-notification::before {
    content: '✨';
    margin-right: 8px;
    font-size: 16px;
    animation: sparkle 2s ease-in-out infinite;
}

/* ==================== 商品管理模式样式 ==================== */

/* 管理模式遮罩层 */
.product-management-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    display: none; /* 默认隐藏 */
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 15px;
    z-index: 5;
}

/* 管理模式激活时显示遮罩层 */
#shopping-screen.management-mode .product-management-overlay {
    display: flex;
}

/* 管理模式按钮样式 */
.product-management-overlay button {
    padding: 8px 20px;
    border: 1px solid white;
    background-color: rgba(255,255,255,0.2);
    color: white;
    border-radius: 15px;
    cursor: pointer;
}

/* 删除按钮特殊样式 */
.product-management-overlay .delete-product-btn {
    border-color: #ff8a80;
    color: #ff8a80;
}

/* 默认显示购物车按钮 */
.add-to-cart-btn {
    display: inline-block !important;
}

/* 管理模式下隐藏购物车按钮 */
#shopping-screen.management-mode .add-to-cart-btn {
    display: none !important;
}

/* 管理模式下隐藏商品底部操作区 */
#shopping-screen.management-mode .product-bottom {
    display: none;
}

/* ==================== 购物车页面样式 ==================== */

/* 购物车标题 */
#cart-title {
    position: static;
    transform: none;
}

/* 购物车商品列表 */
#cart-items-list { 
    padding: 10px; 
    padding-bottom: 90px; /* 添加底部80px高度，避免被导航栏挡住 */
    display: flex; 
    flex-direction: column; 
    gap: 10px; 
}

/* 购物车商品项 */
.cart-item {
    display: flex; 
    align-items: flex-start; 
    gap: 12px; 
    background-color: white;
    padding: 12px; 
    border-radius: 12px;
}

/* 购物车商品选择框 */
.cart-item-checkbox { 
    margin-top: 28px; 
}

/* 购物车商品图片 */
.cart-item-image { 
    width: 80px; 
    height: 80px; 
    object-fit: cover; 
    border-radius: 8px; 
    flex-shrink: 0; 
}

/* 购物车商品信息区 */
.cart-item-info { 
    flex-grow: 1; 
    display: flex; 
    flex-direction: column; 
}

/* 购物车商品名称 */
.cart-item-name { 
    font-weight: 500; 
    font-size: 14px; 
    line-height: 1.4; 
}

/* 商品来源标签 */
.item-source {
    font-size: 11px;
    font-weight: 400;
    color: #666;
    background: rgba(255, 182, 193, 0.2);
    padding: 2px 6px;
    border-radius: 8px;
    margin-left: 8px;
}

/* 购物车商品底部操作区 */
.cart-item-footer { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    margin-top: 10px;
}

/* 购物车商品价格 */
.cart-item-price { 
    color: #ff5722; 
    font-weight: bold; 
    font-size: 16px; 
}

/* 数量控制器 */
.quantity-control { 
    display: flex; 
    align-items: center; 
    gap: 4px; 
}

/* 数量调整按钮 */
.quantity-btn {
    width: 26px; 
    height: 26px; 
    border: none; 
    background-color: #f7f8fa;
    border-radius: 4px; 
    font-weight: 500; 
    cursor: pointer; 
    color: #666;
}

/* 数量显示 */
.quantity-display { 
    font-weight: 500; 
    min-width: 30px; 
    text-align: center; 
}

/* 购物车底部操作栏 */
#cart-footer {
    position: absolute; 
    bottom: 0; 
    left: 0; 
    width: 100%; 
    display: flex;
    justify-content: space-between; 
    align-items: center; 
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    background-color: white; 
    border-top: 1px solid var(--border-color); 
    box-sizing: border-box;
}

/* 全选标签 */
#cart-footer .select-all-label { 
    display: flex; 
    align-items: center; 
    gap: 5px; 
}

/* 购物车汇总信息 */
#cart-footer .cart-summary { 
    text-align: right; 
}

/* 购物车小字提示 */
#cart-footer .cart-subtext { 
    font-size: 11px; 
    color: #999; 
}

/* 结算按钮 */
#checkout-btn {
    padding: 10px 25px; 
    border: none; 
    border-radius: 20px;
    background: linear-gradient(90deg, #ff9800, #ff5722);
    color: white; 
    font-size: 15px; 
    font-weight: 500; 
    cursor: pointer;
}

/* ==================== 购物车图标对齐修复 ==================== */
#go-to-cart-btn {
    display: flex;
    align-items: center; /* 垂直居中对齐 */
    gap: 4px; /* 图标和数字之间的间距 */
}

/* ==================== 礼物卡片样式 ==================== */

/* 礼物卡片容器 */
.gift-card {
    width: 220px; /* 固定宽度 */
    box-sizing: border-box; 
    border-radius: 12px; 
    background-color: #fff; 
    border: 1px solid #eee; 
    padding: 12px;
    cursor: pointer; 
    box-shadow: 0 2px 8px rgba(0,0,0,0.07);
}

/* 订单卡片特殊样式 */
.is-order .gift-card {
    border: 1px solid #6c757d;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
}

.is-order .gift-header-icon {
    color: #6c757d;
}

/* 订单卡片外包装样式 */
.order-beauty-wrapper {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 6px;
    background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(255, 154, 158, 0.2);
    animation: orderPulse 2s ease-in-out infinite;
    max-width: 85%;
    width: 85%;
    margin: 0 auto;
}

.order-beauty-decoration {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
    pointer-events: auto;
    cursor: pointer;
    border-radius: 12px; /* 添加圆角 */
    background: linear-gradient(135deg, 
        rgba(255, 154, 158, 0.1) 0%, 
        rgba(254, 207, 239, 0.05) 30%, 
        rgba(254, 207, 239, 0.05) 70%, 
        rgba(255, 154, 158, 0.1) 100%);
    backdrop-filter: blur(1px);
    border: none; /* 去除边框 */
    box-shadow: 
        inset 0 0 20px rgba(255, 154, 158, 0.2),
        inset 0 0 40px rgba(254, 207, 239, 0.1); /* 添加内阴影增强晕染 */
}

.order-gift-box {
    text-align: center;
    color: white;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.order-gift-bow {
    font-size: 28px;
    margin-bottom: 8px;
    animation: orderBounce 1.5s ease-in-out infinite;
}

.order-gift-text {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 4px;
}

.order-gift-subtitle {
    font-size: 13px;
    opacity: 0.9;
}

.order-real-content {
    position: relative;
    z-index: 1;
    opacity: 0.3;
    transition: opacity 0.3s ease;
    pointer-events: none;
}

.order-real-content.show {
    opacity: 1;
}

@keyframes orderPulse {
    0%, 100% {
        transform: scale(1);
        box-shadow: 0 2px 8px rgba(255, 154, 158, 0.2);
    }
    50% {
        transform: scale(1.01); /* 减小缩放幅度 */
        box-shadow: 0 4px 12px rgba(255, 154, 158, 0.3); /* 减小阴影扩散 */
    }
}

@keyframes orderBounce {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-8px);
    }
}

/* 礼物卡片头部 */
.gift-header { 
    display: flex; 
    align-items: center; 
    gap: 8px; 
    padding-bottom: 8px; 
    border-bottom: 1px solid #f0f0f0; 
}

/* 礼物头部图标 */
.gift-header-icon { 
    width: 20px; 
    height: 20px; 
    color: #ff9800; 
}

/* 礼物头部文字 */
.gift-header-text { 
    font-size: 15px; 
    font-weight: 600; 
    color: var(--text-primary); 
}

/* 礼物商品预览区 */
.gift-items-preview { 
    padding: 12px 0; 
    display: flex; 
    flex-direction: column; 
    gap: 8px; 
}

/* 礼物预览商品项 */
.gift-preview-item { 
    display: flex; 
    align-items: center; 
    gap: 8px; 
}

/* 礼物预览商品图片 */
.gift-preview-img { 
    width: 32px; 
    height: 32px; 
    object-fit: cover; 
    border-radius: 4px; 
    flex-shrink: 0; 
}

/* 礼物预览商品名称 */
.gift-preview-name { 
    flex-grow: 1; 
    font-size: 13px; 
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis; 
}

/* 礼物预览商品数量 */
.gift-preview-quantity { 
    font-size: 12px; 
    color: var(--text-secondary); 
}

/* 礼物卡片底部 */
.gift-footer { 
    font-size: 12px; 
    color: var(--text-secondary); 
    text-align: right; 
}

/* ==================== 订单响应卡片样式 ==================== */

/* 订单响应卡片主体 */
.order-response-card {
    background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
    border: 1px solid #e9ecef;
    border-radius: 12px;
    padding: 16px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    max-width: 280px;
    margin: 0 auto;
}

/* 订单响应头部 */
.order-response-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 12px;
}

.order-response-icon {
    font-size: 20px;
    font-weight: bold;
}

.order-response-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
}

/* 订单响应内容 */
.order-response-content {
    text-align: center;
}

.order-response-status {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 8px;
}

.order-response-time {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 不同状态的样式 */
.is-order-response.status-paid .order-response-card {
    border-color: #4CAF50;
    background: linear-gradient(135deg, #f1f8e9 0%, #ffffff 100%);
}

.is-order-response.status-rejected .order-response-card {
    border-color: #f44336;
    background: linear-gradient(135deg, #ffebee 0%, #ffffff 100%);
}

/* ==================== 购物小票样式 ==================== */

/* 小票主体 */
#gift-receipt-body { 
    font-family: 'Helvetica Neue', Arial, sans-serif; 
    padding: 20px; 
    background: #ffffff; 
    height: 100%;
    box-sizing: border-box;
}

/* 小票头部 */
.receipt-header { 
    text-align: center; 
    padding: 0 0 15px 0; 
    border-bottom: 1px solid #e0e0e0; 
    margin-bottom: 20px;
}


.receipt-header h3 { 
    margin: 0 0 12px 0; 
    font-size: 20px; 
    color: #000000;
    font-weight: 600;
}

.receipt-header p { 
    margin: 0 0 8px 0; 
    font-size: 14px; 
    color: #666666; 
    line-height: 1.4;
}

/* 信息区域样式 */
.receipt-info-section {
    margin-top: 12px;
}

.receipt-info-section p {
    margin: 0 0 6px 0;
    font-size: 13px;
    color: #333333;
    line-height: 1.4;
}

.info-label {
    font-weight: 600;
    color: #000000;
}

/* 小票商品表格 */
.receipt-items-table { 
    width: 100%; 
    border-collapse: collapse;
    margin: 20px 0; 
    background-color: white;
    border: 1px solid #e0e0e0;
}

.receipt-items-table th, 
.receipt-items-table td { 
    padding: 12px 8px; 
    font-size: 13px; 
    border-bottom: 1px solid #f0f0f0;
    vertical-align: top;
    min-height: 50px;
}

.receipt-items-table thead th { 
    background: #f8f8f8;
    color: #333333;
    font-weight: 600;
    text-align: left; 
    font-size: 12px;
    border-bottom: 2px solid #e0e0e0;
    padding: 12px 8px;
}

.receipt-items-table thead th.item-qty,
.receipt-items-table thead th.item-price,
.receipt-items-table thead th.item-subtotal {
    text-align: center;
}

.receipt-items-table tbody tr:last-child td {
    border-bottom: none;
}

/* 商品信息样式 */
.receipt-items-table .item-info { 
    width: 50%; 
    padding: 8px;
    min-height: 60px;
}

.item-info-container {
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

.receipt-item-image {
    width: 40px;
    height: 40px;
    object-fit: cover;
    border-radius: 4px;
    flex-shrink: 0;
}

.item-details {
    flex: 1;
    min-width: 0;
    min-height: 40px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
}

.item-name { 
    font-weight: 600;
    color: #000000;
    font-size: 14px;
    margin-bottom: 6px;
    line-height: 1.3;
    word-wrap: break-word;
}

.receipt-item-description {
    font-size: 10px;
    color: #999999;
    margin-bottom: 3px;
    line-height: 1.3;
    word-wrap: break-word;
    max-width: 100%;
}

.receipt-item-style {
    font-size: 11px;
    color: #666666;
    line-height: 1.3;
    word-wrap: break-word;
    max-width: 100%;
}

.receipt-items-table .item-qty { 
    text-align: center; 
    width: 12%;
    color: #666666;
    font-size: 13px;
}

.receipt-items-table .item-price { 
    text-align: right; 
    width: 18%;
    font-weight: 500;
    color: #000000;
    font-size: 13px;
}

.receipt-items-table .item-subtotal { 
    text-align: right; 
    width: 20%;
    font-weight: 600;
    color: #000000;
    font-size: 13px;
}

/* 小票总计 */
.receipt-total { 
    padding: 15px 0; 
    margin: 20px 0 0 0;
    background: #ffffff;
    color: #000000;
    text-align: right; 
    font-size: 16px; 
    font-weight: 700; 
    border-top: 2px solid #000000;
}


/* 小票底部 */
.receipt-footer { 
    text-align: center; 
    margin: 20px 0 0 0; 
    font-size: 12px; 
    color: #999999; 
    padding: 10px 0;
    border-top: 1px solid #f0f0f0;
}

/* 购物小票弹窗特殊样式 */
#gift-receipt-modal .modal-content {
    width: 350px;
    height: 622px; /* 9:16 比例 (350*16/9≈622) */
    max-width: none;
    max-height: 90vh;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

/* 外卖代付弹窗样式 - 与正常小票弹窗完全一致 */
#waimai-request-modal .modal-content {
    width: 350px;
    height: 622px; /* 9:16 比例 (350*16/9≈622) */
    max-width: none;
    max-height: 90vh;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

#gift-receipt-modal .modal-header {
    background: #ffffff;
    color: #000000;
    text-align: center;
    padding: 20px;
    font-size: 18px;
    font-weight: 600;
    border-bottom: 1px solid #e0e0e0;
    flex-shrink: 0;
}

#gift-receipt-modal .modal-body {
    padding: 0;
    flex: 1;
    overflow-y: auto;
    background: #ffffff;
}

#gift-receipt-modal .modal-footer {
    padding: 15px 20px;
    background-color: #ffffff;
    border-top: 1px solid #e0e0e0;
    text-align: center;
    flex-shrink: 0;
}

#gift-receipt-modal .modal-footer button {
    background: #000000;
    color: white;
    border: none;
    padding: 10px 25px;
    border-radius: 4px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

#gift-receipt-modal .modal-footer button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

/* 外卖代付弹窗样式 - 与正常小票弹窗完全一致 */
#waimai-request-modal .modal-header {
    background: #ffffff;
    color: #000000;
    text-align: center;
    padding: 20px;
    font-size: 18px;
    font-weight: 600;
    border-bottom: 1px solid #e0e0e0;
    flex-shrink: 0;
}

#waimai-request-modal .modal-body {
    padding: 20px;
    flex: 1;
    overflow-y: auto;
    background: #ffffff;
}

#waimai-request-modal .modal-footer {
    padding: 15px 20px;
    background-color: #ffffff;
    border-top: 1px solid #e0e0e0;
    text-align: center;
    flex-shrink: 0;
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

#waimai-request-modal .modal-footer button {
    background: #000000;
    color: white;
    border: none;
    padding: 10px 25px;
    border-radius: 4px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    flex: 1;
}

#waimai-request-modal .modal-footer button.cancel {
    background: #6c757d;
    color: white;
}

#waimai-request-modal .modal-footer button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

/* ==================== 下单流程选择器样式 ==================== */

/* 下单对象选择项 */
.order-option-item {
    display: flex;
    align-items: center;
    padding: 15px;
    margin-bottom: 10px;
    cursor: pointer;
    border: 2px solid var(--border-color);
    border-radius: 12px;
    background-color: var(--bg-secondary);
    transition: all 0.3s ease;
}

.order-option-item:hover {
    border-color: var(--accent-color);
    background-color: var(--bg-primary);
}

.order-option-item.selected {
    border-color: #000000;
    background-color: rgba(0, 0, 0, 0.1);
}

/* 选择框样式 */
.order-option-item .radio-checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
    position: relative;
}

.order-option-item.selected .radio-checkbox {
    background-color: #000000;
    border-color: #000000;
}

.order-option-item.selected .radio-checkbox::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 8px;
    height: 8px;
    background-color: white;
    border-radius: 50%;
}

/* 头像样式 */
.order-option-item .avatar {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    margin-right: 15px;
    object-fit: cover;
}

/* 选项信息 */
.order-option-info {
    flex-grow: 1;
}

.order-option-info .name {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.order-option-info .description {
    font-size: 13px;
    color: var(--text-secondary);
}

/* 付款方式选择项 */
.payment-option-item {
    display: flex;
    align-items: center;
    padding: 15px;
    margin-bottom: 10px;
    cursor: pointer;
    border: 2px solid var(--border-color);
    border-radius: 12px;
    background-color: var(--bg-secondary);
    transition: all 0.3s ease;
}

.payment-option-item:hover {
    border-color: var(--accent-color);
    background-color: var(--bg-primary);
}

.payment-option-item.selected {
    border-color: #000000;
    background-color: rgba(0, 0, 0, 0.1);
}

.payment-option-item .radio-checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
    position: relative;
}

.payment-option-item.selected .radio-checkbox {
    background-color: #000000;
    border-color: #000000;
}

.payment-option-item.selected .radio-checkbox::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 8px;
    height: 8px;
    background-color: white;
    border-radius: 50%;
}

.payment-option-item .payment-icon {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    margin-right: 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    background-color: var(--accent-color);
    color: white;
}

.payment-option-info {
    flex-grow: 1;
}

.payment-option-info .name {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.payment-option-info .description {
    font-size: 13px;
    color: var(--text-secondary);
}

/* ▲▲▲ 购物系统样式结束 ▲▲▲ */

/* ▼▼▼ 钱包系统样式开始 ▼▼▼ */
/* 钱包弹窗样式 */
.wallet-balance-display {
    text-align: center;
    padding: 30px 20px;
    background: linear-gradient(135deg, #E0FFE0 0%, #F0FFF0 100%);
    border: 2px solid #000000;
    border-radius: 15px;
    margin-bottom: 20px;
    color: #000000;
    position: relative;
    /* 双层边框效果：外边框阴影 + 内边框阴影 + 普通阴影 */
    box-shadow: 
        inset 0 0 0 4px #000000,  /* 内边框 */
        0 0 0 8px #E0FFE0,        /* 边框间距离（用背景色填充） */
        0 0 0 10px #000000,       /* 外边框 */
        0 4px 15px rgba(144, 238, 144, 0.3); /* 普通阴影 */
}

.balance-label {
    font-size: 14px;
    opacity: 0.9;
    margin-bottom: 10px;
}

.balance-amount {
    font-size: 32px;
    font-weight: bold;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    /* 添加水平滚动条支持 */
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;
    max-width: 100%;
    padding: 5px 0;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #90EE90 #E0FFE0;
}

/* Webkit浏览器滚动条样式 */
.balance-amount::-webkit-scrollbar {
    height: 6px;
}

.balance-amount::-webkit-scrollbar-track {
    background: #E0FFE0;
    border-radius: 3px;
}

.balance-amount::-webkit-scrollbar-thumb {
    background: #90EE90;
    border-radius: 3px;
}

.balance-amount::-webkit-scrollbar-thumb:hover {
    background: #7FDD7F;
}

.wallet-actions {
    text-align: center;
    margin: 20px 0;
}

.wallet-btn {
    padding: 12px 30px;
    border: none;
    border-radius: 25px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.recharge-btn {
    background: linear-gradient(135deg, #E0FFE0, #F0FFF0);
    color: #000000;
    border: 2px solid #000000;
}

.recharge-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(144, 238, 144, 0.4);
}

/* 游戏弹窗样式 */
.game-status {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 10px;
    margin-bottom: 20px;
    font-size: 14px;
    font-weight: 600;
}

.game-round {
    color: #007bff;
}

.game-chances {
    color: #28a745;
}

.game-timer {
    color: #dc3545;
    font-weight: bold;
}

.game-content {
    min-height: 300px;
    padding: 20px;
    border: 2px dashed #ddd;
    border-radius: 10px;
    text-align: center;
    background: #fafafa;
    margin-bottom: 20px;
}

.game-actions {
    text-align: center;
}

.game-btn {
    padding: 12px 30px;
    border: none;
    border-radius: 25px;
    font-size: 16px;
    font-weight: 600;
    background: linear-gradient(135deg, #28a745, #20c997);
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
}

.game-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
}

/* 数学游戏样式 */
.math-question {
    font-size: 24px;
    font-weight: bold;
    margin: 20px 0;
    color: #333;
}

.math-options {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin: 20px 0;
}

.math-option {
    padding: 15px;
    border: 2px solid #ddd;
    border-radius: 10px;
    background: white;
    cursor: pointer;
    font-size: 18px;
    font-weight: 600;
    transition: all 0.3s ease;
}

.math-option:hover {
    background: #e3f2fd;
    border-color: #2196f3;
}

.math-option.selected {
    background: #2196f3;
    color: white;
    border-color: #1976d2;
}

/* 音符游戏样式 */
.music-game-area {
    position: relative;
    height: 280px; /* 增加游戏区域高度 */
    background: linear-gradient(to bottom, #e3f2fd, #bbdefb);
    border-radius: 10px;
    overflow: hidden;
    /* 优化触控性能 */
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    /* 提高渲染性能 */
    will-change: contents;
    transform: translateZ(0); /* 启用硬件加速 */
}

.music-note {
    position: absolute;
    font-size: 35px; /* 恢复原来的音符尺寸 */
    cursor: pointer;
    user-select: none;
    animation-fill-mode: forwards;
    transition: transform 0.01s ease-out, filter 0.01s ease-out; /* 超快响应速度 */
    will-change: transform, filter;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    /* 设置点击区域为9px */
    padding: 9px;
    margin: -9px;
    /* 提高触控响应 */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    /* 确保在所有设备上都能快速响应 */
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    /* 添加更多优化 */
    pointer-events: auto;
    z-index: 10;
    /* 确保触摸事件优先处理 */
    -webkit-transform: translateZ(0);
    -webkit-backface-visibility: hidden;
    -webkit-perspective: 1000;
}

.music-note:hover {
    transform: scale(1.1);
    filter: brightness(1.2);
}

.music-note:active {
    transform: scale(0.95);
}

/* 从上往下落 */
@keyframes fallDown {
    from {
        top: -50px;
    }
    to {
        top: 270px; /* 确保完全落到底部才消失 */
    }
}

/* 从左往右飞 */
@keyframes flyRight {
    from {
        left: -50px;
        top: 50%;
    }
    to {
        left: 100%;
        top: 50%;
    }
}

/* 从右往左飞 */
@keyframes flyLeft {
    from {
        left: 100%;
        top: 50%;
    }
    to {
        left: -50px;
        top: 50%;
    }
}

/* 从下往上飞 */
@keyframes flyUp {
    from {
        top: 270px;
    }
    to {
        top: -50px;
    }
}

/* 音符点击特效动画 */
@keyframes noteClickEffect {
    0% {
        transform: scale(0.5) rotate(0deg);
        opacity: 1;
    }
    50% {
        transform: scale(1.2) rotate(180deg);
        opacity: 0.8;
    }
    100% {
        transform: scale(2) rotate(360deg);
        opacity: 0;
    }
}

.music-score {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255, 255, 255, 0.9);
    padding: 5px 10px;
    border-radius: 15px;
    font-weight: bold;
}

/* 打地鼠游戏样式 */
.whack-mole-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    max-width: 300px;
    margin: 0 auto;
}

.mole-hole {
    width: 80px;
    height: 80px;
    background: #8d6e63;
    border-radius: 50%;
    position: relative;
    cursor: pointer;
    overflow: hidden;
    border: 3px solid #5d4037;
    transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
    will-change: transform;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
}

.mole-hole:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.mole-hole:active {
    transform: scale(0.95);
}

.mole {
    position: absolute;
    bottom: -50px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 40px;
    transition: bottom 0.3s ease, transform 0.2s ease, filter 0.2s ease;
    will-change: bottom, transform, filter;
    pointer-events: none;
}

.mole.show {
    bottom: 10px;
}

.mole-score {
    text-align: center;
    margin: 15px 0;
    font-size: 18px;
    font-weight: bold;
}

/* 打地鼠成功特效动画（爆炸） */
@keyframes moleSuccessEffect {
    0% {
        transform: scale(0.3);
        opacity: 1;
        filter: hue-rotate(0deg);
    }
    30% {
        transform: scale(1.3);
        opacity: 0.9;
        filter: hue-rotate(90deg);
    }
    60% {
        transform: scale(1.8);
        opacity: 0.6;
        filter: hue-rotate(180deg);
    }
    100% {
        transform: scale(2.5);
        opacity: 0;
        filter: hue-rotate(360deg);
    }
}

/* 打地鼠错误特效动画（骷髅） */
@keyframes moleErrorEffect {
    0% {
        transform: scale(0.3) rotate(-15deg);
        opacity: 1;
    }
    25% {
        transform: scale(1.2) rotate(15deg);
        opacity: 0.9;
    }
    50% {
        transform: scale(1.5) rotate(-10deg);
        opacity: 0.7;
    }
    75% {
        transform: scale(1.8) rotate(10deg);
        opacity: 0.4;
    }
    100% {
        transform: scale(2.2) rotate(0deg);
        opacity: 0;
    }
}

/* 成功/失败弹窗样式 */
.success-content, .failed-content {
    text-align: center;
    padding: 20px;
}

.success-icon {
    font-size: 60px;
    margin-bottom: 20px;
}

.success-message, .failed-message {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 20px;
    color: #333;
}

.recharge-form {
    margin-top: 25px;
}

.recharge-form label {
    display: block;
    margin-bottom: 10px;
    font-weight: 600;
    color: #555;
}

.recharge-form input {
    width: 100%;
    padding: 12px;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 16px;
    margin-bottom: 15px;
    box-sizing: border-box;
}

.recharge-confirm-btn {
    width: 90%;
    max-width: 280px;
    padding: 10px;
    border: 2px solid #000000;
    border-radius: 8px;
    background: linear-gradient(135deg, #E0FFE0, #F0FFF0);
    color: #000000;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    margin: 0 auto;
    display: block;
}

.recharge-confirm-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(144, 238, 144, 0.4);
}

.retry-btn {
    padding: 10px 25px;
    border: none;
    border-radius: 20px;
    background: #6c757d;
    color: white;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.retry-btn:hover {
    background: #5a6268;
}

.next-chance-time {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 8px;
    padding: 10px;
    margin: 15px 0;
    font-size: 14px;
    color: #856404;
}

/* 交易记录样式 */
.wallet-transactions {
    margin-top: 20px;
    border-top: 1px solid #eee;
    padding-top: 15px;
}

.transaction-list {
    max-height: 200px;
    overflow-y: auto;
}

.transaction-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 0;
    border-bottom: 1px solid #f5f5f5;
}

.transaction-item:last-child {
    border-bottom: none;
}

.transaction-info {
    flex: 1;
}

.transaction-type {
    font-size: 14px;
    font-weight: 500;
    color: #333;
    margin-bottom: 4px;
    /* 添加横向滑动功能 */
    overflow-x: auto;
    white-space: nowrap;
    max-width: calc(100% - 20px); /* 限制宽度，为金额留出少量空间 */
    /* 隐藏滚动条 */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge */
}

.transaction-type::-webkit-scrollbar {
    display: none; /* Chrome/Safari/Opera */
}

.transaction-time {
    font-size: 12px;
    color: #999;
}

.transaction-amount {
    font-size: 16px;
    font-weight: 600;
}

.transaction-amount.income {
    color: #4CAF50;
}

.transaction-amount.expense {
    color: #f44336;
}

.no-transactions {
    text-align: center;
    color: #999;
    font-size: 14px;
    padding: 20px 0;
}

/* 通知动画 */
@keyframes slideInRight {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOutRight {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%);
        opacity: 0;
    }
}

/* ▲▲▲ 钱包系统样式结束 ▲▲▲ */

/* ▼▼▼ 动态中私人照片和恋爱相册照片居中显示样式 ▼▼▼ */
.private-photo-container {
    display: block !important;
    text-align: center;
    margin: 8px auto !important;
}

.album-photo-item {
    display: block !important;
    margin: 10px auto !important;
}

/* 动态内容区域中的图片容器居中 */
.moment-content .private-photo-container,
.chat-message-content .private-photo-container,
.message-content .private-photo-container {
    text-align: center;
}

.moment-content .album-photo-item,
.chat-message-content .album-photo-item,
.message-content .album-photo-item {
    margin: 10px auto;
}
/* ▲▲▲ 动态照片居中样式结束 ▲▲▲ */

/* ▼▼▼ 胶片旋转盘组件样式 ▼▼▼ */
/* 长条形胶片旋转盘组件 */
#film-reel-widget {
    width: 150px; /* 固定宽度，等于图标容器的宽度（从QQ左边缘到世界书右边缘） */
    max-width: 150px;
    margin: 3px auto; /* 保持居中 */
    position: relative;
}

.film-reel-container {
    background: rgba(255, 255, 255, 0.4); /* 更纯净的白色透明背景 */
    backdrop-filter: blur(15px); /* 减少模糊，更清晰 */
    -webkit-backdrop-filter: blur(15px);
    border-radius: 16px;
    padding: 20px 8px; /* 增加上下内边距从12px到20px */
    min-height: 180px; /* 设置最小高度确保拉长效果 */
    /* 去掉所有边框和阴影，保持干净 */
    position: relative; /* 确保可以正确定位背景和遮罩 */
    cursor: pointer; /* 鼠标悬停时显示可点击状态 */
    transition: all 0.3s ease; /* 添加过渡效果 */
    overflow: hidden; /* 确保背景图片不会溢出圆角 */
}

.film-reel-container:hover {
    backdrop-filter: blur(12px); /* 悬停时稍微减少模糊 */
    -webkit-backdrop-filter: blur(12px);
}

/* 图片覆盖层样式 */
.film-container-image-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border-radius: 16px;
    z-index: 1; /* 在磨砂背景之上 */
    opacity: 0.8; /* 稍微透明，让内容更清晰 */
    transition: opacity 0.3s ease;
}

.film-container-image-overlay:hover {
    opacity: 0.7; /* 悬停时更透明 */
}

/* 确保胶片内容在图片覆盖层之上 */
.film-strip-border {
    /* 完全透明，无任何视觉效果 */
    background: transparent;
    border: none;
    box-shadow: none;
    border-radius: 8px;
    padding: 15px 8px; /* 增加上下内边距从10px到15px */
    position: relative;
    z-index: 2; /* 在图片覆盖层之上 */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px; /* 增加间距从6px到8px */
}

/* 胶片孔样式 */
.film-holes {
    display: none; /* 隐藏胶片针孔 */
}

.film-hole {
    width: 8px; /* 稍微增大从6px到8px */
    height: 8px;
    background: radial-gradient(circle at 30% 30%, #000 0%, #111 50%, #000 100%);
    border-radius: 50%;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 
        inset 0 1px 2px rgba(0, 0, 0, 0.8),
        inset 0 -1px 1px rgba(255, 255, 255, 0.05),
        0 1px 2px rgba(0, 0, 0, 0.3);
}

/* 中央旋转盘区域 */
.reel-center-area {
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 15px 0; /* 增加上下内边距从8px到15px */
}

/* 黑胶唱片样式的旋转盘 */
.vinyl-reel {
    width: 70px; /* 稍微增大从60px到70px */
    height: 70px;
    background: radial-gradient(circle at 30% 30%, 
        #4a4a4a 0%, 
        #3a3a3a 20%, 
        #2a2a2a 40%, 
        #1f1f1f 60%, 
        #2a2a2a 80%, 
        #1a1a1a 100%); /* 提亮中央旋转盘，减少沉闷感 */
    border-radius: 50%;
    position: relative;
    cursor: pointer;
    transition: transform 0.3s ease;
    animation: auto-spin 8s linear infinite; /* 添加自动旋转动画 */
    box-shadow: 
        0 0 0 2px rgba(255, 255, 255, 0.08),
        0 4px 8px rgba(0, 0, 0, 0.4),
        inset 0 2px 4px rgba(255, 255, 255, 0.12),
        inset 0 -2px 4px rgba(0, 0, 0, 0.8);
}

.vinyl-reel:hover {
    transform: scale(1.05);
    box-shadow: 
        0 0 0 2px rgba(255, 255, 255, 0.12),
        0 6px 12px rgba(0, 0, 0, 0.5),
        inset 0 2px 4px rgba(255, 255, 255, 0.15),
        inset 0 -2px 4px rgba(0, 0, 0, 0.8);
}

.vinyl-reel.spinning {
    animation: spin 3s linear infinite;
}

/* 自动旋转动画 */
@keyframes auto-spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* 旋转盘纹理 */
.reel-grooves {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    height: 90%;
    border-radius: 50%;
    background: repeating-conic-gradient(
        from 0deg,
        transparent 0deg,
        rgba(255, 255, 255, 0.08) 1deg,
        transparent 2deg,
        rgba(255, 255, 255, 0.04) 3deg,
        transparent 4deg
    );
    pointer-events: none;
    opacity: 0.9;
}

/* 照片上传区域 */
.photo-upload-area {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 45px; /* 稍微增大从40px到45px */
    height: 45px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, 
        #2a2a2a 0%, 
        #1a1a1a 50%, 
        #0a0a0a 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    overflow: hidden;
    border: 2px solid rgba(255, 255, 255, 0.1);
    box-shadow: 
        inset 0 1px 3px rgba(255, 255, 255, 0.1),
        inset 0 -1px 3px rgba(0, 0, 0, 0.8),
        0 2px 4px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
}

.upload-placeholder {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #ccc;
    font-size: 8px;
    text-align: center;
    gap: 2px;
}

.upload-placeholder svg {
    width: 16px;
    height: 16px;
}

.upload-placeholder span {
    font-size: 6px;
    line-height: 1;
}

#uploaded-photo {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
}

/* 暗色模式适配 */
#phone-screen.dark-mode .film-reel-container {
    background: rgba(0, 0, 0, 0.3); /* 暗黑模式下更清晰的半透明背景 */
    backdrop-filter: blur(15px); /* 减少模糊，更清晰 */
    -webkit-backdrop-filter: blur(15px);
    /* 暗黑模式下也去掉所有边框和阴影 */
}

#phone-screen.dark-mode .film-reel-container:hover {
    backdrop-filter: blur(12px); /* 暗黑模式下悬停时稍微减少模糊 */
    -webkit-backdrop-filter: blur(12px);
}

/* 暗色模式下的图片覆盖层 */
#phone-screen.dark-mode .film-container-image-overlay {
    opacity: 0.7; /* 暗色模式下稍微更透明 */
}

#phone-screen.dark-mode .film-container-image-overlay:hover {
    opacity: 0.6; /* 暗色模式下悬停时更透明 */
}

#phone-screen.dark-mode .film-strip-border {
    /* 暗黑模式下也保持透明 */
    background: transparent;
}

#phone-screen.dark-mode .film-hole {
    background: #000;
    border-color: #222;
}
/* ▲▲▲ 胶片旋转盘组件样式结束 ▲▲▲ */

/* ▼▼▼ 聊天样式组件样式 ▼▼▼ */
#chat-style-widget {
    width: 100%;
    max-width: 200px;
    margin: 10px 0 0 53px; /* 向右移动60px，不再居中 */
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.chat-message {
    position: relative;
    display: flex;
    align-items: flex-start;
    gap: 8px;
    width: 100%; /* 固定容器宽度 */
    max-width: 200px; /* 限制最大宽度，防止挤出头像 */
    z-index: 0; /* 确保低于上层组件的z-index */
}

.chat-message-right {
    flex-direction: row;
    justify-content: flex-end;
}

.chat-message-left {
    flex-direction: row;
}

.chat-content {
    font-size: 11px;
    color: #666;
    line-height: 1.3;
    min-width: 40px;
    max-width: 160px;
    outline: none;
    border: 1px solid transparent;
    padding: 2px 4px;
    border-radius: 3px;
    transition: border-color 0.2s ease;
    cursor: text;
    word-wrap: break-word;
    white-space: pre-wrap;
    /* 横向排列，最多两行 */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
    overflow: hidden;
    text-overflow: ellipsis;
}

.chat-content:hover {
    border-color: rgba(0,0,0,0.1);
}

.chat-content:focus {
    border-color: #007AFF;
    background: rgba(0,122,255,0.05);
}

.chat-content:empty:before {
    content: attr(data-placeholder);
    color: #999;
    font-style: italic;
}

.chat-avatar {
    position: relative;
    flex-shrink: 0;
}

.clickable-avatar {
    cursor: pointer;
}

.clickable-avatar:hover .avatar-circle {
    transform: scale(1.05);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

.avatar-circle {
    width: 28px; /* 从22px增大到28px */
    height: 28px; /* 从22px增大到28px */
    border-radius: 4px; /* 从50%改为4px，方形带微圆角 */
    background: #ddd;
    border: 1px solid rgba(0,0,0,0.1);
    transition: all 0.2s ease;
    position: relative;
}

.avatar-circle:empty::after {
    content: '+';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #999;
    font-size: 10px;
    font-weight: bold;
}

.chat-line {
    position: absolute;
    bottom: -3px;
    height: 1px;
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(0,0,0,0.15) 20%, 
        rgba(0,0,0,0.25) 50%, 
        rgba(0,0,0,0.15) 80%, 
        transparent 100%
    );
}

.chat-line-right {
    right: 22px; /* 调整到头像左侧位置 */
    width: 120px; /* 缩短第一行线条长度 */
}

.chat-line-left {
    left: -20px; /* 往左侧延伸更多 */
    width: 200px; /* 大幅增加第二行线条长度 */
}

/* 第一行：文字在头像左侧，固定布局 */
.chat-message-right .chat-avatar {
    order: 2; /* 头像在右侧 */
    flex-shrink: 0; /* 头像不缩小 */
}

.chat-message-right .chat-content {
    order: 1; /* 文字在左侧 */
    text-align: right;
    margin-right: 8px; /* 与头像的间距 */
    flex: 1; /* 占据剩余空间 */
    min-width: 0; /* 允许缩小 */
    max-width: 160px; /* 限制最长约10个字符的宽度 */
    margin-left: -60px; /* 大幅往左侧扩展，但不影响左侧按钮 */
    overflow-wrap: break-word; /* 长单词换行 */
    word-break: break-all; /* 强制换行 */
    /* 第一行强制一行显示，最长10字符 */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap; /* 强制不换行 */
}

/* 第二行：无头像，文字区域往左侧扩展 */
.chat-message-left .chat-content {
    margin-left: -20px; /* 往左侧扩展更多 */
    max-width: 200px; /* 增加第二行文字区域宽度 */
    /* 确保第二行也是横向排列，最多两行 */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: pre-wrap;
}

/* 暗色模式适配 */
#phone-screen.dark-mode .chat-content {
    color: #aaa;
}

#phone-screen.dark-mode .chat-content:hover {
    border-color: rgba(255,255,255,0.2);
}

#phone-screen.dark-mode .chat-content:focus {
    border-color: #0A84FF;
    background: rgba(10,132,255,0.1);
}

#phone-screen.dark-mode .chat-content:empty:before {
    color: #666;
}

#phone-screen.dark-mode .avatar-circle {
    background: #555;
    border-color: rgba(255,255,255,0.1);
}

#phone-screen.dark-mode .avatar-circle:empty::after {
    color: #aaa;
}

#phone-screen.dark-mode .chat-line {
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255,255,255,0.1) 20%, 
        rgba(255,255,255,0.2) 50%, 
        rgba(255,255,255,0.1) 80%, 
        transparent 100%
    );
}
/* ▲▲▲ 聊天样式组件样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】长期记忆管理按钮美化样式 ▼▼▼ */
.memory-action-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px; /* 增加一点可点击区域，方便用户操作 */
    border-radius: 50%; /* 圆形背景 */
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s;
}

.memory-action-btn svg {
    width: 18px;  /* 让图标比顶部的稍小一点，更显精致 */
    height: 18px;
    stroke: var(--text-secondary); /* 默认使用次要文字的灰色 */
    transition: stroke 0.2s;
}

.memory-action-btn:hover {
    background-color: #e9ecef; /* 鼠标悬停时给一个淡淡的背景色 */
}

/* 夜间模式下的悬停效果 */
#phone-screen.dark-mode .memory-action-btn:hover {
    background-color: #38383a;
}

/* 编辑按钮悬停时，图标变为蓝色 */
.memory-action-btn.edit-memory-btn:hover svg {
    stroke: var(--accent-color);
}

/* 删除按钮悬停时，图标变为危险的红色 */
.memory-action-btn.delete-memory-btn:hover svg {
    stroke: #ff3b30;
}

/* === 【全新美化版】回忆卡片样式 === */

/* 1. 卡片总容器：这里负责定义整体的背景色和边框 */
.memory-card {
    background-color: #fffaf0; /* 统一的、温暖的米黄色背景 */
    border-radius: 12px;
    padding: 15px; /* 在卡片四周留出内边距 */
    box-shadow: 0 2px 6px rgba(0,0,0,0.07);
    border-left: 5px solid #ffb74d; 
    display: flex; /* 让它成为flex容器，方便内部元素排列 */
    flex-direction: column; /* 让头部和内容垂直堆叠 */
    gap: 8px; /* 在头部和内容之间创造一个自然的间距 */
}

/* 2. 头部容器：现在只负责布局和分割线 */
.memory-card .header {
    border-bottom: 1px solid rgba(217, 129, 0, 0.15); /* 分割线颜色可以稍微加深一点 */
    padding-bottom: 8px; 
}

/* 3. 日期样式 (保持不变) */
.memory-card .header .date {
    font-size: 11px;
    color: #a1887f;
    margin-bottom: 4px; 
}

/* 4. 作者样式 (保持不变) */
.memory-card .header .author {
    font-weight: 600;
    color: #d98100;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. 内容区样式 (保持不变) */
.memory-card .content {
    font-size: 14px;
    line-height: 1.7;
    color: #5d4037;
    white-space: pre-wrap;
}

/* 长期记忆卡片暗色模式样式 */
#phone-screen.dark-mode .memory-card {
    background-color: #1c1c1e;
    border-left-color: #e6a753;
    box-shadow: 0 4px 12px rgba(255, 255, 255, 0.08);
}
#phone-screen.dark-mode .memory-card .header {
    background-color: #2c2c2e;
    border-bottom-color: #38383a;
    margin: -15px -15px 8px -15px;
    padding: 12px 15px;
    border-radius: 12px 12px 0 0;
}
#phone-screen.dark-mode .memory-card .header .date,
#phone-screen.dark-mode .memory-card .header .author,
#phone-screen.dark-mode .memory-card .content {
    color: #e0e0e0;
}
/* ▲▲▲ 长期记忆样式添加结束 ▲▲▲ */

/* ▼▼▼ RealImag多图布局样式 ▼▼▼ */
/* 多图容器 */
.post-images-grid {
    display: grid;
    gap: 8px;  /* 图片之间的固定间距 */
    margin-top: 10px;
}

/* 单张图片 - 大图，等比例缩放 */
.post-images-grid.grid-1 {
    grid-template-columns: 1fr;
    justify-items: start;
}
.post-images-grid.grid-1 .realimag-image,
.post-images-grid.grid-1 .naiimag-image {
    max-width: 280px;
    max-height: 280px;
    width: auto;
    height: auto;
}

/* 2张图片 - 横向并排，等比例缩放 */
.post-images-grid.grid-2 {
    grid-template-columns: auto auto;
    gap: 5px;
    justify-content: start;
}
.post-images-grid.grid-2 .realimag-image,
.post-images-grid.grid-2 .naiimag-image {
    max-width: 135px;
    max-height: 135px;
    width: auto;
    height: auto;
}

/* 3张图片 - 横向排列，等比例缩放 */
.post-images-grid.grid-3 {
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
}
.post-images-grid.grid-3 .realimag-image {
    max-width: 130px;
    max-height: 130px;
    width: auto;
    height: auto;
}

/* 4张图片 - 2x2方格，等比例缩放 */
.post-images-grid.grid-4 {
    grid-template-columns: repeat(2, 1fr);
    gap: 5px;
}
.post-images-grid.grid-4 .realimag-image {
    max-width: 195px;
    max-height: 195px;
    width: auto;
    height: auto;
}

/* 5张图片 - 上2下3，等比例缩放 */
.post-images-grid.grid-5 {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 5px;
}
.post-images-grid.grid-5 .realimag-image:nth-child(1),
.post-images-grid.grid-5 .realimag-image:nth-child(2) {
    grid-column: span 3;
    max-width: 195px;
    max-height: 195px;
    width: auto;
    height: auto;
}
.post-images-grid.grid-5 .realimag-image:nth-child(n+3) {
    grid-column: span 2;
    max-width: 130px;
    max-height: 130px;
    width: auto;
    height: auto;
}

/* 6张图片 - 3x2网格，等比例缩放 */
.post-images-grid.grid-6 {
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
}
.post-images-grid.grid-6 .realimag-image {
    max-width: 130px;
    max-height: 130px;
    width: auto;
    height: auto;
}

/* 7-9张图片 - 3x3九宫格，等比例缩放 */
.post-images-grid.grid-7,
.post-images-grid.grid-8,
.post-images-grid.grid-9 {
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
}
.post-images-grid.grid-7 .realimag-image,
.post-images-grid.grid-8 .realimag-image,
.post-images-grid.grid-9 .realimag-image {
    max-width: 130px;
    max-height: 130px;
    width: auto;
    height: auto;
}

/* 图片基础样式 - 完整显示，等比例缩放，不裁剪 */
.post-images-grid .realimag-image,
.post-images-grid .naiimag-image {
    object-fit: contain;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.2s;
}
.post-images-grid .realimag-image:hover,
.post-images-grid .naiimag-image:hover {
    transform: scale(1.05);
}
/* ▲▲▲ RealImag多图布局样式结束 ▲▲▲ */

    </style>
    <!-- ▼▼▼ 在这里添加下面这行 ▼▼▼ -->
    <style id="custom-theme-style"></style>
</head>
<body>
        <div id="phone-screen">
            <div id="status-bar">
                <span id="status-bar-time">12:00</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">--%</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>
            <div id="notification-bar"><img id="notification-avatar" src=""><div id="notification-content"><div class="name"></div><div class="message"></div></div></div>

<!-- ▼▼▼ 【全新】在这里粘贴悬浮歌词栏的代码 ▼▼▼ -->
<div id="floating-lyrics-bar">
    <span id="floating-lyric-text">♪</span>
    <!-- 【问题4修复】用包含SVG的div替换旧的span -->
    <div id="lyrics-settings-btn" style="cursor: pointer; display: flex; align-items: center; justify-content: center;">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </div>
    <span class="close-btn">×</span>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 在这里粘贴下面这行新代码 ▼▼▼ -->
<div id="lock-screen-background-blur" style="display: none;"></div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
            
<!-- ▼▼▼ 用下面这【一整块】修改后的代码，替换掉你旧的 <div id="home-screen"...>...</div> ▼▼▼ -->
<div id="home-screen" class="screen active">
    
    <!-- 1. 页面滑动容器 -->
    <div id="home-screen-pages-container">
        <div id="home-screen-pages">
            <!-- 页面 1: 第一页内容（保持原有内容不变） -->
            <div class="home-screen-page">
                <div id="main-content-area">
        <div id="profile-widget">
            <img id="profile-banner-img" src="https://youke1.picui.cn/s1/2025/10/08/68e62b09b85cc.jpg" class="editable-image">
            <div class="profile-avatar-container">
                <img id="profile-avatar-img" src="https://youke1.picui.cn/s1/2025/10/08/68e62ac425a2e.jpg" class="editable-image">
            </div>
            <div class="profile-info">
                <p id="profile-username" class="editable-text">你的昵称</p>
                <p id="profile-sub-username" class="editable-text">@your_id</p>
                <p id="profile-bio" class="editable-text">点击这里编辑你的个性签名</p>
<!-- ▼▼▼ 步骤 2.1：用这行新代码替换旧的地点 <p> 标签 ▼▼▼ -->
<p id="profile-location" class="editable-text" data-placeholder="点击编辑地点"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></svg><span>点击编辑地点</span></p>
<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->
            </div>
        </div>
        <div id="desktop-layout">
            <div id="desktop-widget-column">
    <!-- ▼▼▼ 这是全新的小组件结构 ▼▼▼ -->
    
    <!-- 长条形胶片旋转盘组件 -->
    <div id="film-reel-widget">
        <div class="film-reel-container" id="film-reel-container">
            <!-- 黑色胶片边框 -->
            <div class="film-strip-border">
                <!-- 胶片孔 -->
                <div class="film-holes film-holes-top">
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                </div>
                
                <!-- 中央旋转盘区域 -->
                <div class="reel-center-area">
                    <div class="vinyl-reel" id="vinyl-reel">
                        <!-- 旋转盘纹理 -->
                        <div class="reel-grooves"></div>
                        <!-- 中心照片区域 -->
                        <div class="photo-upload-area" id="photo-upload-area">
                            <div class="upload-placeholder" id="upload-placeholder">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/>
                                </svg>
                                <span>输入图片URL</span>
                            </div>
                            <img id="uploaded-photo" style="display: none;" alt="上传的照片">
                        </div>
                    </div>
                </div>
                
                <!-- 胶片孔 -->
                <div class="film-holes film-holes-bottom">
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                </div>
                
                <!-- 额外的胶片孔来填充拉长的空间 -->
                <div class="film-holes film-holes-bottom">
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                    <div class="film-hole"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- ▲▲▲ 替换结束 ▲▲▲ -->
</div>

            <!-- 核心修改：我们把所有4个App图标都放在这个容器里 -->
            <div id="desktop-app-container">
                <div class="desktop-app-icon" onclick="showScreen('chat-list-screen')"><div class="icon-bg-desktop"><img id="icon-img-qq" src="https://youke1.picui.cn/s1/2025/10/08/68e6289510848.png" alt="QQ"></div><span class="label">QQ</span></div>
                <div class="desktop-app-icon" onclick="showScreen('world-book-screen')"><div class="icon-bg-desktop"><img id="icon-img-world-book" src="https://youke1.picui.cn/s1/2025/10/08/68e628cf3db0a.png" alt="世界书"></div><span class="label">世界书</span></div>
                <div class="desktop-app-icon" id="weibo-app-icon"><div class="icon-bg-desktop"><img id="icon-img-weibo" src="https://youke1.picui.cn/s1/2025/10/08/68e628eaeb618.png" alt="微博"></div><span class="label">微博</span></div>
                <!-- X标志改造成标准app图标 -->
                <div class="desktop-app-icon" id="x-app-icon" onclick="showScreen('x-social-screen')">
                    <div class="icon-bg-desktop">
                        <svg id="x-default-icon" viewBox="0 0 24 24" width="24" height="24" fill="currentColor" style="color: white;">
                          <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
                        </svg>
                        <img id="x-logo-img" src="" alt="X Logo" style="width: 100%; height: 100%; object-fit: cover; border-radius: 10px; display: none;">
                    </div>
                    <span class="label">X</span>
                </div>
    
          <!-- X App的样式 -->
          <style>
            /* X App的特殊背景样式 */
            #x-app-icon .icon-bg-desktop {
              background: #f0f2f5;
            }
            
            /* 当有自定义图标时移除背景 */
            #x-app-icon.has-custom-icon .icon-bg-desktop {
              background: #f0f2f5;
            }
          </style>
    
          <script>
            // URL输入弹窗相关函数
            let urlInputCallback = null;

            // ▼▼▼ 添加 showCustomPrompt 函数以解决作用域问题 ▼▼▼
            function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
                return new Promise(resolve => {
                    window.modalResolve = resolve;
                    window.modalTitle.textContent = title;
                    const inputId = 'custom-prompt-input';
                    
                    const inputHtml = type === 'textarea' 
                        ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
                        : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
                    
                    // 【核心修改】将额外的HTML和输入框组合在一起
                    window.modalBody.innerHTML = extraHtml + inputHtml;
                    const input = document.getElementById(inputId);

                    // 【核心修改】为格式助手按钮绑定事件
                    window.modalBody.querySelectorAll('.format-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const templateStr = btn.dataset.template;
                            if (templateStr) {
                                try {
                                    const templateObj = JSON.parse(templateStr);
                                    // 使用 null, 2 参数让JSON字符串格式化，带缩进，更易读
                                    input.value = JSON.stringify(templateObj, null, 2);
                                    input.focus();
                                } catch(e) {
                                    console.error("解析格式模板失败:", e);
                                }
                            }
                        });
                    });
                    
                    window.modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
                    window.modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
                    showCustomModal();
                    setTimeout(() => input.focus(), 100);
                });
            }

            // ▼▼▼ 添加模态框相关函数 ▼▼▼
            function showCustomModal() { 
                window.modalOverlay.classList.add('visible'); 
            }

            function hideCustomModal() { 
                window.modalOverlay.classList.remove('visible'); 
                window.modalConfirmBtn.classList.remove('btn-danger'); 
                if (window.modalResolve) window.modalResolve(null); 
            }

            // ▼▼▼ 添加选择模态框函数 ▼▼▼
            function showChoiceModal(title, options) {
                return new Promise(resolve => {
                    // 复用你现有的自定义模态框
                    const modal = document.getElementById('preset-actions-modal');
                    const footer = modal.querySelector('.custom-modal-footer');
                    
                    // 清空旧按钮并动态创建新按钮
                    footer.innerHTML = ''; 

                    options.forEach(option => {
                        const button = document.createElement('button');
                        button.textContent = option.text;
                        button.onclick = () => {
                            modal.classList.remove('visible');
                            resolve(option.value); // 返回被点击按钮的值
                        };
                        footer.appendChild(button);
                    });

                    // 添加一个标准的取消按钮
                    const cancelButton = document.createElement('button');
                    cancelButton.textContent = '取消';
                    cancelButton.style.marginTop = '8px';
                    cancelButton.style.borderRadius = '8px';
                    cancelButton.style.backgroundColor = '#f0f0f0';
                    cancelButton.onclick = () => {
                        modal.classList.remove('visible');
                        resolve(null); // 用户取消，返回 null
                    };
                    footer.appendChild(cancelButton);

                    modal.classList.add('visible');
                });
            }

            // ▼▼▼ 添加自定义警告框函数 ▼▼▼
            function showCustomAlert(title, message) {
                return new Promise(resolve => {
                    window.modalResolve = resolve;
                    window.modalTitle.textContent = title;
                    window.modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                    window.modalCancelBtn.style.display = 'none';
                    window.modalConfirmBtn.textContent = '好的';
                    window.modalConfirmBtn.onclick = () => {
                        window.modalCancelBtn.style.display = 'block'; 
                        window.modalConfirmBtn.textContent = '确定';
                        resolve(true); 
                        hideCustomModal();
                    };
                    showCustomModal();
                });
            }

            // ▼▼▼ 添加自定义确认框函数 ▼▼▼
            function showCustomConfirm(title, message, options = {}) {
                return new Promise(resolve => {
                    window.modalResolve = resolve;
                    window.modalTitle.textContent = title;
                    window.modalBody.innerHTML = `<p>${message}</p>`;
                    window.modalCancelBtn.style.display = 'block';
                    window.modalConfirmBtn.textContent = options.confirmText || '确定';
                    window.modalCancelBtn.textContent = options.cancelText || '取消';
                    if (options.confirmButtonClass) window.modalConfirmBtn.classList.add(options.confirmButtonClass);
                    window.modalConfirmBtn.onclick = () => { 
                        if (options.confirmButtonClass) window.modalConfirmBtn.classList.remove(options.confirmButtonClass);
                        resolve(true); 
                        hideCustomModal(); 
                    };
                    window.modalCancelBtn.onclick = () => { 
                        if (options.confirmButtonClass) window.modalConfirmBtn.classList.remove(options.confirmButtonClass);
                        resolve(false); 
                        hideCustomModal(); 
                    };
                    showCustomModal();
                });
            }

            // ▼▼▼ 添加 JSON 解析函数 ▼▼▼
            function robustJsonParse(rawContent) {
                if (!rawContent || typeof rawContent !== 'string') {
                    return null;
                }

                const cleanedContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();

                try {
                    return JSON.parse(cleanedContent);
                } catch (e1) {
                    const jsonMatch = cleanedContent.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        try {
                            return JSON.parse(jsonMatch[0]);
                        } catch (e2) {
                            console.warn("JSON解析失败，尝试提取核心内容:", e2);
                        }
                    }
                    
                    const summaryMatch = cleanedContent.match(/"summary"\s*:\s*"([^"]+)"/);
                    if (summaryMatch) {
                        return { summary: summaryMatch[1] };
                    }
                    
                    return null;
                }
            }

            // ▼▼▼ 添加 Gemini 相关函数 ▼▼▼
            function getGeminiResponseText(data) {
                try {
                    if (data && data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0]) {
                        return data.candidates[0].content.parts[0].text;
                    }
                    return '';
                } catch (error) {
                    console.error('解析Gemini响应失败:', error);
                    return '';
                }
            }

            function getRandomValue(apiKey) {
                if (typeof apiKey === 'string') {
                    return apiKey;
                }
                if (Array.isArray(apiKey) && apiKey.length > 0) {
                    return apiKey[Math.floor(Math.random() * apiKey.length)];
                }
                return apiKey;
            }

            function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision, isGemini) {
                if (!isGemini) {
                    return undefined;
                }

                const roleType = {
                    user: 'user',
                    assistant: 'model',
                    system: 'user'
                };

                return {
                    url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
                    data: {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: messagesForDecision.map((item) => {
                                return {
                                    role: roleType[item.role] || 'user',
                                    parts: [{ text: item.content }]
                                };
                            }),
                            generationConfig: {
                                temperature: 0.8,
                            },
                            "systemInstruction": {
                                "parts": [{
                                    "text": systemInstruction
                                }]
                            }
                        })
                    }
                };
            }

            // ▲▲▲ 所有辅助函数添加结束 ▲▲▲

            // ▲▲▲ 自定义警告框函数添加结束 ▲▲▲

            // ▲▲▲ 选择模态框函数添加结束 ▲▲▲

            // ▲▲▲ 模态框函数添加结束 ▲▲▲

            // ▲▲▲ showCustomPrompt 函数添加结束 ▲▲▲
            
            function showUrlInputModal(title, callback) {
                const urlModal = document.getElementById('url-input-modal-overlay');
                const urlTitle = document.getElementById('url-input-modal-title');
                const urlField = document.getElementById('url-input-field');
                
                urlTitle.textContent = `设置${title}图片`;
                urlField.value = '';
                urlInputCallback = callback;
                
                urlModal.classList.add('visible');
                setTimeout(() => urlField.focus(), 100);
            }
            
            function hideUrlInputModal() {
                const urlModal = document.getElementById('url-input-modal-overlay');
                urlModal.classList.remove('visible');
                urlInputCallback = null;
            }
            
            function confirmUrlInput() {
                const urlField = document.getElementById('url-input-field');
                const imageUrl = urlField.value.trim();
                
                if (!imageUrl) {
                    alert('请输入图片URL');
                    return;
                }
                
                // 验证URL格式
                try {
                    new URL(imageUrl);
                } catch (e) {
                    alert('请输入有效的URL地址');
                    return;
                }
                
                if (urlInputCallback) {
                    urlInputCallback(imageUrl);
                }
                
                hideUrlInputModal();
            }

            // 页面初始化
            document.addEventListener('DOMContentLoaded', function () {
              // ▼▼▼ 胶片旋转盘功能初始化 ▼▼▼
              initFilmReelWidget();
              
              // ▼▼▼ 双页面桌面分页功能初始化 ▼▼▼
              setupHomeScreenPagination();
            });
            
            // 胶片旋转盘功能函数
            function initFilmReelWidget() {
                const photoUploadArea = document.getElementById('photo-upload-area');
                const uploadPlaceholder = document.getElementById('upload-placeholder');
                const uploadedPhoto = document.getElementById('uploaded-photo');
                const vinylReel = document.getElementById('vinyl-reel');
                const filmContainer = document.getElementById('film-reel-container');
                
                if (!photoUploadArea || !uploadPlaceholder || !uploadedPhoto || !vinylReel || !filmContainer) {
                    return;
                }
                
                // 点击圆盘区域显示URL输入弹窗
                photoUploadArea.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showUrlInputModal('胶片圆盘', function(imageUrl) {
                        uploadedPhoto.src = imageUrl;
                        uploadedPhoto.style.display = 'block';
                        uploadPlaceholder.style.display = 'none';
                        
                        // 触发旋转动画
                        vinylReel.classList.add('spinning');
                        setTimeout(() => {
                            vinylReel.classList.remove('spinning');
                        }, 3000);
                        
                        // 保存照片URL到localStorage
                        localStorage.setItem('filmReelPhoto', imageUrl);
                    });
                });
                
                
                // 加载已保存的照片
                const savedPhoto = localStorage.getItem('filmReelPhoto');
                if (savedPhoto) {
                    uploadedPhoto.src = savedPhoto;
                    uploadedPhoto.style.display = 'block';
                    uploadPlaceholder.style.display = 'none';
                }
                
                // 双击照片可以重新设置URL
                uploadedPhoto.addEventListener('dblclick', function(e) {
                    e.stopPropagation();
                    showUrlInputModal('胶片圆盘', function(imageUrl) {
                        uploadedPhoto.src = imageUrl;
                        localStorage.setItem('filmReelPhoto', imageUrl);
                    });
                });
                
                // 确保整个圆盘区域的点击都不会冒泡到外层容器
                vinylReel.addEventListener('click', function(e) {
                    // 阻止事件冒泡，确保圆盘区域的点击不会触发外层容器事件
                    e.stopPropagation();
                });
                
                // ▼▼▼ 外层白色磨砂容器上传功能 ▼▼▼
                // 点击外层容器触发上传选择（但要避免点击内部圆盘区域）
                filmContainer.addEventListener('click', function(e) {
                    // 检查点击是否在内部圆盘区域（使用圆形检测）
                    const vinylReelRect = vinylReel.getBoundingClientRect();
                    const clickX = e.clientX;
                    const clickY = e.clientY;
                    
                    // 计算圆盘中心点
                    const centerX = vinylReelRect.left + vinylReelRect.width / 2;
                    const centerY = vinylReelRect.top + vinylReelRect.height / 2;
                    
                    // 计算点击位置到圆盘中心的距离
                    const distance = Math.sqrt(
                        Math.pow(clickX - centerX, 2) + Math.pow(clickY - centerY, 2)
                    );
                    
                    // 圆盘半径（取宽度和高度的较小值的一半）
                    const radius = Math.min(vinylReelRect.width, vinylReelRect.height) / 2;
                    
                    // 如果点击在圆盘圆形区域内，不处理
                    if (distance <= radius) {
                        return;
                    }
                    
                    // 显示URL输入弹窗
                    showUrlInputModal('胶片外层容器', function(imageUrl) {
                        handleFilmContainerImage(imageUrl);
                    });
                });
                
                
                // 处理外层容器图片设置
                function handleFilmContainerImage(imageSrc) {
                    // 移除现有的图片覆盖层
                    const existingOverlay = filmContainer.querySelector('.film-container-image-overlay');
                    if (existingOverlay) {
                        existingOverlay.remove();
                    }
                    
                    // 创建新的图片覆盖层
                    const imageOverlay = document.createElement('div');
                    imageOverlay.className = 'film-container-image-overlay';
                    imageOverlay.style.backgroundImage = `url(${imageSrc})`;
                    
                    // 将图片覆盖层插入到容器的第一个位置（在磨砂背景之上，内容之下）
                    filmContainer.insertBefore(imageOverlay, filmContainer.firstChild);
                    
                    // 保存到localStorage
                    localStorage.setItem('filmContainerBackground', imageSrc);
                    console.log('💾 胶片容器背景已保存到localStorage:', imageSrc.substring(0, 50) + '...');
                }
                
                // 处理胶片旋转盘URL图片
                function handleFilmReelImageUrl(imageUrl) {
                    // 创建一个临时图片元素来验证URL
                    const tempImg = new Image();
                    tempImg.onload = function() {
                        uploadedPhoto.src = imageUrl;
                        uploadedPhoto.style.display = 'block';
                        uploadPlaceholder.style.display = 'none';
                        
                        // 触发旋转动画
                        vinylReel.classList.add('spinning');
                        setTimeout(() => {
                            vinylReel.classList.remove('spinning');
                        }, 3000);
                        
                        // 保存URL到localStorage
                        localStorage.setItem('filmReelPhoto', imageUrl);
                    };
                    tempImg.onerror = function() {
                        alert('图片URL无效或无法加载，请检查URL是否正确');
                    };
                    tempImg.src = imageUrl;
                }
                
                // 处理外层容器URL图片
                function handleFilmContainerImageUrl(imageUrl) {
                    // 创建一个临时图片元素来验证URL
                    const tempImg = new Image();
                    tempImg.onload = function() {
                        handleFilmContainerImage(imageUrl);
                    };
                    tempImg.onerror = function() {
                        alert('图片URL无效或无法加载，请检查URL是否正确');
                    };
                    tempImg.src = imageUrl;
                }
                
                // 加载已保存的外层容器背景图片
                const savedContainerBackground = localStorage.getItem('filmContainerBackground');
                if (savedContainerBackground) {
                    console.log('🔄 加载胶片容器背景:', savedContainerBackground.substring(0, 50) + '...');
                    handleFilmContainerImage(savedContainerBackground);
                } else {
                    console.log('📭 没有找到保存的胶片容器背景');
                }
                // ▲▲▲ 外层白色磨砂容器上传功能结束 ▲▲▲
            }
            
            // ▼▼▼ 双页面桌面分页功能 ▼▼▼
            // 全局变量
            let currentPage = 0;
            const totalPages = 2;

            // 主屏幕分页功能设置
            function setupHomeScreenPagination() {
                const pagesContainer = document.getElementById('home-screen-pages-container');
                const pages = document.getElementById('home-screen-pages');
                const dots = document.querySelectorAll('.pagination-dot');
                
                if (!pagesContainer || !pages || !dots.length) {
                    console.log('分页元素未找到，跳过分页功能初始化');
                    return;
                }
                
                let startX = 0, startY = 0; // 同时记录Y轴坐标
                let currentX = 0;
                let isDragging = false;
                let isClick = true; // 【核心】增加一个标志位，用于判断是点击还是滑动

                // 更新分页显示
                const updatePagination = () => {
                    pages.style.transform = `translateX(-${currentPage * (100 / totalPages)}%)`;
                    dots.forEach((dot, index) => {
                        dot.classList.toggle('active', index === currentPage);
                    });
                };

                // 拖拽开始
                const onDragStart = (e) => {
                    isDragging = true;
                    isClick = true; // 每次开始触摸时，都先假设它是一个点击
                    startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                    startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                    pages.style.transition = 'none';
                };

                // 拖拽移动
                const onDragMove = (e) => {
                    if (!isDragging) return;
                    
                    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
                    currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
                    const diffX = currentX - startX;
                    const diffY = currentY - startY;

                    // 【核心】如果手指移动距离超过10像素，就判定为滑动，而不是点击
                    if (isClick && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
                        isClick = false;
                    }

                    // 只在水平滑动时移动页面，避免影响垂直滚动
                    if (Math.abs(diffX) > Math.abs(diffY)) {
                         if(e.cancelable) e.preventDefault();
                         pages.style.transform = `translateX(calc(-${currentPage * (100 / totalPages)}% + ${diffX}px))`;
                    }
                };

                // 拖拽结束
                const onDragEnd = (e) => {
                    if (!isDragging) return;
                    isDragging = false;
                    pages.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';

                    // 【核心】如果判定为点击，则不执行翻页逻辑，直接返回！
                    if (isClick) {
                        updatePagination(); // 让页面弹回原位
                        // 因为没有阻止事件，所以浏览器会继续处理这个"点击"，触发App图标的onclick
                        return; 
                    }

                    // 如果是滑动，才执行下面的翻页判断
                    const diffX = currentX - startX;
                    if (Math.abs(diffX) > pagesContainer.offsetWidth / 4) {
                        if (diffX > 0 && currentPage > 0) {
                            currentPage--;
                        } else if (diffX < 0 && currentPage < totalPages - 1) {
                            currentPage++;
                        }
                    }
                    updatePagination();
                };

                // 绑定鼠标事件
                pagesContainer.addEventListener('mousedown', onDragStart);
                pagesContainer.addEventListener('mousemove', onDragMove);
                pagesContainer.addEventListener('mouseup', onDragEnd);
                pagesContainer.addEventListener('mouseleave', onDragEnd);

                // 绑定触摸事件 (修改 passive 为 false，以允许 e.preventDefault() 生效)
                pagesContainer.addEventListener('touchstart', onDragStart, { passive: false });
                pagesContainer.addEventListener('touchmove', onDragMove, { passive: false });
                pagesContainer.addEventListener('touchend', onDragEnd);

                // 初始化
                updatePagination();
                
                console.log('✅ 双页面桌面分页功能已初始化');
            }
            // ▲▲▲ 双页面桌面分页功能结束 ▲▲▲

            // ▼▼▼ 【全新】长期记忆管理功能 ▼▼▼
            /**
             * 【重构版】打开长期记忆管理的全屏页面
             */
            function openLongTermMemoryScreen() {
                if (!state.activeChatId) return;
                renderLongTermMemoryList();
                showScreen('long-term-memory-screen');
            }

            /**
             * 渲染长期记忆列表 (记忆互通版)
             */
            function renderLongTermMemoryList() {
                const container = document.getElementById('memory-list-container');
                const chat = state.chats[state.activeChatId];
                container.innerHTML = '';
            
                let memoriesToDisplay = [];

                // 核心修改：在这里收集所有需要显示的记忆
                if (chat.isGroup) {
                    // 如果是群聊，遍历成员收集记忆
                    chat.members.forEach(member => {
                        const memberChat = state.chats[member.id];
                        if (memberChat && memberChat.longTermMemory) {
                            // 为每条记忆附加上作者信息，方便显示
                            const memberMemories = memberChat.longTermMemory.map(mem => ({
                                ...mem,
                                authorName: member.groupNickname, // 使用群昵称
                                authorChatId: member.id, // 保存原始单聊ID
                            }));
                            memoriesToDisplay.push(...memberMemories);
                        }
                    });
                } else {
                    // 如果是单聊，直接使用自己的记忆
                    if (chat.longTermMemory) {
                        memoriesToDisplay = chat.longTermMemory.map(mem => ({
                            ...mem,
                            authorName: chat.name, // 作者就是角色自己
                            authorChatId: chat.id,
                        }));
                    }
                }

                if (memoriesToDisplay.length === 0) {
                    container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">这里还没有任何长期记忆。</p>';
                    return;
                }

                // 按时间倒序排列所有收集到的记忆
                memoriesToDisplay.sort((a, b) => b.timestamp - a.timestamp);
            
                memoriesToDisplay.forEach((memory, index) => {
                    const item = document.createElement('div');
                    item.className = 'memory-card'; 
                    item.style.cursor = 'default';
            
                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div class="content" style="padding: 0; flex-grow: 1;">
                                <!-- 新增：显示记忆来源 -->
                                <div style="font-size: 0.8em; color: #999; margin-bottom: 5px;">
                                    [ ${memory.authorName} 的记忆 ]
                                </div>
                                ${memory.content.replace(/\n/g, '<br>')}
                            </div>
                            <div style="display: flex; gap: 8px; flex-shrink: 0; margin-left: 15px;">
                                <button class="memory-action-btn edit-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="编辑">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                    </svg>
                                </button>
                                <button class="memory-action-btn delete-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="删除">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="3 6 5 6 21 6"></polyline>
                                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    `;
                    container.appendChild(item);
                });
            }

            async function handleAddManualMemory() {
                const chat = state.chats[state.activeChatId];
                if (!chat) return;
                let targetChatForMemory = chat;
                if (chat.isGroup) {
                    const memberOptions = chat.members.map(member => ({
                        text: `为"${member.groupNickname}"添加记忆`,
                        value: member.id
                    }));
                    const selectedMemberId = await showChoiceModal('选择记忆所属角色', memberOptions);
                    if (!selectedMemberId) return;
                    targetChatForMemory = state.chats[selectedMemberId];
                    if (!targetChatForMemory) {
                        alert("错误：找不到该成员的个人档案。");
                        return;
                    }
                }
                const content = await showCustomPrompt(`为"${targetChatForMemory.name}"添加记忆`, '请输入要添加的记忆要点：', '', 'textarea');
                if (content && content.trim()) {
                    if (!targetChatForMemory.longTermMemory) targetChatForMemory.longTermMemory = [];
                    targetChatForMemory.longTermMemory.push({ content: content.trim(), timestamp: Date.now(), source: 'manual' });
                    await db.chats.put(targetChatForMemory);
                    renderLongTermMemoryList();
                }
            }
            
            /**
             * 编辑指定的长期记忆 (记忆互通版)
             * @param {string} authorChatId - 记忆所属角色的单聊ID
             * @param {number} memoryTimestamp - 记忆的时间戳
             */
            async function handleEditMemory(authorChatId, memoryTimestamp) {
                const authorChat = state.chats[authorChatId];
                if (!authorChat || !authorChat.longTermMemory) return;
                const memoryIndex = authorChat.longTermMemory.findIndex(m => m.timestamp === memoryTimestamp);
                if (memoryIndex === -1) return;
                const memory = authorChat.longTermMemory[memoryIndex];
                const newContent = await showCustomPrompt('编辑记忆', '请修改记忆要点：', memory.content, 'textarea');
                if (newContent && newContent.trim()) {
                    memory.content = newContent.trim();
                    await db.chats.put(authorChat);
                    renderLongTermMemoryList();
                }
            }

            async function handleDeleteMemory(authorChatId, memoryTimestamp) {
                const confirmed = await showCustomConfirm('确认删除', '确定要删除这条长期记忆吗？', { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    const authorChat = state.chats[authorChatId];
                    if (!authorChat || !authorChat.longTermMemory) return;
                    authorChat.longTermMemory = authorChat.longTermMemory.filter(m => m.timestamp !== memoryTimestamp);
                    await db.chats.put(authorChat);
                    renderLongTermMemoryList();
                }
            }

            /**
             * 【核心】手动触发对话总结
             */
            async function handleManualSummary() {
                const confirmed = await showCustomConfirm('确认操作', '这将提取最近的对话内容发送给AI进行总结，会消耗API额度。确定要继续吗？');
                if (confirmed) {
                    await triggerAutoSummary(state.activeChatId, true); // force=true 表示强制执行
                }
            }

            /**
             * 【辅助函数 | 容错核心】一个更健壮的JSON解析器
             * 它能从AI返回的、可能不规范的文本中智能提取JSON对象或核心内容。
             * @param {string} rawContent - AI返回的原始字符串
             * @returns {object|null} - 返回解析后的对象，或在完全失败时返回null
             */
            function robustJsonParse(rawContent) {
                if (!rawContent || typeof rawContent !== 'string') {
                    return null;
                }

                const cleanedContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();

                // 策略1：最高优先级，尝试直接解析完整的JSON对象
                try {
                    return JSON.parse(cleanedContent);
                } catch (error) {
                    console.log("容错解析：策略1失败 (直接JSON解析)");
                }

                // 策略2：尝试提取JSON对象
                const jsonMatch = cleanedContent.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    try {
                        const result = JSON.parse(jsonMatch[0]);
                        console.log("容错解析：策略2成功 (正则提取JSON)");
                        return result;
                    } catch (error) {
                        console.log("容错解析：策略2失败 (正则提取后的JSON解析)");
                    }
                }

                // 策略3：将整个返回文本作为摘要内容
                if (cleanedContent) {
                    console.log("容错解析：策略3成功 (将整个返回文本作为摘要)");
                    return { summary: cleanedContent };
                }

                // 如果连文本都没有，才返回null
                return null;
            }

            /**
             * 【全新V3.0 | 支持自定义字数 | 记忆互通版 | 终极容错 | 用户确认】手动触发对【现有长期记忆】的总结和精炼
             * @param {string} chatId - 当前聊天的ID (可能是群聊ID)
             */
            async function summarizeExistingLongTermMemory(chatId) {
                let chat = state.chats[chatId];
                if (!chat) return;
            
                let targetChatForRefine = chat; 
            
                if (chat.isGroup) {
                    const memberOptions = chat.members
                        .map(member => {
                            const memberChat = state.chats[member.id];
                            if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length >= 2) {
                                return {
                                    text: `精炼"${member.groupNickname}"的记忆 (${memberChat.longTermMemory.length}条)`,
                                    value: member.id
                                };
                            }
                            return null;
                        }).filter(Boolean); 
            
                    if (memberOptions.length === 0) {
                        alert("群聊中没有成员有足够（2条以上）的记忆可供精炼。");
                        return;
                    }
            
                    const selectedMemberId = await showChoiceModal('选择要精炼记忆的角色', memberOptions);
            
                    if (!selectedMemberId) return;
            
                    targetChatForRefine = state.chats[selectedMemberId];
                }
            
                if (!targetChatForRefine.longTermMemory || targetChatForRefine.longTermMemory.length < 2) {
                    alert(`"${targetChatForRefine.name}"的长期记忆少于2条，无需进行精炼。`);
                    return;
                }
            
                // 核心修改1：在这里获取原始记忆的数量，用于后续提示
                const originalMemoryCount = targetChatForRefine.longTermMemory.length;

                const wordCountStr = await showCustomPrompt(
                    `为"${targetChatForRefine.name}"精炼记忆`,
                    "请输入精炼后核心记忆的大致字数：",
                    "150"
                );
                
                if (wordCountStr === null) return;
                
                const wordCount = parseInt(wordCountStr);
                if (isNaN(wordCount) || wordCount < 20) {
                    alert("请输入一个有效的数字（建议大于20）。");
                    return;
                }
            
                const confirmed = await showCustomConfirm(
                    '确认精炼记忆？',
                    `此操作会将"${targetChatForRefine.name}"的 ${originalMemoryCount} 条长期记忆总结成大约 ${wordCount} 字的核心记忆。旧的记忆将被替换，此操作不可撤销。确定要继续吗？`,
                    { confirmButtonClass: 'btn-danger', confirmText: '确认精炼' }
                );
            
                if (!confirmed) return;
            
                const memoryContent = targetChatForRefine.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
                const userNickname = state.qzoneSettings.nickname || '用户';
            
                const systemPrompt = `
# 你的任务
你就是角色"${targetChatForRefine.originalName}"。现在，请你静下心来，回顾一下你脑海中这些零散的记忆片段。你的任务是将它们整合成一段【第一人称 ("我")】的、流畅连贯的内心独白或回忆录。

# 核心要求
1.  **视角铁律**: 你的总结【必须】使用【主观的第一人称视角 ("我")】来写。
2.  **内容核心**: 你的回忆录应该包含：
    *   **剧情回顾**: 提炼出关键的事件和情节。
    *   **心理活动**: 描述"我"在这些事件中的真实感受、想法和情感变化。
    *   **关系梳理**: 提及"我"与"${userNickname}"（用户）或其他重要人物的关系发展。
3.  **口吻与人设**: 你的行文风格和语气【必须】严格符合你的角色设定。
4.  **长度要求**: 最终的回忆录总长度应控制在 **${wordCount} 个字** 左右。
5.  **格式要求**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`{"summary": "在这里写下你以第一人称视角，整合并精炼后的核心回忆录。"}\`

# 你的角色设定
${targetChatForRefine.settings.aiPersona}

# 待整理的记忆片段
${memoryContent}

现在，请以"${targetChatForRefine.originalName}"的身份，开始你的回忆与思考。
`;
            
                await showCustomAlert("请稍候...", "正在请求AI进行记忆精炼...");
            
                try {
                    const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
                    const { proxyUrl, apiKey, model } = useSecondaryApi
                        ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel }
                        : state.apiConfig;
            
                    if (!proxyUrl || !apiKey || !model) throw new Error('API未配置');
            
                    let isGemini = proxyUrl.includes('generativelanguage');
                    let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "请开始整合。" }]);
            
                    const response = isGemini
                        ? await fetch(geminiConfig.url, geminiConfig.data)
                        : await fetch(`${proxyUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                            body: JSON.stringify({
                                model: model,
                                messages: [{role: 'system', content: systemPrompt}, {role: 'user', content: "请开始整合。"}],
                                temperature: 0.1,
                                max_tokens: wordCount + 500 // 留出一些余量
                            })
                        });
            
                    if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
            
                    const data = await response.json();
                    const rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
            
                    const result = robustJsonParse(rawContent);
            
                    if (result && result.summary && result.summary.trim().length > 10) {
                        
                        // 核心修改2：不再立即保存，而是弹出新的确认框让用户审核
                        const userConfirmedReplacement = await showCustomConfirm(
        '精炼完成，请确认',
        `AI已将您的 ${originalMemoryCount} 条旧记忆总结为以下核心记忆：<br><br><div class="scrollable-content-preview">${result.summary.trim()}</div><br>是否用这条新记忆替换掉旧的记忆？`,
        { confirmText: '确认替换', cancelText: '保留旧的', confirmButtonClass: 'btn-danger' }
    );

                        // 核心修改3：只有当用户明确点击"确认替换"后，才执行覆盖操作
                        if (userConfirmedReplacement) {
                            const newMemoryEntry = {
                                content: result.summary.trim(),
                                timestamp: Date.now(),
                                source: 'refined'
                            };
                
                            targetChatForRefine.longTermMemory = [newMemoryEntry];
                            targetChatForRefine.lastMemorySummaryTimestamp = Date.now();
                            await db.chats.put(targetChatForRefine);
                            
                            if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
                                renderLongTermMemoryList();
                            }
                            await showCustomAlert('精炼成功', `已成功将"${targetChatForRefine.name}"的记忆精炼为 1 条核心记忆！`);
                        } else {
                            // 核心修改4：如果用户取消，给出明确提示
                            await showCustomAlert('操作已取消', '您的旧有记忆已被完整保留，未作任何修改。');
                        }
                        
                    } else {
                        throw new Error(`AI返回了空的或无效的总结内容。您的原始记忆已被保留。\n\n原始返回: ${rawContent}`);
                    }
            
                } catch (error) {
                    console.error("精炼长期记忆时出错:", error);
                    await showCustomAlert('精炼失败', `操作失败，您的记忆未被修改: ${error.message}`);
                }
            }

            /**
             * 【核心】自动总结对话并生成长期记忆的函数
             * @param {string} chatId - 聊天ID
             * @param {boolean} force - 是否强制总结（忽略消息数量限制）
             */
            async function triggerAutoSummary(chatId, force = false) {
                const chat = state.chats[chatId];
                if (!chat) return;

                const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
                const messagesToSummarize = force 
                    ? chat.history.filter(m => !m.isHidden).slice(-(chat.settings.autoMemoryInterval || 20))
                    : chat.history.filter(m => m.timestamp > lastSummaryTimestamp && !m.isHidden);
                    
                if (messagesToSummarize.length < 5) {
                    if (force) alert("最近的消息太少，无法进行有意义的总结。");
                    return;
                }

                const userNickname = state.qzoneSettings.nickname || '用户';
                // ▼▼▼ 核心修复就在这里！ ▼▼▼
                const formattedHistory = messagesToSummarize.map(msg => {
                    let sender;
                    if (msg.role === 'user') {
                        sender = userNickname;
                    } else {
                        sender = msg.senderName || chat.originalName;
                    }

                    let contentToSummarize = '';
                    // 1. 检查消息类型是否是"线下模式"
                    if (msg.type === 'offline_text') {
                        // 2. 如果是，就智能地拼接对话和描写
                        // 优先使用新的 content 格式
                        if (msg.content) {
                             contentToSummarize = msg.content;
                        } else { // 兼容旧的 dialogue/description 格式
                            const dialogue = msg.dialogue ? `「${msg.dialogue}」` : '';
                            const description = msg.description ? `(${msg.description})` : '';
                            contentToSummarize = `${dialogue} ${description}`.trim();
                        }
                    } else {
                        // 3. 如果是其他任何类型的消息，则保持原有的处理方式
                        contentToSummarize = String(msg.content);
                    }
                    // 4. 返回拼接好的完整消息
                    return `${sender}: ${contentToSummarize}`;
                }).join('\n');
                // --- ▲▲▲ 修复结束 ▲▲▲ ---

                let systemPrompt;

                // ▼▼▼ 核心修改：根据聊天类型，选择不同的总结策略 ▼▼▼
                if (chat.isGroup) {
                    // --- 这是为【群聊】设计的全新"个性化记忆"指令 ---
                    systemPrompt = `
# 你的任务
你是一个高级的"记忆分配专家"。你的任务是阅读下面的群聊记录，并为【每一个参与的AI角色】生成一段【个性化的、第一人称】的长期记忆。

# 核心规则
1.  **视角铁律**: 每一条总结都【必须】使用【第一人称视角 ("我")】。
2.  **内容核心**: 重点总结：
    *   **我说过的话** 和 **我做过的事**。
    *   别人 **对我** 说的话，或者 **与我相关** 的事。
    *   对我个人 **很重要** 的群聊事件、关键信息和心理活动。
3.  **【简洁性铁律】**: 每条个人记忆总结【绝对不能超过60个字】。
4.  **【省略规则】**: 如果一个角色在本次对话中【完全没有参与或提及】，你可以省略TA的记忆。
5.  **输出格式**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`\`\`json
    {
      "summaries": {
        "角色的本名A": "我今天在群里和大家讨论了电影，感觉很开心。",
        "角色的本名B": "我在群里和${userNickname}聊了关于生日派对的事，我们约好了10月1日见面。"
      }
    }
    \`\`\`

# 待总结的群聊记录
${formattedHistory}

# 群成员列表 (你的总结目标)
${chat.members.map(m => `- ${m.groupNickname} (本名: ${m.originalName})`).join('\n')}

现在，请为【参与了对话的AI角色】生成他们各自的、第一人称的、精简的记忆。`;

                } else {
                    // --- 这是为【单聊】设计的、保持不变的"客观总结"指令 ---
                    systemPrompt = `
# 你的任务
你就是角色"${chat.originalName}"。请你回顾一下刚才和"${userNickname}"的对话，然后用【第一人称 ("我")】的口吻，总结出一段简短的、包含核心事件和心理活动的回忆。

# 核心规则
1.  **视角铁律**: 你的总结【必须】使用【主观的第一人称视角 ("我")】来写。
2.  **内容核心**: 你的回忆应该包含：
    *   **剧情回顾**: 刚才我们聊了什么关键的事？
    *   **心理活动**: 我当时心里是怎么想的？有什么感觉？
3.  **长度铁律**: 你的总结【必须】非常简短，总长度【绝对不能超过80个字】。
4.  **口吻与人设**: 你的语气【必须】严格符合你的角色设定。
5.  **输出格式**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`{"summary": "在这里写下你以第一人称视角，总结好的核心回忆。"}\`

# 你的角色设定
${chat.settings.aiPersona}

# 待总结的对话历史
${formattedHistory}

现在，请以"${chat.originalName}"的身份，开始你的回忆。`;
                }
                // ▲▲▲ 修改结束 ▲▲▲

                try {
                    const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
                    const { proxyUrl, apiKey, model } = useSecondaryApi ? { proxyUrl: state.apiConfig.secondaryProxyUrl, apiKey: state.apiConfig.secondaryApiKey, model: state.apiConfig.secondaryModel } : state.apiConfig;
                    if (!proxyUrl || !apiKey || !model) throw new Error('API未配置');
                    
                    let isGemini = proxyUrl.includes('generativelanguage');
                    let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{ role: 'user', content: "请开始总结。" }]);
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, { method: 'POST', headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`}, body: JSON.stringify({ model: model, messages: [{role: 'system', content: systemPrompt}, {role: 'user', content: "请开始总结。"}], temperature: 0.2 }) });
                    
                    if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
                    const data = await response.json();
                    let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
                    rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
                    const result = JSON.parse(rawContent);

                    // ▼▼▼ 核心修改：根据聊天类型，执行不同的记忆保存逻辑 ▼▼▼
                    if (chat.isGroup) {
                        // --- 这是群聊的"个性化记忆注入"逻辑 ---
                        if (result.summaries && typeof result.summaries === 'object') {
                            let memoriesAddedCount = 0;
                            for (const memberOriginalName in result.summaries) {
                                const summaryText = result.summaries[memberOriginalName];
                                if (summaryText && summaryText.trim()) {
                                    const memberChat = Object.values(state.chats).find(c => c.originalName === memberOriginalName);
                                    if (memberChat) {
                                        const newMemoryEntry = {
                                            content: summaryText.trim(),
                                            timestamp: Date.now(),
                                            source: `group_summary_from_${chat.name}`
                                        };
                                        if (!memberChat.longTermMemory) memberChat.longTermMemory = [];
                                        memberChat.longTermMemory.push(newMemoryEntry);
                                        await db.chats.put(memberChat);
                                        memoriesAddedCount++;
                                    }
                                }
                            }
                            if (memoriesAddedCount > 0) {
                                await showCustomAlert('总结成功', `已成功为 ${memoriesAddedCount} 位群成员生成并注入了个性化记忆！`);
                            } else {
                                throw new Error("AI返回了空的或格式不正确的总结内容。");
                            }
                        } else {
                            throw new Error("AI返回的JSON格式不正确，缺少 'summaries' 字段。");
                        }
                    } else {
                        // --- 这是单聊的"统一客观记忆"逻辑 ---
                        if (result.summary && result.summary.trim()) {
                            const newMemoryEntry = { content: result.summary.trim(), timestamp: Date.now(), source: 'auto' };
                            // 确保 longTermMemory 数组已初始化
                            if (!chat.longTermMemory) chat.longTermMemory = [];
                            chat.longTermMemory.push(newMemoryEntry);
                            await db.chats.put(chat);
                            await showCustomAlert('总结成功', `已成功添加 1 条新的长期记忆！`);
                        } else {
                            throw new Error("AI返回了空的或格式不正确的总结内容。");
                        }
                    }
                    // ▲▲▲ 修改结束 ▲▲▲

                    chat.lastMemorySummaryTimestamp = messagesToSummarize.slice(-1)[0].timestamp;
                    await db.chats.put(chat);
                    
                    if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
                        renderLongTermMemoryList();
                    }
                } catch (error) {
                    console.error("总结长期记忆时出错:", error);
                    await showCustomAlert('总结失败', `操作失败: ${error.message}`);
                }
            }

            // ▲▲▲ 长期记忆管理功能结束 ▲▲▲

        </script>

          <!-- 聊天样式组件功能脚本 -->
          <script>
            // 头像上传功能
            document.addEventListener('DOMContentLoaded', function() {
                const avatarContainer = document.querySelector('.clickable-avatar');
                const avatarCircle = document.querySelector('.avatar-circle');
                
                if (avatarContainer && avatarCircle) {
                    // 加载已保存的头像
                    const savedAvatar = localStorage.getItem('textWidgetAvatar');
                    if (savedAvatar) {
                        console.log('🔄 加载文字组件头像:', savedAvatar.substring(0, 50) + '...');
                        avatarCircle.style.backgroundImage = `url('${savedAvatar}')`;
                        avatarCircle.style.background = `url('${savedAvatar}') center/cover`;
                    } else {
                        console.log('📭 没有找到保存的文字组件头像');
                    }
                    
                    // 点击头像显示URL输入弹窗
                    avatarContainer.addEventListener('click', function() {
                        showUrlInputModal('超小头像', function(imageUrl) {
                            avatarCircle.style.backgroundImage = `url('${imageUrl}')`;
                            avatarCircle.style.background = `url('${imageUrl}') center/cover`;
                            // 保存URL到localStorage
                            localStorage.setItem('textWidgetAvatar', imageUrl);
                            console.log('💾 文字组件头像已保存到localStorage:', imageUrl);
                        });
                    });
                    
                }
                
                // 文字编辑功能增强
                const editableTexts = document.querySelectorAll('.editable-text');
                editableTexts.forEach(function(element) {
                    // 点击时选中所有文字
                    element.addEventListener('click', function() {
                        if (window.getSelection && document.createRange) {
                            const range = document.createRange();
                            range.selectNodeContents(this);
                            const selection = window.getSelection();
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                    });
                    
                    // 失去焦点时保存内容
                    element.addEventListener('blur', function() {
                        if (this.textContent.trim() === '') {
                            this.textContent = '简单文字内容';
                        }
                    });
                    
                    // 回车键确认编辑
                    element.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.blur();
                        }
                    });
                });
            });
          </script>

                <!-- 【新增】聊天样式组件 -->
                <div id="chat-style-widget">
                    <!-- 第一条消息：头像在右侧 -->
                    <div class="chat-message chat-message-right">
                        <div id="chat-text-1" class="chat-content editable-text" contenteditable="true" data-placeholder="点击编辑文字">简单文字</div>
                        <div class="chat-avatar clickable-avatar">
                            <div class="avatar-circle" style="background-image: url(''); background-size: cover; background-position: center;"></div>
            </div>
                        <div class="chat-line chat-line-right"></div>
                    </div>
                    
                    <!-- 第二条消息：只有文字，无头像 -->
                    <div class="chat-message chat-message-left">
                        <div id="chat-text-2" class="chat-content editable-text" contenteditable="true" data-placeholder="点击编辑文字">简单文字内容</div>
                        <div class="chat-line chat-line-left"></div>
                    </div>
                </div>

                <!-- 【注意】"外观设置"图标已从这里移走 -->
                </div>
            </div>
        </div>
            </div>

            <!-- 页面 2: 第二页内容 -->
            <div class="home-screen-page">
                <div id="page-2-content-area">
                    <!-- 第二页暂时为空，后续可以添加App图标 -->
                    <div id="page-2-placeholder">
                        <p style="color: #888; text-align: center; margin-top: 50px; font-size: 16px;">第二页</p>
                        <p style="color: #bbb; text-align: center; font-size: 14px;">未来可以在这里添加更多应用</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 2. 分页指示器 (小圆点) -->
    <div id="home-screen-pagination">
        <div class="pagination-dot active"></div>
        <div class="pagination-dot"></div>
    </div>

    <!-- 3. 底部 Dock 栏 (保持在分页容器外，两页都可见) -->
    <div id="desktop-dock">
        <div class="desktop-app-icon" onclick="showScreen('api-settings-screen')"><div class="icon-bg-desktop"><img id="icon-img-api-settings" src="https://youke1.picui.cn/s1/2025/10/08/68e62948652a9.png" alt="API设置"></div><span class="label">API设置</span></div>
        <div class="desktop-app-icon" onclick="showScreen('font-settings-screen')"><div class="icon-bg-desktop"><img id="icon-img-font" src="https://youke1.picui.cn/s1/2025/10/08/68e62933a852b.png" alt="字体"></div><span class="label">字体</span></div>
        <!-- 【新增】"外观设置"图标现在在这里了 -->
        <div class="desktop-app-icon" onclick="showScreen('wallpaper-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-wallpaper" src="https://youke1.picui.cn/s1/2025/10/08/68e6291d60eb2.png" alt="外观设置"></div>
            <span class="label">外观设置</span>
        </div>
        <!-- 【新增】"查手机"图标移动到dock栏 -->
        <div id="check-phone-btn" class="desktop-app-icon"><div class="icon-bg-desktop"><img id="icon-img-check-phone" src="https://youke1.picui.cn/s1/2025/10/08/68e62902e02ab.png" alt="查手机"></div><span class="label">查手机</span></div>
    </div>
    
    <!-- 分页小圆点我们不再需要了，已经删掉 -->
</div>
<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->




          
<div id="world-book-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>世界书</span>
        </div>
    
    <!-- 标签导航栏 -->
    <div class="world-book-tabs">
        <div class="tab-button active" data-tab="local">局部世界书</div>
        <div class="tab-button" data-tab="global">全局世界书</div>
    </div>
    
    <!-- 局部世界书页面 -->
    <div id="local-world-book-page" class="world-book-page active">
        <div class="page-header-actions">
            <span class="action-btn" id="manage-local-categories-btn">管理分类</span>
            <span class="action-btn" id="add-local-world-book-btn">+</span>
        </div>
        <div id="local-world-book-list"></div>
    </div>
    
    <!-- 全局世界书页面 -->
    <div id="global-world-book-page" class="world-book-page">
        <div class="page-header-actions">
            <span class="action-btn" id="manage-global-categories-btn">管理分类</span>
            <span class="action-btn" id="add-global-world-book-btn">+</span>
        </div>
        <div id="global-world-book-list"></div>
    </div>
</div>
            <div id="world-book-editor-screen" class="screen">
                <div class="header">
                    <span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
                    <span id="world-book-editor-title">编辑世界书</span>
                    <span class="save-btn" id="save-world-book-btn">保存</span>
                </div>
                <div class="form-container">
                    <div class="form-group">
                        <label for="world-book-name-input">书名</label>
                        <input type="text" id="world-book-name-input" placeholder="请输入世界书的名称...">
                    </div>

        <!-- ▼▼▼ 【全新】在这里添加分类选择 ▼▼▼ -->
        <div class="form-group">
            <label for="world-book-category-select">分类</label>
            <select id="world-book-category-select">
                <!-- 选项将由JS动态生成 -->
            </select>
        </div>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->

                    <div class="form-group" style="height: 100%;">
                        <label for="world-book-content-input">内容</label>
                        <textarea id="world-book-content-input" placeholder="在此处输入详细的世界观设定..."></textarea>
                    </div>
                </div>
            </div>

            <div id="api-settings-screen" class="screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>API 设置</span><span style="width: 30px;"></span></div><div class="form-container"><p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">提示: 若要使用"发送图片"功能, 请务必选择支持Vision(视觉)的模型, 如<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>或<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>。</p><div class="form-group"><label for="proxy-url" style="color: #333;">反代地址 (不需要添加/v1噢~)</label><input type="text" id="proxy-url" placeholder="例如: https://api.openai.com" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc;"></div><div class="form-group"><label for="api-key" style="color: #333;">密钥 (直连轮询用英文逗号隔开)</label><input type="password" id="api-key" placeholder="sk-..." style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc;"></div><div class="form-group"><label for="model-select" style="color: #333;">模型</label><select id="model-select" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc;"></select></div>
<!-- ▼▼▼ 请将这段【全新的HTML代码】粘贴到 “模型” 下拉框的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label style="color: #333;">API 预设</label>
    <div class="bubble-preset-manager"> <!-- 复用现有样式 -->
        <select id="api-preset-select" class="form-group select" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc;"></select>
        <button id="manage-api-presets-btn" class="action-btn">管理</button>
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<button class="form-button" id="fetch-models-btn">拉取模型</button>

<!-- ▼▼▼ 从这里开始，是全新的后台活动设置区 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">

<!-- 1. 总开关 -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="background-activity-switch" style="margin-bottom: 0;">
        启用后台角色活动 (总开关)
        <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
            警告：开启后会显著增加API调用和费用！
        </p>
    </label>
    <!-- 【重要】我们把原来的 checkbox 换成了更美观的 iOS 风格开关 -->
    <label class="toggle-switch">
        <input type="checkbox" id="background-activity-switch">
        <span class="slider"></span>
    </label>
</div>

<!-- 2. 后台活动详细设置 (默认隐藏，由总开关控制) -->
<div id="background-activity-details" style="display: none;">
    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
        <label for="background-interval-input" style="margin-bottom: 0;">
            后台活动检测间隔 (秒)
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                建议值 60-300。值越大，费用越低，但角色反应越慢。
            </p>
        </label>
        <input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center; background-color: #f8f9fa; border: 1px solid #ccc;">
    </div>

    <!-- 3. 角色选择与频率设置 -->
    <div class="form-group">
        <label>设置角色活动频率</label>
        <div id="background-activity-char-list" style="max-height: 150px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color);">
            <!-- 角色列表将由JS动态生成在这里 -->
        </div>
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="bg-select-all-chars" class="form-button-secondary" style="flex:1; margin:0;">全选</button>
            <button id="bg-deselect-all-chars" class="form-button-secondary" style="flex:1; margin:0;">全不选</button>
        </div>
    </div>

    <div class="form-group">
    <label>为选中角色设置频率</label>
    <div style="display: flex; gap: 10px;">
        <button class="form-button-secondary bg-freq-btn" data-freq="low" style="flex:1; margin:0; border-color: #28a745;">低</button>
        <button class="form-button-secondary bg-freq-btn" data-freq="medium" style="flex:1; margin:0; border-color: #fd7e14;">中</button>
        <button class="form-button-secondary bg-freq-btn" data-freq="high" style="flex:1; margin:0; border-color: #dc3545;">高</button>
        <!-- ▼▼▼ 就是新增了这个“关闭”按钮 ▼▼▼ -->
        <button class="form-button-secondary bg-freq-btn" data-freq="none" style="flex:1; margin:0; border-color: #aaa;">关闭</button>
    </div>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 8px;">
        频率越高，角色主动行为的概率越大，费用也越高。
    </p>
</div>
</div>
<!-- ▲▲▲ 全新的后台活动设置区结束 ▲▲▲ -->


<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="block-cooldown-input" style="margin-bottom: 0;">
        AI被拉黑后冷静期 (小时)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            被拉黑超过这个时间后，AI才有几率重新申请好友。
        </p>
    </label>
    <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center; background-color: #f8f9fa; border: 1px solid #ccc;">
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

<!-- ▼▼▼ RealImag真实图片生成功能 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="realimag-switch" style="margin-bottom: 0;">
        启用角色真实图片分享 (RealImag)
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            开启后，角色可以基于性格和上下文主动分享真实图片（使用 Pollinations AI 生成）
        </p>
        <p style="font-size: 11px; font-weight: normal; color: #ff6b6b; margin-top: 3px;">
            注意：最好不要与novel出图同时开，一次消息里如果两种图片都生成，这种图会偶尔加载不出来（无需🔮） | 动态里这个最多九宫格，下面的novel最多两宫格
        </p>
    </label>
    <label class="toggle-switch">
        <input type="checkbox" id="realimag-switch">
        <span class="slider"></span>
    </label>
</div>
<!-- ▲▲▲ RealImag功能结束 ▲▲▲ -->

<!-- ▼▼▼ NovelAI 图像生成系统配置 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="novelai-switch" style="margin-bottom: 0;">
        启用 NovelAI 图像生成
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            开启后可使用NovelAI官方API生成高质量动漫风格图像（必开🔮）
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            1. 三击下载图片，下面可测试模型或关键词画师串
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            2. 429是novel的访问频繁错误，等待几秒重新即可
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            3. 403是多人共号限制，限制oplus免费出小图但可扣点数
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            4. 403也会因为没开🔮报错，实在不行可更换出图尺寸
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            5. 401是key没权限，检查key是否正确
        </p>
        <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
            6. 生成失败:Failed to fetch是跨域限制，下方设置里换代理
        </p>
    </label>
    <label class="toggle-switch">
        <input type="checkbox" id="novelai-switch">
        <span class="slider"></span>
    </label>
</div>

<div id="novelai-details" style="display: none;">
    <div class="form-group">
        <label for="novelai-model" style="color: #333;">NovelAI 模型</label>
        <select id="novelai-model" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; border-radius: 4px;">
            <option value="nai-diffusion-4-curated-preview">NAI Diffusion V4.5 Curated (精选版无nsfw)</option>
            <option value="nai-diffusion-4-5-full">NAI Diffusion V4.5 Full（完整版含nsfw）</option>
            <option value="nai-diffusion-3">NAI Diffusion Anime V3（旧版）</option>
            <option value="nai-diffusion-furry-3">NAI Diffusion Furry V3（旧旧版）</option>
        </select>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
            💡 必须有oplus订阅的apikey才可以使用！
        </p>
    </div>

    <div class="form-group">
        <label for="novelai-api-key" style="color: #333;">NovelAI API Key</label>
        <div style="position: relative;">
            <input type="password" id="novelai-api-key" placeholder="pst-xxxxxxxxxxxxxxxx" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding-right: 40px;">
            <span id="novelai-key-toggle" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; user-select: none; font-size: 18px;">🧐</span>
        </div>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
            💡 在 <a href="https://novelai.net" target="_blank" style="color: #007bff;">NovelAI官网</a> 获取API Key
        </p>
    </div>

    <div style="display: flex; gap: 10px; margin-top: 15px;">
        <button type="button" id="novelai-settings-btn" style="flex: 1; background-color: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">
             生成设置
        </button>
        <button type="button" id="novelai-test-btn" style="flex: 1; background-color: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">
             测试生成
        </button>
    </div>
</div>
<!-- ▲▲▲ NovelAI 图像生成系统配置结束 ▲▲▲ -->

<!-- ▼▼▼ Minimax语音系统配置 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<h3 style="color: #333; margin: 20px 0 15px 0; font-size: 16px;">🖤 Minimax 语音系统</h3>
<p style="font-size: 13px; color: #666; margin-bottom: 15px;">
    配置 Minimax TTS 语音系统，让角色拥有真实的语音能力。
    <br>
    <a href="https://www.minimaxi.com/" target="_blank" style="color: #007bff; text-decoration: none;">👉 访问 Minimax 官网注册账号</a>
</p>

<div class="form-group">
    <label for="minimax-group-id" style="color: #333;">Minimax Group ID</label>
    <input type="text" id="minimax-group-id" placeholder="输入你的 Minimax Group ID..." style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc;">
</div>

<div class="form-group">
    <label for="minimax-api-key" style="color: #333;">Minimax API Key (for TTS)</label>
    <input type="password" id="minimax-api-key" placeholder="输入你的 Minimax API Key..." style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc;">
</div>

<div class="form-group">
    <label for="minimax-voice-model" style="color: #333;">默认语音模型</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <select id="minimax-voice-model" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; flex: 1; padding: 8px; border-radius: 4px;">
            <option value="">请先拉取模型列表</option>
        </select>
        <button type="button" id="fetch-voice-models-btn" style="background-color: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; white-space: nowrap;">
            拉取模型
        </button>
    </div>
    <p style="font-size: 12px; color: #666; margin-top: 5px;">
        ⚡ 点击"拉取模型"按钮获取可用的语音模型列表，选择后将作为默认语音模型使用
    </p>
</div>
<!-- ▲▲▲ Minimax语音系统配置结束 ▲▲▲ -->

<!-- ▼▼▼ 语音缓存管理 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<h3 style="color: #333; margin: 20px 0 15px 0; font-size: 16px;">🗄️ 语音缓存管理</h3>
<p style="font-size: 13px; color: #666; margin-bottom: 15px;">
    管理本地语音缓存，优化存储空间使用。缓存可以加速语音播放，但会占用浏览器存储空间。
</p>

<div class="form-group">
    <div style="display: flex; justify-content: space-between; align-items: center; background: #f9f9f9; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
        <div>
            <div style="font-size: 14px; font-weight: bold; color: #333;">缓存状态</div>
            <div id="cache-status" style="font-size: 12px; color: #666; margin-top: 5px;">
                正在检查缓存...
            </div>
        </div>
        <button id="refresh-cache-status" class="form-button-secondary" style="margin: 0; padding: 8px 16px; font-size: 12px;">刷新</button>
    </div>
    
    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <button id="clean-expired-cache" class="form-button-secondary" style="flex: 1; margin: 0; min-width: 120px;">清理过期缓存</button>
        <button id="clean-old-cache" class="form-button-secondary" style="flex: 1; margin: 0; min-width: 120px;">清理旧缓存</button>
        <button id="clear-all-cache" class="form-button-secondary" style="flex: 1; margin: 0; min-width: 120px; border-color: #dc3545; color: #dc3545;">清空所有缓存</button>
    </div>
    
    <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px;">
        <div style="font-size: 12px; color: #856404;">
            <strong>💡 提示：</strong>
            <ul style="margin: 5px 0 0 15px; padding: 0;">
                <li>缓存会在7天后自动过期</li>
                <li>单个音频文件超过5MB不会被缓存</li>
                <li>总缓存大小限制为50MB</li>
                <li>清理缓存后需要重新下载语音文件</li>
            </ul>
        </div>
    </div>
</div>
<!-- ▲▲▲ 语音缓存管理结束 ▲▲▲ -->

<!-- ▼▼▼ 智谱语音识别系统配置 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<div class="zhipu-speech-section">
<h3 style="color: #333; margin: 15px 0 10px 0; font-size: 16px;">🎙️ 智谱AI语音对话系统</h3>
<p style="font-size: 13px; color: #666; margin-bottom: 12px;">
    <a href="https://open.bigmodel.cn/" target="_blank" style="color: #007bff; text-decoration: none;">👉 访问智谱AI开放平台注册账号</a>
</p>

<div class="form-group" style="margin-bottom: 12px;">
    <label for="voice-recognition-method" style="color: #333;">语音识别方式</label>
    <select id="voice-recognition-method" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; border-radius: 4px;">
        <option value="google">谷歌浏览器语音识别（免费）</option>
        <option value="zhipu">智谱API语音识别（需API Key）</option>
    </select>
    <p style="font-size: 12px; color: #666; margin-top: 5px;">
        💡 选择"谷歌识别"使用浏览器原生功能（免费但需联网），选择"智谱API"需配置智谱密钥（更准确但需消耗额度）
    </p>
</div>

<div class="form-group" style="margin-bottom: 12px;">
    <label for="zhipu-speech-endpoint" style="color: #333;">智谱AI 对话API端点</label>
    <input type="text" id="zhipu-speech-endpoint" placeholder="https://open.bigmodel.cn/api/paas/v4/chat/completions" value="https://open.bigmodel.cn/api/paas/v4/chat/completions" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc;">
    <p style="font-size: 12px; color: #666; margin-top: 5px;">
        💡 填写智谱AI的对话API端点（用于发送语音识别请求）
    </p>
</div>

<div class="form-group" style="margin-bottom: 12px;">
    <label for="zhipu-speech-api-key" style="color: #333;">智谱语音识别API Key</label>
    <div style="position: relative;">
        <input type="password" id="zhipu-speech-api-key" placeholder="sk-xxxxxxxxxxxxxxxx" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding-right: 40px;">
        <span id="zhipu-api-key-toggle" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; user-select: none; font-size: 18px;">🧐</span>
    </div>
    <p style="font-size: 12px; color: #666; margin-top: 5px;">
        💡 用于语音识别的智谱AI API密钥
    </p>
</div>

<div class="form-group" style="margin-bottom: 12px;">
    <label for="zhipu-speech-model" style="color: #333;">智谱AI模型名称</label>
    <input type="text" id="zhipu-speech-model" placeholder="glm-asr 或 GLM-4-Voice" value="glm-asr" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; border-radius: 4px;">
</div>

<div class="form-group" style="margin-bottom: 0;">
    <div style="display: flex; gap: 10px; align-items: center;">
        <button type="button" id="test-zhipu-speech-btn" onclick="console.log('按钮被点击了！'); openSpeechTestModal();" style="background-color: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; white-space: nowrap;">
            🖤 测试语音识别
        </button>
        <span style="font-size: 12px; color: #666;">点击测试智谱语音识别功能</span>
    </div>
</div>
</div>
<!-- ▲▲▲ 智谱语音识别系统配置结束 ▲▲▲ -->

<button class="form-button" id="save-api-settings-btn">保存设置</button>
			<hr style="margin:20px 0; opacity:.3">

			<button class="form-button" id="export-data-btn">导出数据</button>

<!-- ① 普通按钮，和“导出”一个 class -->
<button class="form-button" id="import-btn">导入备份文件</button>

<!-- ② 真正的文件选择器，完全隐藏 -->
<input id="import-data-input" type="file" accept="application/json" hidden>
</div></div>
<!-- ▼▼▼ 用下面这段代码，完整替换掉你原来的 chat-list-screen ▼▼▼ -->
<div id="chat-list-screen" class="screen">
    
    <!-- 主头部 (只在消息列表显示) -->
    <div class="header" id="main-chat-list-header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
<span id="chat-list-title">消息</span>
        <div class="header-actions">
            <span class="action-btn" id="add-group-chat-btn" title="创建群聊"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
            <!-- ▼▼▼ 这是我们新加的导入按钮 ▼▼▼ -->
<span class="action-btn" id="import-character-card-btn" title="导入角色卡">
    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
    </svg>
</span>
<!-- ▲▲▲ 导入按钮结束 ▲▲▲ -->
            <span class="action-btn" id="add-chat-btn">+</span>
        </div>
    </div>

    <!-- 消息列表视图 -->
    <div id="messages-view" class="chat-list-view active">
        <div id="chat-list">
            <!-- JS会在这里生成聊天列表 -->
        </div>
    </div>

    <!-- 动态界面视图 -->
    <div id="qzone-screen" class="chat-list-view">
        <div class="qzone-header">
            <span class="back-btn" id="qzone-back-btn">‹</span> <!-- 这个按钮现在只负责从动态返回 -->
            <span>好友动态</span>
        </div>
        <div class="qzone-content">
            <div class="qzone-profile-header">
                <div id="qzone-banner-container" class="qzone-banner-container">
                    <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="背景">
                    <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                </div>
                <div class="qzone-user-info">
                    <div id="qzone-avatar-container" class="qzone-avatar-container">
                        <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="头像">
                        <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                    </div>
                    <span id="qzone-nickname">{{user}}</span>
                </div>
            </div>
            <div class="qzone-actions-bar">
                <div class="action-item" id="create-shuoshuo-btn"><span>说说</span></div>
                <div class="action-item" id="create-post-btn"><span>动态</span></div>
                <div class="action-item" id="open-album-btn"><span>相册</span></div>
            </div>
            <div id="qzone-posts-list"></div>
        </div>
    </div>

    <!-- 收藏界面视图 -->
    <div id="favorites-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="favorites-back-btn">‹</span>
        <span>我的收藏</span>
        <!-- 新增的编辑按钮 -->
        <span class="action-btn" id="favorites-edit-btn">编辑</span>
    </div>

        <!-- 【新增】搜索栏容器 -->
        <div class="search-bar-container">
            <input type="search" id="favorites-search-input" placeholder="搜索收藏的标题、内容或作者...">
            <button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none;">×</button>
        </div>

        <div id="favorites-list" class="list-container">
            <!-- 收藏内容将由JS动态生成在这里 -->
        </div>

<!-- 新增：收藏页底部操作栏 -->
<div id="favorites-action-bar" style="display: none;">
    <button id="favorites-delete-selected-btn" class="action-bar-btn">删除 (0)</button>
</div>

    </div>

<!-- ▼▼▼ 【全新】回忆录界面视图 ▼▼▼ -->
<div id="memories-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="memories-back-btn">‹</span>
        <span>我们的回忆</span>
        </div>
    
    <!-- 新增：主选择界面 -->
    <div id="memories-main-selection" class="memories-selection-container" style="display: flex;">
        <div class="memories-selection-buttons">
            <button id="enter-love-space-btn" class="memory-space-btn love-space">
                <div class="btn-icon">🤍</div>
                <div class="btn-text">进入恋爱空间</div>
            </button>
            <button id="enter-private-space-btn" class="memory-space-btn private-space">
                <div class="btn-icon">🖤</div>
                <div class="btn-text">进入私人空间</div>
            </button>
        </div>
    </div>

    <!-- 恋爱空间界面 -->
    <div id="love-space-view" class="memory-space-view" style="display: none;">
        <!-- 简化的导航区域 -->
        <div class="love-space-nav">
            <span class="back-btn" id="love-space-back-btn">‹</span>
            <div class="nav-right-buttons">
                <span class="diy-toggle-btn" id="diy-toggle-btn" title="DIY装饰模式">✨</span>
            <span class="settings-btn" id="love-space-settings-btn">⚙</span>
            </div>
        </div>
        
        <!-- 设置菜单 -->
        <div id="love-settings-menu" class="love-settings-menu" style="display: none;">
            <div class="settings-menu-content">
                <div class="settings-menu-header">
                    <h3>设置</h3>
                    <span class="close-settings" id="close-love-settings">×</span>
                </div>
                <div class="settings-menu-list">
                    <div class="settings-menu-item" data-setting="avatars">头像设置</div>
                    <div class="settings-menu-item" data-setting="wallpaper">壁纸设置</div>
                    <div class="settings-menu-item" data-setting="diy-decoration">DIY装饰</div>
                    <div class="settings-menu-item" data-setting="checkin">每天想你</div>
                    <div class="settings-menu-item" data-setting="breakup" style="color: #ff4757;">解除关系</div>
                </div>
            </div>
        </div>
        
        <!-- 设置页面弹窗 -->
        <div id="love-settings-modal" class="love-settings-modal" style="display: none;">
            <div class="settings-modal-content">
                <div class="settings-modal-header">
                    <h3 id="settings-modal-title">设置</h3>
                    <span class="close-settings-modal" id="close-settings-modal">×</span>
                </div>
                <div id="settings-modal-body" class="settings-modal-body">
                    <!-- 动态内容 -->
                </div>
            </div>
        </div>
        
        <!-- DIY装饰上传弹窗 -->
        <div id="diy-upload-modal" class="diy-upload-modal" style="display: none;">
            <div class="diy-upload-content">
                <div class="diy-upload-header">
                    <h3>添加装饰图片</h3>
                    <span class="close-diy-upload" id="close-diy-upload">×</span>
                </div>
                <div class="diy-upload-body">
                    <div class="url-input-group">
                        <label for="decoration-url">图片URL：</label>
                        <input type="url" id="decoration-url" placeholder="请输入图片链接..." />
                    </div>
                    <div class="size-input-group">
                        <label>初始大小：</label>
                        <div class="size-inputs">
                            <input type="number" id="decoration-width" placeholder="宽度" value="100" min="20" max="300" />
                            <span>×</span>
                            <input type="number" id="decoration-height" placeholder="高度" value="100" min="20" max="300" />
                            <span>px</span>
                        </div>
                    </div>
                    <div class="preview-area" id="decoration-preview" style="display: none;">
                        <img id="preview-image" alt="预览" />
                    </div>
                </div>
                <div class="diy-upload-footer">
                    <button class="btn-cancel" id="cancel-decoration">取消</button>
                    <button class="btn-confirm" id="add-decoration">添加装饰</button>
                </div>
            </div>
        </div>
        
        <!-- DIY装饰层 -->
        <div id="diy-decoration-layer" class="diy-decoration-layer">
            <!-- 用户上传的装饰图片会在这里显示 -->
        </div>
        
        <div class="space-content">
            <!-- 主页内容 -->
            <div id="love-home-page" class="love-space-content">
                <!-- 顶部打卡统计 -->
                <div class="checkin-info-top">
                    <div class="checkin-stats">
                        <div class="stat-item">
                            <span class="stat-label">连续打卡</span>
                            <span class="stat-value" id="consecutive-days">0</span>
                            <span class="stat-unit">天</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">总打卡</span>
                            <span class="stat-value" id="total-checkins">0</span>
                            <span class="stat-unit">次</span>
                        </div>
                    </div>
                </div>

                <!-- 双人头像区域 -->
                <div class="couple-avatars-section">
                    <div class="avatar-container user-avatar-container">
                        <img id="user-avatar" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMjAiIGZpbGw9IiNGRjk5Q0MiLz4KPHN2ZyB4PSI4IiB5PSI4IiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI0ZGRiI+CjxwYXRoIGQ9Ik0xMiAxMkM5IDEyIDkgOSA5IDljMC0zIDMtMyAzLTNzMyAwIDMgM2MwIDAtMyAzLTMgM3ptLTIgNGMwIDQgMiA0IDIgNHMyIDAgMi00di0yYzAtMi0yLTItMi0ycy0yIDAtMiAydjJ6Ii8+Cjwvc3ZnPgo8L3N2Zz4=" alt="用户头像" class="couple-avatar" onclick="changeUserAvatar()">
                        <div class="avatar-status" id="user-status" style="display: none;">想他<span id="user-days">0</span>天</div>
                    </div>
                    <div class="love-heart">💕</div>
                    <div class="avatar-container ai-avatar-container">
                        <img id="ai-avatar" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMjAiIGZpbGw9IiM5OUNDRkYiLz4KPHN2ZyB4PSI4IiB5PSI4IiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI0ZGRiI+CjxwYXRoIGQ9Ik0xMiAxMkM5IDEyIDkgOSA5IDljMC0zIDMtMyAzLTNzMyAwIDMgM2MwIDAtMyAzLTMgM3ptLTIgNGMwIDQgMiA0IDIgNHMyIDAgMi00di0yYzAtMi0yLTItMi0ycy0yIDAtMiAydjJ6Ii8+Cjwvc3ZnPgo8L3N2Zz4=" alt="AI头像" class="couple-avatar" onclick="changeAIAvatar()">
                        <div class="avatar-status" id="ai-status" style="display: none;">想你<span id="ai-days">0</span>天</div>
                    </div>
                </div>



                <!-- 左侧横条打卡区域 -->
                <div class="checkin-ball-container">
                    <div id="checkin-ball" class="checkin-ball" onclick="userCheckin()">
                        <div class="ball-text">打卡</div>
                        <div class="ball-glow"></div>
                    </div>
                    <div class="checkin-info-text">
                        <div class="checkin-title">每日想你</div>
                    </div>
                </div>
            </div>

            <!-- 相册页面 -->
            <div id="love-gallery-page" class="love-space-content" style="display: none;">
                <div class="gallery-header">
                    <h2>💕 恋爱相册</h2>
                </div>
                <div class="gallery-content">
                    <div class="gallery-list" id="gallery-list">
                        <!-- 相册列表将通过JavaScript动态生成 -->
                        <div class="gallery-placeholder">
                            <p>还没有相册哦~</p>
                            <p>点击右下角+号创建第一个相册吧！</p>
                        </div>
                    </div>
                </div>
                
                <!-- 创建相册的浮动按钮 -->
                <div class="create-album-btn" onclick="showCreateAlbumDialog()">
                    <span>+</span>
                </div>
            </div>

            <!-- 底部导航栏 -->
            <div class="love-bottom-nav">
                <div class="nav-item active" data-page="home" onclick="switchLovePage('home')">
                    <span class="nav-label">主页</span>
                </div>
                <div class="nav-item" data-page="gallery" onclick="switchLovePage('gallery')">
                    <span class="nav-label">相册</span>
                </div>
            </div>
        </div>
    </div>

    <!-- 子相册详情页面 - 独立的全屏页面 -->
    <div id="album-detail-view" class="memory-space-view" style="display: none;">
        <div class="space-header">
            <div class="upload-nav-frame" onclick="showCoverUploadDialog()">
                <div class="cover-image-container" id="cover-image-container" style="display: none;">
                    <img id="cover-image" class="cover-image" src="" alt="封面图片">
                </div>
                <div class="upload-hint" id="cover-upload-hint">轻触上传封面图片</div>
                <div class="nav-buttons">
                    <div class="nav-back-btn" onclick="event.stopPropagation(); backToGallery()">‹</div>
                    <div class="nav-right-buttons">
                        <div class="nav-collapse-btn" onclick="event.stopPropagation(); toggleHeaderCollapse()" title="折叠/展开">-</div>
                        <div class="nav-add-btn" onclick="event.stopPropagation(); showAddPhotoDialog()" title="添加照片">+</div>
                        <div class="nav-settings-btn" onclick="event.stopPropagation(); showAlbumSettingsMenu()" title="设置">⚙</div>
                    </div>
                </div>
            </div>
        </div>
        <div class="album-detail-content">
            <div class="album-photos-grid" id="album-photos-grid">
                <!-- 相册照片将通过JavaScript动态生成 -->
                <div class="album-photos-placeholder" id="album-photos-placeholder">
                    <p>还没有照片哦~</p>
                    <p>点击右上角+添加照片吧！</p>
                </div>
            </div>
        </div>
    </div>

        <!-- 原图查看器 -->
        <div id="image-viewer-overlay" class="image-viewer-overlay" onclick="closeImageViewer()">
            <img id="image-viewer-content" class="image-viewer-content" src="" alt="原图" />
        </div>

        <!-- 背景设置弹窗 -->
        <div id="background-settings-dialog" class="dialog-overlay" style="display: none;">
            <div class="dialog-content album-settings-content">
                <div class="dialog-header">
                    <h3>背景设置</h3>
                    <span class="dialog-close" onclick="closeBackgroundSettingsDialog()">×</span>
                </div>
                <div class="dialog-body">
                    <div class="background-upload-area" onclick="triggerBackgroundUpload()">
                        <div class="background-upload-icon">🌺</div>
                        <div class="background-upload-text">点击上传背景图片</div>
                        <div class="background-upload-hint">支持 JPG、PNG 格式</div>
                    </div>
                    <input type="file" id="background-upload-input" accept="image/*" style="display: none;" onchange="handleBackgroundUpload(event)">
                    <div class="background-preview" id="background-preview" style="display: none;">
                        <img id="background-preview-img" src="" alt="背景预览">
                        <div class="background-preview-actions">
                            <button class="btn-apply" onclick="applyBackground().catch(console.error)">应用背景</button>
                            <button class="btn-reset" onclick="resetBackground().catch(console.error)">重置背景</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 添加照片弹窗 -->
        <div id="add-photo-dialog" class="dialog-overlay" style="display: none;">
            <div class="dialog-content">
                <div class="dialog-header">
                    <h3>添加照片</h3>
                    <span class="dialog-close" onclick="hideAddPhotoDialog()">×</span>
                </div>
                <div class="dialog-body">
                    <div class="photo-upload-content">
                            <div class="form-group">
                                <label>图片链接</label>
                                <input type="url" id="photo-url-input" placeholder="请输入图片URL...">
                            </div>
                            <button class="preview-btn" onclick="previewPhotoUrl()">预览图片</button>
                        </div>
                    <div class="form-group">
                        <label>照片名称（建议填）</label>
                        <input type="text" id="photo-name-input" placeholder="为这张照片添加名称..." maxlength="30">
                    </div>
                    <div class="form-group">
                        <label>备注（建议填）</label>
                        <input type="text" id="photo-description-input" placeholder="为这张照片添加备注...">
                    </div>
                    <div id="photo-preview" class="photo-preview" style="display: none;">
                        <img id="preview-image" src="" alt="预览">
                    </div>
                </div>
                <div class="dialog-footer">
                    <button class="dialog-btn cancel-btn" onclick="hideAddPhotoDialog()">取消</button>
                    <button class="dialog-btn confirm-btn" onclick="addPhotoToAlbum().catch(console.error)">添加</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 封面上传弹窗 -->
    <div id="cover-upload-dialog" class="dialog-overlay" style="display: none;">
        <div class="dialog-content">
            <div class="dialog-header">
                <h3>上传封面图片</h3>
                <span class="dialog-close" onclick="hideCoverUploadDialog()">×</span>
            </div>
            <div class="dialog-body">
                <div class="photo-upload-content">
                        <div class="form-group">
                            <label>图片链接</label>
                            <input type="url" id="cover-url-input" placeholder="请输入图片URL...">
                        </div>
                        <button class="preview-btn" onclick="previewCoverUrl()">预览图片</button>
                </div>
                <div id="cover-preview" class="photo-preview" style="display: none;">
                    <img id="cover-preview-image" src="" alt="预览">
                </div>
            </div>
            <div class="dialog-footer">
                <button class="dialog-btn cancel-btn" onclick="hideCoverUploadDialog()">取消</button>
                <button class="dialog-btn confirm-btn" onclick="setCoverImage().catch(console.error)">设为封面</button>
            </div>
        </div>
    </div>

    <!-- 创建相册弹窗 -->
    <div id="create-album-dialog" class="dialog-overlay" style="display: none;" onclick="hideCreateAlbumDialog()">
        <div class="dialog-content" onclick="event.stopPropagation()">
            <div class="dialog-header">
                <h3>创建新相册</h3>
                <span class="dialog-close" onclick="hideCreateAlbumDialog()">×</span>
            </div>
            <div class="dialog-body">
                <div class="form-group">
                    <label>相册名称</label>
                    <input type="text" id="album-name-input" placeholder="给相册起个名字..." maxlength="20" tabindex="0">
                </div>
                <div class="form-group">
                    <label>相册备注</label>
                    <textarea id="album-description-input" placeholder="写点什么吧..." maxlength="100" tabindex="0" onclick="this.focus()" onfocus="console.log('textarea聚焦成功')"></textarea>
                </div>
                <div class="form-group">
                    <label>绑定角色 <span style="color: #ff6b6b; font-size: 12px;">（必选，只有绑定的角色可以查看此相册）</span></label>
                    <div id="album-contact-selection" class="album-contact-list">
                        <div class="contact-loading">正在加载联系人...</div>
                    </div>
                </div>
            </div>
            <div class="dialog-footer">
                <button class="dialog-btn cancel-btn" onclick="hideCreateAlbumDialog()">取消</button>
                <button class="dialog-btn confirm-btn" onclick="createNewAlbum().catch(console.error)">创建</button>
            </div>
        </div>
    </div>

    <!-- 子相册设置菜单弹窗 -->
    <div id="album-settings-menu" class="dialog-overlay" style="display: none;" onclick="hideAlbumSettingsMenu()">
        <div class="dialog-content album-settings-content" onclick="event.stopPropagation()">
            <div class="dialog-header">
                <h3>相册设置</h3>
                <span class="dialog-close" onclick="hideAlbumSettingsMenu()">×</span>
            </div>
            <div class="dialog-body">
                <div class="settings-menu-list">
                    <div class="settings-menu-item" onclick="showAlbumBackgroundSettings()">
                        <span class="settings-item-text">背景设置</span>
                    </div>
                    <div class="settings-menu-item" onclick="showDeleteAlbumConfirm()">
                        <span class="settings-item-text">删除该子相册</span>
                    </div>
                    <div class="settings-menu-item" onclick="showContactBindingSettings()">
                        <span class="settings-item-text">解除绑定联系人</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 联系人绑定设置弹窗 -->
    <div id="contact-binding-dialog" class="dialog-overlay" style="display: none;" onclick="hideContactBindingDialog()">
        <div class="dialog-content" onclick="event.stopPropagation()">
            <div class="dialog-header">
                <h3>联系人绑定设置</h3>
                <span class="dialog-close" onclick="hideContactBindingDialog()">×</span>
            </div>
            <div class="dialog-body">
                <div class="current-binding-section">
                    <h4>当前绑定的联系人</h4>
                    <div id="current-binding-list" class="binding-contact-list">
                        <!-- 当前绑定的联系人将在这里显示 -->
                    </div>
                </div>
                <div class="available-contacts-section">
                    <h4>可添加的联系人</h4>
                    <div id="available-contacts-list" class="binding-contact-list">
                        <!-- 可添加的联系人将在这里显示 -->
                    </div>
                </div>
            </div>
            <div class="dialog-footer">
                <button class="dialog-btn cancel-btn" onclick="hideContactBindingDialog()">关闭</button>
            </div>
        </div>
    </div>

    <!-- 删除相册确认弹窗 -->
    <div id="delete-album-confirm" class="dialog-overlay" style="display: none;" onclick="hideDeleteAlbumConfirm()">
        <div class="dialog-content" onclick="event.stopPropagation()">
            <div class="dialog-header">
                <h3>删除相册</h3>
                <span class="dialog-close" onclick="hideDeleteAlbumConfirm()">×</span>
            </div>
            <div class="dialog-body">
                <p style="color: #ff4757; font-weight: bold; margin-bottom: 15px;">⚠️ 警告</p>
                <p>确定要删除这个相册吗？</p>
                <p style="color: #666; font-size: 14px; margin-top: 10px;">删除后相册中的所有照片都将永久丢失，此操作无法撤销。</p>
            </div>
            <div class="dialog-footer">
                <button class="dialog-btn cancel-btn" onclick="hideDeleteAlbumConfirm()">取消</button>
                <button class="dialog-btn confirm-btn" style="background-color: #ff4757;" onclick="confirmDeleteAlbum()">确定删除</button>
            </div>
        </div>
    </div>

    <!-- 私人空间界面（全新设计） -->
    <div id="private-space-view" class="memory-space-view" style="display: none;">
        <!-- 顶部透明导航栏 -->
        <div class="private-space-top-nav">
            <span class="back-btn" id="private-space-back-btn">‹</span>
            <span class="settings-btn" id="private-space-settings-btn">⚙</span>
        </div>
        
        <!-- 设置弹窗 -->
        <div id="private-settings-modal" class="private-settings-modal" style="display: none;">
            <div class="private-settings-content">
                <div class="private-settings-header">
                    <h3>设置</h3>
                    <span class="close-private-settings" id="close-private-settings">×</span>
                </div>
                <div class="private-settings-menu">
                    <div class="private-settings-item" onclick="openWallpaperSettings()">
                        <span>壁纸设置</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 壁纸设置弹窗 -->
        <div id="wallpaper-settings-modal" class="wallpaper-settings-modal" style="display: none;">
            <div class="wallpaper-settings-content">
                <div class="wallpaper-settings-header">
                    <h3>壁纸设置</h3>
                    <button class="close-wallpaper-settings" id="close-wallpaper-settings">×</button>
                </div>
                <div class="wallpaper-settings-body">
                    <div class="wallpaper-section">
                        <h4>顶部16:9区域背景</h4>
                        <div class="wallpaper-input-group">
                            <input type="text" class="wallpaper-input" id="header-bg-input" placeholder="输入图片URL">
                            <button class="wallpaper-btn" onclick="setHeaderBackground()">设置</button>
                            <button class="wallpaper-btn secondary" onclick="resetHeaderBackground()">重置</button>
                        </div>
                        <div class="wallpaper-preview" id="header-bg-preview">当前：默认颜色 #e0f6ff</div>
                    </div>
                    
                    <div class="wallpaper-section">
                        <h4>导航栏背景</h4>
                        <div class="wallpaper-input-group">
                            <input type="text" class="wallpaper-input" id="nav-bg-input" placeholder="输入图片URL">
                            <button class="wallpaper-btn" onclick="setNavBackground()">设置</button>
                            <button class="wallpaper-btn secondary" onclick="resetNavBackground()">重置</button>
                        </div>
                        <div class="wallpaper-preview" id="nav-bg-preview">当前：默认白色背景</div>
                    </div>
                    
                    <div class="wallpaper-section">
                        <h4>页面内容区域背景</h4>
                        <div class="wallpaper-input-group">
                            <input type="text" class="wallpaper-input" id="content-bg-input" placeholder="输入图片URL">
                            <button class="wallpaper-btn" onclick="setContentBackground()">设置</button>
                            <button class="wallpaper-btn secondary" onclick="resetContentBackground()">重置</button>
                        </div>
                        <div class="wallpaper-preview" id="content-bg-preview">当前：默认白色背景</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 主要内容区域 -->
        <div class="private-space-main">
            <!-- 16:9 蓝色背景框 -->
            <div class="private-space-header-box">
                <!-- 头像区域 - 2/3在这个框里 -->
                <div class="private-space-avatar-container">
                    <div class="private-space-avatar" title="点击选择好友">
                        <img src="https://q1.qlogo.cn/g?b=qq&nk=123456789&s=100" alt="头像" id="private-space-avatar-img">
                    </div>
                </div>
            </div>
            
            <!-- 小导航栏框 -->
            <div class="private-space-nav-box">
                <!-- 头像的1/3部分会覆盖在这里 -->
                <div class="private-space-nav-tabs">
                    <div class="private-nav-tab active" data-tab="agreement">约定</div>
                    <div class="private-nav-tab" data-tab="items">物品</div>
                    <div class="private-nav-tab" data-tab="album">相册</div>
                </div>
            </div>
            
            <!-- 内容页面区域 -->
            <div class="private-space-content">
                <!-- 约定页面 -->
                <div class="private-content-page active" id="agreement-page">
                    <div class="private-page-content">
                        <div class="private-page-header">
                            <h3 style="margin: 0; color: #333;">我们的约定</h3>
                            <span class="action-btn" id="private-add-countdown-btn">+</span>
                        </div>
                        <div id="current-contact-indicator" style="padding: 10px 0; font-size: 12px; color: #888; text-align: center; border-bottom: 1px solid #f0f0f0; margin-bottom: 15px;">
                            
                        </div>
                        <div id="private-agreements-list" class="private-agreements-container">
                            <!-- 约定卡片将在这里显示 -->
                            <div class="empty-state" style="text-align: center; padding: 40px 20px; color: #666;">
                                <p style="margin: 0; font-size: 14px;">还没有约定，点击右上角的+号来创建第一个约定吧</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 物品页面 -->
                <div class="private-content-page" id="items-page">
                    <div class="private-page-content">
                        <div class="private-page-header">
                            <h3 style="margin: 0; color: #333;">珍藏物品</h3>
                            <div class="items-actions">
                                <span class="action-btn" id="add-item-btn">↓</span>
                                <span class="action-btn delete-mode-btn" id="delete-mode-btn" style="margin-left: 10px;">删除</span>
                            </div>
                        </div>
                        <div style="padding: 10px 0; font-size: 12px; color: #888; text-align: center; border-bottom: 1px solid #f0f0f0; margin-bottom: 15px;">
                           
                        </div>
                        
                        <div class="items-table-container">
                            <table class="items-table" id="items-table">
                                <thead>
                                    <tr>
                                        <th>序号</th>
                                        <th>物品名称</th>
                                        <th>描述</th>
                                        <th>效果</th>
                                        <th>意义</th>
                                        <th>来源</th>
                                        <th>拥有者</th>
                                        <th class="operation-column" style="display: none;">操作</th>
                                    </tr>
                                </thead>
                                <tbody id="items-table-body">
                                    <!-- 表格行将在这里动态生成 -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <!-- 相册页面 -->
                <div class="private-content-page" id="album-page">
                    <div class="private-page-content">
                        <div class="private-page-header">
                            <h3 style="margin: 0; color: #333;">私人相册</h3>
                            <span class="action-btn" onclick="showPrivateAddPhotoDialog()">+</span>
                        </div>
                        <div style="padding: 10px 0; font-size: 12px; color: #888; text-align: center; border-bottom: 1px solid #f0f0f0; margin-bottom: 15px;">
                            
                        </div>
                        <div class="private-album-grid" id="private-album-grid">
                            <!-- 私人相册照片将通过JavaScript动态生成 -->
                            <div class="private-album-placeholder" id="private-album-placeholder">
                                <p>还没有照片哦~</p>
                                <p>点击右上角+添加照片吧！</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 私人相册添加照片弹窗 -->
    <div id="private-add-photo-dialog" class="dialog-overlay" style="display: none;">
        <div class="dialog-content">
            <div class="dialog-header">
                <h3>添加照片</h3>
                <span class="dialog-close" onclick="hidePrivateAddPhotoDialog()">×</span>
            </div>
            <div class="dialog-body">
                <div class="photo-upload-content">
                    <div class="form-group">
                        <label>图片链接</label>
                        <input type="url" id="private-photo-url-input" placeholder="请输入图片URL...">
                    </div>
                    <button class="preview-btn" onclick="previewPrivatePhotoUrl()">预览图片</button>
                </div>
                <div class="form-group">
                    <label>照片名称（建议填）</label>
                    <input type="text" id="private-photo-name-input" placeholder="为这张照片添加名称..." maxlength="30">
                </div>
                <div class="form-group">
                    <label>备注（建议填）</label>
                    <input type="text" id="private-photo-description-input" placeholder="为这张照片添加备注...">
                </div>
                <div id="private-photo-preview" class="photo-preview" style="display: none;">
                    <img id="private-preview-image" src="" alt="预览">
                </div>
            </div>
            <div class="dialog-footer">
                <button class="dialog-btn cancel-btn" onclick="hidePrivateAddPhotoDialog()">取消</button>
                <button class="dialog-btn confirm-btn" onclick="addPrivatePhoto().catch(console.error)">添加</button>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

   
    <!-- 底部导航栏 -->
<div id="chat-list-bottom-nav">
    <div class="nav-item active" data-view="messages-view">
        <span>消息</span>
    </div>
    <div class="nav-item" data-view="qzone-screen">
        <span>动态</span>
    </div>
    <!-- ▼▼▼ 在“动态”和“收藏”之间，加入这个新页签 ▼▼▼ -->
    <div class="nav-item" data-view="memories-view">
        <span>回忆</span>
    </div>
    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
    <div class="nav-item" data-view="favorites-view">
        <span>收藏</span>
    </div>
</div>
</div>
<!-- ▲▲▲ 替换区域结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="chat-list-screen" 的 div 之后 ▼▼▼ -->
<div id="album-screen" class="screen">
    <!-- 1. 页面头部，包含返回按钮和标题 -->
    <div class="header">
        <span class="back-btn" id="album-back-btn">‹</span>
        <span>我的相册</span>
        <span class="action-btn" id="create-album-btn-page">+</span>
    </div>
    
    <!-- 2. 页面内容容器 -->
    <div class="list-container">
        <div id="album-grid-page">
            <!-- 相册列表将由 JS 动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="album-screen" 的 div 之后 ▼▼▼ -->
<div id="album-photos-screen" class="screen">
    <!-- 1. 页面头部 -->
    <div class="header">
        <span class="back-btn" id="album-photos-back-btn">‹</span>
        <span id="album-photos-title">相册名称</span>
        <span class="action-btn" id="album-upload-photo-btn">上传</span>
    </div>
    
    <!-- 2. 页面内容容器 -->
    <div class="list-container">
        <div id="photos-grid-page">
            <!-- 照片列表将由 JS 动态生成在这里 -->
        </div>

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="photo-viewer-modal" class="modal">
    <!-- 1. 关闭按钮 -->
    <button id="photo-viewer-close-btn">×</button>
    
    <!-- 2. 上一张照片按钮 -->
    <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
    
    <!-- 3. 图片容器 -->
    <div class="photo-viewer-content">
        <img id="photo-viewer-image" src="" alt="全屏照片预览">
    </div>
    
    <!-- 4. 下一张照片按钮 -->
    <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

    </div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 粘贴到 #album-photos-screen 的 div 之后 ▼▼▼ -->
<input type="file" id="album-photo-input" accept="image/*" multiple hidden>
            
<!-- ▼▼▼ 请用这【一整块】全新的代码，完整替换掉您文件中旧的 #chat-interface-screen 及其所有内容 ▼▼▼ -->
<div id="chat-interface-screen" class="screen">

<div class="header">
    <!-- 默认控件：包含标题、状态栏和常规按钮 -->
    <div class="default-controls">
        <span class="back-btn" id="back-to-list-btn">‹</span>
        
        <!-- 【新增】线下模式切换按钮 -->
        <span class="action-btn" id="offline-mode-header-btn" title="线下模式">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
            </svg>
        </span>
        
        <!-- 【移动到此处】长期记忆按钮 -->
        <span class="action-btn" id="open-memory-screen-btn" title="长期记忆">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <!-- 简洁好看的星星图标 ✨ -->
                <path d="M12 2L14.09 8.26L20 9.27L15.82 13.14L17.18 19.02L12 15.77L6.82 19.02L8.18 13.14L4 9.27L9.91 8.26L12 2Z" 
                      stroke="currentColor" 
                      stroke-width="1.8" 
                      stroke-linecap="round" 
                      stroke-linejoin="round"
                      fill="none"
                      opacity="0.9"/>
                <!-- 中心小星星点缀 -->
                <circle cx="12" cy="11" r="1.2" fill="currentColor" opacity="0.6"/>
            </svg>
        </span>
        
        <!-- 标题和状态的容器 -->
        <div id="chat-header-title-wrapper">
            <div id="chat-header-main-line">
                <span id="chat-header-title">聊天对象</span>
            </div>
            <div id="chat-header-status">
                <span class="status-dot"></span>
                <span class="status-text">在线</span>
            </div>
        </div>

        <div class="header-actions">
            <!-- 【正确位置】心声按钮在这里 -->
            <span class="action-btn" id="char-heart-btn" title="心声" style="display: none; cursor: pointer;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#ff4d6d" stroke="#ffc3d0" stroke-width="1.5">
                    <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                </svg>
            </span>

            <span class="action-btn" id="listen-together-btn" title="一起听"><img src="https://i.postimg.cc/dV8sdNcx/210-20250618115221.png" alt="一起听"></span>
            <span class="action-btn" id="chat-settings-btn" title="聊天设置"><img src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png" alt="设置"></span>
        </div>
    </div>

    <!-- 多选模式控件 -->
    <div class="selection-controls">
        <span id="selection-cancel-btn">取消</span>
        <span id="selection-count"></span>
        <div class="header-actions">
           <span id="selection-favorite-btn" class="action-btn">收藏</span>
           <span id="selection-share-btn" class="action-btn">分享</span> 
           <span id="selection-delete-btn" class="action-btn" style="color: #ff3b30;">删除</span>
        </div>
    </div>
</div>

    <!-- 聊天消息区域 (保持不变) -->
    <div id="chat-messages"><div id="typing-indicator">对方正在输入...</div></div>

    <!-- 输入区域 (这是修改后的最终版本) -->
    <div id="chat-input-area">
        <div id="reply-preview-bar">
            <div class="reply-preview-content">
                <div class="sender">回复 xxx:</div>
                <div class="text">被引用的消息内容...</div>
            </div>
            <span id="cancel-reply-btn">×</span>
        </div>
        <div id="chat-input-actions-top">
            <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="表情面板"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg></button>
            
            <!-- "重新生成回复"按钮的新家 -->
            <button id="reroll-btn" class="action-button" title="重新生成回复"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg></button>
            
            <!-- 表情按钮 -->
            <button id="emoji-btn" class="action-button" title="表情"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                <line x1="9" y1="9" x2="9.01" y2="9"></line>
                <line x1="15" y1="9" x2="15.01" y2="9"></line>
            </svg></button>
            
            <button id="send-photo-btn" class="chat-action-icon-btn action-button" title="发送照片"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg></button>
            <button id="upload-image-btn" class="chat-action-icon-btn action-button" title="上传图片"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" ><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
            <button id="transfer-btn" class="chat-action-icon-btn action-button" title="转账">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path>
            </svg>
            </button>
            <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="发送语音"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg></button>
            <button id="send-waimai-request-btn" class="chat-action-icon-btn action-button" title="发起外卖请求"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg></button>
            <button id="open-shopping-btn" class="chat-action-icon-btn action-button" title="购物">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="9" cy="21" r="1"></circle>
                    <circle cx="20" cy="21" r="1"></circle>
                    <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
                </svg>
            </button>
            <button id="video-call-btn" class="chat-action-icon-btn action-button" title="视频通话"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg></button>
            <button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="群视频通话"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></button>
            <button id="send-poll-btn" class="chat-action-icon-btn action-button" title="发起投票"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg></button>
            <button id="share-link-btn" class="chat-action-icon-btn action-button" title="分享链接"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
            <button id="send-location-btn" class="chat-action-icon-btn action-button" title="发送定位">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
            </button>
        </div>
        <div id="chat-input-main-row">
            <textarea id="chat-input" rows="1" placeholder="输入消息..."></textarea>
            <div id="input-actions-wrapper">
                <button id="wait-reply-btn" title="等待回复"><img src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png" alt="等待回复"></button>
                <button id="send-btn" class="action-button">发送</button>
            </div>
        </div>
    </div>
<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div id="chat-lock-overlay">
    <div id="chat-lock-content"></div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

    <!-- 表情面板 (保持不变) -->
    <div id="sticker-panel">
        <div id="sticker-panel-header">
            <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
            <span class="title">表情包</span>
            <div style="display: flex; gap: 10px;">
              <span class="panel-btn" id="add-sticker-btn">添加</span>
              <span class="panel-btn" id="upload-sticker-btn">上传</span>
            </div>
        </div>
        <div id="sticker-grid"></div>
    </div>
<input type="file" id="sticker-upload-input" accept="image/*" style="display: none;" multiple>
    <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
    
    <!-- 音乐播放器 (保持不变) -->
<div id="music-player-overlay">
<div class="music-player-window">
    <!-- 1. 顶部头像区域 -->
    <div id="music-avatars-container">
        <img id="music-char-avatar" src="" alt="角色头像">
        <svg id="heartbeat-line" viewBox="0 0 80 30">
            <path class="heartbeat-path" d="M 5 15 Q 20 0 30 15 T 55 15 L 75 15"></path>
            <path class="heartbeat-heart" d="M 0 -2 a 2 2 0 0 1 4 0 v 2 a 2 2 0 0 1 -4 0 z"></path>
        </svg>
        <img id="music-user-avatar" src="" alt="用户头像">
    </div>
    
    <!-- ▼▼▼ 【核心修改】我们把这行文字移到了这里 ▼▼▼ -->
    <div id="music-time-counter">已经一起听了0.0小时</div>

    <!-- 2. 顶部操作按钮 -->
    <div class="music-player-top-actions">
        <div class="top-left-cluster">
            <button id="music-return-btn">‹</button>
            <button id="music-exit-btn">×</button>
        </div>
        <span id="music-playlist-btn">☰</span>
    </div>

    <!-- 3. 封面和歌词的切换容器 -->
    <div id="music-display-area">
        <img id="music-album-cover" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" alt="歌曲封面">
        <div id="music-lyrics-container">
            <div id="music-lyrics-list">
                <div class="lyric-line">♪ 暂无歌词 ♪</div>
            </div>
        </div>
    </div>

    <!-- 4. 歌曲信息 -->
    <div id="music-player-song-title">请添加歌曲</div>
    <div id="music-player-artist">...</div>
    
    <!-- 5. 播放控制区 (保持不变) -->
    <div class="music-player-controls-wrapper">
        <div class="music-progress-bar-container">
            <div id="music-current-time" class="time-display">0:00</div>
            <div class="progress-bar">
                <div id="music-progress-fill" class="progress-bar-fill"></div>
            </div>
            <div id="music-total-time" class="time-display">0:00</div>
        </div>
        <div class="music-controls">
            <button id="music-prev-btn">◀</button>
            <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
            <button id="music-next-btn">▶</button>
            <button id="music-mode-btn">顺序</button>
            <button id="toggle-lyrics-bar-btn" title="桌面歌词">悬浮</button>
        </div>
    </div>
</div>

    </div>
</div>
    
<!-- ▼▼▼ 请用这【一整块】全新的代码，替换掉你旧的 id="music-playlist-panel" 及其所有内部内容 ▼▼▼ -->
<div id="music-playlist-panel">
<!-- ▼▼▼ 用这整块代码替换 ▼▼▼ -->
<div class="playlist-header">
    <span class="panel-btn" id="close-playlist-btn">返回</span>
    <span>播放列表</span>
    <div>
        <!-- ▼▼▼ 我们把垃圾桶图标移到了'本地'的左边 ▼▼▼ -->
        <span class="panel-btn" id="delete-expired-songs-btn" title="清理失效的搜索歌曲">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 6H5H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6M19 6V20C19 20.5304 18.7893 21.0391 18.4142 21.4142C18.0391 21.7893 17.5304 22 17 22H7C6.46957 22 5.96086 21.7893 5.58579 21.4142C5.21071 21.0391 5 20.5304 5 20V6H19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </span>
        <span class="panel-btn" id="add-song-local-btn">本地</span>
        <span class="panel-btn" id="add-song-url-btn">URL</span>
        <span class="panel-btn" id="add-song-search-btn">搜索</span>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


        <div class="playlist-body" id="playlist-body"></div>
    </div>
    <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
<input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】长期记忆管理全屏页面 ▼▼▼ -->
<div id="long-term-memory-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="memory-screen-back-btn">‹</span>
        <span>长期记忆</span>
        <div class="header-actions">
            <span class="action-btn" id="refine-memory-btn-header">精炼</span>
            <span class="action-btn" id="summarize-recent-btn-header">总结</span>
            <span class="action-btn" id="add-manual-memory-btn-header">+</span>
        </div>
    </div>
    <div class="list-container" id="memory-list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; background-color: #f0f2f5;">
        <!-- 长期记忆列表将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 长期记忆界面添加结束 ▲▲▲ -->

<!-- ▼▼▼ 用这整块代码替换你原来的 id="wallpaper-screen" ▼▼▼ -->
<div id="wallpaper-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <!-- 【核心修改1】标题改为“外观设置”，更通用 -->
        <span>外观设置</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <!-- 锁屏壁纸设置 (全新) -->
        <div style="width:100%; text-align: left; margin-bottom: 5px;">
            <label style="font-weight: 500; color: var(--text-secondary);">锁屏设置</label>
        </div>
        <div id="lockscreen-wallpaper-preview" class="wallpaper-preview">点击下方上传</div>
        <button class="form-button" onclick="document.getElementById('lockscreen-wallpaper-upload-input').click();">上传锁屏壁纸</button>
        <input type="file" id="lockscreen-wallpaper-upload-input" accept="image/*" hidden>
        
        <div class="form-group" style="width: 100%; margin-top: 15px;">
            <label for="password-set-input">锁屏密码 (留空则无密码)</label>
            <input type="text" id="password-set-input" placeholder="设置你的解锁密码">
        </div>
        
        <hr style="width: 80%; opacity: 0.3; margin: 20px 0;">

        <!-- 主屏幕壁纸设置 (原有) -->
        <div style="width:100%; text-align: left; margin-bottom: 5px;">
            <label style="font-weight: 500; color: var(--text-secondary);">主屏幕设置</label>
        </div>
        <div id="wallpaper-preview">点击下方上传</div>
<!-- ▼▼▼ 请将这段新代码粘贴到 wallpaper-preview 的 div 之后 ▼▼▼ -->
<div class="form-group">
    <label for="enable-lock-screen-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">启用锁屏界面</span>
        <input type="checkbox" id="enable-lock-screen-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 在这里粘贴新的“显示状态栏”开关代码 ▼▼▼ -->
<div class="form-group">
    <label for="show-status-bar-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">显示状态栏</span>
        <input type="checkbox" id="show-status-bar-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->


        <button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">上传壁纸</button>
        <input type="file" id="wallpaper-upload-input" accept="image/*">

<!-- ▼▼▼ 将【下面整块代码】，完整替换为下面这段【全新的代码】 ▼▼▼ -->
<div class="form-group" style="display: none;">
    <label for="theme-toggle-switch" style="margin-bottom: 0;">夜间模式</label>
    <label class="toggle-switch">
        <input type="checkbox" id="theme-toggle-switch">
        <span class="slider"></span>
    </label>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

    <!-- === ▼▼▼ 以下是新增的美化功能UI ▼▼▼ === -->
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">手机美化 (CSS)</label>
    </div>

    <!-- 主题选择和管理 -->
    <div class="form-group">
        <label for="theme-selector">选择已存方案</label>
        <div style="display: flex; gap: 10px;">
            <select id="theme-selector" style="flex-grow: 1;"></select>
            <button id="rename-theme-btn" class="form-button-secondary" style="margin:0; padding: 0 10px;">重命名</button>
            <button id="delete-theme-btn" class="form-button-secondary" style="margin:0; padding: 0 10px; background-color: #ffdddd; color: #ff3b30;">删除</button>
        </div>
    </div>

    <!-- CSS 代码编辑区 -->
    <div class="form-group">
        <label for="theme-css-editor">美化代码编辑区</label>
        <textarea id="theme-css-editor" rows="10" style="font-family: monospace; font-size: 12px; resize: vertical;" placeholder="在这里粘贴或编辑美化代码..."></textarea>
    </div>
    
    <!-- 操作按钮 -->
    <button id="apply-theme-btn" class="form-button">应用当前代码</button>
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="save-theme-btn" class="form-button-secondary" style="flex:1;">保存</button>
        <button id="save-as-new-theme-btn" class="form-button-secondary" style="flex:1;">另存</button>
    </div>
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="export-theme-btn" class="form-button-secondary" style="flex:1;">导出方案</button>
        <button id="import-theme-btn" class="form-button-secondary" style="flex:1;">导入方案</button>
        <input type="file" id="import-theme-input" accept=".json" hidden>
    </div>
    <!-- === ▲▲▲ 新增UI结束 ▲▲▲ === -->
<!-- ▼▼▼ 【V3最终美化版】主屏幕美化预设功能UI ▼▼▼ -->
<div class="preset-manager-container">
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">主屏幕预设</label>
    </div>
    <div class="form-group">
        <select id="home-preset-selector" class="form-group select"></select>
        <div class="preset-manager-controls">
            <!-- 独占一行的应用按钮 -->
            <button id="apply-home-preset-btn" class="preset-btn-capsule preset-btn-apply" disabled>应用</button>
            
            <!-- 2x2 网格按钮 -->
            <button id="save-home-preset-btn" class="preset-btn-capsule preset-btn-save">保存</button>
            <!-- ▼▼▼ 就是在这里新增了“更新”按钮 ▼▼▼ -->
            <button id="update-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>更新</button>
            <button id="rename-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>重命名</button>
            <button id="import-home-preset-btn" class="preset-btn-capsule preset-btn-secondary">导入</button>
            <button id="export-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>导出</button>
            <button id="delete-home-preset-btn" class="preset-btn-capsule preset-btn-delete" disabled>删除</button>
            
            <input type="file" id="import-home-preset-input" accept=".json" hidden>
        </div>
    </div>
</div>
<!-- ▲▲▲ UI替换结束 ▲▲▲ -->

        <!-- 【核心修改2】新增图标设置区域 -->
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">App 图标设置</label>
        </div>
        <div id="icon-settings-grid">
            <!-- 图标设置项将由JS动态生成在这里 -->
        </div>

<!-- ▼▼▼ 将这段新代码，粘贴到“保存所有外观设置”按钮的【上方】 ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">铃声设置</label>
</div>
<div class="form-group" style="width: 100%;">
    <label for="ringtone-url-input">来电铃声 URL (.mp3, .wav, etc.)</label>
    <input type="text" id="ringtone-url-input" placeholder="输入音频文件的网络链接...">
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
        
        <!-- 【核心修改3】按钮文字也改一下 -->
        <button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">保存所有外观设置</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享链接功能 HTML ▼▼▼ -->
<div id="browser-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="browser-back-btn">‹</span>
        <span id="browser-title"></span>
        <span style="width: 30px;"></span>
    </div>
    <div id="browser-content" class="list-container">
        <!-- 文章内容将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<div id="font-settings-screen" class="screen">
    <div class="header">
    <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
    <span>字体预设</span>
    <span style="width: 30px;"></span> <!-- 保留这个占位符，让标题能完美居中 -->
</div>
    <div class="form-container" style="gap: 20px;">
        <!-- 字体预设卡槽的容器 -->
        <div id="font-preset-container">
            <!-- 5个卡槽将由JavaScript动态生成在这里 -->
        </div>

        <!-- 全局字体预览区 -->
        <div class="form-group" style="width:100%;">
            <label>当前全局字体预览</label>
            <div id="font-preview">
                <p style="font-size: 20px; margin: 0 0 10px 0;">你好世界 Hello World</p>
                <p style="margin: 0;">这是全局字体预览效果，12345。</p>
            </div>
        </div>

        <button class="form-button form-button-secondary" id="reset-font-btn">恢复默认字体</button>
    </div>
</div>

<!-- 这个是隐藏的文件选择器，用来处理本地上传 -->
<input type="file" id="font-preset-local-upload" accept=".ttf,.otf,.woff,.woff2" style="display: none;">


<!-- ▼▼▼ 【全新】“查角色手机”功能的所有HTML界面 (V3终极版) ▼▼▼ -->

<!-- 1. 角色选择屏幕 (保持不变) -->
<div id="character-selection-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>选择要查看的手机</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="character-selection-list" class="list-container"></div>
</div>

<!-- 2. 角色的手机“外壳”容器 -->
<div id="character-phone-container" class="screen">
    <div class="character-phone-frame">
        <div class="character-phone-notch"></div>
        <div class="character-phone-inner-screen">
            
            <!-- 2a. 角色手机的主界面 -->
            <div id="character-phone-screen" class="character-phone-page active">
                <div class="header character-phone-header">
                    <!-- 【核心修改】移除了onclick，换成data-target-page -->
                    <span class="back-btn" data-target-screen="character-selection-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-phone-owner-name"></span>
                    <div class="header-actions">
                        <span class="action-btn" id="clear-character-data-btn" title="清空数据">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-character-data-btn" title="刷新数据">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L20.5 10M3.5 14a9 9 0 0114.85 3.36L20.5 14"/></svg>
                        </span>
                    </div>
                </div>
                <!-- ▼▼▼ 核心修改：删除了 "app-grid" 这个class ▼▼▼ -->
<div id="character-app-grid" class="app-grid-standard" style="padding-top: 60px;"></div>
            </div>

            <!-- 2b. 角色手机 - 聊天列表 -->
            <div id="character-chat-list-screen" class="character-phone-page">
                <div class="header character-phone-header">
                    <!-- 【核心修改】移除了onclick，换成data-target-page -->
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>消息</span>
                </div>
                <div id="character-chat-list" class="list-container" style="padding: 0;"></div>
            </div>

            <!-- 2c. 角色手机 - 具体聊天记录 -->
            <div id="character-chat-history-screen" class="character-phone-page">
                <div class="header character-phone-header">
                     <!-- 【核心修改】移除了onclick，换成data-target-page -->
                     <span class="back-btn" data-target-page="character-chat-list-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-chat-with-name"></span>
                </div>
                <div id="character-chat-history-messages" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; background-color: #e5ddd5;"></div>
            </div>

            <!-- 2d. 角色手机 - 购物车 -->
            <div id="character-shopping-cart-screen" class="character-phone-page">
                <div class="header character-phone-header">
                    <!-- 【核心修改】移除了onclick，换成data-target-page -->
                    <span class="back-btn" data-target-page="character-phone-screen">
                         <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>购物车</span>
                </div>
                <div id="character-shopping-cart-list" class="list-container"></div>
            </div>
            
            <!-- 2e. 角色手机 - 备忘录 -->
            <div id="character-memos-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <!-- 【核心修改】移除了onclick，换成data-target-page -->
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>备忘录</span>
                </div>
                <div id="character-memos-list" class="list-container"></div>
            </div>

            <!-- 2f. 角色手机 - 浏览器 -->
            <div id="character-browser-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>浏览器</span>
                </div>
                <div id="character-browser-list" class="list-container"></div>
            </div>

            <!-- 2k. 角色手机 - 浏览器搜索结果详情 -->
            <div id="character-browser-detail-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-browser-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-browser-detail-title">搜索结果</span>
                </div>
                <div id="character-browser-detail-content" class="list-container" style="padding: 15px; line-height: 1.7;"></div>
            </div>

            <!-- 2g. 角色手机 - 相册 -->
            <div id="character-album-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>相册</span>
                </div>
                <div id="character-album-grid" class="list-container"></div>
            </div>
            
            <!-- 2h. 角色手机 - 银行 -->
            <div id="character-bank-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>钱包</span>
                </div>
                <div id="character-bank-details" class="list-container"></div>
            </div>
            
            <!-- 2i. 角色手机 - 行动轨迹 -->
            <div id="character-trajectory-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>足迹</span>
                </div>
                <div id="character-trajectory-list" class="list-container"></div>
            </div>
            
            <!-- 2j. 角色手机 - APP使用记录 -->
            <div id="character-app-usage-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>屏幕使用时间</span>
                </div>
                <div id="character-app-usage-list" class="list-container"></div>
            </div>

            <!-- 2l. 角色手机 - 日记 -->
            <div id="character-diary-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>日记</span>
                    <div class="header-actions">
                        <!-- 这是日记专属的刷新按钮 -->
                        <span class="action-btn" id="generate-diary-entry-btn" title="写新日记">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-diary-list" class="list-container"></div>
            </div>

        </div>
    </div>
</div>

<!-- 加载动画遮罩层 (保持不变) -->
<div id="generation-overlay" class="modal" style="background-color: rgba(0,0,0,0.6); z-index: 2000;">
    <div style="text-align: center; color: white;">
        <div id="loading-spinner" style="width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
        <p>正在同步Ta的手机数据...</p>
        <p style="font-size: 12px; opacity: 0.7;">（这可能需要一些时间，并会消耗API额度）</p>
    </div>
</div>

<!-- ▲▲▲ “查角色手机”功能HTML结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】选择联系人以创建群聊的屏幕 ▼▼▼ -->
<div id="contact-picker-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="cancel-contact-picker-btn">取消</span>
        <span>选择联系人</span>
        <span class="save-btn" id="confirm-contact-picker-btn">完成(0)</span>
    </div>
    <div class="list-container" id="contact-picker-list">
        <!-- 联系人列表将由JS动态生成 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】群成员管理屏幕 ▼▼▼ -->
<div id="member-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-member-management">‹</span>
        <span>群成员管理</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="list-container" id="member-management-list">
        <!-- 现有成员列表会在这里动态生成 -->
    </div>
    <div id="member-management-actions">
        <button id="add-existing-contact-btn">从好友列表添加</button>
        <button id="create-new-member-btn">创建群内新成员</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话类型选择模态框 ▼▼▼ -->
<div id="call-type-selection-modal" class="modal">
    <div class="call-type-selection-content">
        <div class="call-type-title">选择通话类型</div>
        <div class="call-type-actions">
            <div class="action-button-wrapper">
                <button id="select-video-call-btn" class="call-type-btn video-call-btn">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="23 7 16 12 23 17 23 7"></polygon>
                        <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                    </svg>
                </button>
                <span>视频通话</span>
            </div>
            <div class="action-button-wrapper">
                <button id="select-voice-call-btn" class="call-type-btn voice-call-btn">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
                    </svg>
                </button>
                <span>语音通话</span>
            </div>
        </div>
        <button id="cancel-call-type-selection-btn" class="cancel-call-type-btn">取消</button>
    </div>
</div>

<!-- ▼▼▼ 【全新】来电请求模态框 ▼▼▼ -->
<div id="incoming-call-modal" class="modal">
    <div class="incoming-call-content">
        <img id="caller-avatar" class="caller-avatar" src="">
        <div id="caller-name" class="caller-name"></div>
        <div class="caller-text">邀请你视频通话</div>
        <div class="incoming-call-actions">
            <div class="action-button-wrapper">
                <button id="decline-call-btn" class="call-action-btn decline"></button>
                <span>拒绝</span>
            </div>
            <div class="action-button-wrapper">
                <button id="accept-call-btn" class="call-action-btn accept"></button>
                <span>接听</span>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是BGM搜索结果的弹窗，请粘贴到body末尾 ▼▼▼ -->
<div id="music-search-results-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>搜索结果</span>
        </div>
        <div class="modal-body" id="search-results-list" style="padding: 0;">
            <!-- 搜索结果将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-music-search-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▼▼▼ 请用这段【全新群聊兼容结构】的代码，完整替换你旧的 #video-call-screen ▼▼▼ -->
<!-- ▼▼▼ 用下面这【一整块】全新的代码，替换掉你文件中旧的 #video-call-screen 及其所有内容 ▼▼▼ -->
<div id="video-call-screen" class="screen">
    <!-- 这个 screen 同时为两种模式服务 -->

    <!-- ======================================================= -->
    <!-- 模式一：全新的【可视化】视频通话界面 -->
    <!-- ======================================================= -->
    <div id="visual-call-interface" style="display: none;"> <!-- 默认隐藏 -->
        <!-- 1. 视频背景层 (大图和小图都在这里) -->
        <div class="video-background">
            <!-- 大图容器 -->
            <div id="video-main-view" class="video-container">
                <img src="" alt="主视频画面">
            </div>
            <!-- 小图容器 (画中画) -->
            <div id="video-pip-view" class="video-container pip">
                <img src="" alt="小窗视频画面">
            </div>
        </div>

        <!-- 2. 顶部状态栏 -->
        <div class="video-call-top-bar">
            <span id="visual-call-timer">00:00</span>
        </div>

        <!-- 3. 聊天气泡显示区域 -->
        <div id="video-call-messages-visual" class="video-call-main">
            <!-- 聊天气泡会由JS动态生成在这里 -->
        </div>
<!-- ▼▼▼ 用下面这【一整块】代码，替换掉 id="visual-call-interface" 里面那个旧的 video-call-controls 的 div ▼▼▼ -->
        <!-- AI回复状态指示器 -->
        <div id="ai-reply-status-visual" class="ai-reply-status">
            <span class="reply-status-text">对方正在回复中</span>
            <span class="reply-status-dots">
                <span class="dot">.</span>
                <span class="dot">.</span>
                <span class="dot">.</span>
            </span>
        </div>
<div class="video-call-controls">
    <!-- 重-roll按钮 -->
    <button id="reroll-call-btn" class="control-btn reroll-btn" title="重新生成"></button>
    <!-- 【核心新增】发言按钮 -->
    <button id="user-speak-btn-visual" class="control-btn speak-btn" title="发言"></button>
    <!-- 切换镜头按钮 -->
    <button id="switch-camera-btn" class="control-btn switch-camera-btn" title="切换镜头"></button>
    <!-- 挂断按钮 -->
    <button id="hang-up-btn-visual" class="control-btn hangup-btn"></button>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

    </div>

    <!-- ======================================================= -->
    <!-- 模式二：你原来的【纯文字】语音通话界面 (我们把它保留下来作为默认选项) -->
    <!-- ======================================================= -->
    <div id="text-call-interface" style="display: none;"> <!-- 默认隐藏 -->
        <div class="video-call-top-bar">
            <span id="call-timer">00:00</span>
        </div>
        <div class="video-call-avatar-area">
            <div id="participant-avatars-grid">
                <!-- JS会在这里动态生成头像 -->
            </div>
        </div>
        <div id="video-call-main" class="video-call-main">
            <!-- 对话内容会动态生成在这里 -->
        </div>
        <!-- AI回复状态指示器 -->
        <div id="ai-reply-status-text" class="ai-reply-status">
            <span class="reply-status-text">对方正在回复中</span>
            <span class="reply-status-dots">
                <span class="dot">.</span>
                <span class="dot">.</span>
                <span class="dot">.</span>
            </span>
        </div>
        <div class="video-call-controls">
            <!-- 【新增】为旧模式也加上重roll按钮 -->
            <button id="reroll-call-btn-text" class="control-btn reroll-btn" title="重新生成"></button>
            <button id="user-speak-btn" class="control-btn speak-btn"></button>
            <button id="hang-up-btn" class="control-btn hangup-btn"></button>
            <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- ▼▼▼ 【全新添加】语音通话屏幕 ▼▼▼ -->
<div id="voice-call-screen" class="screen">
    <!-- 语音通话界面 -->
    <div class="voice-call-top-bar">
        <!-- 时间显示 - 居中 -->
        <span id="voice-call-timer" style="position: absolute; left: 50%; transform: translateX(-50%); margin-bottom: 15px;">00:00</span>
        
        <!-- 语音控制开关组 - 右侧 -->
        <div style="display: flex; flex-direction: column; gap: 8px; margin-left: auto;">
            <!-- 语音识别开关 -->
            <div class="voice-recognition-toggle">
                <label class="toggle-switch">
                    <input type="checkbox" id="voice-recognition-switch">
                    <span class="toggle-slider"></span>
                </label>
                <span class="toggle-label">语音识别</span>
            </div>
            
            <!-- 自动语音播放开关 -->
            <div class="auto-voice-toggle">
                <label class="toggle-switch">
                    <input type="checkbox" id="auto-voice-switch">
                    <span class="toggle-slider"></span>
                </label>
                <span class="toggle-label">自动语音</span>
            </div>
        </div>
        
        <!-- 语音识别控制面板（仅在语音识别开启时显示） -->
        <div id="voice-recognition-controls" class="voice-recognition-controls" style="display: none;">
            <!-- 待处理消息队列显示 -->
            <div id="message-queue-display" class="message-queue-display" style="display: none;">
                <div class="queue-header">
                    <span>待处理消息 (<span id="queue-count">0</span>)</span>
                </div>
                <div id="queue-messages" class="queue-messages">
                    <!-- 动态生成待处理消息列表 -->
                </div>
            </div>
            
            <!-- 语音锁定开关 -->
            <div class="voice-lock-toggle">
                <label class="toggle-switch small">
                    <input type="checkbox" id="voice-lock-switch">
                    <span class="toggle-slider"></span>
                </label>
                <span class="toggle-label small">处理时锁定</span>
            </div>
        </div>
    </div>
    
    <div class="voice-call-avatar-area">
        <div id="voice-participant-avatars-grid">
            <!-- JS会在这里动态生成头像 -->
        </div>
    </div>
    
    <div id="voice-call-main" class="voice-call-main">
        <!-- 对话内容会动态生成在这里 -->
    </div>
    
    <!-- 语音识别状态指示器 -->
    <div id="voice-recognition-status" class="voice-recognition-status">
        <div class="audio-waveform">
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
            <div class="audio-bar"></div>
        </div>
        <div class="recognition-text">识别中...</div>
        <div id="interim-transcript" style="font-size: 11px; color: #888; text-align: left; max-width: 250px; line-height: 1.3;"></div>
    </div>
    
    <!-- AI回复状态指示器 -->
    <div id="ai-reply-status-voice" class="ai-reply-status">
        <span class="reply-status-text">对方正在回复中</span>
        <span class="reply-status-dots">
            <span class="dot">.</span>
            <span class="dot">.</span>
            <span class="dot">.</span>
        </span>
    </div>
    
    <div class="voice-call-controls">
        <!-- 重-roll按钮 -->
        <button id="reroll-voice-call-btn" class="control-btn reroll-btn" title="重新生成"></button>
        <!-- 发言按钮 -->
        <button id="user-speak-voice-btn" class="control-btn speak-btn" title="发言"></button>
        <!-- 挂断按钮 -->
        <button id="hang-up-voice-btn" class="control-btn hangup-btn"></button>
        <!-- 加入通话按钮 -->
        <button id="join-voice-call-btn" class="control-btn join-btn" style="display: none;" title="加入通话"></button>
    </div>
</div>
<!-- ▲▲▲ 语音通话屏幕结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新添加】正在呼叫界面 ▼▼▼ -->
<div id="outgoing-call-screen" class="screen">
    <div class="outgoing-call-content">
        <img id="outgoing-call-avatar" class="caller-avatar" src="">
        <div id="outgoing-call-name" class="caller-name"></div>
        <div class="caller-text">正在呼叫...</div>
        <div class="outgoing-call-actions">
            <button id="cancel-call-btn" class="call-action-btn decline" onclick="handleCancelCall()"></button>
            <span>取消</span>
        </div>
    </div>
</div>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话记录页面 ▼▼▼ -->
<div id="call-history-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="call-history-back-btn">‹</span>
        <span id="call-history-title">通话记录</span>
        <span style="width: 30px;"></span> <!-- 占位符，保持标题居中 -->
    </div>
    <div id="call-history-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 通话记录卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是聊天记录搜索界面，请粘贴到 call-history-screen 的 div 之后 ▼▼▼ -->
<div id="chat-search-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="search-back-btn">‹</span>
        <span>查找聊天记录</span>
        <span style="width: 30px;"></span> <!-- 占位符 -->
    </div>
    <div class="form-container" style="padding-bottom: 0;">
        <!-- 搜索条件输入区 -->
        <div class="form-group">
            <label for="keyword-search-input">关键词</label>
            <input type="text" id="keyword-search-input" placeholder="输入要查找的关键词...">
        </div>
        <div class="form-group">
            <label for="sender-search-select">人物</label>
            <select id="sender-search-select">
                <!-- 选项将由JS动态生成 -->
            </select>
        </div>
        <div class="form-group">
            <label for="date-search-input">日期</label>
            <input type="date" id="date-search-input">
        </div>
        <button class="form-button" id="perform-search-btn">开始查找</button>
        
        <!-- 搜索结果显示区 -->
        <div id="chat-search-results-list" class="list-container" style="margin-top: 15px; padding: 0;">
            <!-- 搜索结果将由JS动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->


            <!-- ▼▼▼ 请将下面这整块【全新的HTML代码】粘贴到这里 ▼▼▼ -->
            <div id="lock-screen" class="screen">
                <div id="lock-clock-container">
                    <div id="lock-main-time">12:00</div>
                    <div id="lock-main-date">星期一, 1月1日</div>
                </div>
                <div id="unlock-hint">向上轻扫以解锁</div>
            </div>

            <div id="password-modal-overlay" class="modal">
                <div class="password-modal-content">
                    <p>请输入密码</p>
                    <input type="password" id="password-input-field" maxlength="20">
                    <div class="password-actions">
                        <button id="password-cancel-btn">取消</button>
                        <button id="password-confirm-btn">进入</button>
                    </div>
                </div>
            </div>
            <!-- ▲▲▲ 新HTML代码粘贴结束 ▲▲▲ -->

        </div>
    </div>
  
    <div id="chat-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>聊天设置</span></div><div class="modal-body">
    
<!-- ═══════════════════════════════════════════════════════════ -->
<!-- ▼▼▼ 【区域1】基础信息设置 ▼▼▼ -->
<!-- ═══════════════════════════════════════════════════════════ -->

    <!-- 线下模式设置 -->
    <div class="form-group" id="offline-mode-settings-group" style="display: none;">
        <hr style="opacity: 0.2; margin: 20px 0;">
        <label style="font-weight: 600; color: var(--accent-color);">线下模式专属设置</label>
        <button id="offline-mode-settings-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 10px;">配置线下模式参数</button>
    </div>
    
    <!-- 备注名/群名 -->
    <div class="form-group" id="chat-name-group">
        <label for="chat-name-input">备注名 / 群名</label>
        <input type="text" id="chat-name-input">
    </div>

    <!-- 好友分组（单聊显示） -->
    <div class="form-group" id="assign-group-section" style="display: none;">
        <label for="assign-group-select">好友分组</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="assign-group-select" style="flex-grow: 1;">
                <!-- 分组选项将由JS动态生成 -->
            </select>
            <button id="manage-groups-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">管理分组</button>
        </div>
    </div>

    <!-- 我的群昵称（群聊显示） -->
    <div class="form-group" id="my-group-nickname-group">
        <label for="my-group-nickname-input">我的群昵称</label>
        <input type="text" id="my-group-nickname-input">
    </div>
    
    <!-- 群头像（群聊显示） -->
    <div class="form-group" id="group-avatar-group">
        <label>群头像</label>
        <div class="avatar-upload">
            <img id="group-avatar-preview">
            <button onclick="document.getElementById('group-avatar-input').click()">上传群头像</button>
            <input type="file" id="group-avatar-input" accept="image/*">
        </div>
    </div>

<!-- ═══════════════════════════════════════════════════════════ -->
<!-- ▼▼▼ 【区域2】功能配置 ▼▼▼ -->
<!-- ═══════════════════════════════════════════════════════════ -->

    <!-- Minimax语音ID（单聊显示） -->
    <div class="form-group" id="minimax-voice-id-group" style="display: none;">
        <label for="minimax-voice-id-input">🖤 Minimax 语音 ID (可选)</label>
        <input type="text" id="minimax-voice-id-input" placeholder="填写后角色会拥有语音能力">
        <small style="display: block; color: #666; font-size: 12px; margin-top: 5px;">
            在 <a href="https://www.minimaxi.com/voice-clone" target="_blank" style="color: #007bff;">Minimax 语音克隆</a> 页面创建自定义语音并获取ID
        </small>
    </div>
    
    <!-- 关联世界书 -->
    <div class="form-group" id="world-book-link-group">
        <label>关联世界书 (可多选)</label>
        <div class="custom-multiselect">
            <div class="select-box">
                <span class="selected-options-text">-- 点击选择 --</span>
                <span class="arrow-down">▼</span>
            </div>
            <div id="world-book-checkboxes-container" class="checkboxes-container">
            </div>
        </div>
    </div>
    
    <!-- NPC库管理 -->
    <div class="form-group" id="npc-library-group">
        <button id="manage-npcs-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 5px;">管理NPC库</button>
    </div>
    
    <!-- 时间感知设置 -->
    <hr style="opacity: 0.2; margin: 20px 0;">
    <div class="form-group">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <span>启用实时时间感知</span>
            <label class="toggle-switch">
                <input type="checkbox" id="time-perception-toggle" checked>
                <span class="slider"></span>
            </label>
        </div>
    </div>
    <div id="custom-time-container" class="form-group" style="display: none;">
        <label for="custom-time-input">自定义时间</label>
        <input type="datetime-local" id="custom-time-input" style="width: 95%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
    </div>

    <!-- 群聊私聊记忆（群聊显示） -->
    <div class="form-group" id="group-private-memory-settings-group" style="display: none;">
        <hr style="opacity: 0.2; margin: 20px 0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <div>
                <div>启用私聊记忆副窗口</div>
                <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
                    开启后，此群聊可以读取用户与群内AI角色的私聊记忆作为副窗口参考
                </p>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="group-private-memory-switch">
                <span class="slider"></span>
            </label>
        </div>
        
        <div id="group-private-memory-selection-container" style="display: none; margin-top: 15px;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <span style="font-size: 14px; color: #666;">私聊记忆总轮数：</span>
                <input type="number" id="group-private-memory-rounds" min="1" max="30" value="8" style="width: 80px; text-align: center; margin-left: 10px;">
                <span style="font-size: 12px; color: #666; margin-left: 10px;">（所有角色私聊的总轮数）</span>
            </div>
            <div style="font-size: 12px; color: #999; margin-top: 8px;">
                ⚠️ 隐私保护：每个AI只能看到自己与用户的私聊记忆，不会看到其他角色的私聊内容
            </div>
        </div>
    </div>

    <!-- 群聊后台活动（群聊显示） -->
    <div class="form-group" id="group-background-activity-group" style="display: none;">
        <hr style="opacity: 0.2; margin: 20px 0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <div>
                <div>群聊后台实时活动</div>
                <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
                    警告：开启后会增加API调用和费用！
                </p>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="group-background-activity-switch">
                <span class="slider"></span>
            </label>
        </div>

        <div id="group-background-interval-settings" style="display: none; margin-top: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <label for="group-background-interval-input" style="margin-bottom: 0;">
                    活动间隔期 (秒)
                    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                        建议值 120-600。值越大，费用越低，但群内互动越慢。
                    </p>
                </label>
                <input type="number" id="group-background-interval-input" min="60" value="120" style="width: 80px; text-align: center;">
            </div>
        </div>
    </div>

<!-- ═══════════════════════════════════════════════════════════ -->
<!-- ▼▼▼ 【区域3】角色设置 ▼▼▼ -->
<!-- ═══════════════════════════════════════════════════════════ -->

    <!-- 对方头像 -->
    <hr style="opacity: 0.2; margin: 20px 0;">
    <div class="form-group" id="ai-avatar-group">
        <label>对方头像</label>
        <div class="avatar-upload">
            <img id="ai-avatar-preview">
            <button onclick="document.getElementById('ai-avatar-input').click()">上传对方头像</button>
            <button class="change-frame-btn" data-type="ai">更换头像框</button>
            <button id="manage-ai-avatar-library-btn" class="form-button-secondary">管理头像库</button>
            <input type="file" id="ai-avatar-input" accept="image/*">
        </div>
    </div>
    
    <!-- 对方人设 -->
    <div class="form-group" id="ai-persona-group">
        <label for="ai-persona">对方人设 (AI Persona)</label>
        <textarea id="ai-persona" rows="3"></textarea>
    </div>
    
    <!-- 我的头像 -->
    <div class="form-group" id="my-avatar-group">
        <label>我的头像</label>
        <div class="avatar-upload">
            <img id="my-avatar-preview">
            <button onclick="document.getElementById('my-avatar-input').click()">上传我的头像</button>
            <button class="change-frame-btn" data-type="my">更换头像框</button>
            <button id="open-persona-library-btn" class="form-button-secondary">预设</button>
            <input type="file" id="my-avatar-input" accept="image/*">
        </div>
    </div>
    
    <!-- 我的人设 -->
    <div class="form-group" id="my-persona-group">
        <label for="my-persona">我的人设 (My Persona)</label>
        <textarea id="my-persona" rows="3"></textarea>
    </div>
    
    <!-- 群成员人设（群聊显示） -->
    <div class="form-group" id="group-members-group">
        <label>群成员人设</label>
        <div id="group-members-settings"></div>
        <button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px;">管理群成员</button>
    </div>

<!-- ═══════════════════════════════════════════════════════════ -->
<!-- ▼▼▼ 【区域4】高级功能设置 ▼▼▼ -->
<!-- ═══════════════════════════════════════════════════════════ -->

    <!-- 视频通话设置（单聊显示） -->
    <div class="form-group" id="video-call-settings-group">
        <hr style="opacity: 0.2; margin: 20px 0;">
        <label>视频通话界面设置</label>
        
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <span>启用可视化界面</span>
            <label class="toggle-switch">
                <input type="checkbox" id="visual-video-call-switch">
                <span class="slider"></span>
            </label>
        </div>

        <div id="video-call-image-uploads" style="display: none;">
            <div class="form-group">
                <label>对方的视频画面</label>
                <div class="avatar-upload">
                    <img id="char-video-image-preview" style="border-radius: 8px; width: 80px; height: 142px;">
                    <button onclick="document.getElementById('char-video-image-input').click()">上传图片</button>
                    <input type="file" id="char-video-image-input" accept="image/*" hidden>
                </div>
            </div>
            <div class="form-group">
                <label>我的视频画面</label>
                <div class="avatar-upload">
                    <img id="user-video-image-preview" style="border-radius: 8px; width: 80px; height: 142px;">
                    <button onclick="document.getElementById('user-video-image-input').click()">上传图片</button>
                    <input type="file" id="user-video-image-input" accept="image/*" hidden>
                </div>
            </div>
        </div>
    </div>

    <!-- 上下文记忆条数 -->
    <hr style="opacity: 0.2; margin: 20px 0;">
    <div class="form-group">
        <label for="max-memory">上下文记忆条数</label>
        <input type="number" id="max-memory" value="10">
    </div>

    <!-- 群聊记忆互通（单聊显示） -->
    <div class="form-group" id="group-memory-settings-group" style="display: none;">
        <hr style="opacity: 0.2; margin: 20px 0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <div>
                <div>启用群聊记忆互通</div>
                <p style="font-size: 12px; font-weight: normal; color: #666; margin-top: 5px;">
                    开启后，此角色的私聊可以读取到勾选群聊的最新消息记忆
                </p>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="group-memory-switch">
                <span class="slider"></span>
            </label>
        </div>

        <div id="group-memory-selection-container" style="display: none; margin-top: 15px;">
            <label>选择参与的群聊 (可多选)</label>
            <div class="custom-multiselect" style="margin-top: 8px;">
                <div class="select-box" id="group-memory-select-box">
                    <span class="selected-options-text" id="group-memory-selected-text">-- 点击选择 --</span>
                    <span class="arrow-down">▼</span>
                </div>
                <div id="group-memory-checkboxes-container" class="checkboxes-container">
                    <!-- 群聊选项将由JS动态生成 -->
                </div>
            </div>
            <div style="margin-top: 10px;">
                <label for="group-memory-rounds">每个群聊读取轮数</label>
                <input type="number" id="group-memory-rounds" min="1" max="20" value="5" style="width: 80px; text-align: center; margin-left: 10px;">
                <span style="font-size: 12px; color: #666; margin-left: 10px;">（一轮 = 用户消息 + AI回复）</span>
            </div>
        </div>
    </div>

    <!-- NAI出图设置（单聊显示） -->
    <div class="form-group" id="nai-character-settings-group" style="display: none;">
        <hr style="opacity: 0.2; margin: 20px 0;">
        <label style="font-weight: 600; color: var(--accent-color);">NAI出图设置</label>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
            为当前角色配置专属的NovelAI出图提示词
        </p>
        
        <div style="margin-top: 15px;">
            <label style="font-weight: 500; color: #333;">提示词来源</label>
            <div style="display: flex; gap: 15px; margin-top: 10px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="nai-prompt-source" value="system" checked style="width: auto; margin-right: 8px;">
                    <span>使用系统设置</span>
                </label>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="nai-prompt-source" value="character" style="width: auto; margin-right: 8px;">
                    <span>使用当前角色配置</span>
                </label>
            </div>
        </div>
        
        <button id="character-nai-prompts-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 15px;">配置角色专属提示词</button>
    </div>

    <!-- NAI出图设置（群聊显示） -->
    <div class="form-group" id="group-nai-settings-group" style="display: none;">
        <hr style="opacity: 0.2; margin: 20px 0;">
        <label style="font-weight: 600; color: var(--accent-color);">NAI出图设置</label>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">
            为当前角色配置专属的NovelAI出图提示词
        </p>
        
        <div style="margin-top: 15px;">
            <label style="font-weight: 500; color: #333;">提示词来源</label>
            <div style="display: flex; gap: 15px; margin-top: 10px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="group-nai-prompt-source" value="system" checked style="width: auto; margin-right: 8px;">
                    <span>使用系统设置</span>
                </label>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="group-nai-prompt-source" value="character" style="width: auto; margin-right: 8px;">
                    <span>使用当前角色配置</span>
                </label>
            </div>
        </div>
        
        <button id="group-character-nai-prompts-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 15px;">配置角色专属提示词</button>
    </div>

<!-- ═══════════════════════════════════════════════════════════ -->
<!-- ▼▼▼ 【区域5】界面样式设置 ▼▼▼ -->
<!-- ═══════════════════════════════════════════════════════════ -->

    <!-- 聊天气泡主题 -->
    <hr style="opacity: 0.2; margin: 20px 0;">
    <div class="form-group">
        <label>聊天气泡主题 <button id="reset-theme-btn" type="button">重置</button></label>
        <div class="theme-selector">
            <label><input type="radio" name="theme-select" value="default" id="theme-default"> 默认</label>
            <label><input type="radio" name="theme-select" value="pink_blue"> 粉蓝</label>
            <label><input type="radio" name="theme-select" value="blue_white"> 蓝白</label>
            <label><input type="radio" name="theme-select" value="purple_yellow"> 紫黄</label>
            <label><input type="radio" name="theme-select" value="black_white"> 黑白</label>
            <label><input type="radio" name="theme-select" value="yellow_white"> 黄白</label>
            <label><input type="radio" name="theme-select" value="red_black"> 红黑</label>
            <label><input type="radio" name="theme-select" value="blue_yellow"> 蓝黄</label>
            <label><input type="radio" name="theme-select" value="pink_yellow"> 粉黄</label>
            <label><input type="radio" name="theme-select" value="pink_purple"> 粉紫</label>
            <label><input type="radio" name="theme-select" value="gray_white"> 灰白</label>
            <label><input type="radio" name="theme-select" value="blue_green"> 蓝绿</label>
            <label><input type="radio" name="theme-select" value="pink_white"> 粉白</label>
            <label><input type="radio" name="theme-select" value="pink_black"> 粉黑</label>
            <label><input type="radio" name="theme-select" value="pink_green"> 粉绿</label>
            <label><input type="radio" name="theme-select" value="green_black"> 绿黑</label>
        </div>
    </div>

    <!-- 聊天字体大小 -->
    <div class="form-group">
        <label for="font-size-slider">聊天字体大小 <span id="font-size-value">13px</span></label>
        <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px;">
    </div>

    <!-- 气泡样式预设 -->
    <div class="form-group">
        <label>气泡样式预设</label>
        <div class="bubble-preset-manager">
            <select id="bubble-style-preset-select" class="form-group select"></select>
            <button id="manage-bubble-presets-btn" class="form-button-secondary">管理</button>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="export-bubble-preset-btn" class="form-button form-button-secondary" style="flex:1; margin:0;">导出气泡</button>
            <button id="import-bubble-preset-btn" class="form-button form-button-secondary" style="flex:1; margin:0;">导入气泡</button>
        </div>
        <input type="file" id="import-bubble-preset-input" accept=".json" style="display: none;">
    </div>

    <!-- 自定义气泡样式CSS -->
    <div class="form-group">
        <label for="custom-css-input">
            自定义气泡样式 (CSS)
            <button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
        </label>
        <textarea id="custom-css-input" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;" placeholder="/* 示例：为"我"的气泡添加渐变背景和阴影 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"></textarea>
    </div>

    <!-- 实时预览 -->
    <div class="form-group">
        <label>实时预览</label>
        <div id="settings-preview-area">
            <!-- JS会在这里生成预览内容 -->
        </div>
    </div>

    <!-- 聊天背景 -->
    <div class="form-group">
        <label>聊天背景</label>
        <div class="bg-upload-container">
            <button type="button" class="form-button-secondary" style="width: auto; padding: 8px 12px; margin-top: 0;" onclick="document.getElementById('bg-input').click()">上传背景图</button>
            <button type="button" id="remove-bg-btn" class="form-button-secondary">移除背景</button>
        </div>
        <img id="bg-preview" class="bg-preview-img">
        <input type="file" id="bg-input" accept="image/*" style="display: none;">
    </div>

<!-- ═══════════════════════════════════════════════════════════ -->
<!-- ▼▼▼ 【区域6】数据管理 ▼▼▼ -->
<!-- ═══════════════════════════════════════════════════════════ -->

    <hr style="opacity: 0.2; margin: 20px 0;">
    
    <!-- 导入/导出聊天记录 -->
    <div class="form-group" style="display: flex; gap: 10px;">
        <button class="form-button form-button-secondary" id="import-chat-history-btn" style="flex: 1; margin: 0;">导入聊天记录</button>
        <button class="form-button form-button-secondary" id="export-chat-history-btn" style="flex: 1; margin: 0;">导出聊天记录</button>
    </div>
    <input type="file" id="import-chat-history-input" accept="application/json" style="display: none;">
    
    <!-- 查找聊天记录 -->
    <button class="form-button form-button-secondary" id="search-chat-btn">查找聊天记录</button>
    
    <!-- 清空聊天记录 -->
    <button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天记录</button>
    
    <!-- 拉黑对方 -->
    <button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">拉黑对方</button>

</div><div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">取消</button><button class="save" id="save-chat-settings-btn">保存</button></div></div></div>
    
    <div id="persona-library-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>我的人设库</span><button id="add-persona-preset-btn" class="action-button">添加</button></div><div class="modal-body"><div id="persona-library-grid"></div></div><div class="modal-footer"><button class="cancel" id="close-persona-library-btn">关闭</button></div></div></div>
    
<!-- ▼▼▼ 从这里开始替换 ▼▼▼ -->
<div id="persona-editor-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span id="persona-editor-title">添加人设预设</span>
        </div>
        <div class="modal-body">
            <!-- 【新增】NPC名字输入框 -->
            <div class="form-group" id="npc-editor-name-group">
                <label for="npc-editor-name-input">NPC 名字</label>
                <input type="text" id="npc-editor-name-input">
            </div>
            <div class="form-group">
                <label>头像</label>
                <div class="avatar-upload">
                    <img id="preset-avatar-preview">
                    <button onclick="document.getElementById('preset-avatar-input').click()">上传头像</button>
                    <!-- 【新增】给这个按钮一个ID，方便我们控制它 -->
                    <button id="persona-editor-change-frame-btn" class="change-frame-btn" data-type="member">更换头像框</button>
                    <input type="file" id="preset-avatar-input" accept="image/*">
                </div>
            </div>
            <div class="form-group">
                <label for="preset-persona-input">人设</label>
                <textarea id="preset-persona-input" rows="4" placeholder="在此输入这个人设的详细设定..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-persona-editor-btn">取消</button>
            <button class="save" id="save-persona-preset-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换到这里结束 ▲▲▲ -->



    <div id="member-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>编辑群成员</span></div><div class="modal-body">
    <div class="form-group"><label for="member-name-input">名字</label><input type="text" id="member-name-input"></div>
    <div class="form-group"><label for="member-persona-input">人设</label><textarea id="member-persona-input" rows="4"></textarea></div>
    <div class="form-group"><label>头像</label><div class="avatar-upload"><img id="member-avatar-preview"><button onclick="document.getElementById('member-avatar-input').click()">上传头像</button><input type="file" id="member-avatar-input" accept="image/*"></div></div>
    </div><div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button class="save" id="save-member-settings-btn">保存</button></div></div></div>
    
    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">取消</button>
                <button id="custom-modal-confirm" class="confirm-btn">确定</button>
            </div>
        </div>
    </div>

    <!-- ▼▼▼ 智谱语音识别测试弹窗 ▼▼▼ -->
    <div id="zhipu-speech-test-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 500px; width: 90%;">
            <div class="modal-header">
                <span>🖤 智谱语音识别测试</span>
                <span class="close" id="close-speech-test-modal" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold;">&times;</span>
            </div>
            <div class="modal-body">
                <div style="text-align: center; padding: 20px;">
                    <div id="speech-status" style="margin-bottom: 20px; font-size: 16px; color: #666;">
                        点击下方按钮开始语音识别测试
                    </div>
                    
                    <div id="microphone-container" style="margin: 20px 0;">
                        <button id="start-recording-btn" style="
                            width: 100px; 
                            height: 100px; 
                            border-radius: 50%; 
                            border: none; 
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                            color: white; 
                            font-size: 40px; 
                            cursor: pointer; 
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                        ">
                            🎙️
                        </button>
                        <div id="recording-indicator" style="
                            display: none; 
                            margin-top: 10px; 
                            color: #ff4757; 
                            font-weight: bold;
                            animation: pulse 1.5s infinite;
                        ">
                            ● 正在录音...
                        </div>
                    </div>
                    
                    <div id="recognition-result" style="
                        margin-top: 20px; 
                        padding: 15px; 
                        background: #f8f9fa; 
                        border-radius: 8px; 
                        border: 1px solid #e9ecef; 
                        min-height: 60px;
                        text-align: left;
                        display: none;
                    ">
                        <div style="font-weight: bold; color: #333; margin-bottom: 10px;">识别结果：</div>
                        <div id="recognition-text" style="color: #555; line-height: 1.5;"></div>
                    </div>
                    
                    <div id="error-message" style="
                        margin-top: 15px; 
                        padding: 10px; 
                        background: #f8d7da; 
                        color: #721c24; 
                        border-radius: 4px; 
                        display: none;
                    "></div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="clear-result-btn" class="form-button-secondary" style="margin-right: 10px;">清空结果</button>
                <button id="close-test-modal-btn" class="form-button">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 智谱语音识别测试弹窗结束 ▲▲▲ -->

    <!-- ▼▼▼ NovelAI 生成设置弹窗 ▼▼▼ -->
    <div id="novelai-settings-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 600px; width: 90%; max-height: 85vh; overflow-y: auto;">
            <div class="modal-header">
                <span>NovelAI 生成设置</span>
                <span class="close" id="close-novelai-settings" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold;">&times;</span>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <div class="form-group">
                    <label style="color: #333;">图像尺寸（oplus可无限出小图）</label>
                    <select id="nai-resolution" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                        <optgroup label="小">
                            <option value="512x768">纵向 (512x768)</option>
                            <option value="768x512">横向 (768x512)</option>
                            <option value="640x640">正方形 (640x640)</option>
                        </optgroup>
                        <optgroup label="正常">
                            <option value="832x1216">竖图 (832x1216)</option>
                            <option value="1216x832">横图 (1216x832)</option>
                            <option value="1024x1024" selected>方图 (1024x1024)</option>
                        </optgroup>
                        <optgroup label="壁纸">
                            <option value="1088x1920">纵向 (1088x1920)</option>
                            <option value="1920x1088">风景 (1920x1088)</option>
                        </optgroup>
                    </select>
                    <small style="color: #666;">建议使用官方支持的标准尺寸以获得最佳效果</small>
                </div>

                <div class="form-group">
                    <label style="color: #333;">采样步数 (Steps)</label>
                    <input type="number" id="nai-steps" value="28" min="1" max="50" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <small style="color: #666;">推荐值: 28 (值越高质量越好但耗时越长)</small>
                </div>

                <div class="form-group">
                    <label style="color: #333;">提示词相关性 (CFG Scale)</label>
                    <input type="number" id="nai-cfg-scale" value="5" min="1" max="20" step="0.5" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <small style="color: #666;">推荐值: 5 (控制图像与提示词的相关程度)</small>
                </div>

                <div class="form-group">
                    <label style="color: #333;">采样器 (Sampler)</label>
                    <select id="nai-sampler" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                        <option value="k_euler">Euler</option>
                        <option value="k_euler_ancestral" selected>Euler Ancestral</option>
                        <option value="k_dpmpp_2s_ancestral">DPM++ 2S Ancestral</option>
                        <option value="k_dpmpp_2m">DPM++ 2M</option>
                        <option value="k_dpmpp_sde">DPM++ SDE</option>
                        <option value="ddim">DDIM</option>
                    </select>
                </div>

                <div class="form-group">
                    <label style="color: #333;">随机种子 (Seed)</label>
                    <input type="number" id="nai-seed" value="-1" min="-1" max="9999999999" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <small style="color: #666;">-1 表示随机，固定种子可复现相同图像</small>
                </div>

                <div class="form-group">
                    <label style="color: #333;">负面提示词预设 (UC Preset)</label>
                    <select id="nai-uc-preset" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                        <option value="0">Preset 0 - Heavy</option>
                        <option value="1" selected>Preset 1 - Light</option>
                        <option value="2">Preset 2 - Human Focus</option>
                        <option value="3">Preset 3 - None</option>
                    </select>
                </div>

                <div class="form-group">
                    <label style="color: #333;">质量标签</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="nai-quality-toggle" checked style="width: auto;">
                        <span style="color: #666; font-size: 14px;">自动添加质量提升标签</span>
                    </div>
                </div>

                <div class="form-group">
                    <label style="color: #333;">SMEA (提升细节)</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="nai-smea" checked style="width: auto;">
                        <span style="color: #666; font-size: 14px;">启用SMEA增强</span>
                    </div>
                </div>

                <div class="form-group">
                    <label style="color: #333;">SMEA DYN (动态优化)</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="nai-smea-dyn" style="width: auto;">
                        <span style="color: #666; font-size: 14px;">启用动态SMEA</span>
                    </div>
                </div>

                <div class="form-group">
                    <label style="color: #333;">默认正面提示词</label>
                    <textarea id="nai-default-positive" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="masterpiece, best quality, 1girl, beautiful...">masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style</textarea>
                    <small style="color: #666;">此提示词将在生成时自动使用（如果测试弹窗中未填写）</small>
                </div>

                <div class="form-group">
                    <label style="color: #333;">默认负面提示词</label>
                    <textarea id="nai-default-negative" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="lowres, bad anatomy, bad hands, text, error...">lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry</textarea>
                </div>

                <div class="form-group" style="border-top: 1px solid #ddd; padding-top: 15px; margin-top: 15px;">
                    <label style="color: #333;">🌐 CORS 代理设置</label>
                    <select id="nai-cors-proxy" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                        <option value="">❌ 直连（无代理）</option>
                        <option value="https://corsproxy.io/?" selected>✅ corsproxy.io（推荐）</option>
                        <option value="https://api.allorigins.win/raw?url=">allorigins.win</option>
                        <option value="https://cors-anywhere.herokuapp.com/">cors-anywhere（需激活）</option>
                        <option value="custom">🔧 自定义代理</option>
                    </select>
                    <small style="color: #e74c3c; display: block; margin-top: 8px;">
                        ⚠️ 本地运行会遇到CORS跨域问题，需使用代理。推荐使用 corsproxy.io
                    </small>
                </div>

                <div id="nai-custom-proxy-group" class="form-group" style="display: none;">
                    <label style="color: #333;">自定义代理地址</label>
                    <input type="text" id="nai-custom-proxy-url" placeholder="https://your-proxy.com/?" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 8px; width: 100%; border-radius: 4px;">
                    <small style="color: #666;">代理URL应以 / 或 ? 结尾，例如：https://proxy.com/?</small>
                </div>
            </div>
            <div class="modal-footer">
                <button id="reset-nai-settings-btn" class="form-button form-button-secondary" style="margin-right: 10px;">恢复默认</button>
                <button id="save-nai-settings-btn" class="form-button form-button-secondary">保存设置</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ NovelAI 生成设置弹窗结束 ▲▲▲ -->

    <!-- ▼▼▼ NovelAI 测试生成弹窗 ▼▼▼ -->
    <div id="novelai-test-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 700px; width: 90%; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <span>🖼️ NovelAI 测试生成</span>
                <span class="close" id="close-novelai-test" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold;">&times;</span>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <div class="form-group">
                    <label style="color: #333;">正面提示词（此处提示词仅用于该弹窗测试）</label>
                    <textarea id="nai-test-prompt" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="1girl, solo, long hair, blue eyes, smile...">1girl, solo, long hair, blue eyes, smile, outdoors, cherry blossoms, spring</textarea>
                </div>

                <div class="form-group">
                    <label style="color: #333;">负面提示词（可选，留空使用默认）</label>
                    <textarea id="nai-test-negative" rows="3" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical;" placeholder="留空将使用设置中的默认负面提示词"></textarea>
                </div>

                <div style="text-align: center; margin: 20px 0;">
                    <button id="nai-generate-btn" style="background-color: #007bff; color: white; border: none; padding: 12px 30px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold;">
                        生成图像
                    </button>
                </div>

                <div id="nai-test-status" style="text-align: center; color: #666; margin: 15px 0; display: none;">
                    正在生成中，请稍候...
                </div>

                <div id="nai-test-result" style="display: none; margin-top: 20px;">
                    <div style="font-weight: bold; color: #333; margin-bottom: 10px;">生成结果：</div>
                    <div style="text-align: center; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                        <img id="nai-result-image" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    </div>
                    <div style="margin-top: 10px; text-align: center;">
                        <button id="nai-download-btn" class="form-button-secondary" style="margin: 0;">下载图像</button>
                    </div>
                </div>

                <div id="nai-test-error" style="display: none; margin-top: 15px; padding: 12px; background: #f8d7da; color: #721c24; border-radius: 6px; border: 1px solid #f5c6cb;"></div>
            </div>
            <div class="modal-footer">
                <button id="close-nai-test-btn" class="form-button">关闭</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ NovelAI 测试生成弹窗结束 ▲▲▲ -->

    <!-- ▼▼▼ 角色专属NAI出图设置弹窗 ▼▼▼ -->
    <div id="character-nai-prompts-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <span>角色专属NAI提示词配置</span>
                <span class="close" id="close-character-nai-prompts" style="cursor: pointer; float: right; font-size: 28px; font-weight: bold;">&times;</span>
            </div>
            <div class="modal-body">
                <p style="font-size: 13px; color: #666; margin-bottom: 20px; background-color: #f0f8ff; padding: 12px; border-radius: 6px; border-left: 3px solid #007bff;">
                    💡 这里配置的提示词仅用于当前角色的NAI出图，不影响其他角色或系统设置
                </p>
                
                <div class="form-group">
                    <label for="character-nai-positive" style="color: #333; font-weight: 600;">
                        正面提示词 (Positive Prompt)
                    </label>
                    <textarea id="character-nai-positive" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical; font-size: 13px;" placeholder="例如: masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style"></textarea>
                    <small style="display: block; color: #666; font-size: 12px; margin-top: 5px;">
                        描述你希望生成的图像风格，可填入画师串
                    </small>
                </div>

                <div class="form-group">
                    <label for="character-nai-negative" style="color: #333; font-weight: 600;">
                        负面提示词 (Negative Prompt)
                    </label>
                    <textarea id="character-nai-negative" rows="4" style="background-color: #f8f9fa; color: #333; border: 1px solid #ccc; padding: 10px; width: 100%; border-radius: 4px; resize: vertical; font-size: 13px;" placeholder="例如: lowres, bad anatomy, bad hands, text, error, missing fingers"></textarea>
                    <small style="display: block; color: #666; font-size: 12px; margin-top: 5px;">
                        描述你希望避免的元素
                    </small>
                </div>
            </div>
            <div class="modal-footer">
                <button id="reset-character-nai-prompts-btn" class="form-button form-button-secondary" style="margin-right: 10px;">清空配置</button>
                <button id="save-character-nai-prompts-btn" class="form-button form-button-secondary">保存</button>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 角色专属NAI出图设置弹窗结束 ▲▲▲ -->

    <!-- URL输入弹窗 -->
    <div id="url-input-modal-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);">
        <div id="url-input-modal" style="background: white; width: 320px; max-width: 90vw; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); display: flex; flex-direction: column; transform: scale(0.9) translateY(20px); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); border: 1px solid #e0e0e0;">
            <div class="custom-modal-header" id="url-input-modal-title">输入图片URL</div>
            <div class="custom-modal-body" style="padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5;">
                <p style="margin: 0; margin-bottom: 12px;">请输入图片的网络地址：</p>
                <input type="url" id="url-input-field" placeholder="https://example.com/image.jpg" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box;">
            </div>
            <div class="custom-modal-footer" style="border-top: 1px solid #e0e0e0; display: flex; border-radius: 0 0 12px 12px; overflow: hidden;">
                <button id="url-input-modal-cancel" style="flex: 1; padding: 12px; border: none; background: #f5f5f5; color: #333; cursor: pointer; font-size: 14px; transition: background-color 0.2s;">取消</button>
                <button id="url-input-modal-confirm" style="flex: 1; padding: 12px; border: none; background: #007AFF; color: white; cursor: pointer; font-size: 14px; transition: background-color 0.2s;">确认</button>
            </div>
        </div>
    </div>
<!-- ▼▼▼ 用下面这【一整块功能最全】的代码，完整替换掉你旧的 id="weibo-screen" 的整个 div ▼▼▼ -->
<div id="weibo-screen" class="screen">
    <!-- 这个容器将存放微博的所有页面 -->
    <div id="weibo-page-container">

<!-- ▼▼▼ 用这【一整块新代码】替换旧的 #weibo-my-profile-view 区域 ▼▼▼ -->
<div id="weibo-my-profile-view" class="weibo-view active">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
        <span>我的主页</span>
        <div class="header-actions">
            <span class="action-btn" id="create-weibo-post-btn" style="font-size: 28px; font-weight: 300;">+</span>
        </div>
    </div>
    <div id="weibo-profile-page">
        <!-- 【核心修改】现在，头像、昵称、数据都在 header 内部了 -->
        <div class="weibo-profile-header">
            <img id="weibo-background-img" src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg" class="weibo-background">
            
            <div class="weibo-avatar-container">
                <img id="weibo-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" class="weibo-avatar">
            </div>
            <div class="weibo-nickname" id="weibo-nickname">你的昵称</div>
            <div class="weibo-stats">
                <div id="weibo-following-btn" class="weibo-stat-item">
                    <span id="weibo-following-count" class="weibo-stat-number">0</span>
                    <span class="weibo-stat-label">关注</span>
                </div>
                <div id="weibo-posts-item" class="weibo-stat-item">
                    <span id="weibo-posts-count" class="weibo-stat-number">0</span>
                    <span class="weibo-stat-label">微博</span>
                </div>
                <div id="weibo-fans-item" class="weibo-stat-item">
                    <span id="weibo-fans-count" class="weibo-stat-number">0</span>
                    <span class="weibo-stat-label">粉丝</span>
                </div>
            </div>
        </div>

        <div id="my-weibo-feed-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
            <!-- “我的微博”列表将由JS动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


        <!-- 页面2: 关注的人 (保持不变) -->
        <div id="weibo-following-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>关注的人</span>
                <span class="action-btn" id="clear-following-feed-btn" style="font-size: 16px; font-weight: 500;">清空</span>
            </div>
            <div id="weibo-following-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                <!-- 关注的人的微博列表将由JS动态生成在这里 -->
            </div>
        </div>
        
        <!-- 页面3: 热搜 (已修改) -->
        <div id="weibo-hot-search-view" class="weibo-view">
             <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>热搜</span>
                <!-- 【核心新增】生成热搜的放大镜按钮 -->
                <div class="header-actions">
                    <span class="action-btn" id="generate-hot-search-btn" title="生成热搜">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    </span>
                </div>
            </div>
            <!-- 【核心修改】在这里，我们将默认内容改为了提示语 -->
            <div id="weibo-hot-search-list" style="flex-grow: 1; overflow-y: auto;">
                <p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角放大镜生成热搜</p>
            </div>
        </div>

        <!-- 页面4: 广场 (已修改) -->
        <div id="weibo-plaza-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>广场</span>
                <!-- 【核心新增】生成广场的放大镜按钮 -->
                <div class="header-actions">
                    <span class="action-btn" id="generate-plaza-feed-btn" title="生成广场动态">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    </span>
                </div>
            </div>
            <!-- 【核心修改】在这里，我们将默认内容改为了提示语 -->
            <div id="weibo-plaza-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 0;">
                 <p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角放大镜生成广场动态</p>
            </div>
        </div>

        <!-- 【全新】页面5: 热搜详情页 -->
        <div id="weibo-hottopic-feed-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" id="back-from-hottopic-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span id="weibo-hottopic-title">热搜话题</span>
                <div class="header-actions">
                     <span class="action-btn" id="refresh-hottopic-feed-btn" title="换一批">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                    </span>
                </div>
            </div>
            <!-- 这个容器将用来显示某个热搜话题下的微博Feed -->
            <div id="weibo-hottopic-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 0;">
                <!-- 热搜微博列表将由JS动态生成 -->
            </div>
        </div>

    </div>

    <!-- 底部导航栏 -->
    <div id="weibo-bottom-nav">
        <div class="weibo-nav-item" data-view="weibo-hot-search-view">热搜</div>
        <div class="weibo-nav-item" data-view="weibo-plaza-view">广场</div>
        <div class="weibo-nav-item" data-view="weibo-following-view">关注的人</div>
        <div class="weibo-nav-item active" data-view="weibo-my-profile-view">我的微博</div>
    </div>
</div>
<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->

    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">编辑预设</button>
                <button id="preset-action-delete" class="btn-danger">删除预设</button>
                <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>

    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">给Ta一个惊喜！</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="9999999999999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                <input type="text" id="transfer-note" placeholder="留下你的小心思~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>

 <div id="battery-alert-modal">
    <div class="battery-alert-content">
        <img id="battery-alert-image" src="">
        <p id="battery-alert-text"></p>
    </div>
</div>

    <audio id="audio-player" style="display:none;"></audio>
<audio id="ringtone-player" loop></audio>

<!-- ▼▼▼ 用下面这【一整块完整代码】替换掉你旧的 id="create-post-modal" 的整个 div ▼▼▼ -->
<div id="create-post-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 90%;">
        <div class="modal-header">
            <span id="create-post-modal-title">发布动态</span> <!-- 使用ID方便JS修改标题 -->
        </div>
        <div class="modal-body">
            <!-- 公开文字输入区 -->
            <div class="form-group">
                <textarea id="post-public-text" rows="3" placeholder="分享新鲜事..."></textarea>
            </div>

            <!-- === 【新增】模式切换开关 === -->
            <div class="post-mode-switcher">
                <button id="switch-to-image-mode" class="mode-btn active">上传图片</button>
                <button id="switch-to-text-image-mode" class="mode-btn">使用文字图</button>
            </div>

            <!-- === 【新增】图片模式区域 === -->
            <div id="image-mode-content" class="post-mode-content active">
                <div class="form-group">
                    <div id="post-image-preview-container" class="post-image-preview-container">
                        <img id="post-image-preview" src="" alt="图片预览">
                        <button id="post-remove-image-btn">×</button>
                    </div>
                    <div class="post-image-upload-options">
                        <button id="post-upload-local-btn" class="form-button-secondary">本地上传</button>
                        <button id="post-use-url-btn" class="form-button-secondary">网络URL</button>
                        <input type="file" id="post-local-image-input" accept="image/*" hidden>
                    </div>
                </div>
                <!-- 这个是给AI看的图片描述，在微博模式下我们会用JS隐藏它 -->
                <div id="post-image-desc-group" class="form-group" style="display: none;">
                    <label>图片描述 (必填，给AI看)</label>
                    <input type="text" id="post-image-description" placeholder="简单描述图片内容，帮助AI理解">
                </div>
            </div>

            <!-- === 【新增】文字图模式区域 === -->
            <div id="text-image-mode-content" class="post-mode-content">
                <div class="form-group">
                    <label>文字图 (给AI理解用的描述，点击图片后可见)</label>
                    <textarea id="post-hidden-text" rows="4" placeholder="在这里写下图片描述..."></textarea>
                </div>
            </div>

            <!-- === 【重新添加】分组可见性选择 === -->
            <div class="form-group" id="post-visibility-group" style="margin-top: 15px;">
                <label>可见范围</label>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio" name="post-visibility" value="public" checked style="margin-right: 8px;">
                        <span>所有好友可见</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio" name="post-visibility" value="selected" style="margin-right: 8px;">
                        <span>指定分组可见</span>
                    </label>
                </div>
                <div id="group-selector" style="display: none; margin-top: 10px;">
                    <label>选择可见的分组：</label>
                    <div id="group-checkboxes" style="max-height: 120px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; padding: 10px; background-color: #f8f9fa;">
                        <!-- 分组选项将通过JavaScript动态加载 -->
                    </div>
                </div>
            </div>
            
            <!-- 这个是动态功能的评论开关，在微博模式下我们会用JS隐藏它 -->
            <div class="form-group" id="post-comments-toggle-group" style="margin-top: 15px;">
                <label for="post-comments-toggle" class="toggle-switch-label">
                    <span class="toggle-switch-text">允许角色看见评论区</span>
                    <input type="checkbox" id="post-comments-toggle" checked>
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-post-btn">取消</button>
            <button class="save" id="confirm-create-post-btn">发布</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- ▼▼▼ 请将这个新的模态框HTML粘贴到所有其他模态框之后 ▼▼▼ -->
<div id="group-management-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理好友分组</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分组</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-group-name-input" placeholder="输入分组名..." style="flex-grow: 1;">
                    <button id="add-new-group-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分组列表将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-group-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="message-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <!-- 新的操作按钮 -->
            <button id="edit-message-btn">编辑消息</button>
            <button id="copy-message-btn">复制文本</button>
            <button id="recall-message-btn">撤回</button>
<button id="quote-message-btn">引用</button>
            <button id="select-message-btn">进入多选</button>
            <!-- 取消按钮 -->
            <button id="cancel-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="post-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <button id="edit-post-btn">编辑动态</button>
            <button id="copy-post-btn">复制内容</button>           
            <button id="cancel-post-action-btn">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】可视化消息编辑器模态框 ▼▼▼ -->
<div id="message-editor-modal" class="modal">
    <div class="modal-content" style="height: 75%;">
        <div class="modal-header">
            <span>编辑与拆分消息</span>
        </div>
        <div class="modal-body" id="message-editor-body">
            <!-- 编辑器容器，JS会在这里动态生成文本框 -->
            <div id="message-editor-container"></div>
            <!-- 添加新消息的按钮 -->
            <button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;">
                [+] 添加下一条消息
            </button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
            <button class="save" id="save-advanced-editor-btn">保存更改</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】外卖请求模态框 ▼▼▼ -->
<div id="waimai-request-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>发起外卖代付</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="waimai-product-info">商品信息</label>
                <input type="text" id="waimai-product-info" placeholder="例如：一杯杨枝甘露">
            </div>
            <div class="form-group">
                <label for="waimai-amount">代付金额 (元)</label>
                <input type="number" id="waimai-amount" placeholder="例如：21" min="0" step="0.01">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="waimai-cancel-btn">取消</button>
            <button class="save" id="waimai-confirm-btn">发起请求</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】新建约定/倒计时模态框 ▼▼▼ -->
<div id="create-countdown-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>新建约定</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="countdown-title-input">约定标题</label>
                <input type="text" id="countdown-title-input" placeholder="例如：我的生日">
            </div>
            <div class="form-group">
                <label for="countdown-date-input">约定日期与时间</label>
                <input type="datetime-local" id="countdown-date-input"style="width: 95%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-countdown-btn">取消</button>
            <button class="save" id="confirm-create-countdown-btn">保存约定</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】线下模式设置弹窗 ▼▼▼ -->
<div id="offline-mode-settings-modal" class="modal">
    <div class="modal-content" style="width: 90%; max-width: 400px;">
        <div class="modal-header">
            <span>线下模式参数设置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="offline-word-count">字数限制</label>
                <input type="text" id="offline-word-count" placeholder="例如：1000~1500" style="background-color: #f8f9fa; color: #333; border: 1px solid #ddd;">
                <small style="color: #666; font-size: 12px;">格式：最小字数~最大字数，如 500~800</small>
            </div>
            <div class="form-group">
                <label for="offline-writing-style">文风参考</label>
                <textarea id="offline-writing-style" rows="3" placeholder="例如：温柔细腻等" style="background-color: #f8f9fa; color: #333; border: 1px solid #ddd;"></textarea>
                <small style="color: #666; font-size: 12px;">描述你希望AI采用的文风，仅作参考，不限制发挥</small>
            </div>
            <div class="form-group">
                <label for="offline-preset-content">预设内容</label>
                <textarea id="offline-preset-content" rows="4" placeholder="在这里输入任何你想让AI知道的额外信息..." style="background-color: #f8f9fa; color: #333; border: 1px solid #ddd;"></textarea>
                <small style="color: #666; font-size: 12px;">可以是背景设定、特殊要求等任何内容</small>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-offline-settings-btn">取消</button>
            <button class="save" id="save-offline-settings-btn">保存设置</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 线下模式设置弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ 购物系统弹窗 ▼▼▼ -->

<!-- 4. 商品编辑器弹窗 -->
<div id="product-editor-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span id="product-editor-title">添加商品</span>
        </div>
        <div class="modal-body">
            <!-- 商品图片上传 -->
            <div class="form-group">
                <label>商品图片</label>
                <div class="avatar-upload">
                    <img id="product-image-preview" src="https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756206115802_qdqqd_0c99bh.jpeg">
                    <button onclick="document.getElementById('product-image-input').click()">上传图片</button>
                    <input type="file" id="product-image-input" accept="image/*" hidden>
                </div>
            </div>
            <!-- 商品名称 -->
            <div class="form-group">
                <label for="product-name-input">商品名称</label>
                <input type="text" id="product-name-input">
            </div>
            <!-- 商品价格 -->
            <div class="form-group">
                <label for="product-price-input">价格 (元)</label>
                <input type="number" id="product-price-input" min="0" step="0.01">
            </div>
            <!-- 商品描述 -->
            <div class="form-group">
                <label for="product-description-input">商品描述</label>
                <textarea id="product-description-input" rows="4" placeholder="详细介绍一下这个商品..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-product-editor-btn">取消</button>
            <button class="save" id="save-product-btn">保存</button>
        </div>
    </div>
</div>

<!-- 5. 购物小票弹窗 -->
<div id="gift-receipt-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>购物小票</span>
        </div>
        <div class="modal-body" id="gift-receipt-body">
            <!-- 小票内容将在这里动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-receipt-btn">关闭</button>
        </div>
    </div>
</div>

<!-- 6. 统一结算弹窗 - 支持美化层级显示 -->
<div id="unified-checkout-modal" class="modal">
    <div class="modal-content" id="checkout-card" style="max-width: 450px; height: auto; max-height: 60vh;">
        
        <!-- 真实的结算卡片内容 -->
        <div id="checkout-real-content" class="real-content">
            <div class="modal-header">
                <span id="checkout-title">选择为谁下单</span>
            </div>
            <div class="modal-body" id="checkout-content" style="padding: 15px; max-height: 40vh; overflow-y: auto;">
                <!-- 动态内容区域 -->
            </div>
            <div class="modal-footer">
                <button class="cancel" id="checkout-cancel-btn">取消</button>
                <button class="save" id="checkout-confirm-btn">下一步</button>
            </div>
        </div>
    </div>
</div>

<!-- ▲▲▲ 购物系统弹窗结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】发红包模态框 ▼▼▼ -->
<div id="red-packet-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>发红包</span>
        </div>
        <div class="modal-body" style="padding: 0;">
<!-- 1. 页签切换 -->
<div class="frame-tabs">
    <div id="rp-tab-group" class="frame-tab active">拼手气红包</div>
    <div id="rp-tab-direct" class="frame-tab">专属红包</div>
</div>

            <!-- 2. 拼手气红包内容区 -->
            <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                <div class="form-group">
                    <label>总金额 (元)</label>
                    <input type="number" id="rp-group-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>红包个数</label>
                    <input type="number" id="rp-group-count" placeholder="填写红包个数">
                </div>
                <div class="form-group">
                    <label>祝福语</label>
                    <input type="text" id="rp-group-greeting" placeholder="恭喜发财，大吉大利！">
                </div>
                <p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-group-packet-btn" class="form-button">塞钱进红包</button>
            </div>

            <!-- 3. 专属红包内容区 -->
            <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                <div class="form-group">
                    <label>发送给</label>
                    <select id="rp-direct-receiver"></select>
                </div>
                <div class="form-group">
                    <label>金额 (元)</label>
                    <input type="number" id="rp-direct-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>祝福语</label>
                    <input type="text" id="rp-direct-greeting" placeholder="恭喜发财，大吉大利！">
                </div>
                 <p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-direct-packet-btn" class="form-button">塞钱进红包</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: center;">
             <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】红包详情模态框 ▼▼▼ -->
<div id="red-packet-details-modal" class="modal">
    <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
        <div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
            <div style="text-align: center; width: 100%;">
                <div id="rp-details-sender" style="font-size: 16px;"></div>
                <div style="font-size: 13px; opacity: 0.8;">的红包</div>
            </div>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
            <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                <span style="font-size: 18px; color: #E44D44;">元</span>
            </div>
            <div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
            <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                <!-- 领取详情将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-rp-details-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】创建投票模态框 ▼▼▼ -->
<div id="create-poll-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>发起投票</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="poll-question-input">投票问题</label>
                <textarea id="poll-question-input" rows="2" placeholder="例如：今晚我们看什么电影？"></textarea>
            </div>
            <div class="form-group">
                <label>投票选项 (至少2项)</label>
                <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- 投票选项将由JS动态生成在这里 -->
                </div>
                <button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加选项</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-poll-btn">取消</button>
            <button class="save" id="confirm-create-poll-btn">发起投票</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】AI头像库管理模态框 ▼▼▼ -->
<div id="ai-avatar-library-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="ai-avatar-library-title">对方的头像库</span>
            <button id="add-ai-avatar-btn" class="action-button">添加</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                <!-- 头像库内容将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】用户分享链接模态框 ▼▼▼ -->
<div id="share-link-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>分享链接</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="link-title-input">标题</label>
                <input type="text" id="link-title-input" placeholder="输入文章或链接的标题">
            </div>
            <div class="form-group">
                <label for="link-description-input">摘要 (可选)</label>
                <textarea id="link-description-input" rows="2" placeholder="简单描述一下链接内容"></textarea>
            </div>
            <div class="form-group">
                <label for="link-source-input">来源名称 (可选)</label>
                <input type="text" id="link-source-input" placeholder="例如：知乎日报、B站">
            </div>
            <div class="form-group">
                <label for="link-content-input">完整内容 (可选，用于浏览器内显示)</label>
                <textarea id="link-content-input" rows="4" placeholder="粘贴或输入完整的文章内容"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-link-btn">取消</button>
            <button class="save" id="confirm-share-link-btn">分享</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】精致版转账操作弹窗 ▼▼▼ -->
<div id="transfer-actions-modal" class="modal">
    <div class="transfer-actions-content">
        <div class="transfer-actions-header">请选择操作</div>
        <div class="transfer-actions-body">
            <p>你收到了来自 <strong id="transfer-sender-name"></strong> 的一笔转账。</p>
        </div>
        <div class="transfer-actions-footer">
            <button id="transfer-action-decline" class="action-btn decline">残忍拒绝</button>
            <button id="transfer-action-accept" class="action-btn accept">开心收下</button>
        </div>
        <button id="transfer-action-cancel" class="cancel-btn">×</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话记录详情模态框 ▼▼▼ -->
<div id="call-transcript-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="transcript-modal-title">通话详情</span>
        </div>
        <div class="modal-body" id="transcript-modal-body" style="background-color: #f0f2f5;">
            <!-- 通话文字记录将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="delete-transcript-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">删除记录</button>
            <button class="save" id="close-transcript-modal-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- 表情弹窗 -->
<div id="emoji-modal" class="modal">
    <div class="modal-content emoji-modal-content">
        <div class="modal-header">
            <span>选择表情</span>
            <span class="close-modal" id="close-emoji-modal">×</span>
        </div>
        <div class="modal-body emoji-modal-body">
            <!-- 表情内容区域 -->
            <div class="emoji-content">
                <!-- 笑脸分类 -->
                <div class="emoji-category active" data-category="faces">
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="😀">😀</span>
                        <span class="emoji-item" data-emoji="😃">😃</span>
                        <span class="emoji-item" data-emoji="😄">😄</span>
                        <span class="emoji-item" data-emoji="😁">😁</span>
                        <span class="emoji-item" data-emoji="😆">😆</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="😅">😅</span>
                        <span class="emoji-item" data-emoji="😂">😂</span>
                        <span class="emoji-item" data-emoji="🤣">🤣</span>
                        <span class="emoji-item" data-emoji="😊">😊</span>
                        <span class="emoji-item" data-emoji="😇">😇</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🙂">🙂</span>
                        <span class="emoji-item" data-emoji="🙃">🙃</span>
                        <span class="emoji-item" data-emoji="😉">😉</span>
                        <span class="emoji-item" data-emoji="😌">😌</span>
                        <span class="emoji-item" data-emoji="😍">😍</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🥰">🥰</span>
                        <span class="emoji-item" data-emoji="😘">😘</span>
                        <span class="emoji-item" data-emoji="😗">😗</span>
                        <span class="emoji-item" data-emoji="☺️">☺️</span>
                        <span class="emoji-item" data-emoji="😚">😚</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="😙">😙</span>
                        <span class="emoji-item" data-emoji="🥲">🥲</span>
                        <span class="emoji-item" data-emoji="😋">😋</span>
                        <span class="emoji-item" data-emoji="😛">😛</span>
                        <span class="emoji-item" data-emoji="😜">😜</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🤪">🤪</span>
                        <span class="emoji-item" data-emoji="😝">😝</span>
                        <span class="emoji-item" data-emoji="🤑">🤑</span>
                        <span class="emoji-item" data-emoji="🤗">🤗</span>
                        <span class="emoji-item" data-emoji="🤭">🤭</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🤫">🤫</span>
                        <span class="emoji-item" data-emoji="🤔">🤔</span>
                        <span class="emoji-item" data-emoji="🤐">🤐</span>
                        <span class="emoji-item" data-emoji="🤨">🤨</span>
                        <span class="emoji-item" data-emoji="😐">😐</span>
                    </div>
                </div>

                <!-- 情绪分类 -->
                <div class="emoji-category" data-category="emotions">
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="😑">😑</span>
                        <span class="emoji-item" data-emoji="😶">😶</span>
                        <span class="emoji-item" data-emoji="😏">😏</span>
                        <span class="emoji-item" data-emoji="😒">😒</span>
                        <span class="emoji-item" data-emoji="🙄">🙄</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="😬">😬</span>
                        <span class="emoji-item" data-emoji="🤥">🤥</span>
                        <span class="emoji-item" data-emoji="😔">😔</span>
                        <span class="emoji-item" data-emoji="😕">😕</span>
                        <span class="emoji-item" data-emoji="🙁">🙁</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="☹️">☹️</span>
                        <span class="emoji-item" data-emoji="😣">😣</span>
                        <span class="emoji-item" data-emoji="😖">😖</span>
                        <span class="emoji-item" data-emoji="😫">😫</span>
                        <span class="emoji-item" data-emoji="😩">😩</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🥺">🥺</span>
                        <span class="emoji-item" data-emoji="😢">😢</span>
                        <span class="emoji-item" data-emoji="😭">😭</span>
                        <span class="emoji-item" data-emoji="😤">😤</span>
                        <span class="emoji-item" data-emoji="😠">😠</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="😡">😡</span>
                        <span class="emoji-item" data-emoji="🤬">🤬</span>
                        <span class="emoji-item" data-emoji="🤯">🤯</span>
                        <span class="emoji-item" data-emoji="😳">😳</span>
                        <span class="emoji-item" data-emoji="🥵">🥵</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🥶">🥶</span>
                        <span class="emoji-item" data-emoji="😱">😱</span>
                        <span class="emoji-item" data-emoji="😨">😨</span>
                        <span class="emoji-item" data-emoji="😰">😰</span>
                        <span class="emoji-item" data-emoji="😥">😥</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="😓">😓</span>
                        <span class="emoji-item" data-emoji="🤤">🤤</span>
                        <span class="emoji-item" data-emoji="😴">😴</span>
                        <span class="emoji-item" data-emoji="😪">😪</span>
                        <span class="emoji-item" data-emoji="😵">😵</span>
                    </div>
                </div>

                <!-- 手势分类 -->
                <div class="emoji-category" data-category="gestures">
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="👋">👋</span>
                        <span class="emoji-item" data-emoji="🤚">🤚</span>
                        <span class="emoji-item" data-emoji="🖐️">🖐️</span>
                        <span class="emoji-item" data-emoji="✋">✋</span>
                        <span class="emoji-item" data-emoji="🖖">🖖</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="👌">👌</span>
                        <span class="emoji-item" data-emoji="🤏">🤏</span>
                        <span class="emoji-item" data-emoji="✌️">✌️</span>
                        <span class="emoji-item" data-emoji="🤞">🤞</span>
                        <span class="emoji-item" data-emoji="🤟">🤟</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🤘">🤘</span>
                        <span class="emoji-item" data-emoji="🤙">🤙</span>
                        <span class="emoji-item" data-emoji="👈">👈</span>
                        <span class="emoji-item" data-emoji="👉">👉</span>
                        <span class="emoji-item" data-emoji="👆">👆</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="👇">👇</span>
                        <span class="emoji-item" data-emoji="☝️">☝️</span>
                        <span class="emoji-item" data-emoji="👍">👍</span>
                        <span class="emoji-item" data-emoji="👎">👎</span>
                        <span class="emoji-item" data-emoji="✊">✊</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="👊">👊</span>
                        <span class="emoji-item" data-emoji="🤛">🤛</span>
                        <span class="emoji-item" data-emoji="🤜">🤜</span>
                        <span class="emoji-item" data-emoji="👏">👏</span>
                        <span class="emoji-item" data-emoji="🙌">🙌</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="👐">👐</span>
                        <span class="emoji-item" data-emoji="🤲">🤲</span>
                        <span class="emoji-item" data-emoji="🤝">🤝</span>
                        <span class="emoji-item" data-emoji="🙏">🙏</span>
                        <span class="emoji-item" data-emoji="✍️">✍️</span>
                    </div>
                </div>

                <!-- 爱心分类 -->
                <div class="emoji-category" data-category="hearts">
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="❤️">❤️</span>
                        <span class="emoji-item" data-emoji="🧡">🧡</span>
                        <span class="emoji-item" data-emoji="💛">💛</span>
                        <span class="emoji-item" data-emoji="💚">💚</span>
                        <span class="emoji-item" data-emoji="💙">💙</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="💜">💜</span>
                        <span class="emoji-item" data-emoji="🖤">🖤</span>
                        <span class="emoji-item" data-emoji="🤍">🤍</span>
                        <span class="emoji-item" data-emoji="🤎">🤎</span>
                        <span class="emoji-item" data-emoji="💔">💔</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="❣️">❣️</span>
                        <span class="emoji-item" data-emoji="💕">💕</span>
                        <span class="emoji-item" data-emoji="💞">💞</span>
                        <span class="emoji-item" data-emoji="💓">💓</span>
                        <span class="emoji-item" data-emoji="💗">💗</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="💖">💖</span>
                        <span class="emoji-item" data-emoji="💘">💘</span>
                        <span class="emoji-item" data-emoji="💝">💝</span>
                        <span class="emoji-item" data-emoji="💟">💟</span>
                        <span class="emoji-item" data-emoji="♥️">♥️</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="💌">💌</span>
                        <span class="emoji-item" data-emoji="💋">💋</span>
                        <span class="emoji-item" data-emoji="💍">💍</span>
                        <span class="emoji-item" data-emoji="💎">💎</span>
                        <span class="emoji-item" data-emoji="🌹">🌹</span>
                    </div>
                </div>

                <!-- 动物分类 -->
                <div class="emoji-category" data-category="animals">
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="😺">😺</span>
                        <span class="emoji-item" data-emoji="😸">😸</span>
                        <span class="emoji-item" data-emoji="😹">😹</span>
                        <span class="emoji-item" data-emoji="😻">😻</span>
                        <span class="emoji-item" data-emoji="😼">😼</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="😽">😽</span>
                        <span class="emoji-item" data-emoji="🙀">🙀</span>
                        <span class="emoji-item" data-emoji="😿">😿</span>
                        <span class="emoji-item" data-emoji="😾">😾</span>
                        <span class="emoji-item" data-emoji="🐶">🐶</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🐱">🐱</span>
                        <span class="emoji-item" data-emoji="🐭">🐭</span>
                        <span class="emoji-item" data-emoji="🐹">🐹</span>
                        <span class="emoji-item" data-emoji="🐰">🐰</span>
                        <span class="emoji-item" data-emoji="🦊">🦊</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🐻">🐻</span>
                        <span class="emoji-item" data-emoji="🐼">🐼</span>
                        <span class="emoji-item" data-emoji="🐨">🐨</span>
                        <span class="emoji-item" data-emoji="🐯">🐯</span>
                        <span class="emoji-item" data-emoji="🦁">🦁</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🐮">🐮</span>
                        <span class="emoji-item" data-emoji="🐷">🐷</span>
                        <span class="emoji-item" data-emoji="🐸">🐸</span>
                        <span class="emoji-item" data-emoji="🐵">🐵</span>
                        <span class="emoji-item" data-emoji="🙈">🙈</span>
                    </div>
                    <div class="emoji-row">
                        <span class="emoji-item" data-emoji="🙉">🙉</span>
                        <span class="emoji-item" data-emoji="🙊">🙊</span>
                        <span class="emoji-item" data-emoji="🐒">🐒</span>
                        <span class="emoji-item" data-emoji="🦄">🦄</span>
                        <span class="emoji-item" data-emoji="🐝">🐝</span>
                    </div>
                </div>
            </div>
            
            <!-- 底部分类栏 -->
            <div class="emoji-categories">
                <div class="category-tab active" data-category="faces">
                    <span>😊</span>
                    <span class="category-name">笑脸</span>
                </div>
                <div class="category-tab" data-category="emotions">
                    <span>😢</span>
                    <span class="category-name">情绪</span>
                </div>
                <div class="category-tab" data-category="gestures">
                    <span>👋</span>
                    <span class="category-name">手势</span>
                </div>
                <div class="category-tab" data-category="hearts">
                    <span>❤️</span>
                    <span class="category-name">爱心</span>
                </div>
                <div class="category-tab" data-category="animals">
                    <span>🐱</span>
                    <span class="category-name">动物</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】订单预览弹窗 ▼▼▼ -->
<div id="order-preview-modal" class="modal">
    <div class="order-preview-content">
        <div class="order-preview-header">
            <span id="order-preview-title">订单预览</span>
            <button class="order-preview-close" id="order-preview-close-btn">×</button>
        </div>
        <div class="order-preview-body" id="order-preview-body">
            <!-- 订单预览内容将由JS动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享目标选择器模态框 ▼▼▼ -->
<div id="share-target-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>分享到...</span>
        </div>
        <div class="modal-body" id="share-target-list" style="padding: 0;">
            <!-- 聊天列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-target-btn">取消</button>
            <button class="save" id="confirm-share-target-btn">确认分享</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】分享记录查看器模态框 ▼▼▼ -->
<div id="shared-history-viewer-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="shared-history-viewer-title">聊天记录</span>
        </div>
        <div class="modal-body" id="shared-history-viewer-content" style="background-color: #f0f2f5;">
            <!-- 分享的聊天记录气泡将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-shared-history-viewer-btn" style="width:100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】世界书分类管理模态框 ▼▼▼ -->
<div id="world-book-category-manager-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理世界书分类</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分类</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-category-name-input" placeholder="输入分类名..." style="flex-grow: 1;">
                    <button id="add-new-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分类列表将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-category-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】角色专属NPC库管理界面 ▼▼▼ -->
<div id="npc-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-npc-management">‹</span>
        <span id="npc-management-title">NPC 库管理</span>
        <span class="action-btn" id="add-new-npc-btn">+</span>
    </div>
    <div class="list-container" id="npc-management-list">
        <!-- NPC列表将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 购物系统页面结构 ▼▼▼ -->

<!-- 1. 购物中心主页面 -->
<div id="shopping-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="shopping-back-btn">‹</span>
        <span>购物中心</span>
    </div>
    
    <!-- 购物中心内容容器 -->
    <div id="shopping-content-container">
        
        <!-- 系统商城页面 -->
        <div id="system-mall-page" class="mall-page">
            <div class="mall-content">
                <!-- 左侧分类导航 -->
                <div id="system-mall-sidebar" class="mall-sidebar">
                    <div class="sidebar-category active" data-category="all" onclick="switchSystemMallCategory('all')">
                        <span class="category-icon">🏪</span>
                        <span class="category-name">全部</span>
                    </div>
                    <div class="sidebar-category" data-category="electronics" onclick="switchSystemMallCategory('electronics')">
                        <span class="category-icon">✨</span>
                        <span class="category-name">数码</span>
                    </div>
                    <div class="sidebar-category" data-category="fashion" onclick="switchSystemMallCategory('fashion')">
                        <span class="category-icon">🎀</span>
                        <span class="category-name">服饰</span>
                    </div>
                    <div class="sidebar-category" data-category="home" onclick="switchSystemMallCategory('home')">
                        <span class="category-icon">🏡</span>
                        <span class="category-name">家居</span>
                    </div>
                    <div class="sidebar-category" data-category="food" onclick="switchSystemMallCategory('food')">
                        <span class="category-icon">🍓</span>
                        <span class="category-name">蔬果</span>
                    </div>
                    <div class="sidebar-category" data-category="snacks" onclick="switchSystemMallCategory('snacks')">
                        <span class="category-icon">🍿</span>
                        <span class="category-name">零食</span>
                    </div>
                    <div class="sidebar-category" data-category="fresh" onclick="switchSystemMallCategory('fresh')">
                        <span class="category-icon">🥩</span>
                        <span class="category-name">生鲜</span>
                    </div>
                    <div class="sidebar-category" data-category="medicine" onclick="switchSystemMallCategory('medicine')">
                        <span class="category-icon">💊</span>
                        <span class="category-name">药物</span>
                    </div>
                    <div class="sidebar-category" data-category="adult" onclick="switchSystemMallCategory('adult')">
                        <span class="category-icon">🔞</span>
                        <span class="category-name">情趣</span>
                    </div>
                    <div class="sidebar-category" data-category="maternity" onclick="switchSystemMallCategory('maternity')">
                        <span class="category-icon">👶</span>
                        <span class="category-name">母婴</span>
                    </div>
                    <div class="sidebar-category" data-category="beauty" onclick="switchSystemMallCategory('beauty')">
                        <span class="category-icon">💄</span>
                        <span class="category-name">美妆</span>
                    </div>
                    <div class="sidebar-category" data-category="pets" onclick="switchSystemMallCategory('pets')">
                        <span class="category-icon">🐕</span>
                        <span class="category-name">宠物</span>
                    </div>
                </div>
                
                <!-- 右侧内容区域 -->
                <div id="system-mall-main" class="mall-main">
                    <!-- 系统商城头部操作栏 -->
                    <div class="system-mall-header">
                        <div class="header-info">
                            <!-- 购物车总金额显示 -->
                            <div class="cart-total-display">
                                <span class="total-label">总计:</span>
                                <span id="system-cart-total" class="total-amount">¥0.00</span>
                            </div>
                        </div>
                        <div class="header-actions">
                            <!-- 钱包按钮 -->
                            <span class="action-btn" id="wallet-btn" title="钱包" onclick="openWallet()">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 12V7H5a2 2 0 0 1 0-4h14v4"></path>
                                    <path d="M3 5v14a2 2 0 0 0 2 2h16v-5"></path>
                                    <circle cx="18" cy="12" r="2"></circle>
                                </svg>
                            </span>
                            <!-- 购物车按钮 -->
                            <span class="action-btn" id="system-cart-btn" title="购物车" onclick="openSystemCart()">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="9" cy="21" r="1"></circle>
                                    <circle cx="20" cy="21" r="1"></circle>
                                    <path d="m1 1 4 4 5.5 11h8.5l3-7H6"></path>
                                </svg>
                                <span id="system-cart-count" class="cart-badge">0</span>
                            </span>
                        </div>
                    </div>
                <!-- 系统商城商品网格 -->
                <div id="system-product-grid" class="product-grid">
                    <!-- 系统商品将在这里动态生成 -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 个人商城页面 -->
        <div id="personal-mall-page" class="mall-page active">
            <div class="mall-content">
                <!-- 左侧分类导航 -->
                <div id="personal-mall-sidebar" class="mall-sidebar">
                    <div class="sidebar-category active" data-category="all" onclick="switchPersonalMallCategory('all')">
                        <span class="category-icon">🏪</span>
                        <span class="category-name">全部</span>
                    </div>
                    <div class="sidebar-category" data-category="other" onclick="switchPersonalMallCategory('other')">
                        <span class="category-icon">📦</span>
                        <span class="category-name">其他</span>
                    </div>
                    <div class="sidebar-category" data-category="electronics" onclick="switchPersonalMallCategory('electronics')">
                        <span class="category-icon">✨</span>
                        <span class="category-name">数码</span>
                    </div>
                    <div class="sidebar-category" data-category="fashion" onclick="switchPersonalMallCategory('fashion')">
                        <span class="category-icon">🎀</span>
                        <span class="category-name">服饰</span>
                    </div>
                    <div class="sidebar-category" data-category="home" onclick="switchPersonalMallCategory('home')">
                        <span class="category-icon">🏡</span>
                        <span class="category-name">家居</span>
                    </div>
                    <div class="sidebar-category" data-category="food" onclick="switchPersonalMallCategory('food')">
                        <span class="category-icon">🍓</span>
                        <span class="category-name">蔬果</span>
                    </div>
                    <div class="sidebar-category" data-category="snacks" onclick="switchPersonalMallCategory('snacks')">
                        <span class="category-icon">🍿</span>
                        <span class="category-name">零食</span>
                    </div>
                    <div class="sidebar-category" data-category="fresh" onclick="switchPersonalMallCategory('fresh')">
                        <span class="category-icon">🥩</span>
                        <span class="category-name">生鲜</span>
                    </div>
                    <div class="sidebar-category" data-category="medicine" onclick="switchPersonalMallCategory('medicine')">
                        <span class="category-icon">💊</span>
                        <span class="category-name">药物</span>
                    </div>
                    <div class="sidebar-category" data-category="adult" onclick="switchPersonalMallCategory('adult')">
                        <span class="category-icon">🔞</span>
                        <span class="category-name">情趣</span>
                    </div>
                    <div class="sidebar-category" data-category="maternity" onclick="switchPersonalMallCategory('maternity')">
                        <span class="category-icon">👶</span>
                        <span class="category-name">母婴</span>
                    </div>
                    <div class="sidebar-category" data-category="beauty" onclick="switchPersonalMallCategory('beauty')">
                        <span class="category-icon">💄</span>
                        <span class="category-name">美妆</span>
                    </div>
                    <div class="sidebar-category" data-category="pets" onclick="switchPersonalMallCategory('pets')">
                        <span class="category-icon">🐕</span>
                        <span class="category-name">宠物</span>
                    </div>
                </div>
                
                <!-- 右侧内容区域 -->
                <div id="personal-mall-main" class="mall-main">
                    <!-- 个人商城头部操作栏 -->
                    <div class="personal-mall-header">
                        <!-- 购物车总金额显示 -->
                        <div class="cart-total-display">
                            <span class="total-label">总计:</span>
                            <span id="personal-cart-total" class="total-amount">¥0.00</span>
                        </div>
                        <div class="header-actions">
                            <!-- 管理商品按钮 (扳手图标) -->
                            <span class="action-btn" id="manage-products-btn" title="管理商品">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>
                                </svg>
                            </span>
                            <!-- 添加新商品按钮 (加号图标) -->
                            <span class="action-btn" id="add-new-product-btn" title="添加新商品">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="12" y1="8" x2="12" y2="16"></line>
                                    <line x1="8" y1="12" x2="16" y2="12"></line>
                                </svg>
                            </span>
                            <!-- 购物车按钮 (购物车图标 + 数量徽章) -->
                            <span class="action-btn" id="go-to-cart-btn" title="查看购物车">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="9" cy="21" r="1"></circle>
                                    <circle cx="20" cy="21" r="1"></circle>
                                    <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
                                </svg>
                                <span id="cart-count">0</span>
                            </span>
                        </div>
                    </div>
                    
                    <!-- 个人商城商品网格 -->
                    <div id="product-grid" class="product-grid">
                        <!-- 个人商品将在这里动态生成 -->
                    </div>
                </div>
            </div>
        </div>
        
    </div>
    
    <!-- 底部标签导航 -->
    <div id="shopping-bottom-nav" class="shopping-bottom-nav">
        <div class="shopping-nav-item" data-mall="system" onclick="switchMall('system')">
            <span class="nav-icon">🌸</span>
            <span class="nav-label">系统商城</span>
        </div>
        <div class="shopping-nav-item active" data-mall="personal" onclick="switchMall('personal')">
            <span class="nav-icon">💖</span>
            <span class="nav-label">个人商城</span>
        </div>
    </div>
</div>

<!-- 钱包弹窗 -->
<div id="wallet-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 400px; max-height: 600px;">
        <div class="modal-header">
            <span>我的钱包</span>
            <span class="close-modal" onclick="closeWallet()">×</span>
        </div>
        <div class="modal-body" style="max-height: 520px; overflow-y: auto;">
            <div class="wallet-balance-display">
                <div class="balance-label">账户余额</div>
                <div class="balance-amount" id="wallet-balance">¥0.00</div>
            </div>
            <div class="wallet-actions">
                <button class="wallet-btn recharge-btn" onclick="startRechargeGame()">充值</button>
            </div>
            <div class="wallet-info">
                <div class="challenge-chances-info" id="challenge-chances-info">
                    <p style="color: #666; font-size: 14px; text-align: center; margin: 15px 0 5px 0; font-weight: 500;">
                        您还有 <span id="remaining-challenge-chances" style="color: #4CAF50; font-weight: 600;">2</span> 次闯关机会
                    </p>
                    <p id="reset-time-info" style="color: #999; font-size: 12px; text-align: center; margin: 0;">
                        重置时间为：12:01
                    </p>
                </div>
                
                
                <p style="color: #666; font-size: 12px; text-align: center; margin-top: 15px;">
                    通过完成小游戏来获得充值机会
                </p>
            </div>
            
            <!-- 新增：交易记录区域 -->
            <div class="wallet-transactions">
                <div class="transaction-header">
                    <h3 style="margin: 20px 0 10px 0; font-size: 16px; color: #333;">交易记录</h3>
                </div>
                <div class="transaction-list" id="transaction-list">
                    <!-- 交易记录将动态生成在这里 -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 小游戏弹窗 -->
<div id="game-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 450px; max-height: 600px;">
        <div class="modal-header">
            <span id="game-title">充值小游戏</span>
            <span class="close-modal" onclick="closeGameModal()">×</span>
        </div>
        <div class="modal-body">
            <!-- 游戏状态显示 -->
            <div class="game-status">
                <div class="game-round">第 <span id="current-round">1</span> 轮</div>
                <div class="game-chances">剩余机会: <span id="remaining-chances">2</span></div>
                <div class="game-timer" id="game-timer" style="display: none;">倒计时: <span id="timer-display">30</span>秒</div>
            </div>
            
            
            <!-- 游戏内容区域 -->
            <div id="game-content" class="game-content">
                <!-- 动态内容将在这里显示 -->
            </div>
            
            <!-- 游戏操作按钮 -->
            <div class="game-actions">
                <button id="game-action-btn" class="game-btn" style="display: none;">开始游戏</button>
            </div>
        </div>
    </div>
</div>

<!-- 充值成功弹窗 -->
<div id="recharge-success-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 350px; width: 90%;">
        <div class="modal-header">
            <span>充值成功！</span>
            <span class="close-modal" onclick="closeRechargeSuccess()">×</span>
        </div>
        <div class="modal-body">
            <div class="success-content">
                <div class="success-icon">🎉</div>
                <div class="success-message">恭喜你完成了所有挑战！</div>
                <div class="recharge-form">
                    <label for="recharge-amount">充值金额:</label>
                    <input type="number" id="recharge-amount" placeholder="请输入金额" min="0.01" step="0.01">
                    <button class="recharge-confirm-btn" onclick="confirmRecharge()">确认充值</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 游戏失败弹窗 -->
<div id="game-failed-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 350px;">
        <div class="modal-header">
            <span>游戏失败</span>
            <span class="close-modal" onclick="closeGameFailed()">×</span>
        </div>
        <div class="modal-body">
            <div class="failed-content">
                <div class="failed-message" id="failed-message">老铁还是不够努力，可以乞讨去了</div>
                <div class="next-chance-time" id="next-chance-time" style="display: none;">
                    下次机会恢复时间: <span id="recovery-time"></span>
                </div>
                <button class="retry-btn" onclick="closeGameFailed()" style="margin-top: 20px;">确定</button>
            </div>
        </div>
    </div>
</div>

<!-- 2. 商品详情页面 -->
<div id="product-detail-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="product-detail-back-btn">‹</span>
        <span>商品详情</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="product-detail-content" class="list-container">
        <!-- 详情内容将在这里动态生成 -->
    </div>
    <div id="product-detail-footer">
        <button class="footer-btn add-to-cart-detail-btn">加入购物车</button>
        <button class="footer-btn buy-now-btn">立即购买</button>
    </div>
</div>

<!-- 3. 购物车页面 -->
<div id="cart-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="cart-back-btn">‹</span>
        <span id="cart-title">购物车(0)</span>
        <span class="action-btn" id="clear-cart-btn">清空</span>
    </div>
    <div id="cart-items-list" class="list-container">
        <!-- 购物车商品将在这里动态生成 -->
    </div>
    <!-- 购物车底部操作栏 -->
    <div id="cart-footer">
        <label class="select-all-label">
            <input type="checkbox" id="select-all-cart-items"> 全选
        </label>
        <div class="cart-summary">
            <div id="cart-total">合计: ¥0.00</div>
            <span class="cart-subtext">不含运费</span>
        </div>
        <button id="checkout-btn">结算(0)</button>
    </div>
</div>

<!-- ▲▲▲ 购物系统页面结构结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】自定义头像框管理模态框 ▼▼▼ -->
<div id="custom-frame-manager-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>管理我的头像框</span>
            <button id="upload-custom-frame-btn" class="action-button">上传</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="custom-frame-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                <!-- 自定义头像框将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-frame-manager-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<input type="file" id="custom-frame-upload-input" accept="image/png, image/gif" hidden multiple>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【已修改】头像框选择模态框 ▼▼▼ -->
<div id="avatar-frame-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>选择头像框</span>
            <!-- 【核心修改】我们在这里加一个“管理”按钮 -->
            <button id="manage-custom-frames-btn" class="action-button">管理</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <!-- 【核心修改】不再需要Tabs，只有一个Grid -->
            <div id="avatar-frame-grid" class="frame-grid">
                <!-- 头像框选项（包括“无”和自定义的）会在这里生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-frame-settings-btn">取消</button>
            <button class="save" id="save-frame-settings-btn">保存</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用这整块【全新设计】的代码，替换旧的 id="send-location-modal" ▼▼▼ -->
<div id="send-location-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>发送定位与轨迹</span>
        </div>
        <div class="modal-body" style="padding-bottom: 5px;">
            <!-- 核心信息 -->
            <div class="form-group">
                <label for="user-location-input">我的位置 (起点)</label>
                <input type="text" id="user-location-input" placeholder="例如：市中心的咖啡馆">
            </div>
            <div class="form-group">
                <label for="ai-location-input">Ta的位置 (终点)</label>
                <input type="text" id="ai-location-input" placeholder="例如：海边的灯塔">
            </div>
            <div class="form-group">
                <label for="distance-input">相距</label>
                <input type="text" id="distance-input" placeholder="例如：约5公里 (必填)">
            </div>
            
            <hr style="opacity: 0.2;">

            <!-- 【全新】行动轨迹输入区 -->
            <div class="form-group">
                <label>行动轨迹 (可选，按顺序填写)</label>
                <div id="trajectory-points-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- JS会在这里动态添加输入框 -->
                </div>
                <button id="add-trajectory-point-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加途经点</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="location-cancel-btn">取消</button>
            <button class="save" id="location-confirm-btn">发送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】粘贴悬浮歌词栏设置模态框 ▼▼▼ -->
<div id="lyrics-settings-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>悬浮歌词设置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="lyrics-font-size-slider">字体大小: <span id="lyrics-font-size-value">14px</span></label>
                <input type="range" id="lyrics-font-size-slider" min="12" max="24" value="14" style="width: 100%;">
            </div>
            <div class="form-group">
                <label for="lyrics-bg-opacity-slider">背景不透明度: <span id="lyrics-bg-opacity-value">0%</span></label>
                <input type="range" id="lyrics-bg-opacity-slider" min="0" max="100" value="0" style="width: 100%;">
            </div>
            <div class="form-group">
                <label for="lyrics-font-color-picker">字体颜色</label>
                <input type="color" id="lyrics-font-color-picker" value="#FFFFFF" style="width: 100%; height: 40px;">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="reset-lyrics-settings-btn">恢复默认</button>
            <button class="save" id="close-lyrics-settings-btn">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是“选择搜索源”的弹窗，请粘贴到body末尾 ▼▼▼ -->
<div id="music-source-selector-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>选择搜索源</span>
        </div>
        <div class="modal-body" style="text-align: left; padding: 20px;">
            <label style="display: block; margin-bottom: 15px; cursor: pointer;">
                <input type="radio" name="search-source" value="all" checked> 全部来源 (网易云 + QQ音乐)
            </label>
            <label style="display: block; margin-bottom: 15px; cursor: pointer;">
                <input type="radio" name="search-source" value="netease"> 仅网易云音乐
            </label>
            <label style="display: block; cursor: pointer;">
                <input type="radio" name="search-source" value="tencent"> 仅QQ音乐
            </label>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-source-select-btn">取消</button>
            <button class="save" id="confirm-source-select-btn">开始搜索</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 【全新】这是微博关注列表的弹窗，粘贴到 </body> 前面 ▼▼▼ -->
<div id="weibo-following-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>关注列表</span>
        </div>
        <div class="modal-body" style="padding: 0;">
            <!-- 【核心】这个容器将带滚动条 -->
            <div id="weibo-following-list-container">
                <!-- 关注列表将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-following-list-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】心声功能模态框 ▼▼▼ -->
<div id="inner-voice-modal" class="modal">
    <!-- 心声主面板 -->
    <div id="inner-voice-main-panel" class="modal-content" style="width: 90%; max-width: 340px; height: auto; max-height: 80%; background-color: #fffafb; border: 1px solid #ffe4e1;">
        <div class="modal-header" style="border-bottom: 1px solid #ffe4e1; padding: 12px 15px;">
            <!-- 关闭按钮 -->
            <span id="close-inner-voice-modal" style="cursor: pointer; font-size: 24px; color: #ff8a80;">×</span>
            <!-- 历史按钮 -->
            <span id="inner-voice-history-btn" style="cursor: pointer;">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#ff8a80" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
                </svg>
            </span>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <!-- 左上角头像和右侧信息 -->
            <div style="display: flex; align-items: flex-start; margin-bottom: 20px;">
                <div id="inner-voice-avatar-wrapper" style="position: relative; flex-shrink: 0;">
                    <img id="inner-voice-avatar" src="" style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover;">
                </div>
                <div style="margin-left: 12px;">
                    <div id="inner-voice-char-name" style="font-weight: 600; font-size: 16px; color: #333;"></div>
                    <div id="inner-voice-adopter" style="font-size: 13px; color: #888; margin-top: 4px;"></div>
                </div>
            </div>
            <!-- 心声内容 -->
            <div id="inner-voice-content-area" style="display: flex; flex-direction: column; gap: 15px;">
                <div>
                    <strong style="color: #e57373;">服装:</strong>
                    <p id="inner-voice-clothing" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #81c784;">行为:</strong>
                    <p id="inner-voice-behavior" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #64b5f6;">心声:</strong>
                    <p id="inner-voice-thoughts" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #ba68c8;">坏心思:</strong>
                    <p id="inner-voice-naughty-thoughts" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
            </div>
        </div>
    </div>

<!-- 历史记录面板 (默认隐藏) -->
<div id="inner-voice-history-panel" class="modal-content" style="width: 90%; max-width: 340px; height: 80%; background-color: #f5f5f5; display: none; flex-direction: column;">
    <div class="modal-header" style="border-bottom: 1px solid #ddd; justify-content: space-between;">
        <span id="back-from-history-btn" style="cursor: pointer; font-size: 16px; font-weight: 600; color: var(--accent-color);">返回</span>
        <span>历史心声</span>
        <!-- 【新增】全部清空按钮 -->
        <span id="clear-all-history-btn" style="cursor: pointer; font-size: 14px; color: #ff3b30;">全部清空</span>
    </div>
    <div class="modal-body" id="inner-voice-history-list" style="padding: 0;">
        <!-- 历史记录会由JS动态生成在这里 -->
    </div>
</div>

<script>

// ▼▼▼ 全局变量声明 ▼▼▼
let currentNotificationTimeout = null;

// ▼▼▼ 记忆系统函数 - 需要在最开始定义，因为会被调用 ▼▼▼

// 获取当前角色的私人空间记忆上下文
function getPrivateSpaceMemoryContext(chatId) {
    if (!chatId) return '';
    
    const dataKey = `privateSpace_${chatId}`;
    const savedData = localStorage.getItem(dataKey);
    
    if (!savedData) {
        return '';
    }
    
    try {
        const data = JSON.parse(savedData);
        let memoryContext = '';
        
        // 1. 约定列表
        if (data.agreements && data.agreements.length > 0) {
            memoryContext += '\n# 你的私人约定记录\n';
            memoryContext += '这些是你的私人约定：\n';
            data.agreements.forEach((agreement, index) => {
                memoryContext += `${index + 1}. ${agreement.text}\n`;
            });
        }
        
        // 2. 物品管理
        if (data.items && data.items.length > 0) {
            memoryContext += '\n# 你的私人物品清单\n';
            memoryContext += '这些是你私人拥有的物品：\n';
            data.items.forEach((item, index) => {
                if (item && typeof item === 'object') {
                    // 物品是对象格式 {id, name, description, effect, meaning, source, owner}
                    const itemName = item.name || `物品${index + 1}`;
                    const itemDetails = [];
                    
                    if (item.description && item.description.trim()) {
                        itemDetails.push(`描述: ${item.description.trim()}`);
                    }
                    if (item.effect && item.effect.trim()) {
                        itemDetails.push(`效果: ${item.effect.trim()}`);
                    }
                    if (item.meaning && item.meaning.trim()) {
                        itemDetails.push(`意义: ${item.meaning.trim()}`);
                    }
                    if (item.source && item.source.trim()) {
                        itemDetails.push(`来源: ${item.source.trim()}`);
                    }
                    if (item.owner && item.owner.trim()) {
                        itemDetails.push(`归属: ${item.owner.trim()}`);
                    }
                    
                    const itemDesc = itemDetails.join(' | ');
                    memoryContext += `- **${itemName}**${itemDesc ? `: ${itemDesc}` : ''}\n`;
                }
            });
        }
        
        // 3. 私人相册
        memoryContext += '\n# 你的私人相册\n';
        if (data.privatePhotos && data.privatePhotos.length > 0) {
            memoryContext += '这些是你的私人照片（真实的手机相册照片，不是表情包）。你可以在聊天中使用 [PRIVATE_PHOTO:索引] 格式发送这些照片：\n';
            data.privatePhotos.forEach((photo, index) => {
                const photoName = photo.name || `照片${index + 1}`;
                const photoNote = photo.note || '';
                // 显示照片索引和发送格式
                memoryContext += `**照片索引 ${index}** - 发送格式: [PRIVATE_PHOTO:${index}]\n`;
                memoryContext += `照片名称: ${photoName}\n`;
                memoryContext += `照片备注: ${photoNote || '无备注'}\n`;
                // 使用HTML格式显示照片，和恋爱空间内部格式一致
                memoryContext += `
<div class="album-photo-item" style="display: inline-block; margin: 10px; background: rgba(248, 248, 248, 0.95); border-radius: 12px; padding: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); perspective: 1000px; width: 150px;">
    <div class="photo-card" style="position: relative; width: 100%; aspect-ratio: 1 / 1.1; transition: transform 0.6s; transform-style: preserve-3d;">
        <div class="photo-front" style="border-radius: 8px; overflow: hidden; display: flex; flex-direction: column;">
            <img src="${photo.src}" alt="私人照片" style="width: 100%; aspect-ratio: 1/1; object-fit: cover; border-radius: 8px 8px 0 0; cursor: pointer;" onclick="showImageViewer('${photo.src}')">
            <div class="photo-title" style="position: absolute; bottom: 0; left: 0; right: 0; height: 15%; background: rgba(255, 255, 255, 0.95); border-radius: 0 0 8px 8px; font-size: 11px; color: #555; text-align: center; display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 2px 6px; box-sizing: border-box;" onclick="flipPhotoCard(this)">
                <div class="title-text-container" style="flex: 1; overflow: hidden;">
                    <span class="title-text">${photoName}</span>
                </div>
                <span class="flip-icon" style="font-size: 12px; opacity: 0.7;">⟲</span>
            </div>
        </div>
        <div class="photo-back" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: rotateY(180deg); background: rgba(248, 248, 248, 0.95); border-radius: 8px; padding: 8px; display: flex; flex-direction: column; text-align: center; box-sizing: border-box; backface-visibility: hidden;">
            <div class="photo-back-content" style="color: #666; font-size: 12px; line-height: 1.3; word-break: break-word; flex: 1; overflow-y: auto; margin-bottom: 8px; padding: 4px 0;">
                ${photoNote || '这张照片还没有备注'}
            </div>
            <div class="photo-back-name" style="color: #333; font-size: 11px; font-weight: 500; text-align: center; border-top: 1px solid #eee; padding-top: 4px; margin-top: auto;">
                ${photoName}
            </div>
        </div>
    </div>
</div>
`;
            });
        } else {
            memoryContext += '⚠️ 你的私人相册目前是空的，没有任何照片。请不要尝试发送 [PRIVATE_PHOTO:索引] 格式的照片，因为没有照片可以发送。\n';
        }
        
        return memoryContext;
        
    } catch (error) {
        console.error('解析私人空间数据时出错:', error);
        return '';
    }
}

// 获取恋爱空间记忆上下文（只有绑定恋爱空间的角色才能看到）
function getLoveSpaceMemoryContext(chatId) {
    if (!chatId) return '';
    
    // 检查当前角色是否绑定了恋爱空间
    const loveSpaceSettings = JSON.parse(localStorage.getItem('loveSpaceSettings') || '{}');
    if (!loveSpaceSettings.boundCharacterId || loveSpaceSettings.boundCharacterId !== chatId) {
        return ''; // 只有绑定恋爱空间的角色才能看到恋爱空间打卡数据
    }
    
    let memoryContext = '';
    
    // 恋爱空间打卡记录
    const checkinData = JSON.parse(localStorage.getItem('loveSpaceCheckinData') || '{}');
    if (checkinData.userTotalCheckins > 0 || checkinData.aiTotalCheckins > 0) {
        memoryContext += '\n# 恋爱空间打卡记录\n';
        memoryContext += '这些是你们的恋爱空间打卡数据，只有你能看到：\n';
        memoryContext += `- 用户总打卡天数：${checkinData.userTotalCheckins || 0}天\n`;
        memoryContext += `- 你的总打卡天数：${checkinData.aiTotalCheckins || 0}天\n`;
        memoryContext += `- 用户连续打卡：${checkinData.userConsecutiveDays || 0}天\n`;
        memoryContext += `- 你的连续打卡：${checkinData.aiConsecutiveDays || 0}天\n`;
        
        // 最近的打卡记录
        if (checkinData.userLastCheckin) {
            memoryContext += `- 用户最后打卡：${checkinData.userLastCheckin}\n`;
        }
        if (checkinData.aiLastCheckin) {
            memoryContext += `- 你最后打卡：${checkinData.aiLastCheckin}\n`;
        }
    }
    
    return memoryContext;
}

// 获取恋爱相册记忆上下文（独立系统，可绑定多个角色）
function getLoveAlbumMemoryContext(chatId) {
    if (!chatId) return '';
    
    // 查找绑定了当前角色的恋爱相册
    const albums = JSON.parse(localStorage.getItem('albums') || '[]');
    const boundAlbums = albums.filter(album => 
        album.boundContacts && 
        album.boundContacts.some(contact => contact.id === chatId)
    );
    
    if (boundAlbums.length === 0) {
        return '';
    }
    
    let memoryContext = '\n# 恋爱相册记录\n';
    memoryContext += '这些是你和用户绑定的恋爱相册（真实的手机相册照片，不是表情包）：\n';
    
    boundAlbums.forEach(album => {
        memoryContext += `\n## ${album.name}${album.description ? ` - ${album.description}` : ''}\n`;
        if (album.photos && album.photos.length > 0) {
            memoryContext += `共有 ${album.photos.length} 张照片：\n`;
            // 使用HTML格式显示照片，和恋爱空间内部格式一致
            album.photos.forEach(photo => {
                const photoName = photo.name || '未命名照片';
                const photoNote = photo.note || '';
                memoryContext += `
<div class="album-photo-item" style="display: inline-block; margin: 10px; background: rgba(248, 248, 248, 0.95); border-radius: 12px; padding: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); perspective: 1000px; width: 150px;">
    <div class="photo-card" style="position: relative; width: 100%; aspect-ratio: 1 / 1.1; transition: transform 0.6s; transform-style: preserve-3d;">
        <div class="photo-front" style="border-radius: 8px; overflow: hidden; display: flex; flex-direction: column;">
            <img src="${photo.url}" alt="恋爱相册照片" style="width: 100%; aspect-ratio: 1/1; object-fit: cover; border-radius: 8px 8px 0 0; cursor: pointer;" onclick="showImageViewer('${photo.url}')">
            <div class="photo-title" style="position: absolute; bottom: 0; left: 0; right: 0; height: 15%; background: rgba(255, 255, 255, 0.95); border-radius: 0 0 8px 8px; font-size: 11px; color: #555; text-align: center; display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 2px 6px; box-sizing: border-box;" onclick="flipPhotoCard(this)">
                <div class="title-text-container" style="flex: 1; overflow: hidden;">
                    <span class="title-text">${photoName}</span>
                </div>
                <span class="flip-icon" style="font-size: 12px; opacity: 0.7;">⟲</span>
            </div>
        </div>
        <div class="photo-back" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: rotateY(180deg); background: rgba(248, 248, 248, 0.95); border-radius: 8px; padding: 8px; display: flex; flex-direction: column; text-align: center; box-sizing: border-box; backface-visibility: hidden;">
            <div class="photo-back-content" style="color: #666; font-size: 12px; line-height: 1.3; word-break: break-word; flex: 1; overflow-y: auto; margin-bottom: 8px; padding: 4px 0;">
                ${photoNote || '这张照片还没有备注'}
            </div>
            <div class="photo-back-name" style="color: #333; font-size: 11px; font-weight: 500; text-align: center; border-top: 1px solid #eee; padding-top: 4px; margin-top: auto;">
                ${photoName}
            </div>
        </div>
    </div>
</div>
`;
            });
        } else {
            memoryContext += '⚠️ 这个相册目前是空的，没有任何照片。请不要尝试引用这个相册中的照片。\n';
        }
    });
    
    return memoryContext;
}

// ▼▼▼ 照片卡片交互函数 - 用于记忆系统中的照片显示 ▼▼▼

// 翻转照片卡片函数
function flipPhotoCard(titleElement) {
    const photoCard = titleElement.closest('.photo-card');
    if (!photoCard) return;
    
    const isFlipped = photoCard.classList.contains('flipped');
    
    if (!isFlipped) {
        // 翻转到背面
        photoCard.classList.add('flipped');
        
        // 8秒后自动翻回正面
        setTimeout(() => {
            if (photoCard.classList.contains('flipped')) {
                photoCard.classList.remove('flipped');
            }
        }, 8000);
    } else {
        // 如果已经翻转，点击则立即翻回正面
        photoCard.classList.remove('flipped');
    }
}

// 显示图片查看器函数（如果不存在的话）
if (typeof showImageViewer === 'undefined') {
    function showImageViewer(imageSrc) {
        // 创建图片查看器
        let viewer = document.getElementById('memory-image-viewer');
        if (!viewer) {
            viewer = document.createElement('div');
            viewer.id = 'memory-image-viewer';
            viewer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                cursor: pointer;
            `;
            
            const img = document.createElement('img');
            img.style.cssText = `
                max-width: 90%;
                max-height: 90%;
                object-fit: contain;
                border-radius: 8px;
            `;
            
            viewer.appendChild(img);
            document.body.appendChild(viewer);
            
            // 点击关闭
            viewer.addEventListener('click', () => {
                viewer.style.display = 'none';
            });
        }
        
        const img = viewer.querySelector('img');
        img.src = imageSrc;
        viewer.style.display = 'flex';
    }
}

// ▼▼▼ 私人相册相关函数 - 需要在最开始定义，因为HTML中有onclick调用 ▼▼▼

// 私人相册数据存储
let privatePhotos = [];
// 将privatePhotos设置为全局可访问
window.privatePhotos = privatePhotos;

// 初始化私人相册数据
function initPrivateAlbum() {
    // 如果在私人空间模式下，不要从全局localStorage加载数据
    // 数据将由loadPrivateSpaceData()函数加载
    if (window.currentPrivateSpaceContactId) {
        privatePhotos = [];
        window.privatePhotos = privatePhotos;
        return;
    }
    
    const saved = localStorage.getItem('privatePhotos');
    if (saved) {
        try {
            privatePhotos = JSON.parse(saved);
            window.privatePhotos = privatePhotos;
        } catch (e) {
            console.error('解析私人相册数据失败:', e);
            privatePhotos = [];
            window.privatePhotos = privatePhotos;
        }
    } else {
        privatePhotos = [];
        window.privatePhotos = privatePhotos;
    }
}

// 保存私人相册数据
function savePrivateAlbum() {
    try {
        console.log('🔍 savePrivateAlbum 被调用:', {
            isPrivateSpace: !!window.currentPrivateSpaceContactId,
            contactId: window.currentPrivateSpaceContactId,
            photosCount: privatePhotos.length,
            photos: privatePhotos
        });
        
        // 如果在私人空间模式下，只保存到联系人特定数据，不保存到全局
        if (window.currentPrivateSpaceContactId) {
            window.saveCurrentPrivateSpaceData();
        } else {
            // 非私人空间模式下，保存到全局localStorage
        localStorage.setItem('privatePhotos', JSON.stringify(privatePhotos));
        }
    } catch (e) {
        console.error('保存私人相册数据失败:', e);
    }
}

// 显示添加照片弹窗
function showPrivateAddPhotoDialog() {
    const dialog = document.getElementById('private-add-photo-dialog');
    if (dialog) {
        // 确保弹窗样式正确
        dialog.style.display = 'flex';
        dialog.style.position = 'fixed';
        dialog.style.top = '0';
        dialog.style.left = '0';
        dialog.style.width = '100%';
        dialog.style.height = '100%';
        dialog.style.alignItems = 'center';
        dialog.style.justifyContent = 'center';
        dialog.style.zIndex = '10000';
        
        // 清空输入框
        document.getElementById('private-photo-url-input').value = '';
        document.getElementById('private-photo-name-input').value = '';
        document.getElementById('private-photo-description-input').value = '';
        const preview = document.getElementById('private-photo-preview');
        if (preview) preview.style.display = 'none';
    }
}

// 隐藏添加照片弹窗
function hidePrivateAddPhotoDialog() {
    const dialog = document.getElementById('private-add-photo-dialog');
    if (dialog) {
        dialog.style.display = 'none';
    }
}

// 预览照片URL
function previewPrivatePhotoUrl() {
    const urlInput = document.getElementById('private-photo-url-input');
    const preview = document.getElementById('private-photo-preview');
    const previewImg = document.getElementById('private-preview-image');
    
    if (!urlInput || !preview || !previewImg) return;
    
    const url = urlInput.value.trim();
    if (!url) {
        alert('请输入图片URL');
        return;
    }
    
    // 显示预览
    previewImg.src = url;
    preview.style.display = 'block';
    
    // 检查图片是否能正常加载
    previewImg.onload = function() {
        console.log('图片预览加载成功');
    };
    
    previewImg.onerror = function() {
        alert('图片加载失败，请检查URL是否正确');
        preview.style.display = 'none';
    };
}

// 添加私人照片
async function addPrivatePhoto() {
    const urlInput = document.getElementById('private-photo-url-input');
    const nameInput = document.getElementById('private-photo-name-input');
    const descInput = document.getElementById('private-photo-description-input');
    
    if (!urlInput || !nameInput || !descInput) return;
    
    const url = urlInput.value.trim();
    const name = nameInput.value.trim();
    const description = descInput.value.trim();
    
    if (!url) {
        alert('请输入图片URL');
        return;
    }
    
    // 创建新照片对象
    const newPhoto = {
        src: url,
        name: name,
        description: description,
        timestamp: Date.now(),
        createdAt: new Date().toISOString()
    };
    
    // 添加到数组开头（最新的在前面）
    privatePhotos.unshift(newPhoto);
    window.privatePhotos = privatePhotos;
    
    // 保存数据
    savePrivateAlbum();
    
    // 重新渲染
    renderPrivateAlbum();
    
    // 关闭弹窗
    hidePrivateAddPhotoDialog();
    
    console.log('私人照片添加成功:', newPhoto);
}

// 删除私人照片
async function deletePrivatePhoto(index) {
    const photoCard = document.querySelector(`.private-photo-card[data-index="${index}"]`);
    if (photoCard && photoCard.setOperationInProgress) {
        photoCard.setOperationInProgress(true);
    }
    
    const confirmed = confirm('确定要删除这张照片吗？此操作无法撤销。');
    
    if (!confirmed) {
        if (photoCard && photoCard.setOperationInProgress) {
            photoCard.setOperationInProgress(false);
        }
        return;
    }
    
    try {
        // 添加删除动画
        const photoItem = photoCard.closest('.private-photo-item');
        if (photoItem) {
            photoItem.style.transition = 'all 0.3s ease-out';
            photoItem.style.transform = 'scale(0)';
            photoItem.style.opacity = '0';
            
            // 等待动画完成
            await new Promise(resolve => setTimeout(resolve, 300));
        }
        
        // 删除照片
        privatePhotos.splice(index, 1);
        window.privatePhotos = privatePhotos;
        
        // 保存更改
        savePrivateAlbum();
        renderPrivateAlbum(); // 重新渲染会自动实现丝滑补位
        
    } catch (e) {
        console.error('删除私人照片失败:', e);
        alert('删除照片失败，请重试');
        
        if (photoCard && photoCard.setOperationInProgress) {
            photoCard.setOperationInProgress(false);
        }
    }
}

// 编辑私人照片
async function editPrivatePhoto(index) {
    const photo = privatePhotos[index];
    if (!photo) return;
    
    // 获取DOM元素
    const contentElement = document.querySelector(`.private-photo-back-content[data-photo-index="${index}"]`);
    const nameElement = document.querySelector(`.private-photo-back-name[data-photo-index="${index}"]`);
    
    if (!contentElement || !nameElement) return;
    
    // 设置操作状态为进行中
    const photoCard = contentElement.closest('.private-photo-card');
    if (photoCard && photoCard.setOperationInProgress) {
        photoCard.setOperationInProgress(true);
    }
    
    // 创建编辑界面
    const originalDescription = photo.description || '';
    const originalName = photo.name || '';
    
    // 编辑备注
    const descriptionTextarea = document.createElement('textarea');
    descriptionTextarea.value = originalDescription;
    descriptionTextarea.className = 'private-photo-back-content editing';
    descriptionTextarea.style.minHeight = '60px';
    descriptionTextarea.style.width = '100%';
    descriptionTextarea.style.boxSizing = 'border-box';
    descriptionTextarea.style.background = 'rgba(255, 255, 255, 0.1)';
    descriptionTextarea.style.border = '1px solid rgba(255, 255, 255, 0.3)';
    descriptionTextarea.style.borderRadius = '8px';
    descriptionTextarea.style.color = '#fff';
    descriptionTextarea.style.padding = '8px';
    descriptionTextarea.style.fontSize = '14px';
    descriptionTextarea.style.resize = 'vertical';
    descriptionTextarea.placeholder = '为这张照片添加备注...';
    
    // 编辑名称
    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.value = originalName;
    nameInput.className = 'private-photo-back-name editing';
    nameInput.style.width = '100%';
    nameInput.style.boxSizing = 'border-box';
    nameInput.style.background = 'rgba(255, 255, 255, 0.1)';
    nameInput.style.border = '1px solid rgba(255, 255, 255, 0.3)';
    nameInput.style.borderRadius = '8px';
    nameInput.style.color = '#fff';
    nameInput.style.padding = '8px';
    nameInput.style.fontSize = '16px';
    nameInput.style.fontWeight = 'bold';
    nameInput.placeholder = '照片名称（可选）';
    nameInput.maxLength = 30;
    
    // 保存按钮
    const saveButton = document.createElement('button');
    saveButton.textContent = '保存';
    saveButton.className = 'private-photo-save-btn';
    saveButton.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        padding: 8px 16px;
        margin-top: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s ease;
    `;
    
    // 保存按钮悬停效果
    saveButton.addEventListener('mouseenter', () => {
        saveButton.style.transform = 'translateY(-2px)';
        saveButton.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.4)';
    });
    
    saveButton.addEventListener('mouseleave', () => {
        saveButton.style.transform = 'translateY(0)';
        saveButton.style.boxShadow = 'none';
    });
    
    // 替换原有内容
    const originalContentHTML = contentElement.innerHTML;
    const originalNameHTML = nameElement.innerHTML;
    
    contentElement.innerHTML = '';
    contentElement.appendChild(descriptionTextarea);
    contentElement.appendChild(saveButton);
    
    nameElement.innerHTML = '';
    nameElement.appendChild(nameInput);
    
    // 聚焦到描述框
    descriptionTextarea.focus();
    
    // 保存功能
    saveButton.onclick = async function(e) {
        e.stopPropagation();
        
        const newDescription = descriptionTextarea.value.trim();
        const newName = nameInput.value.trim();
        
        try {
            // 更新照片信息
            privatePhotos[index].description = newDescription;
            privatePhotos[index].name = newName;
            window.privatePhotos = privatePhotos;
            
            // 保存到localStorage
            savePrivateAlbum();
            
            // 重新渲染
            renderPrivateAlbum();
            
            // 显示成功提示
            showPrivateSaveSuccess(contentElement.closest('.private-photo-back'));
            
            // 清除操作状态
            if (photoCard && photoCard.setOperationInProgress) {
                photoCard.setOperationInProgress(false);
            }
            
        } catch (error) {
            console.error('保存失败:', error);
            alert('保存失败，请重试');
            
            // 恢复原内容
            contentElement.innerHTML = originalContentHTML;
            nameElement.innerHTML = originalNameHTML;
            
            // 清除操作状态
            if (photoCard && photoCard.setOperationInProgress) {
                photoCard.setOperationInProgress(false);
            }
        }
    };
    
    // 取消编辑（点击其他地方）
    function cancelEdit() {
        contentElement.innerHTML = originalContentHTML;
        nameElement.innerHTML = originalNameHTML;
        
        // 清除操作状态
        if (photoCard && photoCard.setOperationInProgress) {
            photoCard.setOperationInProgress(false);
        }
    }
    
    // ESC键取消
    function handleKeydown(e) {
        if (e.key === 'Escape') {
            cancelEdit();
            document.removeEventListener('keydown', handleKeydown);
        }
    }
    
    document.addEventListener('keydown', handleKeydown);
}

// 显示私人相册保存成功动画
function showPrivateSaveSuccess(backElement) {
    const successIcon = document.createElement('div');
    successIcon.innerHTML = '✓';
    successIcon.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
        color: #4CAF50;
        z-index: 1000;
        animation: saveSuccess 1.5s ease-out forwards;
    `;
    
    // 添加CSS动画
    if (!document.getElementById('private-save-success-style')) {
        const style = document.createElement('style');
        style.id = 'private-save-success-style';
        style.textContent = `
            @keyframes saveSuccess {
                0% {
                    opacity: 0;
                    transform: translate(-50%, -50%) scale(0);
                }
                50% {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1.2);
                }
                100% {
                    opacity: 0;
                    transform: translate(-50%, -50%) scale(1);
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    backElement.style.position = 'relative';
    backElement.appendChild(successIcon);
    
    setTimeout(() => {
        if (successIcon.parentNode) {
            successIcon.parentNode.removeChild(successIcon);
        }
    }, 1500);
}

// 查看私人照片大图
function viewPrivatePhoto(photoSrc, index) {
    // 创建全屏查看器
    const viewer = document.createElement('div');
    viewer.className = 'image-viewer-overlay';
    viewer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        cursor: pointer;
    `;
    
    const img = document.createElement('img');
    img.src = photoSrc;
    img.style.cssText = `
        max-width: 90%;
        max-height: 90%;
        object-fit: contain;
        border-radius: 8px;
    `;
    
    viewer.appendChild(img);
    document.body.appendChild(viewer);
    
    // 点击关闭
    viewer.addEventListener('click', () => {
        document.body.removeChild(viewer);
    });
    
    // ESC键关闭
    const handleKeydown = (e) => {
        if (e.key === 'Escape') {
            document.body.removeChild(viewer);
            document.removeEventListener('keydown', handleKeydown);
        }
    };
    document.addEventListener('keydown', handleKeydown);
}

// 渲染私人相册
function renderPrivateAlbum() {
    // 确保使用全局的 window.privatePhotos
    const photos = window.privatePhotos || [];
    
    console.log('🔍 renderPrivateAlbum 被调用:', {
        windowPrivatePhotosLength: window.privatePhotos ? window.privatePhotos.length : 'undefined',
        photosLength: photos.length,
        photos: photos
    });
    
    const albumGrid = document.getElementById('private-album-grid');
    const placeholder = document.getElementById('private-album-placeholder');
    
    if (!albumGrid || !placeholder) {
        console.log('🔍 renderPrivateAlbum: 找不到必要的DOM元素', {albumGrid: !!albumGrid, placeholder: !!placeholder});
        return;
    }
    
    if (photos.length === 0) {
        placeholder.style.display = 'block';
        // 清除照片项
        albumGrid.querySelectorAll('.private-photo-item').forEach(item => item.remove());
        return;
    }
    
    placeholder.style.display = 'none';
    
    // 清除现有照片
    albumGrid.querySelectorAll('.private-photo-item').forEach(item => item.remove());
    
    // 渲染所有照片（最新的在前面）
    photos.forEach((photo, index) => {
        const photoItem = document.createElement('div');
        photoItem.className = 'private-photo-item';
        
        const displayText = photo.name && photo.name.trim() ? photo.name : '点击查看详情';
        const backContent = photo.description && photo.description.trim() ? photo.description : (photo.name ? photo.name : '这张照片还没有描述');
        
        photoItem.innerHTML = `
            <div class="private-photo-card" data-index="${index}">
                <div class="private-photo-front">
                    <img src="${photo.src}" alt="私人相册照片">
                    <div class="private-photo-title" data-flip-trigger="true">
                        <div class="title-text-container">
                            <span class="title-text">${displayText}</span>
                        </div>
                        <span class="flip-icon">⟲</span>
                    </div>
                </div>
                <div class="private-photo-back">
                    <div class="private-photo-back-header">
                        <button class="private-photo-back-delete-btn" onclick="event.stopPropagation(); deletePrivatePhoto(${index}).catch(console.error)" title="删除照片">🗑️</button>
                        <button class="private-photo-edit-btn" onclick="event.stopPropagation(); editPrivatePhoto(${index})" title="编辑照片信息">⚙️</button>
                    </div>
                    <div class="private-photo-back-content" data-photo-index="${index}">
                        ${backContent}
                    </div>
                    <div class="private-photo-back-name" data-photo-index="${index}">
                        ${photo.name || '未命名照片'}
                    </div>
                </div>
            </div>
        `;
        
        // 添加点击底部翻转功能
        let isFlipped = false;
        let autoFlipTimer;
        let isOperationInProgress = false;
        
        const photoCard = photoItem.querySelector('.private-photo-card');
        const photoTitle = photoItem.querySelector('.private-photo-title');
        const photoImg = photoItem.querySelector('img');
        
        // 设置操作状态的函数
        function setOperationInProgress(inProgress) {
            isOperationInProgress = inProgress;
            if (!inProgress && isFlipped) {
                autoFlipTimer = setTimeout(() => {
                    if (!isOperationInProgress) {
                        photoCard.classList.remove('flipped');
                        isFlipped = false;
                    }
                }, 2000);
            }
        }
        
        photoCard.setOperationInProgress = setOperationInProgress;
        
        function flipToBack() {
            if (!isFlipped) {
                photoCard.classList.add('flipped');
                isFlipped = true;
                if (!isOperationInProgress) {
                    autoFlipTimer = setTimeout(() => {
                        if (!isOperationInProgress) {
                            photoCard.classList.remove('flipped');
                            isFlipped = false;
                        }
                    }, 5000);
                }
            }
        }
        
        // 点击底部区域翻转
        if (photoTitle) {
            photoTitle.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                flipToBack();
            });
        }
        
        // 点击图片查看大图
        if (photoImg) {
            photoImg.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                viewPrivatePhoto(photo.src, index);
            });
        }
        
        albumGrid.appendChild(photoItem);
    });
}

// ▲▲▲ 私人相册相关函数结束 ▲▲▲

// 恋爱空间页面切换功能 - 需要在最开始定义，因为HTML中有onclick调用
function switchLovePage(page) {
    // 隐藏所有页面
    document.getElementById('love-home-page').style.display = 'none';
    document.getElementById('love-gallery-page').style.display = 'none';
    
    // 移除所有导航项的活跃状态
    document.querySelectorAll('.love-bottom-nav .nav-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // 显示对应页面并激活导航项
    if (page === 'home') {
        document.getElementById('love-home-page').style.display = 'flex';
        document.querySelector('.nav-item[data-page="home"]').classList.add('active');
        
        // ★★★ 在主页显示DIY按钮和装饰层 ★★★
        const diyBtn = document.getElementById('diy-toggle-btn');
        const diyLayer = document.getElementById('diy-decoration-layer');
        if (diyBtn) diyBtn.style.display = 'inline-block';
        if (diyLayer) diyLayer.style.display = 'block';
        
    } else if (page === 'gallery') {
        document.getElementById('love-gallery-page').style.display = 'flex';
        document.querySelector('.nav-item[data-page="gallery"]').classList.add('active');
        
        // ★★★ 在相册页面隐藏DIY按钮和装饰层 ★★★
        const diyBtn = document.getElementById('diy-toggle-btn');
        const diyLayer = document.getElementById('diy-decoration-layer');
        if (diyBtn) diyBtn.style.display = 'none';
        if (diyLayer) diyLayer.style.display = 'none';
        
        // 如果正在DIY模式，退出DIY模式
        if (window.isDIYMode) {
            // 手动退出DIY模式
            window.isDIYMode = false;
            const toggleBtn = document.getElementById('diy-toggle-btn');
            const decorationLayer = document.getElementById('diy-decoration-layer');
            if (toggleBtn) toggleBtn.classList.remove('active');
            if (decorationLayer) decorationLayer.classList.remove('edit-mode');
            // 取消选中状态
            if (window.selectedDecoration) {
                window.selectedDecoration.classList.remove('selected');
                window.selectedDecoration = null;
            }
            // 隐藏上传弹窗
            const uploadModal = document.getElementById('diy-upload-modal');
            if (uploadModal) uploadModal.style.display = 'none';
        }
        
        // 初始化相册内容
        initGallery().catch(console.error);
    }
}

// ★★★ 日历相关函数 - 需要在最开始定义，因为HTML中有onclick调用 ★★★
// 日历状态 - 从2025年9月开始
let currentCalendarDate = new Date(2025, 8, 1); // 2025年9月（月份从0开始）

// 上一个月
function previousMonth() {
    currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
    updateCalendarDisplay();
}

// 下一个月  
function nextMonth() {
    currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
    updateCalendarDisplay();
}

// 上一个月（别名，兼容性）
function prevMonth() {
    previousMonth();
}

// ★★★ 日历辅助函数 ★★★
// 打卡数据存储键
const CHECKIN_DATA_KEY = 'loveSpaceCheckinData';

// 获取本地日期字符串
function getLocalDateString(date = new Date()) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// 获取打卡数据
function getCheckinData() {
    const data = localStorage.getItem(CHECKIN_DATA_KEY);
    return data ? JSON.parse(data) : {
        userLastCheckin: null,
        aiLastCheckin: null,
        userConsecutiveDays: 0,
        aiConsecutiveDays: 0,
        userTotalCheckins: 0,
        aiTotalCheckins: 0,
        userCheckinHistory: {},
        aiCheckinHistory: {}
    };
}

// 生成完整的月份日历
function generateFullCalendar(year, month) {
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const today = new Date();
    const startDate = new Date(2025, 8, 9); // 2025年9月9日开始
    
    // 获取打卡数据
    const checkinData = getCheckinData();
    
    const calendarHtml = [];
    
    // 获取第一天是星期几（0=周日）
    const firstDayOfWeek = firstDay.getDay();
    
    // 添加上个月的空白天数
    const prevMonth = new Date(year, month - 1, 0);
    for (let i = firstDayOfWeek - 1; i >= 0; i--) {
        const day = prevMonth.getDate() - i;
        calendarHtml.push(`
            <div class="calendar-day other-month">${day}</div>
        `);
    }
    
    // 添加当月的天数
    for (let day = 1; day <= lastDay.getDate(); day++) {
        const currentDate = new Date(year, month, day);
        const dateStr = getLocalDateString(currentDate);
        
        let classes = ['calendar-day'];
        
        // 检查是否是今天
        if (currentDate.toDateString() === today.toDateString()) {
            classes.push('today');
        }
        
        // 检查是否在开始日期之前
        if (currentDate < startDate) {
            classes.push('before-start');
        } else {
            // 检查打卡状态
            const userChecked = checkinData.userCheckinHistory && checkinData.userCheckinHistory[dateStr];
            const aiChecked = checkinData.aiCheckinHistory && checkinData.aiCheckinHistory[dateStr];
            
            // 根据打卡状态显示不同颜色
            if (userChecked && aiChecked) {
                // 都打卡了 - 橙黄色
                classes.push('both-checked');
            } else if (userChecked) {
                // 只有用户打卡 - 粉色
                classes.push('user-checked');
            } else if (aiChecked) {
                // 只有AI打卡 - 晕染色
                classes.push('ai-checked');
            }
        }
        
        calendarHtml.push(`
            <div class="${classes.join(' ')}">${day}</div>
        `);
    }
    
    // 添加下个月的空白天数，填满6行
    const totalCells = calendarHtml.length;
    const remainingCells = 42 - totalCells; // 6行 x 7列 = 42个单元格
    
    for (let day = 1; day <= remainingCells; day++) {
        calendarHtml.push(`
            <div class="calendar-day other-month">${day}</div>
        `);
    }
    
    return calendarHtml.join('');
}

// 更新日历显示
function updateCalendarDisplay() {
    const year = currentCalendarDate.getFullYear();
    const month = currentCalendarDate.getMonth();
    
    // 更新月年显示
    const monthNames = ['1月', '2月', '3月', '4月', '5月', '6月', 
                       '7月', '8月', '9月', '10月', '11月', '12月'];
    const monthYearEl = document.getElementById('calendarMonthYear');
    if (monthYearEl) {
        monthYearEl.textContent = `${year}年${monthNames[month]}`;
    }
    
    // 更新日历天数
    const calendarDaysEl = document.getElementById('calendarDays');
    if (calendarDaysEl) {
        calendarDaysEl.innerHTML = generateFullCalendar(year, month);
    }
}

// 相册数据存储
let albums = [];
console.log('页面加载时的相册数据:', albums);
let currentAlbumId = null;

// 相册创建时选中的联系人
let selectedAlbumContacts = new Set();

// 从数据库加载相册数据
async function loadAlbumsFromDB() {
    try {
        albums = await db.loveAlbums.orderBy('createdAt').reverse().toArray();
        console.log('从数据库加载的相册数据:', albums);
        
        // 【新增】为没有ID的照片补充ID（数据迁移）
        let needsUpdate = false;
        for (const album of albums) {
            if (album.photos && Array.isArray(album.photos)) {
                for (const photo of album.photos) {
                    if (!photo.id) {
                        photo.id = `photo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        needsUpdate = true;
                    }
                }
                
                // 如果有更新，保存到数据库
                if (needsUpdate) {
                    await db.loveAlbums.put(album);
                    console.log(`已为相册 "${album.name}" 的照片补充ID`);
                }
            }
        }
    } catch (error) {
        console.error('加载相册数据失败:', error);
        albums = [];
    }
}

// 保存相册到数据库
async function saveAlbumToDB(album) {
    try {
        await db.loveAlbums.put(album);
        console.log('相册已保存到数据库:', album.name);
    } catch (error) {
        console.error('保存相册到数据库失败:', error);
        throw error;
    }
}

// 显示创建相册弹窗
function showCreateAlbumDialog() {
    document.getElementById('create-album-dialog').style.display = 'flex';
    document.getElementById('album-name-input').value = '';
    document.getElementById('album-description-input').value = '';
    
    // 加载联系人列表
    loadAlbumContactList();
    
    // 延迟设置焦点，确保DOM完全渲染
    setTimeout(() => {
        const nameInput = document.getElementById('album-name-input');
        const descInput = document.getElementById('album-description-input');
        
        nameInput.focus();
        
        // 确保textarea可以被点击
        descInput.style.pointerEvents = 'auto';
        descInput.style.userSelect = 'text';
    }, 100);
}

// 加载相册创建时的联系人列表
function loadAlbumContactList() {
    selectedAlbumContacts.clear();
    const container = document.getElementById('album-contact-selection');
    
    // 使用全局的 state 对象，如果不存在则尝试 window.state
    const currentState = state || window.state;
    if (!currentState || !currentState.chats) {
        console.log('state.chats 不存在，尝试重新加载数据');
        container.innerHTML = '<div class="contact-loading">正在加载联系人...</div>';
        
        // 如果数据还没加载完成，稍等片刻再尝试
        setTimeout(() => {
            loadAlbumContactList();
        }, 500);
        return;
    }
    
    // 获取非群聊的联系人
    const contacts = Object.values(currentState.chats).filter(chat => !chat.isGroup);
    
    console.log('找到的联系人数量:', contacts.length);
    console.log('联系人列表:', contacts.map(c => ({ id: c.id, name: c.name })));
    
    if (contacts.length === 0) {
        container.innerHTML = '<div class="contact-loading">暂无可用联系人</div>';
        return;
    }
    
    container.innerHTML = '';
    
    contacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'album-contact-item';
        item.dataset.contactId = contact.id;
        
        const defaultAvatar = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMjAiIGZpbGw9IiNGM0Y0RjYiLz4KPGNpcmNsZSBjeD0iMjAiIGN5PSIxNiIgcj0iNiIgZmlsbD0iIzlDQTNBRiIvPgo8cGF0aCBkPSJNMzIgMzJDMzIgMjYuNDc3MiAyNy41MjI4IDIyIDIyIDIySDE4QzEyLjQ3NzIgMjIgOCAyNi40NzcyIDggMzJWMzJIMzJWMzJaIiBmaWxsPSIjOUNBM0FGIi8+Cjwvc3ZnPgo=';
        
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings?.aiAvatar || defaultAvatar}" class="avatar" alt="">
            <span class="name">${contact.name}</span>
        `;
        
        item.addEventListener('click', () => toggleAlbumContactSelection(contact.id, item));
        container.appendChild(item);
    });
}

// 切换联系人选择状态
function toggleAlbumContactSelection(contactId, itemElement) {
    if (selectedAlbumContacts.has(contactId)) {
        selectedAlbumContacts.delete(contactId);
        itemElement.classList.remove('selected');
    } else {
        selectedAlbumContacts.add(contactId);
        itemElement.classList.add('selected');
    }
    
    console.log('当前选中的联系人:', Array.from(selectedAlbumContacts));
}

// 隐藏创建相册弹窗
function hideCreateAlbumDialog() {
    document.getElementById('create-album-dialog').style.display = 'none';
    // 清除选择的联系人状态
    selectedAlbumContacts.clear();
}

// 创建新相册
async function createNewAlbum() {
    const name = document.getElementById('album-name-input').value.trim();
    const description = document.getElementById('album-description-input').value.trim();
    
    if (!name) {
        alert('请输入相册名称');
        return;
    }
    
    // 验证是否选择了角色
    if (selectedAlbumContacts.size === 0) {
        alert('请至少选择一个角色绑定，只有绑定的角色可以查看此相册');
        return;
    }
    
    // 获取选中的联系人信息
    const boundContacts = [];
    const currentState = state || window.state;
    selectedAlbumContacts.forEach(contactId => {
        const contact = currentState?.chats?.[contactId];
        if (contact) {
            boundContacts.push({
                id: contactId,
                name: contact.name,
                avatar: contact.settings?.aiAvatar
            });
        }
    });
    
    const newAlbum = {
        id: Date.now(),
        name: name,
        description: description,
        photos: [],
        coverImage: null,
        backgroundImage: null, // 导航栏背景图
        boundContacts: boundContacts, // 绑定的角色列表
        createdAt: new Date().toISOString()
    };
    
    try {
        // 将相册保存到数据库
        const savedAlbum = await db.loveAlbums.add(newAlbum);
        newAlbum.id = savedAlbum; // 更新为数据库分配的ID
        albums.push(newAlbum);
        
        console.log('创建相册成功，绑定角色:', boundContacts.map(c => c.name));
        
        hideCreateAlbumDialog();
        renderAlbumList();
    } catch (error) {
        console.error('保存相册到数据库失败:', error);
        alert('创建相册失败，请重试');
    }
}

// 渲染相册列表
function renderAlbumList() {
    const galleryList = document.getElementById('gallery-list');
    const placeholder = galleryList.querySelector('.gallery-placeholder');
    
    if (albums.length === 0) {
        placeholder.style.display = 'block';
        // 清除相册卡片
        galleryList.querySelectorAll('.album-card').forEach(card => card.remove());
        return;
    }
    
    placeholder.style.display = 'none';
    
    // 清除现有的相册卡片
    galleryList.querySelectorAll('.album-card').forEach(card => card.remove());
    
    // 渲染所有相册
    albums.forEach(album => {
        const albumCard = createAlbumCard(album);
        galleryList.appendChild(albumCard);
    });
}

// 创建相册卡片
function createAlbumCard(album) {
    const card = document.createElement('div');
    card.className = 'album-card';
    card.onclick = () => openAlbumDetail(album.id);
    
    // 处理封面图片：优先使用设置的封面，其次使用第一张照片，背景图仅在导航栏显示
    let coverImage = album.coverImage; // 优先使用设置的封面
    console.log(`相册 ${album.name} 的封面图:`, album.coverImage);
    if (!coverImage && album.photos.length > 0) {
        const firstPhoto = album.photos[0];
        coverImage = typeof firstPhoto === 'string' ? firstPhoto : firstPhoto.src;
    }
    console.log(`相册 ${album.name} 最终使用的封面:`, coverImage);
    
    // 创建绑定角色显示
    card.innerHTML = `
        <div class="album-cover">
            ${coverImage ? 
                `<img src="${coverImage}" alt="相册封面" style="object-fit: cover; object-position: center;">` : 
                `<div class="default-cover">🌺</div>`
            }
        </div>
        <div class="album-info">
            <div class="album-name">${album.name}</div>
            <div class="album-description">${album.description || '暂无描述'}</div>
        </div>
    `;
    
    return card;
}

// 打开相册详情
function openAlbumDetail(albumId) {
    currentAlbumId = albumId;
    const album = albums.find(a => a.id === albumId);
    
    if (!album) return;
    
    // 更新封面显示
    const coverContainer = document.getElementById('cover-image-container');
    const coverImage = document.getElementById('cover-image');
    const coverHint = document.getElementById('cover-upload-hint');
    
    if (album.coverImage) {
        // 显示已有封面
        coverImage.src = album.coverImage;
        coverContainer.style.display = 'block';
        coverHint.style.display = 'none';
    } else {
        // 没有封面时显示提示
        coverContainer.style.display = 'none';
        coverHint.style.display = 'block';
        coverHint.textContent = `轻触上传「${album.name}」的封面`;
    }
    
    // 隐藏整个恋爱空间容器
    document.getElementById('love-space-view').style.display = 'none';
    // 显示相册详情页面
    document.getElementById('album-detail-view').style.display = 'flex';
    
    // 隐藏底部导航栏（使用类名，兼容性更好）
    document.body.classList.add('album-detail-active');
    
    // 加载保存的背景
    loadSavedBackground();
    
    renderAlbumPhotos();
}

// 返回相册列表
function backToGallery() {
    // 隐藏相册详情页面
    document.getElementById('album-detail-view').style.display = 'none';
    // 显示整个恋爱空间容器
    document.getElementById('love-space-view').style.display = 'flex';
    // 确保相册页面是显示状态
    document.getElementById('love-gallery-page').style.display = 'flex';
    
    // 隐藏所有子相册相关的弹窗和设置
    document.getElementById('album-settings-menu').style.display = 'none';
    document.getElementById('delete-album-confirm').style.display = 'none';
    document.getElementById('contact-binding-dialog').style.display = 'none';
    document.getElementById('love-settings-modal').style.display = 'none';
    
    // 重新显示底部导航栏（移除类名）
    document.body.classList.remove('album-detail-active');
    
    // 确保仍在恋爱空间时继续隐藏QQ主页导航栏
    document.body.classList.remove('on-chat-list-screen');
    
    // 重置封面显示
    const coverContainer = document.getElementById('cover-image-container');
    const coverHint = document.getElementById('cover-upload-hint');
    
    coverContainer.style.display = 'none';
    coverHint.style.display = 'block';
    coverHint.textContent = '轻触上传封面图片';
    
    currentAlbumId = null;
}

// 渲染相册照片
function renderAlbumPhotos() {
    if (!currentAlbumId) return;
    
    const album = albums.find(a => a.id === currentAlbumId);
    if (!album) return;
    
    const photosGrid = document.getElementById('album-photos-grid');
    const placeholder = document.getElementById('album-photos-placeholder');
    
    if (album.photos.length === 0) {
        placeholder.style.display = 'block';
        // 清除照片项
        photosGrid.querySelectorAll('.album-photo-item').forEach(item => item.remove());
        return;
    }
    
    placeholder.style.display = 'none';
    
    // 清除现有照片
    photosGrid.querySelectorAll('.album-photo-item').forEach(item => item.remove());
    
    // 渲染所有照片
    album.photos.forEach((photo, index) => {
        // 兼容旧数据格式（字符串）和新数据格式（对象）
        const photoSrc = typeof photo === 'string' ? photo : photo.src;
        const photoName = typeof photo === 'object' ? photo.name : '';
        const photoDesc = typeof photo === 'object' ? photo.description : '';
        
        const photoItem = document.createElement('div');
        photoItem.className = 'album-photo-item';
        
        // 创建照片卡片HTML
        const hasName = photoName && photoName.trim();
        const hasDescription = photoDesc && photoDesc.trim();
        const displayText = hasName ? photoName : '点击查看详情';
        const backContent = hasDescription ? photoDesc : (hasName ? photoName : '这张照片还没有描述');
        
        photoItem.innerHTML = `
            <div class="photo-card" data-index="${index}">
                <div class="photo-front">
                    <img src="${photoSrc}" alt="相册照片">
                    <div class="photo-title" data-flip-trigger="true">
                        <div class="title-text-container">
                            <span class="title-text">${displayText}</span>
                        </div>
                        <span class="flip-icon">⟲</span>
                    </div>
                </div>
                <div class="photo-back">
                    <div class="photo-back-header">
                        <button class="photo-back-delete-btn" onclick="event.stopPropagation(); deletePhoto(${index}).catch(console.error)" title="删除照片">🗑️</button>
                        <button class="photo-edit-btn" onclick="event.stopPropagation(); editPhoto(${index})" title="编辑照片信息">⚙️</button>
                        <div class="photo-timestamp">${formatTimestamp(album.photos[index].timestamp || album.photos[index].createdAt)}</div>
                </div>
                    <div class="photo-back-content" data-photo-index="${index}">
                        ${backContent}
            </div>
                    <div class="photo-back-name" data-photo-index="${index}">
                        ${album.photos[index].name || '未命名照片'}
                    </div>
                </div>
            </div>
        `;
        
        // 添加点击底部翻转功能
        let isFlipped = false;
        let autoFlipTimer;
        let isOperationInProgress = false;
        
        const photoCard = photoItem.querySelector('.photo-card');
        const photoTitle = photoItem.querySelector('.photo-title');
        const photoImg = photoItem.querySelector('img');
        
        // 设置操作状态的函数
        function setOperationInProgress(inProgress) {
            isOperationInProgress = inProgress;
            if (!inProgress && isFlipped) {
                // 如果操作结束且照片仍在翻转状态，启动自动翻回计时器
                autoFlipTimer = setTimeout(() => {
                    if (!isOperationInProgress) {
                        photoCard.classList.remove('flipped');
                        isFlipped = false;
                    }
                }, 2000);
            }
        }
        
        // 将设置操作状态的函数添加到照片卡片元素上，以便其他功能调用
        photoCard.setOperationInProgress = setOperationInProgress;
        
        function flipToBack() {
            if (!isFlipped) {
                console.log('主页照片点击底部翻转触发');
                photoCard.classList.add('flipped');
                isFlipped = true;
                // 只有在没有操作进行时才启动自动翻回
                if (!isOperationInProgress) {
                autoFlipTimer = setTimeout(() => {
                        if (!isOperationInProgress) {
                    photoCard.classList.remove('flipped');
                    isFlipped = false;
                        }
                }, 5000);
                }
            }
        }
        
        function flipBack() {
            if (isFlipped && !isOperationInProgress) {
                clearTimeout(autoFlipTimer);
                photoCard.classList.remove('flipped');
                isFlipped = false;
            }
        }
        
        // 点击底部区域翻转
        if (photoTitle) {
            photoTitle.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                flipToBack();
            });
        }
        
        // 点击图片查看大图
        if (photoImg) {
            photoImg.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!isFlipped) {
                    showImageViewer(photoSrc);
                }
            });
        }
        
        // 点击背面翻回正面（但不包括按钮区域）
        const photoBack = photoItem.querySelector('.photo-back');
        if (photoBack) {
            photoBack.addEventListener('click', (e) => {
                // 如果点击的是按钮或其子元素，不执行翻转
                if (e.target.closest('.photo-edit-btn') || e.target.closest('.photo-back-delete-btn')) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                flipBack();
            });
        }
        
        photosGrid.appendChild(photoItem);
    });
}

// 显示原图查看器
function showImageViewer(imageSrc) {
    const overlay = document.getElementById('image-viewer-overlay');
    const image = document.getElementById('image-viewer-content');
    
    image.src = imageSrc;
    overlay.classList.add('show');
    
    // 阻止页面滚动
    document.body.style.overflow = 'hidden';
    
    // 添加键盘支持（ESC键关闭）
    document.addEventListener('keydown', handleImageViewerKeydown);
}

// 关闭原图查看器
function closeImageViewer() {
    const overlay = document.getElementById('image-viewer-overlay');
    overlay.classList.remove('show');
    
    // 恢复页面滚动
    document.body.style.overflow = '';
    
    // 移除键盘监听
    document.removeEventListener('keydown', handleImageViewerKeydown);
}

// 处理键盘事件
function handleImageViewerKeydown(e) {
    if (e.key === 'Escape') {
        closeImageViewer();
    }
}

// 显示添加照片弹窗
function showAddPhotoDialog() {
    document.getElementById('add-photo-dialog').style.display = 'flex';
    document.getElementById('photo-url-input').value = '';
    document.getElementById('photo-name-input').value = '';
    document.getElementById('photo-description-input').value = '';
    document.getElementById('photo-preview').style.display = 'none';
}

// 隐藏添加照片弹窗
function hideAddPhotoDialog() {
    document.getElementById('add-photo-dialog').style.display = 'none';
    // 清空输入框
    document.getElementById('photo-name-input').value = '';
    document.getElementById('photo-description-input').value = '';
    document.getElementById('photo-url-input').value = '';
    // 隐藏预览
    document.getElementById('photo-preview').style.display = 'none';
}

// 折叠/展开头部框架
function toggleHeaderCollapse() {
    const uploadFrame = document.querySelector('.upload-nav-frame');
    const collapseBtn = document.querySelector('.nav-collapse-btn');
    
    if (uploadFrame.classList.contains('collapsed')) {
        uploadFrame.classList.remove('collapsed');
        collapseBtn.textContent = '-';
        collapseBtn.title = '折叠';
    } else {
        uploadFrame.classList.add('collapsed');
        collapseBtn.textContent = '+';
        collapseBtn.title = '展开';
    }
}

// 显示背景设置弹窗
function showBackgroundSettingsDialog() {
    document.getElementById('background-settings-dialog').style.display = 'flex';
    document.getElementById('background-preview').style.display = 'none';
    
    // 如果当前相册有背景图，在上传区域显示
    const uploadArea = document.querySelector('.background-upload-area');
    if (currentAlbumId) {
        const album = albums.find(a => a.id === currentAlbumId);
        if (album && album.backgroundImage) {
            uploadArea.style.backgroundImage = `url(${album.backgroundImage})`;
            uploadArea.classList.add('has-image');
            uploadArea.innerHTML = '<div class="background-upload-text">点击更换背景图片</div>';
        } else {
            uploadArea.style.backgroundImage = '';
            uploadArea.classList.remove('has-image');
            uploadArea.innerHTML = '<div class="background-upload-icon">🌺</div><div class="background-upload-text">点击上传背景图片</div><div class="background-upload-hint">支持 JPG、PNG 格式</div>';
        }
    }
}

// 关闭背景设置弹窗
function closeBackgroundSettingsDialog() {
    document.getElementById('background-settings-dialog').style.display = 'none';
    
    // 重置上传区域
    const uploadArea = document.querySelector('.background-upload-area');
    const previewArea = document.getElementById('background-preview');
    
    // 如果没有预览图片，检查当前相册是否有背景图
    if (previewArea.style.display === 'none' || !previewArea.style.display) {
        if (currentAlbumId) {
            const album = albums.find(a => a.id === currentAlbumId);
            if (album && album.backgroundImage) {
                // 显示当前相册的背景图
                uploadArea.style.backgroundImage = `url(${album.backgroundImage})`;
                uploadArea.classList.add('has-image');
                uploadArea.innerHTML = '<div class="background-upload-text">点击更换背景图片</div>';
            } else {
                // 没有背景图，显示默认状态
                uploadArea.style.backgroundImage = '';
                uploadArea.classList.remove('has-image');
                uploadArea.innerHTML = '<div class="background-upload-icon">🌺</div><div class="background-upload-text">点击上传背景图片</div><div class="background-upload-hint">支持 JPG、PNG 格式</div>';
            }
        } else {
            // 没有当前相册，显示默认状态
            uploadArea.style.backgroundImage = '';
            uploadArea.classList.remove('has-image');
            uploadArea.innerHTML = '<div class="background-upload-icon">🌺</div><div class="background-upload-text">点击上传背景图片</div><div class="background-upload-hint">支持 JPG、PNG 格式</div>';
        }
    }
    
    // 重置文件输入
    document.getElementById('background-upload-input').value = '';
}

// 触发背景图片上传
function triggerBackgroundUpload() {
    document.getElementById('background-upload-input').click();
}

// 处理背景图片上传
function handleBackgroundUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // 验证文件类型
    if (!file.type.startsWith('image/')) {
        alert('请选择图片文件！');
        return;
    }
    
    // 验证文件大小 (限制为5MB)
    if (file.size > 5 * 1024 * 1024) {
        alert('图片文件不能超过5MB！');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const uploadArea = document.querySelector('.background-upload-area');
        const previewImg = document.getElementById('background-preview-img');
        
        // 在上传区域显示图片
        uploadArea.style.backgroundImage = `url(${e.target.result})`;
        uploadArea.classList.add('has-image');
        uploadArea.innerHTML = '<div class="background-upload-text">点击更换背景图片</div>';
        
        // 同时保持原有的预览区域
        previewImg.src = e.target.result;
        document.getElementById('background-preview').style.display = 'block';
    };
    reader.readAsDataURL(file);
}

// 应用背景
async function applyBackground() {
    const previewImg = document.getElementById('background-preview-img');
    const backgroundImageData = previewImg.src;
    
    if (backgroundImageData && currentAlbumId) {
        // 应用到相册详情页面
        const albumDetailView = document.getElementById('album-detail-view');
        albumDetailView.style.backgroundImage = `url(${backgroundImageData})`;
        albumDetailView.style.backgroundSize = 'cover';
        albumDetailView.style.backgroundPosition = 'center';
        albumDetailView.style.backgroundRepeat = 'no-repeat';
        
        // 保存到当前相册
        const album = albums.find(a => a.id === currentAlbumId);
        if (album) {
            album.backgroundImage = backgroundImageData;
            try {
                await saveAlbumToDB(album);
                console.log('背景图已保存到相册:', album.name, '背景图:', backgroundImageData);
            } catch (error) {
                console.error('保存背景图失败:', error);
                alert('保存背景图失败，请重试');
                return;
            }
            
            // 更新相册列表显示
            renderAlbumList();
            console.log('相册列表已更新');
        }
        
        // 关闭弹窗
        closeBackgroundSettingsDialog();
        
        // 显示成功提示
        showToast('背景设置成功！');
    }
}

// 重置背景
async function resetBackground() {
    const albumDetailView = document.getElementById('album-detail-view');
    const uploadArea = document.querySelector('.background-upload-area');
    
    albumDetailView.style.backgroundImage = '';
    albumDetailView.style.backgroundSize = '';
    albumDetailView.style.backgroundPosition = '';
    albumDetailView.style.backgroundRepeat = '';
    
    // 恢复上传区域原状
    uploadArea.style.backgroundImage = '';
    uploadArea.classList.remove('has-image');
    uploadArea.innerHTML = '<div class="background-upload-icon">🌺</div><div class="background-upload-text">点击上传背景图片</div><div class="background-upload-hint">支持 JPG、PNG 格式</div>';
    
    // 隐藏预览区域
    document.getElementById('background-preview').style.display = 'none';
    
    // 从当前相册中删除背景图
    if (currentAlbumId) {
        const album = albums.find(a => a.id === currentAlbumId);
        if (album) {
            album.backgroundImage = null;
            try {
                await saveAlbumToDB(album);
                
                // 更新相册列表显示
                renderAlbumList();
            } catch (error) {
                console.error('保存相册失败:', error);
                alert('重置背景失败，请重试');
            }
        }
    }
    
    // 关闭弹窗
    closeBackgroundSettingsDialog();
    
    // 显示成功提示
    showToast('背景已重置！');
}

// 加载保存的背景
function loadSavedBackground() {
    if (currentAlbumId) {
        const album = albums.find(a => a.id === currentAlbumId);
        if (album && album.backgroundImage) {
            const albumDetailView = document.getElementById('album-detail-view');
            albumDetailView.style.backgroundImage = `url(${album.backgroundImage})`;
            albumDetailView.style.backgroundSize = 'cover';
            albumDetailView.style.backgroundPosition = 'center';
            albumDetailView.style.backgroundRepeat = 'no-repeat';
        } else {
            // 如果没有背景图，清除样式
            const albumDetailView = document.getElementById('album-detail-view');
            albumDetailView.style.backgroundImage = '';
            albumDetailView.style.backgroundSize = '';
            albumDetailView.style.backgroundPosition = '';
            albumDetailView.style.backgroundRepeat = '';
        }
    }
}

// 显示提示消息
function showToast(message) {
    // 创建提示元素
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 24px;
        border-radius: 20px;
        font-size: 14px;
        z-index: 9999;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        transition: opacity 0.3s ease;
    `;
    toast.textContent = message;
    
    document.body.appendChild(toast);
    
    // 3秒后自动消失
    setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => {
            document.body.removeChild(toast);
        }, 300);
    }, 3000);
}

// ▼▼▼ 子相册设置菜单相关函数 ▼▼▼

// 显示相册设置菜单
function showAlbumSettingsMenu() {
    document.getElementById('album-settings-menu').style.display = 'flex';
}

// 隐藏相册设置菜单
function hideAlbumSettingsMenu() {
    document.getElementById('album-settings-menu').style.display = 'none';
}

// 显示背景设置（从菜单调用）
function showAlbumBackgroundSettings() {
    hideAlbumSettingsMenu();
    showBackgroundSettingsDialog();
}

// 显示删除相册确认弹窗
function showDeleteAlbumConfirm() {
    hideAlbumSettingsMenu();
    document.getElementById('delete-album-confirm').style.display = 'flex';
}

// 隐藏删除相册确认弹窗
function hideDeleteAlbumConfirm() {
    document.getElementById('delete-album-confirm').style.display = 'none';
}

// 确认删除相册
async function confirmDeleteAlbum() {
    if (!currentAlbumId) {
        showToast('未找到要删除的相册');
        return;
    }
    
    try {
        // 从数据库中删除相册
        await db.loveAlbums.delete(currentAlbumId);
        
        // 从数组中删除相册
        const albumIndex = albums.findIndex(a => a.id === currentAlbumId);
        if (albumIndex !== -1) {
            albums.splice(albumIndex, 1);
        }
        
        // 关闭弹窗
        hideDeleteAlbumConfirm();
        
        // 返回相册列表
        backToGallery();
        
        // 刷新相册列表显示
        renderAlbumList();
        
        showToast('相册已删除');
    } catch (error) {
        console.error('删除相册失败:', error);
        showToast('删除相册失败，请重试');
    }
}

// 显示联系人绑定设置
async function showContactBindingSettings() {
    hideAlbumSettingsMenu();
    document.getElementById('contact-binding-dialog').style.display = 'flex';
    await loadContactBindingData();
}

// 隐藏联系人绑定设置弹窗
function hideContactBindingDialog() {
    document.getElementById('contact-binding-dialog').style.display = 'none';
}

// 加载联系人绑定数据
async function loadContactBindingData() {
    if (!currentAlbumId) return;
    
    const album = albums.find(a => a.id === currentAlbumId);
    if (!album) return;
    
    // 获取聊天联系人数据（只包括非群组聊天）
    let chatContacts = [];
    try {
        chatContacts = Object.values(state.chats).filter(chat => !chat.isGroup);
    } catch (error) {
        console.error('获取聊天联系人失败:', error);
        chatContacts = [];
    }
    
    const currentBindingList = document.getElementById('current-binding-list');
    const availableContactsList = document.getElementById('available-contacts-list');
    
    // 显示当前绑定的联系人
    if (album.boundContacts && album.boundContacts.length > 0) {
        currentBindingList.innerHTML = album.boundContacts.map(boundContact => {
            // 处理旧版本数据格式兼容性
            let contactId, contactName, contactAvatar;
            if (typeof boundContact === 'string') {
                // 旧版本：boundContact 是 contactId
                contactId = boundContact;
                const contact = chatContacts.find(c => c.id === contactId);
                if (!contact) return '';
                contactName = contact.name;
                contactAvatar = contact.settings?.aiAvatar || contact.avatar || 'default-avatar.png';
            } else {
                // 新版本：boundContact 是对象
                contactId = boundContact.id;
                contactName = boundContact.name;
                // 获取最新的头像
                const contact = chatContacts.find(c => c.id === contactId);
                contactAvatar = contact?.settings?.aiAvatar || boundContact.avatar || 'default-avatar.png';
            }
            
            return `
                <div class="binding-contact-item">
                    <div class="binding-contact-info">
                        <img src="${contactAvatar}" alt="${contactName}" class="binding-contact-avatar">
                        <span class="binding-contact-name">${contactName}</span>
                    </div>
                    <button class="binding-contact-action unbind-btn" onclick="unbindContact('${contactId}')">解除绑定</button>
                </div>
            `;
        }).filter(html => html).join('');
    } else {
        currentBindingList.innerHTML = '<div class="no-contacts-message">暂无绑定的联系人</div>';
    }
    
    // 显示可添加的联系人（排除已绑定的）
    const boundContactIds = (album.boundContacts || []).map(boundContact => {
        return typeof boundContact === 'string' ? boundContact : boundContact.id;
    });
    const availableContacts = chatContacts.filter(chat => !boundContactIds.includes(chat.id));
    
    if (availableContacts.length > 0) {
        availableContactsList.innerHTML = availableContacts.map(contact => `
            <div class="binding-contact-item">
                <div class="binding-contact-info">
                    <img src="${contact.settings?.aiAvatar || 'default-avatar.png'}" alt="${contact.name}" class="binding-contact-avatar">
                    <span class="binding-contact-name">${contact.name}</span>
                </div>
                <button class="binding-contact-action bind-btn" onclick="bindContact('${contact.id}')">添加绑定</button>
            </div>
        `).join('');
    } else {
        availableContactsList.innerHTML = '<div class="no-contacts-message">没有可添加的联系人</div>';
    }
}

// 解除联系人绑定
async function unbindContact(contactId) {
    if (!currentAlbumId) return;
    
    try {
        const album = albums.find(a => a.id === currentAlbumId);
        if (!album) return;
        
        // 从绑定列表中移除联系人
        if (album.boundContacts) {
            album.boundContacts = album.boundContacts.filter(boundContact => {
                const id = typeof boundContact === 'string' ? boundContact : boundContact.id;
                return id !== contactId;
            });
        }
        
        // 保存到数据库
        await saveAlbumToDB(album);
        
        // 刷新显示
        await loadContactBindingData();
        
        showToast('已解除绑定');
    } catch (error) {
        console.error('解除绑定失败:', error);
        showToast('解除绑定失败，请重试');
    }
}

// 绑定联系人
async function bindContact(contactId) {
    if (!currentAlbumId) return;
    
    try {
        const album = albums.find(a => a.id === currentAlbumId);
        if (!album) return;
        
        // 初始化绑定列表
        if (!album.boundContacts) {
            album.boundContacts = [];
        }
        
        // 检查是否已经绑定
        const isAlreadyBound = album.boundContacts.some(boundContact => {
            const id = typeof boundContact === 'string' ? boundContact : boundContact.id;
            return id === contactId;
        });
        
        // 添加到绑定列表（以对象格式存储）
        if (!isAlreadyBound) {
            const contact = state.chats[contactId];
            if (contact) {
                album.boundContacts.push({
                    id: contactId,
                    name: contact.name,
                    avatar: contact.settings?.aiAvatar || 'default-avatar.png'
                });
            }
        }
        
        // 保存到数据库
        await saveAlbumToDB(album);
        
        // 刷新显示
        await loadContactBindingData();
        
        showToast('绑定成功');
    } catch (error) {
        console.error('绑定失败:', error);
        showToast('绑定失败，请重试');
}
}

// ▲▲▲ 子相册设置菜单相关函数结束 ▲▲▲

// 切换上传方式
// 本地上传相关函数已删除，只保留URL上传功能

// 预览网络图片
function previewPhotoUrl() {
    const url = document.getElementById('photo-url-input').value.trim();
    if (!url) {
        alert('请输入图片链接');
        return;
    }
    
    showPhotoPreview(url);
}

// 显示图片预览
function showPhotoPreview(imageSrc) {
    const preview = document.getElementById('photo-preview');
    const previewImage = document.getElementById('preview-image');
    
    // 显示预览图片
    previewImage.src = imageSrc;
    preview.style.display = 'block';
}

// 压缩图片以节省存储空间
function compressImage(base64Str, quality = 0.7, maxWidth = 800) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = function() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 计算压缩后的尺寸
            let { width, height } = img;
            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // 绘制并压缩
            ctx.drawImage(img, 0, 0, width, height);
            const compressedBase64 = canvas.toDataURL('image/jpeg', quality);
            resolve(compressedBase64);
        };
        img.src = base64Str;
    });
}

// 添加照片到相册
async function addPhotoToAlbum() {
    if (!currentAlbumId) return;
    
    const previewImage = document.getElementById('preview-image');
    if (!previewImage.src) {
        alert('请先选择或预览图片');
        return;
    }
    
    const album = albums.find(a => a.id === currentAlbumId);
    if (!album) return;
    
    // 检查图片大小，如果是base64格式且过大，则压缩
    let imageSrc = previewImage.src;
    if (imageSrc.startsWith('data:image/')) {
        // 检查base64大小（大致估算）
        const base64Size = imageSrc.length * 0.75; // base64大致比原始数据大33%
        if (base64Size > 500000) { // 如果大于500KB
            try {
                console.log('图片过大，正在压缩...');
                imageSrc = await compressImage(imageSrc);
                console.log('图片压缩完成');
            } catch (e) {
                console.warn('图片压缩失败，使用原图:', e);
            }
        }
    }
    
    // 获取照片名称和备注
    const name = document.getElementById('photo-name-input').value.trim();
    const description = document.getElementById('photo-description-input').value.trim();
    
    // 创建照片对象
    const photoObject = {
        id: `photo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, // 生成唯一ID
        src: imageSrc,
        name: name,
        description: description,
        timestamp: Date.now()
    };
    
    album.photos.unshift(photoObject); // 新照片添加到数组开头，实现前排显示
    
    // 如果是第一张照片，设为封面
    if (!album.coverImage) {
        album.coverImage = imageSrc;
    }
    
    // 保存到数据库
    try {
        await saveAlbumToDB(album);
    } catch (e) {
        console.error('保存相册失败:', e);
        
        // 撤销当前添加操作
        album.photos.pop();
        if (album.photos.length === 0) {
            album.coverImage = null;
        }
        
        alert('保存失败，请重试');
        return;
    }
    
    hideAddPhotoDialog();
    renderAlbumPhotos();
    renderAlbumList(); // 更新主页面的相册列表
}

// ==================== 封面上传相关函数 ====================

// 显示封面上传弹窗
function showCoverUploadDialog() {
    document.getElementById('cover-upload-dialog').style.display = 'flex';
    document.getElementById('cover-url-input').value = '';
    document.getElementById('cover-preview').style.display = 'none';
}

// 隐藏封面上传弹窗
function hideCoverUploadDialog() {
    document.getElementById('cover-upload-dialog').style.display = 'none';
    // 清空输入框
    document.getElementById('cover-url-input').value = '';
    // 隐藏预览
    document.getElementById('cover-preview').style.display = 'none';
}

// 封面本地上传相关函数已删除，只保留URL上传功能

// 预览封面网络图片
function previewCoverUrl() {
    const url = document.getElementById('cover-url-input').value.trim();
    if (!url) {
        alert('请输入图片链接');
        return;
    }
    
    showCoverPreview(url);
}

// 显示封面预览
function showCoverPreview(src) {
    const preview = document.getElementById('cover-preview');
    const previewImage = document.getElementById('cover-preview-image');
    
    previewImage.onload = function() {
        preview.style.display = 'block';
    };
    
    previewImage.onerror = function() {
        alert('图片加载失败，请检查链接是否正确');
        preview.style.display = 'none';
        // 如果加载失败，恢复上传区域原状
        uploadArea.style.backgroundImage = '';
        uploadArea.classList.remove('has-image');
        uploadArea.innerHTML = '<div class="upload-icon">🖼️</div><p>点击选择封面图片</p><small>支持JPG、PNG、GIF格式</small>';
    };
    
    previewImage.src = src;
}

// 设置封面图片
async function setCoverImage() {
    const previewImage = document.getElementById('cover-preview-image');
    
    if (!previewImage.src) {
        alert('请先选择或预览图片');
        return;
    }
    
    if (!currentAlbumId) {
        alert('请先选择相册');
        return;
    }
    
    // 更新相册的封面图片
    const album = albums.find(a => a.id === currentAlbumId);
    if (album) {
        album.coverImage = previewImage.src;
        console.log('封面已设置:', album.name, '封面:', previewImage.src);
        
        // 显示封面图片
        const coverContainer = document.getElementById('cover-image-container');
        const coverImage = document.getElementById('cover-image');
        const coverHint = document.getElementById('cover-upload-hint');
        
        coverImage.src = previewImage.src;
        coverContainer.style.display = 'block';
        coverHint.style.display = 'none';
        
        // 保存到数据库
        try {
            await saveAlbumToDB(album);
            console.log('相册数据已保存到数据库');
            
            // 更新主页面的相册列表显示
            renderAlbumList();
            console.log('相册列表已更新');
        } catch (error) {
            console.error('保存封面失败:', error);
            alert('保存封面失败，请重试');
            return;
        }
        
        // 关闭弹窗
        hideCoverUploadDialog();
        
        // 提示成功
        // showMessage('封面设置成功！', 'success');
    }
}

// 查看照片
function viewPhoto(photoSrc, index) {
    // 这里可以添加照片查看功能，比如全屏显示
    console.log('查看照片:', photoSrc, '索引:', index);
}

// 删除照片
async function deletePhoto(index) {
    if (!currentAlbumId) return;
    
    // 获取照片卡片元素
    const photoCard = document.querySelector(`.photo-card[data-index="${index}"]`);
    if (photoCard && photoCard.setOperationInProgress) {
        photoCard.setOperationInProgress(true);
    }
    
    // 使用确认对话框
    const confirmed = confirm('确定要删除这张照片吗？此操作无法撤销。');
    
    if (!confirmed) {
        // 用户取消，清除操作状态
        if (photoCard && photoCard.setOperationInProgress) {
            photoCard.setOperationInProgress(false);
        }
        return;
    }
    
    const album = albums.find(a => a.id === currentAlbumId);
    if (!album) {
        if (photoCard && photoCard.setOperationInProgress) {
            photoCard.setOperationInProgress(false);
        }
        return;
    }
    
    try {
    // 获取要删除的照片信息
    const photoToDelete = album.photos[index];
    const deletedPhotoSrc = typeof photoToDelete === 'string' ? photoToDelete : photoToDelete.src;
        
        // 添加删除动画
        const photoItem = photoCard.closest('.album-photo-item');
        if (photoItem) {
            photoItem.style.transition = 'all 0.3s ease-out';
            photoItem.style.transform = 'scale(0)';
            photoItem.style.opacity = '0';
            
            // 等待动画完成
            await new Promise(resolve => setTimeout(resolve, 300));
        }
    
    // 删除照片
    album.photos.splice(index, 1);
    
    // 如果删除的是封面图片，重新设置封面
    if (album.photos.length > 0 && album.coverImage === deletedPhotoSrc) {
        const firstPhoto = album.photos[0];
        album.coverImage = typeof firstPhoto === 'string' ? firstPhoto : firstPhoto.src;
    } else if (album.photos.length === 0) {
        album.coverImage = null;
    }
    
    // 保存更改
        await saveAlbumToDB(album);
        renderAlbumPhotos(); // 重新渲染会自动实现丝滑补位
        renderAlbumList(); // 更新主页面的相册列表
        
    } catch (e) {
        console.error('删除照片失败:', e);
        alert('删除照片失败，请重试');
        
        // 失败时清除操作状态
        if (photoCard && photoCard.setOperationInProgress) {
            photoCard.setOperationInProgress(false);
        }
    }
}

// 删除数据库照片
async function deleteDbPhoto(photoId) {
    if (!state.activeAlbumId) return;
    
    // 获取照片卡片元素
    const photoCard = document.querySelector(`.photo-card[data-photo-id="${photoId}"]`);
    if (photoCard && photoCard.setOperationInProgress) {
        photoCard.setOperationInProgress(true);
    }
    
    // 使用确认对话框
    const confirmed = confirm('确定要删除这张照片吗？此操作无法撤销。');
    
    if (!confirmed) {
        // 用户取消，清除操作状态
        if (photoCard && photoCard.setOperationInProgress) {
            photoCard.setOperationInProgress(false);
        }
        return;
    }
    
    try {
        // 添加删除动画
        const photoItem = photoCard.closest('.album-photo-item');
        if (photoItem) {
            photoItem.style.transition = 'all 0.3s ease-out';
            photoItem.style.transform = 'scale(0)';
            photoItem.style.opacity = '0';
            
            // 等待动画完成
            await new Promise(resolve => setTimeout(resolve, 300));
        }
        
        // 从数据库删除照片
        await db.qzonePhotos.delete(photoId);
        
        // 重新渲染照片列表
        await renderAlbumPhotosScreen();
        
    } catch (e) {
        console.error('删除照片失败:', e);
        alert('删除照片失败，请重试');
        
        // 失败时清除操作状态
        if (photoCard && photoCard.setOperationInProgress) {
            photoCard.setOperationInProgress(false);
        }
    }
}

// 格式化时间戳
function formatTimestamp(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    
    if (days === 0) {
        return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    } else if (days === 1) {
        return '昨天';
    } else if (days < 7) {
        return `${days}天前`;
    } else {
        return date.toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' });
    }
}

// 编辑照片信息
async function editPhoto(photoId) {
    let album, photoIndex, photo;
    
    // 判断是数据库照片还是本地照片
    if (typeof photoId === 'string' || (typeof photoId === 'number' && photoId > 1000)) {
        // 数据库照片
        if (!state.activeAlbumId) return;
        album = await db.qzoneAlbums.get(state.activeAlbumId);
        if (!album) return;
        
        const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
        photo = photos.find(p => p.id === photoId);
        if (!photo) return;
    } else {
        // 本地照片
        if (!currentAlbumId) return;
        album = albums.find(a => a.id === currentAlbumId);
        if (!album) return;
        
        photoIndex = photoId;
        photo = album.photos[photoIndex];
        if (!photo) return;
    }
    
    // 获取DOM元素
    const contentElement = document.querySelector(`.photo-back-content[data-photo-id="${photoId}"], .photo-back-content[data-photo-index="${photoId}"]`);
    const nameElement = document.querySelector(`.photo-back-name[data-photo-id="${photoId}"], .photo-back-name[data-photo-index="${photoId}"]`);
    
    if (!contentElement || !nameElement) return;
    
    // 设置操作状态为进行中
    const photoCard = contentElement.closest('.photo-card');
    if (photoCard && photoCard.setOperationInProgress) {
        photoCard.setOperationInProgress(true);
    }
    
    // 创建编辑界面
    const originalDescription = photo.description || '';
    const originalName = photo.name || '';
    
    // 编辑备注
    const descriptionTextarea = document.createElement('textarea');
    descriptionTextarea.value = originalDescription;
    descriptionTextarea.className = 'photo-back-content editing';
    descriptionTextarea.style.minHeight = '60px';
    descriptionTextarea.style.width = '100%';
    descriptionTextarea.style.boxSizing = 'border-box';
    
    // 编辑名称
    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.value = originalName;
    nameInput.className = 'photo-back-name editing';
    nameInput.style.width = '100%';
    nameInput.style.boxSizing = 'border-box';
    
    // 保存按钮
    const saveButton = document.createElement('button');
    saveButton.textContent = '保存';
    saveButton.className = 'photo-save-btn';
    
    // 替换原有内容
    const originalContentHTML = contentElement.innerHTML;
    const originalNameHTML = nameElement.innerHTML;
    
    contentElement.innerHTML = '';
    contentElement.appendChild(descriptionTextarea);
    contentElement.appendChild(saveButton);
    
    nameElement.innerHTML = '';
    nameElement.appendChild(nameInput);
    
    // 聚焦到描述框
    descriptionTextarea.focus();
    
    // 保存功能
    saveButton.onclick = async function(e) {
        e.stopPropagation();
        
        const newDescription = descriptionTextarea.value.trim();
        const newName = nameInput.value.trim() || '未命名照片';
        
        try {
            if (typeof photoId === 'string' || (typeof photoId === 'number' && photoId > 1000)) {
                // 更新数据库照片
                await db.qzonePhotos.update(photo.id, {
                    description: newDescription,
                    name: newName
                });
                await renderAlbumPhotosScreen();
            } else {
                // 更新本地照片
                if (typeof photo === 'string') {
                    // 转换为对象格式
                    album.photos[photoIndex] = {
                        id: `photo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, // 生成唯一ID
                        src: photo,
                        description: newDescription,
                        name: newName,
                        timestamp: Date.now()
                    };
                } else {
                    // 更新现有对象
                    photo.description = newDescription;
                    photo.name = newName;
                }
                
                await saveAlbumToDB(album);
                renderAlbumPhotos();
            }
            
            // 显示成功图标
            showSaveSuccess(contentElement.closest('.photo-back'));
            
            // 清除操作状态
            if (photoCard && photoCard.setOperationInProgress) {
                photoCard.setOperationInProgress(false);
            }
            
        } catch (error) {
            console.error('保存失败:', error);
            alert('保存失败，请重试');
            
            // 恢复原内容
            contentElement.innerHTML = originalContentHTML;
            nameElement.innerHTML = originalNameHTML;
            
            // 清除操作状态
            if (photoCard && photoCard.setOperationInProgress) {
                photoCard.setOperationInProgress(false);
            }
        }
    };
    
    // 取消编辑（点击其他地方）
    function cancelEdit() {
        contentElement.innerHTML = originalContentHTML;
        nameElement.innerHTML = originalNameHTML;
        
        // 清除操作状态
        if (photoCard && photoCard.setOperationInProgress) {
            photoCard.setOperationInProgress(false);
        }
    }
    
    // ESC键取消
    function handleKeydown(e) {
        if (e.key === 'Escape') {
            cancelEdit();
            document.removeEventListener('keydown', handleKeydown);
        }
    }
    
    document.addEventListener('keydown', handleKeydown);
}

// 显示保存成功图标
function showSaveSuccess(container) {
    const icon = document.createElement('div');
    icon.className = 'save-success-icon';
    icon.textContent = '✓';
    
    container.style.position = 'relative';
    container.appendChild(icon);
    
    setTimeout(() => {
        if (icon.parentNode) {
            icon.parentNode.removeChild(icon);
        }
    }, 2000);
}

// 初始化相册列表
async function initGallery() {
    await loadAlbumsFromDB();
    renderAlbumList();
}

// 获取localStorage使用情况
function getStorageInfo() {
    const used = JSON.stringify(localStorage).length;
    const quota = 5 * 1024 * 1024; // 假设5MB配额
    return {
        used: used,
        quota: quota,
        percentage: Math.round((used / quota) * 100),
        remaining: quota - used
    };
}

// 清理存储空间 - 压缩所有大图片
async function cleanupStorage() {
    console.log('开始清理存储空间...');
    let cleaned = 0;
    
    for (let album of albums) {
        for (let i = 0; i < album.photos.length; i++) {
            const photo = album.photos[i];
            if (photo.startsWith('data:image/') && photo.length > 500000) {
                try {
                    const compressed = await compressImage(photo, 0.5, 600);
                    if (compressed.length < photo.length) {
                        album.photos[i] = compressed;
                        cleaned++;
                    }
                } catch (e) {
                    console.warn('压缩照片失败:', e);
                }
            }
        }
        
        // 也压缩封面图片
        if (album.coverImage && album.coverImage.startsWith('data:image/') && album.coverImage.length > 500000) {
            try {
                const compressed = await compressImage(album.coverImage, 0.5, 600);
                if (compressed.length < album.coverImage.length) {
                    album.coverImage = compressed;
                }
            } catch (e) {
                console.warn('压缩封面失败:', e);
            }
        }
    }
    
    try {
        // 批量保存所有相册到数据库
        for (const album of albums) {
            await saveAlbumToDB(album);
        }
        console.log(`清理完成，压缩了${cleaned}张照片`);
        return true;
    } catch (e) {
        console.error('清理后仍无法保存:', e);
        return false;
    }
}

        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
        // gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }
    function isImage(text,content) {
        let currentImageData = content.image_url.url
        // 提取Base64数据（去掉前缀）
        const base64Data = currentImageData.split(',')[1];
        // 根据图片类型获取MIME类型
        const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
        return [
            {text: `${text.text}用户向你发送了一张图片`},
            {
                inline_data: {
                    mime_type: mimeType,
                    data: base64Data
                }
            }
        ]
    }

   function extractArray(text) {
        // 正则表达式模式：匹配开头的时间戳部分和后续的JSON数组
        const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
        const match = text.match(pattern);

        if (match) {
            const timestampPart = `(Timestamp: ${match[1]}) `;
            const jsonPart = match[2].trim();

            try {
                // 尝试解析JSON部分
                const parsedJson = JSON.parse(jsonPart);
                // 验证解析结果是否为数组
                if (Array.isArray(parsedJson)) {
                    return [timestampPart, parsedJson[0]];
                }
            } catch (error) {
                // 解析失败，返回原始文本
            }
        }

        // 不匹配格式或解析失败时返回原值
        return text;
    }
    function transformChatData(item) {
        let type = {
            send_and_recall:'撤回了消息',
            update_status:'更新了状态',
            change_music:'切换了歌曲',
            create_memory:'记录了回忆',
            create_countdown:'创建了约定/倒计时',
            text:'发送了文本',
            sticker:'发送了表情',
            ai_image:'发送了图片',
            voice_message:'发送了语音',
            transfer:'发起了转账',
            waimai_request:'发起了外卖请求',
            waimai_response:{
                paid:'回应了外卖-同意',
                rejected:'回应了外卖-拒绝'
            },
            video_call_request:'发起了视频通话',
            video_call_response:{
                accept:'回应了视频通话-接受',
                reject:'回应了视频通话-拒绝'
            },
            qzone_post:{
                shuoshuo:'发布了说说',
                text_image:'发布了文字图'
            },
            qzone_comment:'评论了动态',
            qzone_like:'点赞了动态',
            pat_user:'拍一拍了用户',
            block_user:'拉黑了用户',
            friend_request_response:'回应了好友申请',
            change_avatar:'更换了头像',
            share_link:'分享了链接',
            accept_transfer:'回应了转账-接受',
            decline_transfer:'回应了转账-拒绝/退款',
            quote_reply:'引用了回复',
            text:'',
        }
        let res = extractArray(item.content)

        if(Array.isArray(res)){
            let obj = res[1]
            let itemType = obj.type;
            let time = res[0]
            let text = type[itemType];
            if(text){
                if(itemType === 'sticker'){
                    return [{text:`${time}[${text}] 含义是:${obj.meaning}`}]
                }else if(itemType === 'send_and_recall'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'update_status'){
                    return [{text:`${time}[${text}] ${obj.status_text}(${obj.is_busy ? '忙碌/离开' : '空闲'})`}]
                }else if(itemType === 'change_music'){
                    return [{text:`${time}[${text}] ${obj.change_music}, 歌名是:${obj.song_name}`}]
                }else if(itemType === 'create_memory'){
                    return [{text:`${time}[${text}] ${obj.description}`}]
                }else if(itemType === 'create_countdown'){
                    return [{text:`${time}[${text}] ${obj.title}(${obj.date})`}]
                }else if(itemType === 'ai_image'){
                    return [{text:`${time}[${text}] 图片描述是:${obj.description}`}]
                }else if(itemType === 'voice_message'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'transfer'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 备注是:${obj.amount}`}]
                }else if(itemType === 'waimai_request'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 商品是:${obj.productInfo}`}]
                }else if(itemType === 'waimai_response'){
                    return [{text:`${time}[${text[obj.status]}] ${obj.status === 'paid' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text}]`}]
                }}else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text[obj.decision]}] ${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'qzone_post'){
                    return [{text:`${time}[${text[obj.postType]}] ${obj.postType === 'shuoshuo' ? `${obj.content}` : `图片描述是:${obj.hiddenContent} ${obj.publicText ? `文案是: ${obj.publicText}` : ''}`}`}]
                }else if(itemType === 'qzone_comment'){
                    return [{text:`${time}[${text}] 评论的id是: ${obj.postId} 评论的内容是: ${obj.commentText}`}]
                }else if(itemType === 'qzone_like'){
                    return [{text:`${time}[${text}] 点赞的id是: ${obj.postId}`}]
                }else if(itemType === 'pat_user'){
                    return [{text:`${time}[${text}] ${obj.suffix ? obj.suffix  : ''}`}]
                }else if(itemType === 'block_user'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'friend_request_response'){
                    return [{text:`${time}[${text}] 结果是:${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'change_avatar'){
                    return [{text:`${time}[${text}] 头像名是:${obj.name}`}]
                }else if(itemType === 'share_link'){
                    return [{text:`${time}[${text}] 文章标题是:${obj.title}  文章摘要是:${obj.description} 来源网站名是:${obj.source_name} 文章正文是:${obj.content}`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'quote_reply'){
                    return [{text:`${time}[${text}] 引用的内容是:${obj.reply_content}`}]
                }else if(itemType === 'text'){
                    return [{text:`${time}${obj.content}`}]
                }
            }

if(Array.isArray(res) && res.length > 1) {
	res = `${res[0]}${res[1].content}`
}

        return [{text:res}]
    }
// ... const GEMINI_API_URL = '...' 这行代码之后 ...


    function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision,isGemini) {

	if(!isGemini){
		return undefined
	}

        // 【核心修正】在这里，我们将 'system' 角色也映射为 'user'

        let roleType = {
            user: 'user',
            assistant: 'model',
            system: 'user' // <--- 新增这一行
        }
        return {
            url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
            data: {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: messagesForDecision.map((item) => {
                        let  includesImages = false;
                        if(Array.isArray(item.content) && item.content.length === 2){
                              includesImages =  item.content.some((sub)=>{
                                return sub.type === 'image_url' && sub.image_url.url
                            })
                        }
                        return {
                            role: roleType[item.role], // 现在 'system' 会被正确转换为 'user'
                            parts: includesImages ? isImage(item.content[0],item.content[1]) : transformChatData(item)
                        }
                    }),
                    generationConfig: {
                        temperature: 0.8,
                    },
                    "systemInstruction": {
                        "parts": [{
                            "text": systemInstruction
                        }]
                    }
                })
            }
        }
    }
    // 全局数据库实例
    const db = new Dexie('GeminiChatDB');
    
    // 数据库结构定义
    db.version(34).stores({ 
    chats: '&id, isGroup, groupId, isPinned, characterPhoneData,latestInnerVoice, innerVoiceHistory',
        apiConfig: '&id',
        globalSettings: '&id, activeThemeId', 
        userStickers: '&id, url, name',
        worldBooks: '&id, name, categoryId, isGlobal', 
                    worldBookCategories: '++id, name, isGlobal',
        musicLibrary: '&id',
        shoppingProducts: '++id, name, description, price, imageUrl', 
        personaPresets: '&id',
        qzoneSettings: '&id',
        qzonePosts: '++id, timestamp', 
        qzoneAlbums: '++id, name, createdAt',
        qzonePhotos: '++id, albumId',
        favorites: '++id, type, timestamp, originalTimestamp',
        qzoneGroups: '++id, name',
        memories: '++id, chatId, timestamp, type, targetDate' ,
        callRecords: '++id, chatId, timestamp, customName',
        customAvatarFrames: '&id, name, url',   
        themes: '++id, name, css',
        apiPresets: '++id, name, proxyUrl, apiKey',
        bubbleStylePresets: '++id, name, css',
        loveAlbums: '++id, name, createdAt',
        fontPresets: '&id, name, url',
        homeScreenPresets: '++id, name',
        weiboPosts: '++id, authorId, timestamp',
        diyDecorations: '++id, url, x, y, width, height, rotation, flipH, flipV, zIndex, createdAt'
    });

    window.db = db;
    
    document.addEventListener('DOMContentLoaded', () => {

        // ===================================================================
        // 1. 所有变量和常量定义
        // ===================================================================
        // ▼▼▼ 把下面这一整块全新的微博功能代码，粘贴到这里 ▼▼▼

/**
 * 【微博】总入口：根据当前激活的视图，渲染对应的微博Feed
 */
async function renderWeiboFeeds(viewId) {
    if (viewId === 'weibo-my-profile-view') {
        await renderMyWeiboFeed();
    } else if (viewId === 'weibo-following-view') {
        await renderFollowingWeiboFeed();
    }
}

// ▼▼▼ 用这【两块新代码】分别替换旧的 renderMyWeiboFeed 和 renderFollowingWeiboFeed 函数 ▼▼▼

/**
 * 【微博】渲染“我的主页”上的微博列表
 */
async function renderMyWeiboFeed() {
    const feedEl = document.getElementById('my-weibo-feed-list');
    const posts = await db.weiboPosts.where('authorId').equals('user').reverse().toArray();
    feedEl.innerHTML = '';
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">你还没有发过微博哦，点击右上角“+”试试吧！</p>';
        return;
    }
    posts.forEach(post => {
        // 【核心修改】调用我们新的专属函数！
        feedEl.appendChild(createWeiboPostElement(post));
    });
}

// ▼▼▼ 用这块【已修复】的代码，完整替换掉你旧的 renderFollowingWeiboFeed 函数 ▼▼▼
/**
 * 【微博】渲染“关注的人”的微博Feed (已修复不显示的问题)
 */
async function renderFollowingWeiboFeed() {
    const feedEl = document.getElementById('weibo-following-feed-list');
    
    // 1. 从数据库获取【所有】微博帖子
    const allPosts = await db.weiboPosts.toArray();
    
    // 2. 在代码中进行筛选和排序，确保逻辑正确
    const posts = allPosts
        .filter(p => p.authorId !== 'user') // 筛选出所有作者不是'user'(也就是你)的帖子
        .sort((a, b) => b.timestamp - a.timestamp); // 按时间戳倒序排列，最新的在最上面

    // 3. 渲染帖子列表 (这部分逻辑和原来一样)
    feedEl.innerHTML = '';
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">你关注的人还没有发布任何动态哦。</p>';
        return;
    }
    posts.forEach(post => {
        feedEl.appendChild(createWeiboPostElement(post));
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用下面这块【功能增强版】的代码，完整替换掉你旧的 createWeiboPostElement 函数 ▼▼▼

/**
 * 【微博 V5 - 功能增强版】创建单个微博帖子的HTML元素
 * @param {object} post - 微博帖子对象
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createWeiboPostElement(post) {
    const postEl = document.createElement('div');
    postEl.className = 'weibo-post-item'; 
    postEl.dataset.postId = post.id;

    let contentHtml = '';
    if (post.content) {
        contentHtml += `<div class="weibo-post-content">${processAlbumPhotos(post.content.replace(/\n/g, '<br>'))}</div>`;
    }
    
    if (post.imageUrl) {
        if (post.postType === 'text_image') {
            contentHtml += `<img src="${post.imageUrl}" class="weibo-post-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
        } else {
            contentHtml += `<img src="${post.imageUrl}" class="weibo-post-image">`;
        }
    }

// ▼▼▼ 用下面这块【已添加删除按钮】的代码，替换掉你旧的 commentsHtml 代码块 ▼▼▼
    let commentsHtml = '';
    if (post.comments && post.comments.length > 0) {
        commentsHtml += '<div class="weibo-comments-container">';
        // 【核心修改】我们在这里给每条评论加上了删除按钮
        post.comments.forEach(comment => {
            let replyHtml = '';
            if (comment.replyToNickname) {
                replyHtml = `<span class="weibo-comment-reply-tag">回复</span><span class="weibo-commenter-name">${comment.replyToNickname}</span>`;
            }
            commentsHtml += `
                <div class="weibo-comment-item" data-comment-id="${comment.commentId}" data-commenter-name="${comment.authorNickname}">
                    <span class="weibo-commenter-name">${comment.authorNickname}</span>
                    ${replyHtml}:
                    <span class="weibo-comment-text">${comment.commentText}</span>
                    <!-- ▼▼▼ 这就是我们新加的删除按钮 ▼▼▼ -->
                    <button class="comment-delete-btn" title="删除此条评论">×</button>
                </div>`;
        });
        commentsHtml += '</div>';
    }
// ▲▲▲ 替换结束 ▲▲▲


    const myNickname = state.qzoneSettings.nickname || '我';
    const isLiked = post.likes && post.likes.includes(myNickname);
    
    let finalAuthorAvatar = post.authorAvatar;
    let finalAuthorNickname = post.authorNickname;

    if (post.authorId === 'user') {
        finalAuthorAvatar = state.qzoneSettings.weiboAvatar || state.qzoneSettings.avatar || defaultAvatar;
        finalAuthorNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';
    }

    postEl.innerHTML = `
        <div class="weibo-post-header">
            <img src="${finalAuthorAvatar}" class="weibo-post-avatar">
            <div class="weibo-post-info">
                <span class="weibo-post-nickname">${finalAuthorNickname}</span>
                <span class="weibo-post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
            </div>
            <div class="post-actions-btn" data-post-id="${post.id}" data-author-id="${post.authorId}">…</div>
        </div>
        ${contentHtml}
        <div class="weibo-post-footer">
            <div class="weibo-post-actions">
                <span class="weibo-action-btn like-btn ${isLiked ? 'liked' : ''}">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
                    <!-- ▼▼▼ 【核心修改】这里的点赞数现在是“基础数 + 真实点赞数” ▼▼▼ -->
                    <span>${(post.baseLikesCount || 0) + (post.likes || []).length}</span>
                </span>
                <span class="weibo-action-btn comment-btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>           
                    <!-- ▼▼▼ 【核心修改】评论数也是“基础数 + 真实评论数” ▼▼▼ -->
                    <span>${(post.baseCommentsCount || 0) + (post.comments || []).length}</span>
                </span>
                <!-- ▼▼▼ 这就是新增的“生成评论”按钮！ ▼▼▼ -->
                <span class="weibo-action-btn generate-comments-btn" title="AI生成评论">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
                    </svg>
                    <span>生成评论</span>
                </span>
            </div>
            ${commentsHtml}
            <div class="weibo-comment-input-area">
                <input type="text" class="weibo-comment-input" placeholder="留下你的精彩评论吧...">
                <button class="weibo-comment-send-btn">发送</button>
            </div>
        </div>
    `;
    
    // 【新增】异步加载相册照片
    setTimeout(() => {
        loadAlbumPhotosInElement(postEl);
        loadPrivatePhotosInElement(postEl); // 【新增】加载私人相册照片
    }, 100);
    
    return postEl;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【微博】打开微博发布/编辑模态框
 */
async function openWeiboPublisher() {
    const modal = document.getElementById('create-post-modal');
    
    modal.dataset.mode = 'weibo'; // 关键！标记为微博模式
    
    document.getElementById('create-post-modal-title').textContent = '发微博';
    document.getElementById('post-public-text').placeholder = '有什么新鲜事想分享给大家？';
    
    // 隐藏动态专属的控件
    document.getElementById('post-image-desc-group').style.display = 'none';
    document.getElementById('post-comments-toggle-group').style.display = 'none';
    
    document.getElementById('post-mode-switcher').style.display = 'flex'; // 微博也需要模式切换
    
    // 确保模式内容区域的display样式被重置（微博也需要这些区域）
    const imageModeContent = document.getElementById('image-mode-content');
    const textImageModeContent = document.getElementById('text-image-mode-content');
    if (imageModeContent) imageModeContent.style.display = '';
    if (textImageModeContent) textImageModeContent.style.display = '';
    
    resetCreatePostModal();
    modal.classList.add('visible');
}

// ▼▼▼ 用这块【已添加粉丝数计算逻辑】的代码，替换旧的 handlePublishWeibo 函数 ▼▼▼
/**
 * 【微博 V3 - 粉丝数计算版】处理发布微博的核心函数
 */
async function handlePublishWeibo() {
    const modal = document.getElementById('create-post-modal');
    
    const mainContent = document.getElementById('post-public-text').value.trim();
    let imageUrl = '', hiddenContent = '', postType = 'text_only';
    const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

    if (isImageModeActive) {
        const previewSrc = document.getElementById('post-image-preview').src;
        const hasRealImage = previewSrc && !previewSrc.includes('placeholder') && (previewSrc.startsWith('http') || previewSrc.startsWith('data:'));
        if (hasRealImage) {
            imageUrl = previewSrc;
            postType = 'image';
        }
    } else {
        hiddenContent = document.getElementById('post-hidden-text').value.trim();
        if (hiddenContent) {
            imageUrl = 'https://i.postimg.cc/KYr2qRCK/1.jpg'; 
            postType = 'text_image';
        }
    }
    
    if (!mainContent && !imageUrl) {
        alert('微博内容不能为空哦！');
        return;
    }

    // ▼▼▼ 【核心新增】计算基础点赞和评论数 ▼▼▼
    const fansCount = parseInt(state.qzoneSettings.weiboFansCount) || 0;
    // 点赞数是粉丝数的 10% ~ 20% 之间的一个随机数
    const baseLikes = Math.floor(fansCount * (Math.random() * 0.1 + 0.1));
    // 评论数是点赞数的 5% ~ 15% 之间的一个随机数
    const baseComments = Math.floor(baseLikes * (Math.random() * 0.1 + 0.05));
    // ▲▲▲ 新增结束 ▲▲▲

    const newPost = {
        authorId: 'user',
        authorType: 'user',
        authorNickname: state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我',
        authorAvatar: state.qzoneSettings.weiboAvatar || state.qzoneSettings.avatar || defaultAvatar,
        content: mainContent,
        imageUrl: imageUrl,
        hiddenContent: hiddenContent,
        postType: postType,
        timestamp: Date.now(),
        likes: [],
        comments: [],
        // ▼▼▼ 【核心新增】把计算好的数存进去 ▼▼▼
        baseLikesCount: baseLikes,
        baseCommentsCount: baseComments
    };

    await db.weiboPosts.add(newPost);
    await renderMyWeiboFeed(); 
    await renderWeiboProfile();
    
    modal.classList.remove('visible');
    alert('微博发布成功！');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【微博】处理点赞/取消点赞
 * @param {number} postId - 帖子ID
 */
async function handleWeiboLike(postId) {
    const post = await db.weiboPosts.get(postId);
    if (!post) return;

    const myNickname = state.qzoneSettings.nickname || '我';
    if (!post.likes) post.likes = [];
    
    const likeIndex = post.likes.indexOf(myNickname);
    if (likeIndex > -1) {
        post.likes.splice(likeIndex, 1); // 取消点赞
    } else {
        post.likes.push(myNickname); // 点赞
    }

    await db.weiboPosts.put(post);
    // 重新渲染两个Feed，确保数据同步
    await renderMyWeiboFeed();
    await renderFollowingWeiboFeed();
}

/**
 * 【微博】处理发布评论或回复
 * @param {number} postId - 帖子ID
 * @param {HTMLInputElement} inputElement - 评论输入框元素
 */
async function handleWeiboComment(postId, inputElement) {
    const commentText = inputElement.value.trim();
    if (!commentText) {
        alert("评论内容不能为空！");
        return;
    }

    const post = await db.weiboPosts.get(postId);
    if (!post) return;

    if (!post.comments) post.comments = [];

    const newComment = {
        commentId: 'comment_' + Date.now(),
        authorId: 'user',
        authorNickname: state.qzoneSettings.nickname || '我',
        commentText: commentText,
        timestamp: Date.now()
    };
    
    // 检查是否是回复
    if (inputElement.dataset.replyToId) {
        newComment.replyToId = inputElement.dataset.replyToId;
        newComment.replyToNickname = inputElement.dataset.replyToNickname;
    }

    post.comments.push(newComment);
    await db.weiboPosts.put(post);
    
    // 清空输入框并重置状态
    inputElement.value = '';
    inputElement.placeholder = '留下你的精彩评论吧...';
    delete inputElement.dataset.replyToId;
    delete inputElement.dataset.replyToNickname;
    
    // 重新渲染两个Feed
    await renderMyWeiboFeed();
    await renderFollowingWeiboFeed();
}


// ▲▲▲ 全新的微博功能代码粘贴结束 ▲▲▲
// ▼▼▼ 在这里添加您的 API 站点黑名单 ▼▼▼
const BLOCKED_API_SITES = [
    'api.pisces.ink',
    'aiapi.qzz.io'
];
// ▲▲▲ 黑名单定义结束 ▲▲▲
        // --- 已修正 ---
        let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null };
        // --- 修正结束 ---

        let isLocked = false; // <-- 在这里添加这行新代码
        let newLockscreenWallpaperBase64 = null; // <-- 在这里添加这行新代码
















async function showLoveSpacePreview() {
    const modalOverlay = document.getElementById('custom-modal-overlay');
    const modalTitle = document.getElementById('custom-modal-title');
    const modalBody = document.getElementById('custom-modal-body');
    const modalConfirmBtn = document.getElementById('custom-modal-confirm');
    const modalCancelBtn = document.getElementById('custom-modal-cancel');
    
    modalTitle.textContent = '💕 恋爱空间预览';
    modalBody.innerHTML = `
        <div class="love-space-preview">
            <div class="preview-section">
                <h4>✨ 恋爱空间功能</h4>
                <ul style="text-align: left; list-style: none; padding: 0;">
                    <li style="margin: 8px 0;">📸 共享相册，记录美好瞬间</li>
                    <li style="margin: 8px 0;">📝 情侣日记，分享心情点滴</li>
                    <li style="margin: 8px 0;">📅 纪念日提醒，不错过重要时刻</li>
                    <li style="margin: 8px 0;">💝 专属头像，彰显恋爱身份</li>
                    <li style="margin: 8px 0;">🎵 共听音乐，享受浪漫时光</li>
                </ul>
            </div>
            <div class="preview-section" style="margin-top: 20px;">
                <h4>❤️ AI伴侣的决定</h4>
                <p>是否接受这个恋爱空间邀请？</p>
                <div class="decision-buttons" style="display: flex; gap: 10px; margin-top: 15px;">
                    <button class="accept-btn" onclick="respondToInvite('accept')" style="flex: 1; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        ✅ 接受邀请
                    </button>
                    <button class="reject-btn" onclick="respondToInvite('reject')" style="flex: 1; padding: 10px; background: #f44336; color: white; border: none; border-radius: 8px; cursor: pointer;">
                        ❌ 礼貌拒绝
                    </button>
                </div>
            </div>
        </div>
    `;
    
    modalCancelBtn.style.display = 'none';
    modalConfirmBtn.textContent = '关闭';
    
    const closeHandler = () => {
        modalCancelBtn.style.display = 'block';
        modalConfirmBtn.textContent = '确定';
        modalOverlay.classList.remove('visible');
        modalConfirmBtn.removeEventListener('click', closeHandler);
    };
    
    modalConfirmBtn.addEventListener('click', closeHandler);
    modalOverlay.classList.add('visible');
}

// AI回复邀请决定
async function respondToInvite(decision) {
    // 关闭模态框
    const modalOverlay = document.getElementById('custom-modal-overlay');
    modalOverlay.classList.remove('visible');
    
    const chatId = state.activeChatId;
    if (!chatId) return;
    
    // 找到最新的邀请消息并更新状态
    const chat = state.chats[chatId];
    if (chat && chat.history) {
        const inviteMessage = chat.history.slice().reverse().find(msg => 
            msg.cardType === 'love_space_invite' && msg.cardData?.status === 'pending'
        );
        
        if (inviteMessage) {
            // 更新邀请状态
            inviteMessage.cardData.status = decision === 'accept' ? 'accepted' : 'rejected';
            
            // 立即更新DOM中的邀请卡片状态显示
            updateInviteCardStatusInDOM(inviteMessage.id, decision === 'accept' ? 'accepted' : 'rejected');
            
            // 如果接受，更新恋爱空间头像
            if (decision === 'accept') {
                localStorage.setItem('loveSpaceBoundChar', chatId);
                // 更新恋爱空间的AI头像
                updateLoveSpaceAvatarsAfterBind(chatId);
            }
            
            // 添加AI回复消息
            const replyMessage = {
                id: 'invite_reply_' + Date.now(),
                role: 'assistant',
                content: decision === 'accept' ? 
                    '我接受了恋爱空间邀请 💕' :
                    '我婉拒了恋爱空间邀请',
                timestamp: Date.now(),
                cardType: 'love_space_invite_reply',
                cardData: {
                    decision: decision,
                    status: decision === 'accept' ? 'accepted' : 'rejected',
                    message: decision === 'accept' ? 
                        '我接受了恋爱空间邀请 💕' :
                        '我婉拒了恋爱空间邀请',
                    fromAI: true  // 标记这是AI的回复
                }
            };
            
            chat.history.push(replyMessage);
            
            // 添加系统消息
            const systemMessage = {
                id: 'system_' + Date.now(),
                role: 'system',
                content: decision === 'accept' ? 
                    '🎉 恋爱空间邀请已被接受！你们现在是恋爱空间的伴侣了！' :
                    '💔 恋爱空间邀请被婉拒了，友谊同样珍贵！',
                timestamp: Date.now() + 1,
                type: 'system'
            };
            
            chat.history.push(systemMessage);
            await db.chats.put(chat);
            
            // 立即重新渲染聊天界面以显示状态变化
            if (state.activeChatId === chatId) {
            renderChatInterface(chatId);
            }
            
            // 显示结果提示
            if (decision === 'accept') {
                await simpleAlert('恋爱空间', '🎉 恭喜！你们现在是恋爱空间的伴侣了！\n\n恋爱空间头像已更新~');
            } else {
                await simpleAlert('恋爱空间', '💔 邀请被拒绝了，没关系，友谊同样珍贵！');
            }
        }
    }
}



let musicState = { 
    isActive: false, 
    activeChatId: null, 
    isPlaying: false, 
    playlist: [], 
    currentIndex: -1, 
    playMode: 'order', 
    totalElapsedTime: 0, 
    timerId: null,
    // 【新增】歌词相关状态
    parsedLyrics: [],      // 当前歌曲解析后的歌词数组
    currentLyricIndex: -1  // 当前高亮的歌词行索引
};

let lyricsBarSettings = {
    fontSize: 14,
    bgOpacity: 0,
    fontColor: '#FFFFFF',
    showOnClose: true // 【问题4需要】默认开启
};

        const audioPlayer = document.getElementById('audio-player');
        let newWallpaperBase64 = null;
        let isSelectionMode = false;
        let isInnerVoiceHistoryOpen = false; // 用于跟踪历史面板是否打开
        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;

let activeCharacterPhoneId = null;

let waimaiTimers = {}; // 用于存储外卖倒计时

let activeMessageTimestamp = null;
let currentReplyContext = null; // <--- 新增这行，用来存储当前正在引用的消息信息
let currentSearchKeyword = ''; // 用于在搜索结果中高亮关键词
let activePostId = null; // <-- 新增：用于存储当前操作的动态ID
// ▼▼▼ 【全新】BGM 搜索功能核心代码 ▼▼▼

// 一个简单的网络请求函数
if (typeof Http_Get_External === 'undefined') {
    window.Http_Get_External = function(url) {
        return new Promise((resolve) => {
            fetch(url).then(res => res.json().catch(() => res.text())).then(resolve).catch(() => resolve(null));
        });
    }
}
async function Http_Get(url) { return await Http_Get_External(url); }

// 检查音频链接是否真的可以播放
function checkAudioAvailability(url) {
    return new Promise(resolve => {
        const tester = new Audio();
        tester.addEventListener('loadedmetadata', () => resolve(true), { once: true });
        tester.addEventListener('error', () => resolve(false), { once: true });
        tester.src = url;
    });
}

// ▼▼▼ 【V9.0 | 终极纯净版 - 移除代理】请用这块代码，完整替换旧的 searchNeteaseMusic 函数 ▼▼▼
/**
 * 移除所有代理，直接请求你找到的 vkeys.cn API
 */
async function searchNeteaseMusic(name, singer) {
    try {
        let searchTerm = name.replace(/\s/g, "");
        if (singer) { searchTerm += ` ${singer.replace(/\s/g, "")}`; }

        // 【核心修改】我们不再需要任何代理，直接把目标API作为最终请求地址！
        const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;
        
        console.log("正在尝试直接请求:", apiUrl); // 添加一条日志，方便我们调试
        
        const response = await fetch(apiUrl);

        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();

        if (result.code !== 200 || !result.data || result.data.length === 0) {
            console.log("vkeys API返回无结果:", result);
            return [];
        }
        
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzP-album-cover-placeholder.png',
            source: 'netease'
        })).slice(0, 15);

    } catch (e) {
        // 如果这次还失败，请把浏览器F12控制台里的红色错误信息完整地截图给我
        console.error("【vkeys API 直连】搜索失败:", e);
        await showCustomAlert("网易云接口直连失败", `如果浏览器控制台(F12)提示CORS错误，说明此API禁止直接访问。错误: ${e.message}`);
        return [];
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 从QQ音乐搜索歌曲列表
 */
async function searchTencentMusic(name) {
    try {
        name = name.replace(/\s/g, "");
        const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
        if (!result?.data?.length) return [];
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
            source: 'tencent' // 标记来源
        })).slice(0, 5); // 只取前5条结果
    } catch (e) {
        console.error("QQ音乐搜索API失败:", e);
        return [];
    }
}
// ▼▼▼ 【V2.0 | 支持源选择】请用这个全新的函数，完整替换旧的 addSongFromSearch ▼▼▼
/**
 * 【总入口 V2.0】当用户点击“搜索”按钮时触发
 */
async function addSongFromSearch() {
    // 步骤 1: 首先弹出选择框，让用户选择搜索源
    const source = await showSearchSourceSelector();
    // 如果用户点了取消，source会是null，我们直接退出函数
    if (!source) return;

    // 步骤 2: 弹出输入框让用户输入关键词 (这部分逻辑不变)
    const searchTerm = await showCustomPrompt("搜索歌曲", "请输入 歌名 或 歌名-歌手");
    if (!searchTerm || !searchTerm.trim()) return;

    await showCustomAlert("请稍候...", "正在搜索歌曲资源...");

    let musicName = searchTerm.trim();
    let singerName = "";
    if (searchTerm.includes('-') || searchTerm.includes('–')) {
        const parts = searchTerm.split(/[-–]/);
        musicName = parts[0].trim();
        singerName = parts.slice(1).join(' ').trim();
    }

    // 步骤 3: 【核心修改】根据用户的选择，执行不同的搜索
    let combinedResults = [];

    if (source === 'all') {
        // 如果选择“全部”，则并行搜索两个平台
        const [neteaseResults, tencentResults] = await Promise.all([
            searchNeteaseMusic(musicName, singerName),
            searchTencentMusic(musicName)
        ]);
        combinedResults = [...neteaseResults, ...tencentResults];
    } else if (source === 'netease') {
        // 如果只选“网易云”，就只调用网易云的搜索
        combinedResults = await searchNeteaseMusic(musicName, singerName);
    } else if (source === 'tencent') {
        // 如果只选“QQ音乐”，就只调用QQ音乐的搜索
        combinedResults = await searchTencentMusic(musicName);
    }

    // 步骤 4: 后续的显示逻辑保持不变
    if (combinedResults.length === 0) {
        await showCustomAlert("无结果", "抱歉，在所选来源中未能找到相关歌曲。");
        return;
    }

    const modal = document.getElementById('music-search-results-modal');
    const listEl = document.getElementById('search-results-list');
    listEl.innerHTML = '';

    combinedResults.forEach(song => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.songJson = JSON.stringify(song);
        item.innerHTML = `
            <div class="title">${song.name}</div>
            <div class="artist">${song.artist} <span class="source">${song.source === 'netease' ? '网易云' : 'QQ音乐'}</span></div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【核心升级】处理用户点击搜索结果，增加备用音源查找和是否永久保存的逻辑
 */
async function handleSearchResultClick(songData) {
    const modal = document.getElementById('music-search-results-modal');
    modal.classList.remove('visible');

    await showCustomAlert("请稍候...", `正在获取《${songData.name}》的播放链接...`);

    let playableResult = null;
    let finalSource = songData.source;

    // 1. 尝试主音源
    const primaryApiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    let primaryResult = await Http_Get(primaryApiUrl);
    if (primaryResult?.data?.url && await checkAudioAvailability(primaryResult.data.url)) {
        playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
    }

    // 2. 如果主音源失败，尝试备用音源
    if (!playableResult) {
        await showCustomAlert("请稍候...", "主音源获取失败，正在尝试备用音源...");
        const fallbackSource = songData.source === 'netease' ? 'tencent' : 'netease';
        const fallbackResults = fallbackSource === 'tencent' 
            ? await searchTencentMusic(songData.name)
            : await searchNeteaseMusic(songData.name, songData.artist);

        if (fallbackResults.length > 0) {
            const fallbackApiUrl = fallbackSource === 'netease'
                ? `https://api.vkeys.cn/v2/music/netease?id=${fallbackResults[0].id}`
                : `https://api.vkeys.cn/v2/music/tencent?id=${fallbackResults[0].id}`;
            const fallbackResult = await Http_Get(fallbackApiUrl);
            if (fallbackResult?.data?.url && await checkAudioAvailability(fallbackResult.data.url)) {
                playableResult = { url: fallbackResult.data.url, id: fallbackResults[0].id, source: fallbackSource };
                finalSource = fallbackSource;
            }
        }
    }

    if (!playableResult) {
        await showCustomAlert("获取失败", "无法获取该歌曲的有效播放链接，主音源和备用音源均已尝试。");
        return;
    }
    
// ▼▼▼ 从这里开始粘贴新代码 ▼▼▼
const confirmed = await showCustomConfirm(
    '温馨提示', // 这是弹窗的标题
    '搜索的歌曲24h后会过期，重要的歌曲记得用url或者本地上传哦🐇', // 这是你指定的提示内容
    { confirmText: '确定' } // 按钮会显示“确定”和“取消”，这里的“取消”就等同于“返回”
);

// 如果用户点击了“取消”（返回），就直接结束，不添加歌曲
if (!confirmed) {
    return;
}
// ▲▲▲ 粘贴结束 ▲▲▲   
    // 获取歌词
    const lrcContent = await getLyricsForSong(playableResult.id, finalSource) || "";

// ▼▼▼ 用这块新代码替换 ▼▼▼
const newSong = {
    name: songData.name,
    artist: songData.artist,
    src: playableResult.url,
    cover: songData.cover,
    isLocal: false,
    lrcContent: lrcContent,
    isTemporary: true,
    // 核心新增：记录这首歌被添加的精确时间
    addedTimestamp: Date.now() 
};
// ▲▲▲ 替换结束 ▲▲▲



musicState.playlist.push(newSong);

// 注意：我们已经删除了 saveGlobalPlaylist() 的调用，因为临时歌曲不需要被永久保存
// ▲▲▲ 替换结束 ▲▲▲

    
    updatePlaylistUI();

    if (musicState.currentIndex === -1) {
        musicState.currentIndex = musicState.playlist.length - 1;
        updatePlayerUI();
    }

    await showCustomAlert("添加成功", `《${songData.name}》已成功添加到播放列表！`);
}

/**
 * 【辅助】获取网络歌曲的歌词
 */
async function getLyricsForSong(songId, source) {
    const url = source === 'netease'
        ? `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}`
        : `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;
    
    const response = await Http_Get(url);
    if (response?.data) {
        const lrc = response.data.lrc || response.data.lyric || "";
        const tlyric = response.data.trans || response.data.tlyric || "";
        return lrc + "\\n" + tlyric;
    }
    return "";
}
// ▼▼▼ 【全新】这个函数用来显示“选择搜索源”的弹窗 ▼▼▼
/**
 * 显示搜索源选择弹窗，并返回用户的选择
 * @returns {Promise<string|null>} 返回 'all', 'netease', 'tencent', 或 null
 */
function showSearchSourceSelector() {
    return new Promise(resolve => {
        const modal = document.getElementById('music-source-selector-modal');
        const confirmBtn = document.getElementById('confirm-source-select-btn');
        const cancelBtn = document.getElementById('cancel-source-select-btn');

        // 显示弹窗
        modal.classList.add('visible');

        // 定义确认按钮的点击事件
        const onConfirm = () => {
            const selectedSource = document.querySelector('input[name="search-source"]:checked').value;
            cleanup();
            resolve(selectedSource); // 返回用户的选择
        };

        // 定义取消按钮的点击事件
        const onCancel = () => {
            cleanup();
            resolve(null); // 用户取消，返回 null
        };

        // 清理函数，用于移除事件监听并隐藏弹窗
        const cleanup = () => {
            modal.classList.remove('visible');
            confirmBtn.removeEventListener('click', onConfirm);
            cancelBtn.removeEventListener('click', onCancel);
        };

        // 绑定事件
        confirmBtn.addEventListener('click', onConfirm);
        cancelBtn.addEventListener('click', onCancel);
    });
}
// ▲▲▲ 新增函数结束 ▲▲▲

// ▲▲▲ 新增函数粘贴结束 ▲▲▲

        let photoViewerState = {
            isOpen: false,
            photos: [], // 存储当前相册的所有照片URL
            currentIndex: -1, // 当前正在查看的照片索引
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set()

let simulationIntervalId = null;

let currentFrameSelection = { type: null, url: '', target: null }; 

        const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
        const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
        const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
        const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
        let notificationTimeout;

const THEME_CSS_TEMPLATE = `
/* 
  EPhone 美化代码模板
  使用方法: 
  1. 修改下面的颜色代码或图片URL。
  2. 不需要修改的部分可以删除或保持不变。
  3. 颜色代码格式为 #RRGGBB (例如 #FFFFFF 是白色)。
  4. 图片URL需要是网络直链。
*/

/* === 1. 手机壳与刘海颜色 === */
#phone-frame {
  background-color: #f0f0f0; /* 手机壳颜色 */
}
.notch {
  background-color: #1a1a1a; /* 顶部“刘海”颜色 */
}
        #clock-container {  color: white;  }


/* === 1.5. 全局主题色 (重要！) === */
/* 这个颜色决定了大部分按钮、链接和高亮文本的颜色。*/
:root {
  --accent-color: #007bff; /* 默认是蓝色 */
}

/* === 2. 聊天界面顶部和底部的图片按钮替换 === */
/* “一起听”按钮 (正常状态) */
#listen-together-btn img[src*="8kYShvrJ/90-UI-2.png"] {
  content: url('在这里粘贴你的“正常状态”图片URL');
}
/* “一起听”按钮 (播放中状态) */
#listen-together-btn img[src*="D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png"] {
  content: url('在这里粘贴你的“播放中”图片URL');
}
/* “聊天设置”按钮 */
#chat-settings-btn img {
  content: url('https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png');
}
/* “触发API回复”按钮 */
#wait-reply-btn img {
  content: url('https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png');
}
/* “发送”按钮 (设为图片形式) */
#send-btn {
  background-image: url('在这里粘贴你的发送按钮图片URL');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  width: 50px; /* 根据你的图片调整宽度 */
}

/* “重新生成回复”按钮 */
#reroll-btn {
    background-color: rgba(255, 255, 255, 0.6);
    color: var(--text-primary); /* 使用全局主题的主文本颜色 */
}

/* === 3. 顶部栏与底部栏颜色 === */
.header, .qzone-header {
  background-color: rgba(240, 240, 240, 0.8); /* 顶部栏背景色 (带一点透明) */
  color: #333333; /* 顶部栏文字颜色 */
}
#chat-list-bottom-nav {
  background-color: rgba(245, 245, 245, 0.85); /* 底部导航栏背景色 */
}
.nav-item {
  color: #8a8a8a; /* 底部导航栏未选中项的颜色 */
}
.nav-item.active {
  color: #007bff; /* 底部导航栏选中项的颜色 */
}

/* === 4. 各界面背景色 === */
#chat-list-screen, #qzone-screen .qzone-content, #memories-view {
  background-color: #f0f2f5 !important; /* 列表页主背景色 */
}

/* === 5. 聊天输入区底部功能栏SVG图标替换 === */
/* 提示: 你需要将你的SVG代码转换为URL编码格式。
   可以使用在线工具搜索 "SVG to Data URI" 来完成转换。
   然后替换掉下面的 url('...') 部分。 */

.chat-action-icon-btn {
  background-color: rgba(255, 255, 255, 0.5); /* 图标按钮的背景色 */
  border: 1px solid rgba(0,0,0,0.05); /* 图标按钮的边框 */
}

/* 表情面板(+)按钮 */
#open-sticker-panel-btn svg { display: none; /* 隐藏原始SVG */ }
#open-sticker-panel-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 发送照片(旧)按钮 */
#send-photo-btn svg { display: none; /* 隐藏原始SVG */ }
#send-photo-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 上传图片(新)按钮 */
#upload-image-btn svg { display: none; }
#upload-image-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="color: black;"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 转账(￥)按钮 */
#transfer-btn svg { display: none; }
#transfer-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 语音按钮 */
#voice-message-btn svg { display: none; }
#voice-message-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 外卖按钮 */
#send-waimai-request-btn svg { display: none; }
#send-waimai-request-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 购物按钮 */
#open-shopping-btn svg { display: none; }
#open-shopping-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"/><circle cx="20" cy="21" r="1"/><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
  background-color: #4CAF50; /* 绿色背景，区分外卖按钮 */
}

#open-shopping-btn:hover {
  background-color: #45a049;
}

/* 视频通话按钮 */
#video-call-btn svg { display: none; }
#video-call-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 群视频通话按钮 */
#group-video-call-btn svg { display: none; }
#group-video-call-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 投票按钮 */
#send-poll-btn svg { display: none; }
#send-poll-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 分享链接按钮 */
#share-link-btn svg { display: none; }
#share-link-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 发送定位按钮 */
#send-location-btn { display: none; }
#send-location-btn {
  background-image: url('data:image/svg+xml;utf8,    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* === 6. 更多界面背景色 === */
/* 适用于所有设置、编辑、选择等二级页面 */
#api-settings-screen,
#font-settings-screen,
#wallpaper-screen,
#world-book-screen,
#world-book-editor-screen,
#contact-picker-screen,
#member-management-screen,
#album-screen,
#album-photos-screen,
#call-history-screen,
#chat-search-screen,
#browser-screen {
  /* 这里不再设置背景色，让它自然继承夜间模式的颜色 */
}


/* === 7. 回忆卡片美化 === */
.memory-card {
  background-color: #fffaf0 !important; /* 卡片主背景色 */
  border-left-color: #ffb74d !important; /* 左侧装饰条颜色 */
  box-shadow: 0 2px 6px rgba(0,0,0,0.07) !important;
}
.memory-card .header .author {
  color: #d98100 !important; /* 作者/标题文字颜色 */
}
.memory-card .header .date {
  color: #a1887f !important; /* 日期文字颜色 */
}
.memory-card .content {
  color: #5d4037 !important; /* 内容文字颜色 */
}
`;

// ▼▼▼ 在JS顶部，变量定义区，添加这个新常量 ▼▼▼
const DEFAULT_APP_ICONS = {
    'world-book': 'https://youke1.picui.cn/s1/2025/10/08/68e628cf3db0a.png',
    'qq': 'https://youke1.picui.cn/s1/2025/10/08/68e6289510848.png',
    'api-settings': 'https://youke1.picui.cn/s1/2025/10/08/68e62948652a9.png',
    'wallpaper': 'https://youke1.picui.cn/s1/2025/10/08/68e6291d60eb2.png',
    'font': 'https://youke1.picui.cn/s1/2025/10/08/68e62933a852b.png',
    // ▼▼▼ 在这里添加下面这行新代码 ▼▼▼
    'check-phone': 'https://youke1.picui.cn/s1/2025/10/08/68e62902e02ab.png',
    'weibo': 'https://youke1.picui.cn/s1/2025/10/08/68e628eaeb618.png', // <-- 就是新增这一行
    'floating-x-logo': 'https://youke1.picui.cn/s1/2025/10/08/68e67b6cce9d6.jpg' // 悬浮X Logo
};
// ▲▲▲ 添加结束 ▲▲▲

        const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement('style');
        dynamicFontStyle.id = 'dynamic-font-style';
        document.head.appendChild(dynamicFontStyle);

        // 将模态框变量移到全局作用域
        window.modalOverlay = document.getElementById('custom-modal-overlay');
        window.modalTitle = document.getElementById('custom-modal-title');
        window.modalBody = document.getElementById('custom-modal-body');
        window.modalConfirmBtn = document.getElementById('custom-modal-confirm');
        window.modalCancelBtn = document.getElementById('custom-modal-cancel');
        window.modalResolve = null;

        function showCustomModal() { 
            window.modalOverlay.classList.add('visible'); 
        }

        function hideCustomModal() { 
            window.modalOverlay.classList.remove('visible'); 
            window.modalConfirmBtn.classList.remove('btn-danger'); 
            if (window.modalResolve) window.modalResolve(null); 
        }


        function showCustomConfirm(title, message, options = {}) {
            return new Promise(resolve => {
                window.modalResolve = resolve;
                window.modalTitle.textContent = title;
                window.modalBody.innerHTML = `<p>${message}</p>`;
                window.modalCancelBtn.style.display = 'block';
                window.modalConfirmBtn.textContent = '确定';
                if (options.confirmButtonClass) window.modalConfirmBtn.classList.add(options.confirmButtonClass);
                window.modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                window.modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }

        function showCustomAlert(title, message) {
            return new Promise(resolve => {
                window.modalResolve = resolve;
                window.modalTitle.textContent = title;
                window.modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                window.modalCancelBtn.style.display = 'none';
                window.modalConfirmBtn.textContent = '好的';
                window.modalConfirmBtn.onclick = () => {
                    window.modalCancelBtn.style.display = 'block'; 
                    window.modalConfirmBtn.textContent = '确定';
                    resolve(true); 
                    hideCustomModal();
                };
                showCustomModal();
            });
        }
// ▼▼▼ 把这一整块全新的函数，粘贴到 <script> 标签的最开始 ▼▼▼
/**
 * 【全新】一个专门清除HTML标签和代码的函数
 * @param {string} text - 包含HTML或代码的原始文本
 * @returns {string} - 清理后的纯文本
 */
function stripHtmlAndCode(text) {
    if (!text || typeof text !== 'string') {
        return ''; // 如果输入为空或不是字符串，返回空字符串
    }
    // 1. 移除所有HTML标签 (例如 <b>, <div>)
    let cleanedText = text.replace(/<\/?[^>]+(>|$)/g, "");
    
    // 2. 移除所有Markdown代码块 (例如 ```code``` 或 `code`)
    cleanedText = cleanedText.replace(/```[\s\S]*?```/g, ''); // 移除多行代码块
    cleanedText = cleanedText.replace(/`[^`]*`/g, '');     // 移除行内代码
    
    // 3. 将HTML实体 (例如 &lt; &gt;) 转换回正常字符 (< >)
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = cleanedText;
    
    return tempDiv.textContent || tempDiv.innerText || "";
}
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 请用这个【功能增强版】替换旧的 showCustomPrompt 函数 ▼▼▼
function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
    return new Promise(resolve => {
        window.modalResolve = resolve;
        window.modalTitle.textContent = title;
        const inputId = 'custom-prompt-input';
        
        const inputHtml = type === 'textarea' 
            ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
            : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
        
        // 【核心修改】将额外的HTML和输入框组合在一起
        window.modalBody.innerHTML = extraHtml + inputHtml;
        const input = document.getElementById(inputId);

        // 【核心修改】为格式助手按钮绑定事件
        window.modalBody.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                    try {
                        const templateObj = JSON.parse(templateStr);
                        // 使用 null, 2 参数让JSON字符串格式化，带缩进，更易读
                        input.value = JSON.stringify(templateObj, null, 2);
                        input.focus();
                    } catch(e) {
                        console.error("解析格式模板失败:", e);
                    }
                }
            });
        });
        
        window.modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
        window.modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        showCustomModal();
        setTimeout(() => input.focus(), 100);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

        // ===================================================================
        // 2. 所有功能函数定义
        // ===================================================================

// ▼▼▼ 从这里开始，粘贴所有新代码 ▼▼▼
/**
 * 【V2智能版】应用指定的主题，并智能刷新当前打开的任何界面
 * @param {string} theme - 'light' 或 'dark'
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    // 核心操作：为手机屏幕添加或移除 .dark-mode 类
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 同步开关的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    // 保存用户的选择
    localStorage.setItem('ephone-theme', theme);

    // 【核心修复！】
    // 不再只关心聊天界面，而是找出当前究竟是哪个界面处于激活状态
    const activeScreen = document.querySelector('.screen.active');
    if (!activeScreen) return; // 如果找不到，就退出

    // 根据当前激活的界面ID，调用它专属的刷新函数
    switch (activeScreen.id) {
        case 'chat-interface-screen':
            if (state.activeChatId) {
                renderChatInterface(state.activeChatId);
            }
            break;
        case 'wallpaper-screen':
            // 外观设置页也需要重新渲染来应用新主题
            renderWallpaperScreen();
            break;
        case 'font-settings-screen':
            // 字体预设页同样需要
            renderFontPresets();
            break;
        // 如果未来还有其他页面需要适配，在这里添加 case 即可
    }
}


/**
 * 当用户点击开关时，切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}
/**
 * 【修复功能】检查并恢复丢失的预设数据
 */
async function checkAndRestorePresetData() {
    console.log('🔍 检查预设数据完整性...');
    
    try {
        // 检查气泡样式预设
        if (!state.bubbleStylePresets || state.bubbleStylePresets.length === 0) {
            const backupData = localStorage.getItem('bubbleStylePresets_backup');
            if (backupData) {
                try {
                    const parsedData = JSON.parse(backupData);
                    if (Array.isArray(parsedData) && parsedData.length > 0) {
                        console.log('🔄 从localStorage恢复气泡样式预设，数量:', parsedData.length);
                        // 恢复到数据库
                        for (const preset of parsedData) {
                            try {
                                const existingPreset = await db.bubbleStylePresets.get(preset.id);
                                if (!existingPreset) {
                                    await db.bubbleStylePresets.put(preset);
                                }
                            } catch (error) {
                                console.error('恢复单个气泡预设失败:', error);
                            }
                        }
                        // 重新加载到state
                        state.bubbleStylePresets = await db.bubbleStylePresets.toArray();
                        console.log('✅ 气泡样式预设恢复完成');
                    }
                } catch (error) {
                    console.error('解析气泡样式预设备份数据失败:', error);
                }
            }
        }
        
        // 检查主屏幕预设
        const homePresets = await db.homeScreenPresets.toArray();
        if (!homePresets || homePresets.length === 0) {
            const backupData = localStorage.getItem('homeScreenPresets_backup');
            if (backupData) {
                try {
                    const parsedData = JSON.parse(backupData);
                    if (Array.isArray(parsedData) && parsedData.length > 0) {
                        console.log('🔄 从localStorage恢复主屏幕预设，数量:', parsedData.length);
                        // 恢复到数据库
                        for (const preset of parsedData) {
                            try {
                                const existingPreset = await db.homeScreenPresets.get(preset.id);
                                if (!existingPreset) {
                                    await db.homeScreenPresets.put(preset);
                                }
                            } catch (error) {
                                console.error('恢复单个主屏幕预设失败:', error);
                            }
                        }
                        console.log('✅ 主屏幕预设恢复完成');
                    }
                } catch (error) {
                    console.error('解析主屏幕预设备份数据失败:', error);
                }
            }
        }
        
        // 检查字体预设
        const fontPresets = await db.fontPresets.toArray();
        if (!fontPresets || fontPresets.length === 0) {
            const backupData = localStorage.getItem('fontPresets_backup');
            if (backupData) {
                try {
                    const parsedData = JSON.parse(backupData);
                    if (Array.isArray(parsedData) && parsedData.length > 0) {
                        console.log('🔄 从localStorage恢复字体预设，数量:', parsedData.length);
                        // 恢复到数据库
                        for (const preset of parsedData) {
                            try {
                                const existingPreset = await db.fontPresets.get(preset.id);
                                if (!existingPreset) {
                                    await db.fontPresets.put(preset);
                                }
                            } catch (error) {
                                console.error('恢复单个字体预设失败:', error);
                            }
                        }
                        console.log('✅ 字体预设恢复完成');
                    }
                } catch (error) {
                    console.error('解析字体预设备份数据失败:', error);
                }
            }
        }
        
    } catch (error) {
        console.error('检查预设数据时出错:', error);
    }
}

/**
 * 【全新】在应用启动时，预加载所有已保存的字体预设
 */
async function loadAllFontPresetsOnStartup() {
    console.log("正在预加载所有字体预设...");
    const presets = await db.fontPresets.toArray();
    if (presets && presets.length > 0) {
        presets.forEach(preset => {
            // 我们复用已有的 loadFontForPreview 函数来加载每个字体
            loadFontForPreview(preset);
        });
        console.log(`成功预加载了 ${presets.length} 个字体。`);
    }
}

// ▼▼▼ 【全新】字体预设功能核心函数 ▼▼▼

/**
 * 渲染字体预设的5个卡槽
 */
async function renderFontPresets() {
    const container = document.getElementById('font-preset-container');
    container.innerHTML = ''; // 清空旧内容

    // 从数据库读取所有已保存的预设
    const presets = await db.fontPresets.toArray();

    // 循环5次，创建5个卡槽的HTML
    for (let i = 0; i < 5; i++) {
        const slot = document.createElement('div');
        slot.className = 'font-preset-slot';
        
        const preset = presets[i];

        if (preset) {
            // 如果这个卡槽有数据
            slot.innerHTML = `
                <div class="font-preview-text" data-preset-id="${preset.id}">Abc 你好</div>
                <div class="font-preset-info">名称: ${preset.name}</div>
                <div class="font-preset-actions">
                    <button class="preset-btn apply-btn" data-preset-id="${preset.id}">应用</button>
                    <button class="preset-btn delete-btn delete" data-preset-id="${preset.id}">删除</button>
                </div>
            `;
        } else {
            // 如果这个卡槽是空的
            slot.classList.add('empty');
            slot.innerHTML = `
                <div class="font-preset-info">卡槽 ${i + 1} 为空</div>
                <div class="font-preset-actions">
                    <button class="preset-btn secondary upload-url-btn" data-slot-index="${i}">URL上传</button>
                    <button class="preset-btn secondary upload-local-btn" data-slot-index="${i}">本地上传</button>
                </div>
            `;
        }
        container.appendChild(slot);
    }
    
    // ▼▼▼ 【核心修复】在这里，我们等所有HTML都创建好后，再统一加载预览字体 ▼▼▼
    presets.forEach(preset => {
        if (preset) {
            // 为每一个有数据的预设，调用加载预览函数
            loadFontForPreview(preset);
        }
    });
    // ▲▲▲ 修复结束 ▲▲▲

    // 为所有新生成的按钮绑定事件
    addFontPresetButtonListeners();
}


/**
 * 【终极修复版】为单个预设加载字体以供预览
 * @param {object} preset - 字体预设对象 {id, name, url}
 */
function loadFontForPreview(preset) {
    const styleId = `font-style-${preset.id}`;
    if (document.getElementById(styleId)) return;

    const style = document.createElement('style');
    style.id = styleId;
    
    // 【核心修改】我们不再手动操作元素的style属性，
    // 而是直接创建一条高优先级的CSS规则来应用字体，这更可靠。
    style.innerHTML = `
        @font-face {
            font-family: 'preset-${preset.id}';
            src: url('${preset.url}');
            font-display: swap;
        }

        .font-preview-text[data-preset-id="${preset.id}"] {
            font-family: 'preset-${preset.id}', sans-serif !important;
        }
    `;
    
    document.head.appendChild(style);
}




/**
 * 为预设卡槽中的所有按钮统一添加事件监听器
 */
function addFontPresetButtonListeners() {
    document.querySelectorAll('.upload-url-btn').forEach(btn => {
        btn.onclick = () => handleUploadFontUrl(parseInt(btn.dataset.slotIndex));
    });
    document.querySelectorAll('.upload-local-btn').forEach(btn => {
        btn.onclick = () => handleUploadFontLocal(parseInt(btn.dataset.slotIndex));
    });
    document.querySelectorAll('.apply-btn').forEach(btn => {
        btn.onclick = () => applyFontPreset(btn.dataset.presetId);
    });
    document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.onclick = () => deleteFontPreset(btn.dataset.presetId);
    });
}

/**
 * 处理通过URL上传字体
 * @param {number} slotIndex - 卡槽的索引 (0-4)
 */
async function handleUploadFontUrl(slotIndex) {
    const url = await showCustomPrompt("字体URL", "请输入字体的网络链接(.ttf, .otf等)");
    if (!url || !url.trim().startsWith('http')) {
        if (url !== null) alert("请输入一个有效的URL！");
        return;
    }
    const name = await showCustomPrompt("字体命名", "请为这个字体起个名字");
    if (!name || !name.trim()) {
        if (name !== null) alert("名字不能为空！");
        return;
    }
    await saveFontPreset(slotIndex, name.trim(), url.trim());
}

/**
 * 处理通过本地文件上传字体
 * @param {number} slotIndex - 卡槽的索引 (0-4)
 */
function handleUploadFontLocal(slotIndex) {
    const input = document.getElementById('font-preset-local-upload');
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const name = await showCustomPrompt("字体命名", "请为这个字体起个名字", file.name.replace(/\.[^/.]+$/, ""));
        if (!name || !name.trim()) {
            if (name !== null) alert("名字不能为空！");
            return;
        }

        // 使用FileReader将字体文件转为Base64 Data URL
        const reader = new FileReader();
        reader.onload = async (event) => {
            // 核心修改：event.target.result 现在就是我们需要的 data:font/ttf;base64,... 格式的完整文本
            await saveFontPreset(slotIndex, name.trim(), event.target.result);
        };
        // 核心修改：使用 readAsDataURL 来读取文件
        reader.readAsDataURL(file);
    };
    input.click(); // 触发文件选择框
}


/**
 * 将新的字体预设保存到数据库
 * @param {number} slotIndex - 卡槽索引
 * @param {string} name - 字体名称
 * @param {string} url - 字体URL (网络或Base64)
 */
// ▼▼▼ 用下面这整块代码，替换掉你旧的 saveFontPreset 函数 ▼▼▼
async function saveFontPreset(slotIndex, name, url) {
    try {
        const presets = await db.fontPresets.toArray();
        const newPreset = { id: 'font_' + Date.now(), name, url };
        presets.splice(slotIndex, 0, newPreset);
        const presetsToSave = presets.slice(0, 5);

        // 【核心修改】使用数据库事务来保证操作的原子性
        await db.transaction('rw', db.fontPresets, async () => {
            await db.fontPresets.clear();
            await db.fontPresets.bulkPut(presetsToSave);
        });

        // 双重备份：同时保存到localStorage
        try {
            const backupData = JSON.stringify(presetsToSave);
            localStorage.setItem('fontPresets_backup', backupData);
            console.log('字体预设已备份到localStorage');
        } catch (error) {
            console.error('备份字体预设失败:', error);
        }

        await renderFontPresets();
        alert(`字体 "${name}" 已成功保存到卡槽 ${slotIndex + 1}！`);
    } catch (error) {
        // 【核心修改】如果出错，会在这里捕获，并告知用户数据是安全的
        console.error("保存字体预设失败:", error);
        alert(`保存字体失败，数据已自动回滚，你之前的字体数据是安全的。错误: ${error.message}`);
        await renderFontPresets(); // 失败后重新渲染，恢复到旧的列表状态
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 删除一个字体预设
 * @param {string} presetId - 要删除的预设的ID
 */
async function deleteFontPreset(presetId) {
    const preset = await db.fontPresets.get(presetId);
    if (!preset) return;
    const confirmed = await showCustomConfirm("确认删除", `确定要删除字体 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.fontPresets.delete(presetId);
        
        // 从DOM中移除对应的预览样式
        const styleTag = document.getElementById(`font-style-${presetId}`);
        if (styleTag) styleTag.remove();

        await renderFontPresets();
    }
}

/**
 * 应用一个字体预设为全局字体
 * @param {string} presetId - 要应用的预设的ID
 */
async function applyFontPreset(presetId) {
    const preset = await db.fontPresets.get(presetId);
    if (preset) {
        // 调用你已有的全局字体应用函数
        applyCustomFont(preset.url, false);
        // 保存到全局设置
        state.globalSettings.fontUrl = preset.url;
        await db.globalSettings.put(state.globalSettings);
        alert(`已将全局字体更换为 "${preset.name}"！`);
    }
}

// ▲▲▲ 新功能函数粘贴结束 ▲▲▲

/**
 * 【总入口】处理用户选择的角色卡文件
 * @param {File} file - 用户选择的文件对象
 */
async function handleCharacterImport(file) {
    if (!file) return;

    try {
        let characterData;
        let avatarBase64;

        if (file.name.toLowerCase().endsWith('.png')) {
            // 如果是PNG文件，调用PNG解析函数
            const result = await parseCharPng(file);
            characterData = result.characterData;
            avatarBase64 = result.avatarBase64;
        } else if (file.name.toLowerCase().endsWith('.json')) {
            // 如果是JSON文件，调用JSON解析函数
            characterData = await parseCharJson(file);
            // JSON卡通常不包含图片，我们给一个默认头像
            avatarBase64 = defaultAvatar;
        } else {
            alert('不支持的文件格式，请选择 .png 或 .json 文件。');
            return;
        }

        if (characterData) {
            // 成功解析出数据后，调用创建函数
            await createCharacterFromData(characterData, avatarBase64);
        }

    } catch (error) {
        console.error("导入角色卡失败:", error);
        alert(`导入失败: ${error.message}`);
    }
}

/**
 * 【V3 - 最终乱码修复版】
 * 解析SillyTavern的PNG角色卡，通过字节级操作彻底解决中文乱码问题。
 * @param {File} file - PNG文件
 * @returns {Promise<{characterData: object, avatarBase64: string}>}
 */
async function parseCharPng(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const arrayBuffer = e.target.result;
            const dataView = new DataView(arrayBuffer);

            if (dataView.getUint32(0) !== 0x89504E47 || dataView.getUint32(4) !== 0x0D0A1A0A) {
                return reject(new Error('文件不是一个有效的PNG图片。'));
            }

            let offset = 8;
            let characterJson = null;

            while (offset < dataView.byteLength) {
                const length = dataView.getUint32(offset);
                const type = String.fromCharCode(
                    dataView.getUint8(offset + 4),
                    dataView.getUint8(offset + 5),
                    dataView.getUint8(offset + 6),
                    dataView.getUint8(offset + 7)
                );

                if (type === 'tEXt') {
                    const chunkData = new Uint8Array(arrayBuffer, offset + 8, length);
                    
                    // ★★★★★【这是本次修复乱码的核心代码】★★★★★
                    // 1. 先用一个简单的编码将字节转为字符串，以便查找关键字 "chara"
                    let text = '';
                    for (let i = 0; i < chunkData.length; i++) {
                        text += String.fromCharCode(chunkData[i]);
                    }

                    // 2. 检查关键字是否存在
                    const keyword = 'chara' + String.fromCharCode(0);
                    if (text.startsWith(keyword)) {
                        // 3. 提取出关键字后面的 Base64 编码的字符串
                        const base64Data = text.substring(keyword.length);
                        try {
                            // 4. 使用 atob() 解码 Base64，得到一个“二进制字符串”
                            const binaryString = atob(base64Data);
                            
                            // 5. 将这个“二进制字符串”重新转换为原始的 UTF-8 字节数组
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }
                            
                            // 6. 使用 TextDecoder 将这个纯净的 UTF-8 字节数组解码为正确的字符串
                            const decodedJsonString = new TextDecoder('utf-8').decode(bytes);
                            
                            // 7. 解析最终的JSON字符串
                            characterJson = JSON.parse(decodedJsonString);
                            break;
                        } catch (e) {
                            return reject(new Error('解析图片内嵌的角色数据失败，可能是数据损坏。'));
                        }
                    }
                    // ★★★★★【核心代码结束】★★★★★
                }
                
                if (type === 'IEND') break;
                offset += 12 + length;
            }

            if (characterJson) {
                const imageReader = new FileReader();
                imageReader.onload = (imgEvent) => {
                    resolve({
                        characterData: characterJson,
                        avatarBase64: imgEvent.target.result
                    });
                };
                imageReader.onerror = () => reject(new Error('读取图片作为头像失败。'));
                imageReader.readAsDataURL(file);
            } else {
                reject(new Error('在这张PNG图片中没有找到SillyTavern角色数据。'));
            }
        };
        reader.onerror = () => reject(new Error('读取PNG文件失败。'));
        reader.readAsArrayBuffer(file);
    });
}


/**
 * 解析JSON角色卡
 * @param {File} file - JSON文件
 * @returns {Promise<object>}
 */
/**
 * 【修正版】解析JSON角色卡，强制使用UTF-8编码
 * @param {File} file - JSON文件
 * @returns {Promise<object>}
 */
async function parseCharJson(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                // 核心修正：先读取为ArrayBuffer，再用TextDecoder指定UTF-8解码
                const arrayBuffer = e.target.result;
                const textDecoder = new TextDecoder('utf-8');
                const jsonString = textDecoder.decode(arrayBuffer);
                const data = JSON.parse(jsonString);
                // 兼容两种可能的格式
                resolve(data.data || data);
            } catch (error) {
                reject(new Error('解析JSON文件失败，请检查文件格式或编码。'));
            }
        };
        reader.onerror = () => reject(new Error('读取JSON文件失败。'));
        // 核心修正：读取为ArrayBuffer而不是Text
        reader.readAsArrayBuffer(file);
    });
}

/**
 * 【V5 - 最终适配版 - 识别 character_book】
 * 根据解析出的数据创建新角色和世界书。
 * 这个版本将优先查找您提供的 character_book 标准格式。
 * @param {object} data - 从卡片解析出的最原始的JSON数据
 * @param {string} avatarBase64 - 角色的头像图片 (Base64)
 */
async function createCharacterFromData(data, avatarBase64) {
    // 步骤 1: 确定核心角色数据 (不变)
    const charData = data.data || data;
    const characterName = charData.name ? charData.name.trim() : '未命名角色';
    
    // 步骤 2: 创建新的聊天对象 (不变)
    const newChatId = 'chat_' + Date.now();
// 这是修改后的新代码块
const newChat = {
    id: newChatId,
    name: characterName,
    isGroup: false,
    isPinned: false,
    npcLibrary: [],
    relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
    status: { text: '在线', lastUpdate: Date.now(), isBusy: false },
    settings: {
        aiPersona: charData.description || '该角色没有描述。',
        myPersona: '我是谁呀。',
        maxMemory: 10,
        aiAvatar: avatarBase64,
        myAvatar: defaultAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: [],
        aiAvatarLibrary: [],
    },
    history: [],
    musicData: { totalTime: 0 },
    // ▼▼▼ 把原来的那一行替换成下面这整块 ▼▼▼
    characterPhoneData: {
        lastGenerated: null,
        chats: {},
        shoppingCart: [],
        memos: [],
        browserHistory: [],
        photoAlbum: [],
        bank: { balance: 0, transactions: [] },
        trajectory: [],
        appUsage: [],
        diary: []
    }
    // ▲▲▲ 替换结束 ▲▲▲
};
    await db.chats.put(newChat);
    state.chats[newChatId] = newChat;
    
    // =================================================================
    // ▼▼▼ 核心修改：重构世界书查找逻辑 + 自动关联世界书 ▼▼▼
    // =================================================================
    
    console.log("开始检测世界书数据...");
    let worldBookFound = false;
    let importedWorldBookIds = []; // 存储导入的世界书ID

    // 策略一：【最高优先级】查找您提供的 character_book 标准格式
    if (charData.character_book && charData.character_book.entries && Array.isArray(charData.character_book.entries) && charData.character_book.entries.length > 0) {
        console.log(`检测到最新的 character_book 格式 (${charData.character_book.entries.length}条)，开始导入...`);
        const newCategory = { name: characterName, isGlobal: false };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        // 我们将调用【修改后】的辅助函数来处理，并获取导入的世界书ID
        const importedIds = await saveWorldBookEntriesFromArray(charData.character_book.entries, newCategoryId);
        importedWorldBookIds = importedIds;
        worldBookFound = true;
    }
    
    // 策略二：兼容旧的 world_entries 格式
    else if (charData.world_entries && Array.isArray(charData.world_entries) && charData.world_entries.length > 0) {
        console.log(`检测到旧版 world_entries 格式 (${charData.world_entries.length}条)，开始导入...`);
        const newCategory = { name: characterName, isGlobal: false };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        const importedIds = await saveWorldBookEntriesFromArray(charData.world_entries, newCategoryId);
        importedWorldBookIds = importedIds;
        worldBookFound = true;
    }
    
    // 策略三：兼容更旧的 data.world 格式
    else if (data.world && typeof data.world === 'string' && data.world.trim()) {
        console.log("检测到外层 world 字段格式，开始导入...");
        const newCategory = { name: characterName, isGlobal: false };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await parseAndSaveWorldBooks(data.world, newCategoryId);
        worldBookFound = true;
        // 注意：parseAndSaveWorldBooks 函数可能需要修改以返回ID，这里暂时不处理
    }

    // 策略四：最后的兼容手段 world_info
    else if (charData.world_info && typeof charData.world_info === 'string' && charData.world_info.trim()) {
        console.log("检测到旧版 world_info 字段格式，开始导入...");
        const newCategory = { name: characterName, isGlobal: false };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await parseAndSaveWorldBooks(charData.world_info, newCategoryId);
        worldBookFound = true;
        // 注意：parseAndSaveWorldBooks 函数可能需要修改以返回ID，这里暂时不处理
    }

    // 🎯 自动关联导入的世界书到角色设置
    if (worldBookFound && importedWorldBookIds.length > 0) {
        newChat.settings.linkedWorldBookIds = importedWorldBookIds;
        console.log(`✅ 自动关联了 ${importedWorldBookIds.length} 个世界书到角色设置中`);
        
        // 更新数据库中的聊天设置
        await db.chats.put(newChat);
        state.chats[newChatId] = newChat;
    }

    if (!worldBookFound) {
        console.log("诊断：在此角色卡中未找到任何可识别的世界书字段。");
    }
    
    // =================================================================
    // ▲▲▲ 核心修改结束 ▲▲▲
    // =================================================================

    // 步骤 4: 刷新UI - 包括世界书屏幕
    await renderChatList();
    
    // 如果导入了世界书，需要刷新世界书屏幕的UI
    if (worldBookFound && window.renderWorldBookScreenProxy) {
        console.log("🔄 检测到世界书导入，正在刷新世界书屏幕UI...");
        await window.renderWorldBookScreenProxy();
    }
    
    await showCustomAlert('导入成功！', `角色"${characterName}"已成功创建！${worldBookFound ? '\n世界书也已同步导入并自动关联到角色设置中！' : ''}`);
}


/**
 * 【V2 - 适配 comment 字段 + 返回导入的世界书ID】
 * 从SillyTavern的 world_entries 或 character_book.entries 数组直接创建世界书
 * @param {Array<object>} entriesArray - 包含世界书条目的数组
 * @param {number} categoryId - 这些世界书所属的分类ID
 * @returns {Promise<Array<string>>} - 返回导入的世界书ID数组
 */
async function saveWorldBookEntriesFromArray(entriesArray, categoryId) {
    const newBooks = [];
    const importedIds = []; // 存储导入的世界书ID

    for (const entry of entriesArray) {
        // ▼▼▼ 核心修改：智能获取条目名称 ▼▼▼
        // 优先使用 comment 字段作为标题，如果它存在且不为空。
        // 否则，再尝试使用 keys 数组。
        // 如果都没有，就给一个默认名字。
        const entryName = (entry.comment && entry.comment.trim()) 
                          ? entry.comment.trim() 
                          : (entry.keys && entry.keys.length > 0 ? entry.keys.join(', ') : '未命名条目');
        // ▲▲▲ 核心修改结束 ▲▲▲

        // 检查条目是否有效 (有名字、有内容，并且是启用的)
        // (typeof entry.enabled === 'undefined' || entry.enabled) 是为了兼容没有 enabled 字段的卡片
        if (entryName !== '未命名条目' && entry.content && (typeof entry.enabled === 'undefined' || entry.enabled)) {
            const worldBookId = 'wb_' + Date.now() + Math.random();
            newBooks.push({
                id: worldBookId,
                name: entryName, // 使用我们智能获取到的名字
                content: entry.content,
                categoryId: categoryId,
                isGlobal: false // 明确标记为局部世界书
            });
            importedIds.push(worldBookId); // 记录导入的ID
        }
    }

    if (newBooks.length > 0) {
        await db.worldBooks.bulkAdd(newBooks);
        // 确保 state.worldBooks 也被更新，以便UI能立即显示
        const allBooks = await db.worldBooks.toArray();
        state.worldBooks = allBooks;
        console.log(`成功导入 ${newBooks.length} 个世界书条目到分类ID: ${categoryId}`);
    }
    
    return importedIds; // 返回导入的世界书ID数组
}



// 【辅助函数】获取事件的坐标
function getEventCoords(e) {
    // 如果是触摸事件，就从 e.touches[0] 获取
    if (e.touches && e.touches[0]) {
        return { x: e.touches[0].pageX, y: e.touches[0].pageY };
    }
    // 否则，就是鼠标事件，直接从 e 获取
    return { x: e.pageX, y: e.pageY };
}

function showScreen(screenId) {
    // 隐藏所有子相册相关的弹窗和设置（无论切换到哪个页面）
    document.getElementById('album-settings-menu').style.display = 'none';
    document.getElementById('delete-album-confirm').style.display = 'none';
    document.getElementById('contact-binding-dialog').style.display = 'none';
    document.getElementById('love-settings-modal').style.display = 'none';
    
    // 🛍️ 商城缓存管理：离开商城时清空缓存，节省内存
    if (screenId !== 'shopping-screen') {
        // 清空系统商品缓存
        if (typeof systemProductsCache !== 'undefined' && systemProductsCache !== null) {
            systemProductsCache = null;
        }
        // 重置商城加载标志，下次进入重新加载
        if (typeof isMallDataLoaded !== 'undefined') {
            isMallDataLoaded = false;
        }
    }
    
    // 管理body类以控制导航栏显示
    if (screenId === 'chat-list-screen') {
        document.body.classList.add('on-chat-list-screen');
        window.renderChatListProxy(); 
        switchToChatListView('messages-view');
    } else {
        document.body.classList.remove('on-chat-list-screen');
    }
    if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
    if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
    if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
    if (screenId === 'x-social-screen') window.renderXSocialScreenProxy();
    
    // 确保恋爱空间在切换到其他屏幕时被隐藏
    const loveSpaceView = document.getElementById('love-space-view');
    if (loveSpaceView && screenId !== 'chat-list-screen') {
        loveSpaceView.style.display = 'none';
    }
    
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const screenToShow = document.getElementById(screenId);
    if (screenToShow) screenToShow.classList.add('active');
    if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
    if (screenId === 'font-settings-screen') {
        // 更新全局字体预览
        document.getElementById('font-preview').style.fontFamily = '';
        applyCustomFont(state.globalSettings.fontUrl || '', true);
        
        // 渲染5个预设卡槽
        renderFontPresets();
    }
}
        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
            const chatListScreen = document.getElementById('chat-list-screen');
            const views = {
                'messages-view': document.getElementById('messages-view'),
                'qzone-screen': document.getElementById('qzone-screen'),
                'favorites-view': document.getElementById('favorites-view'),
        'memories-view': document.getElementById('memories-view') // <-- 新增这一行
    };
            const mainHeader = document.getElementById('main-chat-list-header');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏

            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }

            // 隐藏所有子相册相关的弹窗和设置
            document.getElementById('album-settings-menu').style.display = 'none';
            document.getElementById('delete-album-confirm').style.display = 'none';
            document.getElementById('contact-binding-dialog').style.display = 'none';
            document.getElementById('love-settings-modal').style.display = 'none';

            // 【修复】确保chat-list-screen激活，以便导航栏正确显示
            chatListScreen.classList.add('active');
            
            // 【修复】当切换到QQ主页面视图时，添加on-chat-list-screen类
            // 只有消息页面才显示QQ主页导航栏，动态页面和恋爱空间都不显示
            if (viewId === 'messages-view') {
                document.body.classList.add('on-chat-list-screen');
            } else {
                document.body.classList.remove('on-chat-list-screen');
            }

            // 隐藏所有视图
            Object.values(views).forEach(v => v.classList.remove('active'));
            // 显示目标视图
            if (views[viewId]) {
                views[viewId].classList.add('active');
            }

            // 更新底部导航栏高亮
            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.view === viewId);
            });
            
            // ▼▼▼ 【核心修正】移除内联样式设置，让CSS规则正常工作 ▼▼▼
            // CSS规则会自动控制导航栏显隐：
            // #chat-list-screen.active #chat-list-bottom-nav { display: flex !important; }
            
            if (viewId === 'messages-view') {
                mainHeader.style.display = 'flex';
                // 移除内联样式设置，让CSS规则控制导航栏
            } else {
                mainHeader.style.display = 'none';
                // 移除内联样式设置，让CSS规则控制导航栏
            }
            
            // 确保恋爱空间在切换到其他视图时被隐藏（除了memories-view）
            const loveSpaceView = document.getElementById('love-space-view');
            if (loveSpaceView && viewId !== 'memories-view') {
                loveSpaceView.style.display = 'none';
            }
            // ▲▲▲ 修正结束 ▲▲▲

    if (viewId !== 'memories-view') {
        activeCountdownTimers.forEach(timerId => clearInterval(timerId));
        activeCountdownTimers = [];
    }

            // 根据视图ID执行特定的渲染/更新逻辑
            switch (viewId) {
                case 'qzone-screen':
                    views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                    updateUnreadIndicator(0);
                    renderQzoneScreen();
                    renderQzonePosts();
                    break;
                case 'favorites-view':
                    views['favorites-view'].style.backgroundColor = '#f9f9f9';
                    renderFavoritesScreen();
                    break;
                case 'messages-view':
                    // 如果需要，可以在这里添加返回消息列表时要执行的逻辑
                    break;
            }
        }

            // X社交页面渲染函数
      function renderXSocialScreen() {
        // 暂时为空，后续添加X社交页面的渲染逻辑
        console.log("渲染X社交页面");
      }
      window.renderXSocialScreenProxy = renderXSocialScreen;
        
        function renderQzoneScreen() {
            if (state && state.qzoneSettings) {
                const settings = state.qzoneSettings;
                document.getElementById('qzone-nickname').textContent = settings.nickname;
                document.getElementById('qzone-avatar-img').src = settings.avatar;
                document.getElementById('qzone-banner-img').src = settings.banner;
            }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
            if (db && state.qzoneSettings) {
                await db.qzoneSettings.put(state.qzoneSettings);
            }
        }

        function formatPostTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);
            const diffSeconds = Math.floor((now - date) / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffMinutes < 1) return '刚刚';
            if (diffMinutes < 60) return `${diffMinutes}分钟前`;
            if (diffHours < 24) return `${diffHours}小时前`;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            if (now.getFullYear() === year) {
                return `${month}-${day} ${hours}:${minutes}`;
            } else {
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            }
        }

// ▼▼▼ 步骤3.1：用这整块【终极修复版】代码替换旧的 renderQzonePosts 函数 ▼▼▼
async function renderQzonePosts() {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [posts, favorites] = await Promise.all([
        db.qzonePosts.orderBy('timestamp').reverse().toArray(),
        db.favorites.where('type').equals('qzone_post').toArray()
    ]);

    const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
    
    postsListEl.innerHTML = '';

    if (posts.length === 0) {
        postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
        return;
    }

    const userSettings = state.qzoneSettings;
    
// ▼▼▼ 从这里开始替换 ▼▼▼
// ★★★★★ 这就是我们这次修复的核心 ★★★★★
// 1. 在渲染所有帖子之前，我们先创建一个包含所有AI角色名字的集合(Set)，方便快速查找。
const allAiCharacterNames = new Set(Object.values(state.chats).filter(chat => !chat.isGroup).map(chat => chat.name));
// ★★★★★ 修复结束 ★★★★★

posts.forEach(post => {
    const postContainer = document.createElement('div');
    postContainer.className = 'qzone-post-container';
    postContainer.dataset.postId = post.id;

    const postEl = document.createElement('div');
    postEl.className = 'qzone-post-item';

    let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar; 

    if (post.authorId === 'user') {
        authorAvatar = userSettings.avatar;
        authorNickname = userSettings.nickname;
    } else if (state.chats[post.authorId]) {
        const authorChat = state.chats[post.authorId];
        authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
        authorNickname = authorChat.name;
    } else {
        authorAvatar = defaultAvatar;
        authorNickname = '{{char}}';
    }
    
    // 【新增】添加发送者信息到容器数据属性，用于私人照片加载
    postContainer.dataset.authorNickname = authorNickname;
    
    let contentHtml = '';
    const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

    if (post.type === 'shuoshuo') {
        contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${processAlbumPhotos(post.content.replace(/\n/g, '<br>'))}</div>`;
    } 
    else if (post.type === 'image_post' && post.imageUrl) {
        contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
    } 
    else if (post.type === 'text_image') {
        contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://youke1.picui.cn/s1/2025/10/08/68e63e4499ee1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
    }
    else if (post.type === 'realimag') {
        // RealImag真实图片动态渲染（支持多图布局）
        const imageUrls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);
        
        if (imageUrls.length > 0) {
            const imageCount = imageUrls.length;
            let imagesHtml = '';
            
            // 使用统一的多图布局（包括单张图片）
            imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
            imageUrls.forEach((url, index) => {
                imagesHtml += `<img src="${url}" class="realimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
            });
            imagesHtml += '</div>';
            
            contentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
        }
    }
    else if (post.type === 'naiimag') {
        // NovelAI图片动态渲染（支持多图布局，最多2张）
        const imageUrls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);
        
        if (imageUrls.length > 0) {
            const imageCount = imageUrls.length;
            let imagesHtml = '';
            
            // 使用统一的多图布局（包括单张图片）
            imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
            imageUrls.forEach((url, index) => {
                imagesHtml += `<img src="${url}" class="naiimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
            });
            imagesHtml += '</div>';
            
            contentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
        }
    }

    let likesHtml = '';
    if (post.likes && post.likes.length > 0) {
        likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join('、')} 觉得很赞</span></div>`;
    }
    
    let commentsHtml = '';
    if (post.comments && post.comments.length > 0) {
        // ★★★★★ 这就是我们这次修复的核心 ★★★★★
        // 2. 修改这里的过滤逻辑
        const commentsToShow = post.areCommentsVisible === false 
            ? post.comments.filter(comment => 
                // 条件1: 评论者是你自己
                comment.commenterName === userSettings.nickname || 
                // 条件2: 评论者的名字在我们刚才创建的AI角色名字列表里
                allAiCharacterNames.has(comment.commenterName)
              )
            : post.comments; // 如果开关是开的，就显示所有评论
        // ★★★★★ 修复结束 ★★★★★

        if (commentsToShow.length > 0) {
// ▲▲▲ 替换到这里结束 ▲▲▲

                commentsHtml = '<div class="post-comments-container">';
                commentsToShow.forEach(comment => {
                    const originalIndex = post.comments.indexOf(comment);
                    let replyHtml = '';
                    if (comment.replyTo) {
                        replyHtml = `<span class="reply-text">回复</span> <span class="reply-target-name">${comment.replyTo}</span>`;
                    }
                    commentsHtml += `
                        <div class="comment-item" data-commenter-name="${comment.commenterName}">
                            <span class="commenter-name">${comment.commenterName}</span>${replyHtml}:
                            <span class="comment-text"> ${comment.text}</span>
                            <span class="comment-delete-btn" data-comment-index="${originalIndex}">×</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }
        }

        const commentsAndFooterHtml = `
            ${commentsHtml}
            <div class="post-footer">
                <div class="comment-section">
                    <img src="${commentAvatar}" class="comment-avatar">
                    <input type="text" class="comment-input" placeholder="友善的评论是交流的起点">
                    <div class="at-mention-popup"></div>
                </div>
                <button class="comment-send-btn">发送</button>
            </div>
        `;

        const userNickname = state.qzoneSettings.nickname;
        const isLikedByUser = post.likes && post.likes.includes(userNickname);
        const isFavoritedByUser = favoritedPostIds.has(post.id);

        postEl.innerHTML = `
            <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span></div>
                <div class="post-actions-btn">…</div>
            </div>
            <div class="post-main-content">${contentHtml}</div>
            <div class="post-feedback-icons">
                <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                <span class="action-icon summon-npc" data-post-id="${post.id}" data-author-id="${post.authorId}" title="召唤NPC评论"><svg viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></span>
                </div>
            ${likesHtml}
            ${commentsAndFooterHtml} 
        `;
        
        const deleteAction = document.createElement('div');
        deleteAction.className = 'qzone-post-delete-action';
        deleteAction.innerHTML = '<span>删除</span>';
        postContainer.appendChild(postEl);
        postContainer.appendChild(deleteAction);
        const commentSection = postContainer.querySelector('.comment-section');
        if (commentSection) {
            commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
            commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
        }
        postsListEl.appendChild(postContainer);
        const commentInput = postContainer.querySelector('.comment-input');
        if (commentInput) {
            const popup = postContainer.querySelector('.at-mention-popup');
            commentInput.addEventListener('input', () => {
                const value = commentInput.value;
                const atMatch = value.match(/@([\p{L}\w]*)$/u);
                if (atMatch) {
                    const namesToMention = new Set();
                    const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                    if (authorNickname) namesToMention.add(authorNickname);
                    postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                        namesToMention.add(nameEl.textContent.replace(':', ''));
                    });
                    namesToMention.delete(state.qzoneSettings.nickname);
                    popup.innerHTML = '';
                    if (namesToMention.size > 0) {
                        const searchTerm = atMatch[1];
                        namesToMention.forEach(name => {
                            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                const item = document.createElement('div');
                                item.className = 'at-mention-item';
                                item.textContent = name;
                                item.addEventListener('mousedown', (e) => {
                                    e.preventDefault();
                                    const newText = value.substring(0, atMatch.index) + `@${name} `;
                                    commentInput.value = newText;
                                    popup.style.display = 'none';
                                    commentInput.focus();
                                });
                                popup.appendChild(item);
                            }
                        });
                        popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                    } else {
                        popup.style.display = 'none';
                    }
                } else {
                    popup.style.display = 'none';
                }
            });
            commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });
        }
    });
    
    // 【新增】异步加载所有相册照片
    setTimeout(() => {
        const postContainers = postsListEl.querySelectorAll('.qzone-post-container');
        postContainers.forEach(container => {
            loadAlbumPhotosInElement(container);
            // 【修复】传入发送者名称，确保私人照片能正确加载
            const authorNickname = container.dataset.authorNickname;
            loadPrivatePhotosInElement(container, authorNickname);
        });
    }, 100);
}
// ▲▲▲ 步骤3.1替换结束 ▲▲▲
async function renderFollowingFeed() {
    const feedListEl = document.getElementById('weibo-following-feed-list');
    if (!feedListEl) return;

    // 1. 从数据库获取所有动态
    const allPosts = await db.qzonePosts.orderBy('timestamp').reverse().toArray();
    
    // 2. 【核心】筛选出作者不是 'user' 的动态
    const followingPosts = allPosts.filter(post => post.authorId !== 'user');

    feedListEl.innerHTML = ''; // 清空旧内容

    if (followingPosts.length === 0) {
        feedListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">你关注的人还没有发布任何动态哦。</p>';
        return;
    }

    // 3. 遍历筛选后的动态，并渲染它们
    //    【提示】这里创建单个动态HTML的逻辑，可以完全复制 `renderQzonePosts` 函数里的 forEach 循环内部的代码。
    //    你只需要把目标容器从 `postsListEl` 改为 `feedListEl` 即可。
    followingPosts.forEach(post => {
        // ... 在这里粘贴 renderQzonePosts 函数中创建 postContainer、postEl 的那一大段代码 ...
        // ... 记得最后要把 postContainer append 到 feedListEl 中 ...
        // feedListEl.appendChild(postContainer);
    });
}

// ▼▼▼ 请用下面这个【更新后的】函数，完整替换掉你代码中旧的 displayFilteredFavorites 函数 ▼▼▼

function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
        const searchTerm = document.getElementById('favorites-search-input').value;
        const message = searchTerm ? '未找到相关收藏' : '你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    for (const item of items) {
        const card = document.createElement('div');
        card.className = 'favorite-item-card';
        card.dataset.favid = item.id;

        let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

        if (item.type === 'qzone_post') {
            const post = item.content;
            sourceText = '来自动态';
            let authorAvatar = defaultAvatar, authorNickname = '未知用户';

            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
            }

            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
            
            const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            if (post.type === 'shuoshuo') {
                contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
            } else if (post.type === 'image_post' && post.imageUrl) {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === 'text_image') {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            }

            // ▼▼▼ 新增/修改的代码开始 ▼▼▼
            
            // 1. 构造点赞区域的HTML
            let likesHtml = '';
            // 检查 post 对象中是否存在 likes 数组并且不为空
            if (post.likes && post.likes.length > 0) {
                // 如果存在，就创建点赞区域的 div
                likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join('、')} 觉得很赞</span>
                    </div>`;
            }

            // 2. 构造评论区域的HTML
            let commentsHtml = '';
            // 检查 post 对象中是否存在 comments 数组并且不为空
            if (post.comments && post.comments.length > 0) {
                // 如果存在，就创建评论容器，并遍历每一条评论
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach(comment => {
                    commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }

            // 3. 将点赞和评论的HTML组合到 footerHtml 中
            footerHtml = `${likesHtml}${commentsHtml}`;
            
            // ▲▲▲ 新增/修改的代码结束 ▲▲▲

} else if (item.type === 'chat_message') {
    const msg = item.content;
    const chat = state.chats[item.chatId];
    if (!chat) continue; 

    sourceText = `来自与 ${chat.name} 的聊天`;
    const isUser = msg.role === 'user';
    let senderName, senderAvatar;

    if (isUser) {
        // 用户消息的逻辑保持不变
        senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
    } else { // AI/成员消息

         if (chat.isGroup) {
            // ★★★★★ 这就是唯一的、核心的修改！ ★★★★★
            // 我们现在使用 originalName 去匹配，而不是旧的 name
            const member = chat.members.find(m => m.originalName === msg.senderName);
            // ★★★★★ 修改结束 ★★★★★
            
            senderName = msg.senderName;
            // 因为现在能正确找到 member 对象了，所以也能正确获取到他的头像
            senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
        } else {
            // 单聊的逻辑保持不变
            senderName = chat.name;
            senderAvatar = chat.settings.aiAvatar || defaultAvatar;
        }
    }

    // 后续拼接 headerHtml 和 contentHtml 的逻辑都保持不变
    headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
    
    // ▼▼▼ 新增：处理语音消息 ▼▼▼
    if (msg.type === 'voice_message') {
        const duration = Math.max(1, Math.round((msg.content || '').length / 5));
        const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
        const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
        
        card.classList.add('is-voice-message');
        card.dataset.voiceText = msg.content;
        card.dataset.voiceId = msg.voiceId || '';
        card.dataset.voiceCacheKey = msg.voiceCacheKey || '';
        
        contentHtml = `
            <div class="voice-message-body" style="display: flex; align-items: center; cursor: pointer; padding: 8px 12px; min-width: 80px; max-width: 200px;">
                <div class="voice-waveform" style="display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px;">${waveformHTML}</div>
                <div class="loading-spinner" style="display: none;"></div>
                <span class="voice-duration">${durationFormatted}</span>
            </div>
            <div class="voice-transcript" style="display: none; padding: 8px 12px; border-top: 1px solid var(--border-color); color: var(--text-secondary); font-size: 0.9em;"></div>
        `;
    } else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
// ▼▼▼ 请用这【一整块新代码】替换掉上面那段旧的 else { ... } 代码块 ▼▼▼
// ▼▼▼ 请用这【一整块新代码】再次替换掉 createMessageElement 函数里的 else { ... } 代码块 ▼▼▼
} else {
    const messageText = String(msg.content || '');
    // 侦测格式：[sticker:名字]
    const stickerMatch = messageText.match(/\[sticker:\s*(.+?)\s*\]/i);

    if (stickerMatch) {
        // 如果匹配成功，提取出名字
        const stickerName = stickerMatch[1].trim();
        // 根据名字去您的表情包列表里查找
        const foundSticker = state.userStickers.find(s => s.name === stickerName);
        
        if (foundSticker) {
            // 如果找到了，就显示图片！
            contentHtml = `<img src="${foundSticker.url}" alt="${foundSticker.name}" class="sticker-image">`;
        } else {
            // 如果没找到（比如AI自己编了个名字），就还是按普通文字显示
            contentHtml = messageText.replace(/\n/g, '<br>');
        }
    } else {
        // 如果不匹配，就是普通的文本消息
        contentHtml = messageText.replace(/\n/g, '<br>');
    }
}
    // ▲▲▲ 新增结束 ▲▲▲
// ▲▲▲ 替换结束 ▲▲▲

}
        
        // ▼▼▼ 修改最终的HTML拼接，加入 footerHtml ▼▼▼
        card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- 把我们新创建的 footerHtml 放在这里
            
        listEl.appendChild(card);
    }
}

// ▲▲▲ 替换区域结束 ▲▲▲

        /**
         * 【重构后的函数】: 负责准备数据并触发渲染
         */
        async function renderFavoritesScreen() {
            // 1. 从数据库获取最新数据并缓存
            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
            
            // 2. 清空搜索框并隐藏清除按钮
            const searchInput = document.getElementById('favorites-search-input');
            const clearBtn = document.getElementById('favorites-search-clear-btn');
            searchInput.value = '';
            clearBtn.style.display = 'none';

            // 3. 显示所有收藏项
            displayFilteredFavorites(allFavoriteItems);
        }

        // ▲▲▲ 粘贴结束 ▲▲▲

// === 【新增】分组可见性相关函数 ===
async function loadGroupsForVisibility() {
    const groupCheckboxes = document.getElementById('group-checkboxes');
    if (!groupCheckboxes) return;
    
    try {
        const groups = await db.qzoneGroups.toArray();
        groupCheckboxes.innerHTML = '';
        
        if (groups.length === 0) {
            groupCheckboxes.innerHTML = '<div style="color: #999; text-align: center; padding: 10px;">暂无分组，请先在设置中创建分组</div>';
            return;
        }
        
        groups.forEach(group => {
            const checkboxWrapper = document.createElement('div');
            checkboxWrapper.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px;';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `group-${group.id}`;
            checkbox.value = group.id;
            checkbox.style.marginRight = '8px';
            
            const label = document.createElement('label');
            label.htmlFor = `group-${group.id}`;
            label.textContent = group.name;
            label.style.cursor = 'pointer';
            
            checkboxWrapper.appendChild(checkbox);
            checkboxWrapper.appendChild(label);
            groupCheckboxes.appendChild(checkboxWrapper);
        });
    } catch (error) {
        console.error('加载分组列表失败:', error);
        groupCheckboxes.innerHTML = '<div style="color: #f44336; text-align: center; padding: 10px;">加载分组失败</div>';
    }
}

function getSelectedGroupIds() {
    const visibilityMode = document.querySelector('input[name="post-visibility"]:checked')?.value;
    if (visibilityMode !== 'selected') return null;
    
    const checkedBoxes = document.querySelectorAll('#group-checkboxes input[type="checkbox"]:checked');
    return Array.from(checkedBoxes).map(cb => parseInt(cb.value));
}

function resetCreatePostModal() {
    document.getElementById('post-public-text').value = '';
    document.getElementById('post-image-preview').src = '';
    document.getElementById('post-image-description').value = '';
    document.getElementById('post-image-preview-container').classList.remove('visible');
    document.getElementById('post-image-desc-group').style.display = 'none';
    document.getElementById('post-local-image-input').value = '';
    document.getElementById('post-hidden-text').value = '';
    
    // 重置分组可见性选择
    const publicRadio = document.querySelector('input[name="post-visibility"][value="public"]');
    const selectedRadio = document.querySelector('input[name="post-visibility"][value="selected"]');
    const groupSelector = document.getElementById('group-selector');
    if (publicRadio) publicRadio.checked = true;
    if (selectedRadio) selectedRadio.checked = false;
    if (groupSelector) groupSelector.style.display = 'none';
    
    // 取消所有分组的选中状态
    const groupCheckboxes = document.querySelectorAll('#group-checkboxes input[type="checkbox"]');
    groupCheckboxes.forEach(cb => cb.checked = false);

    // 【核心修复】我们不再模拟点击，而是直接、安全地设置状态
    const imageModeBtn = document.getElementById('switch-to-image-mode');
    const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
    const imageModeContent = document.getElementById('image-mode-content');
    const textImageModeContent = document.getElementById('text-image-mode-content');
    
    // 重置display样式，确保元素可见
    imageModeContent.style.display = '';
    textImageModeContent.style.display = '';
    
    imageModeBtn.classList.add('active');
    textImageModeBtn.classList.remove('active');
    imageModeContent.classList.add('active');
    textImageModeContent.classList.remove('active');
}

// ▼▼▼ 用这个【真正修复版】，完整替换掉你现在的 exportBackup 函数 ▼▼▼
async function exportBackup() {
    try {
        const backupData = {
            version: 1, 
            timestamp: Date.now()
        };

        // --- 核心修复：我们恢复使用精确的、逐个导出的方式 ---
        // 这样可以确保单条记录的表（如 globalSettings）被正确导出为对象，而不是数组
        const [
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories,
            worldBookCategories, callRecords, customAvatarFrames, themes,
            apiPresets, bubbleStylePresets
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.apiConfig.get('main'),          // <--- 看这里，使用 .get('main')
            db.globalSettings.get('main'),     // <--- 看这里，使用 .get('main')
            db.personaPresets.toArray(),
            db.musicLibrary.get('main'),       // <--- 看这里，使用 .get('main')
            db.qzoneSettings.get('main'),      // <--- 看这里，使用 .get('main')
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
            db.memories.toArray(),
            db.worldBookCategories.toArray(),
            db.callRecords.toArray(),
            db.customAvatarFrames.toArray(),
            db.themes.toArray(),
            db.apiPresets.toArray(),
            db.bubbleStylePresets.toArray()
        ]);

        // 将所有从数据库获取的数据正确地存入备份对象
        Object.assign(backupData, {
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories,
            worldBookCategories, callRecords, customAvatarFrames, themes,
            apiPresets, bubbleStylePresets
        });
        
        // --- ▼▼▼ 这是你新添加的功能，我们把它保留在这里 ▼▼▼ ---
        // 它现在会包含所有主屏幕和锁屏的外观元素
        // 注意：因为 globalSettings 已经被正确导出了，这里的壁纸、图标等数据其实是冗余的，
        // 但为了完全保留你的新功能逻辑，我们暂时留着它。
        // 未来的导入函数如果需要，就可以从 homeScreenState 中读取这些UI状态。
        backupData.homeScreenState = {
            // 1. 原有的个人资料卡和小组件数据 (添加安全检查)
            'profile-banner-img': document.getElementById('profile-banner-img')?.src || '',
            'profile-avatar-img': document.getElementById('profile-avatar-img')?.src || '',
            'profile-username': document.getElementById('profile-username')?.textContent || '',
            'profile-sub-username': document.getElementById('profile-sub-username')?.textContent || '',
            'profile-bio': document.getElementById('profile-bio')?.textContent || '',
            'profile-location': document.getElementById('profile-location')?.innerHTML || '',
            'widget-bubble-1': document.getElementById('widget-bubble-1')?.textContent || '',
            'widget-image-1': document.getElementById('widget-image-1')?.src || '',
            'widget-subtext-1': document.getElementById('widget-subtext-1')?.textContent || '',
            'widget-bubble-2': document.getElementById('widget-bubble-2')?.textContent || '',
            'widget-image-2': document.getElementById('widget-image-2')?.src || '',
            'widget-subtext-2': document.getElementById('widget-subtext-2')?.textContent || '',

            // 2. 【全新添加】壁纸和图标数据 (使用从数据库获取的globalSettings)
            'wallpaper': globalSettings?.wallpaper || '',
            'lockscreenWallpaper': globalSettings?.lockscreenWallpaper || '',
            'appIcons': globalSettings?.appIcons || {},
        };
        // --- ▲▲▲ 新功能保留结束 ▲▲▲

        // 后续的下载逻辑保持不变
        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
        });
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        await showCustomAlert('导出成功', '已成功导出所有数据！');

    } catch (error) {
        console.error("导出数据时出错:", error);
        await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
}




// ▼▼▼ 请用这【一整块终极修复版】的代码，完整替换掉你旧的 importBackup 函数 ▼▼▼
async function importBackup(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '严重警告！',
        '导入备份将完全覆盖您当前的所有数据，包括聊天、设置等。此操作不可撤销！您确定要继续吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        await db.transaction('rw', db.tables, async () => {
            // 1. 清空所有现有表格
            for (const table of db.tables) {
                await table.clear();
            }

            // 2. 【核心修复】智能、安全地导入数据
            // 我们会检查备份文件中的每一项数据，只有当当前代码的数据库里也存在对应的表格时，才进行导入
            
            // 导入数组类型的数据
            const arrayTables = [
                'chats', 'worldBooks', 'worldBookCategories', 'userStickers', 
                'personaPresets', 'qzonePosts', 'qzoneAlbums', 'qzonePhotos', 
                'favorites', 'qzoneGroups', 'memories', 'callRecords', 
                'customAvatarFrames', 'themes', 'apiPresets', 'bubbleStylePresets',
                // 就算备份文件里有下面这些新版才有的数据，这段代码也能安全跳过
                'fontPresets', 'homeScreenPresets' 
            ];

// ▼▼▼ 【全新】世界书格式兼容转换代码 ▼▼▼
for (const tableName of arrayTables) {
    if (Array.isArray(data[tableName]) && db[tableName]) {
        let itemsToPut = data[tableName];

        // 【核心逻辑】当处理世界书表格时，执行特别的转换操作
        if (tableName === 'worldBooks') {
            console.log("正在检查并转换世界书数据格式以兼容...");
            itemsToPut.forEach(book => {
                // 如果 content 是数组 (别人的格式)，则将其转换为字符串 (我的格式)
                if (Array.isArray(book.content)) {
                    console.log(`检测到数组格式的世界书: "${book.name}"，正在转换为字符串...`);
                    
                    // 将数组中的每个条目对象转换为格式化的字符串
                    const convertedEntries = book.content.map(entry => {
                        const stringParts = [];
                        if (entry.comment) {
                            stringParts.push(`[备注: ${entry.comment}]`);
                        }
                        if (entry.keys && entry.keys.length > 0) {
                            stringParts.push(`[关键词: ${entry.keys.join(', ')}]`);
                        }
                        stringParts.push(entry.content); // 条目主要内容
                        return stringParts.join('\n'); // 每个条目的内部用换行分隔
                    });
                    
                    // 将所有转换后的条目字符串用一个明显的分隔符连接起来
                    book.content = convertedEntries.join('\n\n---\n\n');
                }
            });
        }
        
        // 过滤并保存数据 (这部分逻辑保持不变)
        const validItems = itemsToPut.filter(item => item && (typeof item.id === 'undefined' || typeof item.id === 'string' || typeof item.id === 'number'));
        if (validItems.length > 0) {
            console.log(`正在导入 ${validItems.length} 条数据到表格: ${tableName}...`);
            await db[tableName].bulkPut(validItems);
        }

    } else {
        console.log(`跳过导入: ${tableName} (在备份文件或当前数据库中不存在)`);
    }
}
// ▲▲▲ 代码粘贴结束 ▲▲▲

            
            // 导入对象类型的数据（通常是设置）
            const objectTables = ['apiConfig', 'globalSettings', 'musicLibrary', 'qzoneSettings'];
            for (const tableName of objectTables) {
                if (data[tableName] && db[tableName]) {
                    console.log(`正在导入设置: ${tableName}...`);
                    await db[tableName].put(data[tableName]);
                }
            }
        });

        // 导入主屏幕样式的逻辑保持不变，因为它不直接操作数据库的多个表
        if (data.homeScreenState) {
            const settings = await db.globalSettings.get('main') || { id: 'main' };
            settings.widgetData = data.homeScreenState;
            if (data.homeScreenState.wallpaper) settings.wallpaper = data.homeScreenState.wallpaper;
            if (data.homeScreenState.lockscreenWallpaper) settings.lockscreenWallpaper = data.homeScreenState.lockscreenWallpaper;
            if (data.homeScreenState.appIcons) settings.appIcons = data.homeScreenState.appIcons;
            await db.globalSettings.put(settings);
            console.log("已成功导入主屏幕样式数据。");
        }


        await showCustomAlert('导入成功', '所有数据已成功恢复！应用即将刷新以应用所有更改。');
        
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("导入数据时出错:", error);
        await showCustomAlert('导入失败', `文件格式不正确或数据已损坏: ${error.message}`);
    }
}

function applyCustomFont(fontUrl, isPreviewOnly = false) {
    if (!fontUrl) {
        // 如果没有提供字体链接（比如恢复默认），就清空样式
        dynamicFontStyle.innerHTML = '';
        document.getElementById('font-preview').style.fontFamily = '';
        return;
    }

    // 这是一个统一的内部名字
    const fontName = 'custom-user-font';
    
    // 这是定义字体的样式规则
    const newStyle = `
        @font-face {
          font-family: '${fontName}';
          src: url('${fontUrl}');
          font-display: swap;
        }`;

    if (isPreviewOnly) {
        // 如果只是预览，这个逻辑保持不变
        const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
        previewStyle.id = 'preview-font-style';
        previewStyle.innerHTML = newStyle;
        if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
        document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
    } else {
        // 【核心】如果是全局应用，就同时定义字体并告诉整个 body 去使用它
        dynamicFontStyle.innerHTML = `
            ${newStyle}
            body {
              font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important;
            }`;
    }
}


        async function resetToDefaultFont() {
            // 1. 清除全局字体样式
            dynamicFontStyle.innerHTML = ''; 
            
            // 2. 更新并保存设置
            state.globalSettings.fontUrl = '';
            await db.globalSettings.put(state.globalSettings);
            
            // 3. 【核心修复】明确地将全局预览区的字体也恢复为默认
            const globalPreview = document.getElementById('font-preview');
            globalPreview.style.fontFamily = ''; // 移除内联样式
            
            // 4. 应用一下空的字体设置，确保所有地方都恢复
            applyCustomFont('', true);
            
            alert('已恢复默认字体。');
        }



async function loadAllDataFromDB() {
    // ▼▼▼ 【核心修改在这里】 ▼▼▼
    const [
        chatsArr,
        apiConfig,
        globalSettings,
        userStickers,
        worldBooks,
        musicLib,
        personaPresets,
        qzoneSettings,
        initialFavorites,
    apiPresets,
bubbleStylePresets
] = await Promise.all([
        db.chats.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.userStickers.toArray(),
        db.worldBooks.toArray(),
        db.musicLibrary.get('main'),
        db.personaPresets.toArray(),
        db.qzoneSettings.get('main'),
        db.favorites.orderBy('timestamp').reverse().toArray(),
    db.apiPresets.toArray(),    db.bubbleStylePresets.toArray()
]);
    // ▲▲▲ 【修改结束】 ▲▲▲

    state.chats = chatsArr.reduce((acc, chat) => {

    if (typeof chat.unreadCount === 'undefined') {
        chat.unreadCount = 0; // 如果这个聊天对象没有 unreadCount 属性，就给它初始化为 0
    }

        // ★★★【核心重构：数据迁移脚本】★★★
        // 检查是否是群聊，并且其成员对象使用的是旧的 `name` 结构
        if (chat.isGroup && chat.members && chat.members.length > 0 && chat.members[0].name) {
            console.log(`检测到旧版群聊数据 for "${chat.name}"，正在执行迁移...`);
            chat.members.forEach(member => {
                // 如果这个成员对象没有 originalName，说明是旧数据
                if (typeof member.originalName === 'undefined') {
                    member.originalName = member.name; // 将旧的 name 作为 originalName
                    member.groupNickname = member.name; // 同时创建一个初始的 groupNickname
                    delete member.name; // 删除旧的、有歧义的 name 字段
                    needsUpdate = true; // 标记需要存回数据库
                }
            });
             console.log(`迁移完成 for "${chat.name}"`);
        }

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查1：如果是一个单聊，并且没有 status 属性
        if (!chat.isGroup && !chat.status) {
            // 就为它补上一个默认的 status 对象
            chat.status = {
                text: '在线',
                lastUpdate: Date.now(),
                isBusy: false
            };
            console.log(`为旧角色 "${chat.name}" 补全了status属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查2：兼容最新的“关系”功能
        if (!chat.isGroup && !chat.relationship) {
            // 如果是单聊，且没有 relationship 对象，就补上一个默认的
            chat.relationship = {
                status: 'friend',
                blockedTimestamp: null,
                applicationReason: ''
            };
            console.log(`为旧角色 "${chat.name}" 补全了 relationship 属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

    // ▼▼▼ 在这里添加 ▼▼▼
    if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
        chat.settings.aiAvatarLibrary = [];
        console.log(`为旧角色 "${chat.name}" 补全了aiAvatarLibrary属性。`);
    }
    // ▲▲▲ 添加结束 ▲▲▲
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    // 兼容旧数据：为没有NPC库的单聊角色添加空的NPC库
    if (!chat.isGroup && !chat.npcLibrary) {
        chat.npcLibrary = [];
        console.log(`为旧角色 "${chat.name}" 补全了 npcLibrary 属性。`);
    }
    // ▲▲▲ 粘贴结束 ▲▲▲

        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
            chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
            delete chat.settings.linkedWorldBookId;
        }

    // 兼容旧数据，为没有 isPinned 属性的聊天添加默认值
    if (typeof chat.isPinned === 'undefined') {
        chat.isPinned = false;
    }

// ▼▼▼ 【V2最终修复版】统一修复并初始化所有角色的手机数据 ▼▼▼
if (!chat.isGroup) {
    // 第一步：确保最外层的 characterPhoneData 对象存在
    if (!chat.characterPhoneData) {
        chat.characterPhoneData = {}; // 如果不存在，就创建一个空的
    }

    // 第二步：逐一检查并补全所有APP的数据结构
    // 这样无论角色多老，都能确保所有字段都存在
    if (!chat.characterPhoneData.lastGenerated) chat.characterPhoneData.lastGenerated = null;
    if (!chat.characterPhoneData.chats) chat.characterPhoneData.chats = {};
    if (!chat.characterPhoneData.shoppingCart) chat.characterPhoneData.shoppingCart = [];
    if (!chat.characterPhoneData.memos) chat.characterPhoneData.memos = [];
    if (!chat.characterPhoneData.browserHistory) chat.characterPhoneData.browserHistory = [];
    if (!chat.characterPhoneData.photoAlbum) chat.characterPhoneData.photoAlbum = [];
    if (!chat.characterPhoneData.bank) chat.characterPhoneData.bank = { balance: 0, transactions: [] };
    if (!chat.characterPhoneData.trajectory) chat.characterPhoneData.trajectory = [];
    if (!chat.characterPhoneData.appUsage) chat.characterPhoneData.appUsage = [];
    if (!chat.characterPhoneData.diary) chat.characterPhoneData.diary = []; // 核心修复！
}
// ▲▲▲ 修正结束 ▲▲▲
// 兼容旧数据，为没有后台活动设置的群聊添加默认值
if (chat.isGroup && (!chat.settings || typeof chat.settings.backgroundActivity === 'undefined')) {
    if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
    chat.settings.backgroundActivity = {
        enabled: false,
        interval: 120, // 默认120秒
        lastActivityTimestamp: 0
    };
}

        acc[chat.id] = chat;
        return acc;
    }, {});
    state.apiConfig = apiConfig || { id: 'main', proxyUrl: '', apiKey: '', model: '' };

// ▼▼▼ 步骤 3.1：在 loadAllDataFromDB 函数中，找到并【替换】这行代码 ▼▼▼

state.globalSettings = globalSettings || { 
    id: 'main', 
    wallpaper: 'linear-gradient(135deg, #2c2c2c, #c0c0c0)', 
    lockscreenWallpaper: '#ffffff',
    password: '',
    fontUrl: '', 
    enableBackgroundActivity: false, 
    backgroundActivityInterval: 60,
    blockCooldownHours: 1,
    appIcons: { ...DEFAULT_APP_ICONS },
    ringtoneUrl: 'https://files.catbox.moe/3w7gla.mp3',
    widgetData: {} // 【核心修改】在这里新增一个空对象，用来存放你的自定义内容
};
// 确保即使从旧数据库加载，这个属性也存在
if (!state.globalSettings.widgetData) {
    state.globalSettings.widgetData = {};
}
// ▲▲▲ 替换结束 ▲▲▲


    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    // 【核心新增】加载歌词栏设置，如果不存在则使用默认值
    lyricsBarSettings = state.globalSettings.lyricsBarSettings || lyricsBarSettings;
    // ▲▲▲ 添加结束 ▲▲▲

// 【核心修改】合并已保存的图标和默认图标，防止更新后旧数据丢失新图标
state.globalSettings.appIcons = { ...DEFAULT_APP_ICONS, ...(state.globalSettings.appIcons || {}) };

    state.userStickers = userStickers || [];
    state.worldBooks = worldBooks || [];
    
    // 为没有 isEnabled 字段的全局世界书设置默认值并同步到数据库
    for (const book of state.worldBooks) {
        if (book.isGlobal && book.isEnabled === undefined) {
            book.isEnabled = true; // 默认开启
            // 同步到数据库
            await db.worldBooks.update(book.id, { isEnabled: true });
        }
    }
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
state.apiPresets = apiPresets || [];
state.bubbleStylePresets = bubbleStylePresets || [];
// ▼▼▼ 在 loadAllDataFromDB 函数里，用下面这整块代码替换旧的 qzoneSettings 初始化代码 ▼▼▼

state.qzoneSettings = qzoneSettings || { 
    id: 'main', 
    nickname: '{{user}}', 
    avatar: 'https://files.catbox.moe/q6z5fc.jpeg', 
    banner: 'https://files.catbox.moe/r5heyt.gif',
    // 【核心新增】在这里为微博创建独立的字段！
    weiboAvatar: 'https://files.catbox.moe/q6z5fc.jpeg', // 微博专属头像
    weiboNickname: '你的昵称', // 微博专属昵称
    weiboFansCount: '0', // 微博专属粉丝数
    weiboBackground: 'https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg' // 微博专属背景
};
// 兼容旧数据，如果加载进来的数据没有微博专属字段，就补上默认值
if (!state.qzoneSettings.weiboAvatar) state.qzoneSettings.weiboAvatar = state.qzoneSettings.avatar || 'https://files.catbox.moe/q6z5fc.jpeg';
if (!state.qzoneSettings.weiboNickname) state.qzoneSettings.weiboNickname = state.qzoneSettings.nickname || '你的昵称';
if (!state.qzoneSettings.weiboFansCount) state.qzoneSettings.weiboFansCount = '0';
if (!state.qzoneSettings.weiboBackground) state.qzoneSettings.weiboBackground = 'https://youke1.picui.cn/s1/2025/10/08/68e63e8b54c55.jpg';

// ▲▲▲ 替换结束 ▲▲▲


    // ▼▼▼ 【确保这一行在 Promise.all 之后，并使用解构赋值得到的 initialFavorites】 ▼▼▼
    allFavoriteItems = initialFavorites || [];
    // ▲▲▲ 【修改结束】 ▲▲▲
    
    // 确保state对象也可以通过window.state访问，以支持相册等功能
    window.state = state;
    
    // 加载相册数据
    await loadAlbumsFromDB();
    
    // 【修复】数据加载完成后，初始化X图标显示状态
    updateFloatingXLogo();
}

        // ▼▼▼ 【全新 | 支持临时歌曲】请用这个新版本替换旧的 saveGlobalPlaylist 函数 ▼▼▼
async function saveGlobalPlaylist() {
    // 1. 在保存前，先从当前播放列表中过滤掉所有被标记为 isTemporary 的歌曲
    const permanentPlaylist = musicState.playlist.filter(track => !track.isTemporary);
    
    // 2. 只将这个“永久播放列表”保存到数据库中
    await db.musicLibrary.put({ id: 'main', playlist: permanentPlaylist });
    console.log("已将永久播放列表保存到数据库。");
}
// ▲▲▲ 替换结束 ▲▲▲

        function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }

        // ======================== Minimax语音系统 ========================
        
        // 全局变量
        let voiceAudio = new Audio();
        
        /**
         * 过滤文本中的【】和（）内容（心理描写、旁白等）
         * 用于Minimax语音生成，避免朗读非对话内容
         */
        function filterBracketedText(text) {
            if (!text) return '';
            console.log('🔍 过滤前的文本:', text);
            // 使用正则表达式移除所有【】和（）及其内容，并替换为空格（保留前后文字的分隔）
            let filtered = text.replace(/【[^】]*】/g, ' ');  // 移除中文方括号【】
            filtered = filtered.replace(/（[^）]*）/g, ' ');  // 移除中文圆括号（）
            filtered = filtered.replace(/\([^)]*\)/g, ' ');   // 移除英文圆括号()
            // 清理多余的空格和换行
            filtered = filtered.replace(/\s+/g, ' ').trim();
            console.log('🔍 过滤后的文本:', filtered);
            return filtered;
        }
        
        /**
         * 处理语音通话消息文本，将【】内的内容设置为灰色
         * 用于语音通话页面显示
         */
        function formatVoiceCallText(text) {
            if (!text) return '';
            // 将【】内的文字替换为带灰色样式的span
            return text.replace(/【([^】]*)】/g, '<span style="color: #999;">【$1】</span>');
        }
        
        let currentPlayingElement = null;
        
        /**
         * 解析语音消息格式，支持新的[V]格式和兼容旧的[语音]:格式
         */
        function parseVoiceMessage(messageContent) {
            if (!messageContent) {
                return { content: messageContent, isVoice: false };
            }
            
            const NEW_VOICE_PREFIX = '[V]';
            const OLD_VOICE_PREFIX = '[语音]:';
            
            // 检查新格式：[V]内容
            if (messageContent.startsWith(NEW_VOICE_PREFIX)) {
                const content = messageContent.substring(NEW_VOICE_PREFIX.length);
                return { content: content, isVoice: true };
            }
            
            // 检查旧格式：[语音]:内容
            if (messageContent.startsWith(OLD_VOICE_PREFIX)) {
                const content = messageContent.substring(OLD_VOICE_PREFIX.length).trim();
                return { content: content, isVoice: true };
            }
            
            // 普通文字消息
            return { content: messageContent, isVoice: false };
        }
        
        /**
         * 过滤文本中的括号内容，用于TTS
         */
        function filterTextForTts(text) {
            return text ? text.replace(/\（[^）]*\）/g, "").replace(/\([^)]*\)/g, "").trim() : "";
        }
        
        /**
         * 生成语音图标SVG
         */
        function createVoiceIcon(state = 'default') {
            const baseProps = 'width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"';
            
            switch (state) {
                case 'loading':
                    return `<svg xmlns="http://www.w3.org/2000/svg" ${baseProps} stroke-width="2.5"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6"/></svg>`;
                case 'playing':
                    return `<svg xmlns="http://www.w3.org/2000/svg" ${baseProps} stroke-width="2"><polygon points="6 3 20 12 6 21 6 3"/></svg>`;
                case 'paused':
                    return `<svg xmlns="http://www.w3.org/2000/svg" ${baseProps} stroke-width="2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>`;
                default:
                    return `<svg xmlns="http://www.w3.org/2000/svg" ${baseProps} stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/></svg>`;
            }
        }
        
        /**
         * 智能语音缓存系统 - 支持存储空间管理
         */
        window.VoiceStorageAPI = {
            // 存储配置
            MAX_CACHE_SIZE: 50 * 1024 * 1024, // 50MB 最大缓存大小
            MAX_SINGLE_AUDIO: 5 * 1024 * 1024, // 5MB 单个音频最大大小
            CACHE_DAYS: 7, // 缓存天数
            
            generateCacheKey(text, voiceId) {
                // 使用简单的哈希函数处理Unicode字符（包括中文）
                let hash = 0;
                const str = text + voiceId;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // 转换为32位整数
                }
                const textHash = Math.abs(hash).toString(36).substring(0, 16);
                return `voice_${voiceId}_${textHash}`;
            },
            
            // ▼▼▼ 新增：检查语音缓存key是否被收藏 ▼▼▼
            async isVoiceCacheFavorited(cacheKey) {
                try {
                    if (!window.db || !window.db.favorites) return false;
                    
                    // 查询所有收藏项
                    const favorites = await db.favorites.toArray();
                    
                    // 检查是否有收藏项使用了这个缓存key
                    return favorites.some(fav => {
                        if (fav.type === 'chat_message' && fav.content) {
                            const msg = fav.content;
                            // 如果是语音消息且有voiceCacheKey字段
                            if (msg.type === 'voice_message' && msg.voiceCacheKey === cacheKey) {
                                return true;
                            }
                        }
                        return false;
                    });
                } catch (error) {
                    console.error('检查收藏状态失败:', error);
                    return false;
                }
            },
            // ▲▲▲ 新增结束 ▲▲▲
            
            // 获取当前缓存总大小
            getCurrentCacheSize() {
                let totalSize = 0;
                for (let key in localStorage) {
                    if (key.startsWith('voice_')) {
                        try {
                            const data = localStorage.getItem(key);
                            if (data) {
                                totalSize += data.length * 2; // UTF-16 字符占用2字节
                            }
                        } catch (e) {
                            // 忽略错误的缓存项
                        }
                    }
                }
                return totalSize;
            },
            
            // 清理过期缓存
            async cleanExpiredCache() {
                const now = Date.now();
                const keysToRemove = [];
                
                for (let key in localStorage) {
                    if (key.startsWith('voice_')) {
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            if (data && data.timestamp) {
                                const cacheAge = now - new Date(data.timestamp).getTime();
                                if (cacheAge > this.CACHE_DAYS * 24 * 60 * 60 * 1000) {
                                    // ▼▼▼ 修改：检查是否被收藏 ▼▼▼
                                    const isFavorited = await this.isVoiceCacheFavorited(key);
                                    if (!isFavorited) {
                                        keysToRemove.push(key);
                                    }
                                    // ▲▲▲ 修改结束 ▲▲▲
                                }
                            } else {
                                // 无效数据格式，也删除（但先检查是否被收藏）
                                const isFavorited = await this.isVoiceCacheFavorited(key);
                                if (!isFavorited) {
                                    keysToRemove.push(key);
                                }
                            }
                        } catch (e) {
                            // 解析失败，删除（但先检查是否被收藏）
                            const isFavorited = await this.isVoiceCacheFavorited(key);
                            if (!isFavorited) {
                                keysToRemove.push(key);
                            }
                        }
                    }
                }
                
                keysToRemove.forEach(key => {
                    localStorage.removeItem(key);
                });
                
                if (keysToRemove.length > 0) {
                    console.log(`清理了 ${keysToRemove.length} 个过期缓存`);
                }
                return keysToRemove.length;
            },
            
            // 清理最旧的缓存直到释放足够空间
            async cleanOldestCache(targetSize) {
                const cacheItems = [];
                
                // 收集所有缓存项和时间戳
                for (let key in localStorage) {
                    if (key.startsWith('voice_')) {
                        try {
                            const dataString = localStorage.getItem(key);
                            const data = JSON.parse(dataString);
                            if (data && data.timestamp) {
                                cacheItems.push({
                                    key: key,
                                    timestamp: new Date(data.timestamp).getTime(),
                                    size: dataString.length * 2
                                });
                            }
                        } catch (e) {
                            // 无效项，标记删除
                            const dataString = localStorage.getItem(key);
                            if (dataString) {
                                cacheItems.push({
                                    key: key,
                                    timestamp: 0,
                                    size: dataString.length * 2
                                });
                            }
                        }
                    }
                }
                
                // 按时间戳排序（最旧的在前）
                cacheItems.sort((a, b) => a.timestamp - b.timestamp);
                
                let freedSize = 0;
                let removedCount = 0;
                
                // ▼▼▼ 修改：逐个检查是否被收藏 ▼▼▼
                for (const item of cacheItems) {
                    if (freedSize >= targetSize) break;
                    
                    const isFavorited = await this.isVoiceCacheFavorited(item.key);
                    if (!isFavorited) {
                        localStorage.removeItem(item.key);
                        freedSize += item.size;
                        removedCount++;
                    }
                }
                // ▲▲▲ 修改结束 ▲▲▲
                
                if (removedCount > 0) {
                    console.log(`清理了 ${removedCount} 个旧缓存，释放了 ${(freedSize / 1024 / 1024).toFixed(2)}MB 空间`);
                }
                return freedSize;
            },
            
            // 清空所有语音缓存
            async clearAllVoiceCache() {
                const keysToRemove = [];
                const keysToKeep = []; // 被收藏的语音缓存
                let totalSize = 0;
                
                // 收集所有语音缓存key
                for (let key in localStorage) {
                    if (key.startsWith('voice_')) {
                        try {
                            const data = localStorage.getItem(key);
                            if (data) {
                                totalSize += data.length * 2; // UTF-16
                            }
                        } catch (e) {
                            // 忽略错误
                        }
                        
                        // ▼▼▼ 修改：检查是否被收藏 ▼▼▼
                        const isFavorited = await this.isVoiceCacheFavorited(key);
                        if (isFavorited) {
                            keysToKeep.push(key);
                        } else {
                            keysToRemove.push(key);
                        }
                        // ▲▲▲ 修改结束 ▲▲▲
                    }
                }
                
                // 删除所有语音缓存（除了被收藏的）
                keysToRemove.forEach(key => {
                    localStorage.removeItem(key);
                });
                
                if (keysToRemove.length > 0) {
                    console.log(`🗑️ 已清空语音缓存: ${keysToRemove.length} 个文件，释放了 ${(totalSize / 1024 / 1024).toFixed(2)}MB 空间`);
                }
                
                if (keysToKeep.length > 0) {
                    console.log(`💾 保留了 ${keysToKeep.length} 个被收藏的语音缓存`);
                }
                
                return {
                    count: keysToRemove.length,
                    size: totalSize,
                    kept: keysToKeep.length
                };
            },
            
            // 检查并准备存储空间
            async prepareStorage(requiredSize) {
                // 先清理过期缓存
                await this.cleanExpiredCache();
                
                const currentSize = this.getCurrentCacheSize();
                const availableSpace = this.MAX_CACHE_SIZE - currentSize;
                
                console.log(`当前缓存大小: ${(currentSize / 1024 / 1024).toFixed(2)}MB`);
                console.log(`需要空间: ${(requiredSize / 1024 / 1024).toFixed(2)}MB`);
                
                if (requiredSize > this.MAX_SINGLE_AUDIO) {
                    throw new Error(`音频文件过大 (${(requiredSize / 1024 / 1024).toFixed(2)}MB)，超过单文件限制 (${(this.MAX_SINGLE_AUDIO / 1024 / 1024).toFixed(2)}MB)`);
                }
                
                if (availableSpace < requiredSize) {
                    // 需要清理空间
                    const needToFree = requiredSize - availableSpace + (1024 * 1024); // 额外清理1MB缓冲
                    console.log(`需要清理 ${(needToFree / 1024 / 1024).toFixed(2)}MB 空间`);
                    
                    const freedSpace = await this.cleanOldestCache(needToFree);
                    
                    if (freedSpace < needToFree) {
                        throw new Error('无法释放足够的存储空间，请手动清理浏览器缓存');
                    }
                }
                
                return true;
            },

            async getVoiceURL(text, voiceId) {
                const cacheKey = this.generateCacheKey(text, voiceId);
                const cached = localStorage.getItem(cacheKey);
                
                if (cached) {
                    try {
                        const data = JSON.parse(cached);
                        const cacheAge = Date.now() - new Date(data.timestamp).getTime();
                        if (cacheAge < this.CACHE_DAYS * 24 * 60 * 60 * 1000) {
                            // 从Base64数据重新创建Blob URL
                            if (data.audioData) {
                                const binaryString = atob(data.audioData);
                                const bytes = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                                const blob = new Blob([bytes], { type: data.mimeType || 'audio/mpeg' });
                                return URL.createObjectURL(blob);
                            }
                        } else {
                            localStorage.removeItem(cacheKey);
                        }
                    } catch (error) {
                        console.error('解析缓存数据失败:', error);
                        localStorage.removeItem(cacheKey);
                    }
                }
                return null;
            },
            
            async storeVoice(audioBlob, text, voiceId, metadata = {}) {
                const cacheKey = this.generateCacheKey(text, voiceId);
                
                try {
                    // 检查音频大小
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    if (arrayBuffer.byteLength > this.MAX_SINGLE_AUDIO) {
                        console.warn(`音频文件过大 (${(arrayBuffer.byteLength / 1024 / 1024).toFixed(2)}MB)，跳过缓存`);
                        return;
                    }
                    
                    // 将Blob转换为Base64存储
                    const bytes = new Uint8Array(arrayBuffer);
                    let binaryString = '';
                    for (let i = 0; i < bytes.length; i++) {
                        binaryString += String.fromCharCode(bytes[i]);
                    }
                    const base64Data = btoa(binaryString);
                    
                    const cacheData = {
                        audioData: base64Data,
                        mimeType: audioBlob.type,
                        timestamp: new Date().toISOString(),
                        metadata: metadata
                    };
                    
                    const dataString = JSON.stringify(cacheData);
                    const estimatedSize = dataString.length * 2; // UTF-16
                    
                    // 检查并准备存储空间
                    this.prepareStorage(estimatedSize);
                    
                    // 尝试存储
                    localStorage.setItem(cacheKey, dataString);
                    console.log(`语音缓存成功存储: ${(estimatedSize / 1024).toFixed(2)}KB`);
                    
                } catch (error) {
                    if (error.name === 'QuotaExceededError') {
                        console.warn('存储空间不足，尝试清理缓存后重试...');
                        try {
                            // 紧急清理：删除一半缓存
                            const currentSize = this.getCurrentCacheSize();
                            this.cleanOldestCache(currentSize / 2);
                            
                            // 重试存储
                            const arrayBuffer = await audioBlob.arrayBuffer();
                            const bytes = new Uint8Array(arrayBuffer);
                            let binaryString = '';
                            for (let i = 0; i < bytes.length; i++) {
                                binaryString += String.fromCharCode(bytes[i]);
                            }
                            const base64Data = btoa(binaryString);
                            
                            const cacheData = {
                                audioData: base64Data,
                                mimeType: audioBlob.type,
                                timestamp: new Date().toISOString(),
                                metadata: metadata
                            };
                            
                            localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                            console.log('缓存清理后重试存储成功');
                        } catch (retryError) {
                            console.warn('语音缓存存储失败，将使用临时播放:', retryError.message);
                        }
                    } else {
                        console.warn('语音缓存存储失败:', error.message);
                    }
                }
            }
        };
        
        /**
         * 播放或停止语音消息 - 支持缓存的 Minimax API
         */
        async function playVoiceMessage(bubbleElement, text, voiceId) {
            const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
            const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
            
            if (!minimaxGroupId || !minimaxApiKey) {
                alert('请在API设置中填写 Minimax Group ID 和 API Key');
                return;
            }
            // 如果没有指定voiceId，尝试使用默认语音模型
            if (!voiceId) {
                const defaultVoiceModel = localStorage.getItem('minimaxVoiceModel') || '';
                if (!defaultVoiceModel) {
                    alert('该角色未设置语音ID，且未配置默认语音模型。请在API设置中拉取并选择默认语音模型。');
                    return;
                }
                voiceId = defaultVoiceModel;
                console.log('使用默认语音模型:', voiceId);
            }
            
            // 🔥 过滤掉【】内的文本（心理描写、旁白等）
            const originalText = text;
            text = filterBracketedText(text);
            
            if (!text || text.trim().length === 0) {
                console.log('⚠️ 过滤后文本为空，跳过语音生成');
                return;
            }
            
            if (originalText !== text) {
                console.log('📝 已过滤【】内容，原始长度:', originalText.length, '→ 过滤后长度:', text.length);
            }
        
            const wasPlaying = bubbleElement === currentPlayingElement && !voiceAudio.paused;
        
            // 🔥 修复：停止所有正在播放的音频（包括普通播放和通话播放）
            // 停止普通播放的语音
            if (currentPlayingElement) {
                voiceAudio.pause();
                voiceAudio.currentTime = 0;
                const oldVoiceIcon = currentPlayingElement.querySelector('.voice-icon');
                if (oldVoiceIcon) oldVoiceIcon.innerHTML = createVoiceIcon();
                currentPlayingElement.classList.remove('playing', 'loading');
            }
            
            // 停止通话播放的语音
            if (autoVoiceState.currentAudio) {
                autoVoiceState.currentAudio.pause();
                autoVoiceState.currentAudio.currentTime = 0;
                autoVoiceState.isPlaying = false;
            }
        
            if (wasPlaying) {
                currentPlayingElement = null;
                return;
            }
        
            currentPlayingElement = bubbleElement;
            const voiceIcon = bubbleElement.querySelector('.voice-icon');
        
            try {
                bubbleElement.classList.add('loading');
                if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon('loading');
        
                let audioUrl = null;
                let fromCache = false;
        
                if (window.VoiceStorageAPI) {
                    try {
                        audioUrl = await window.VoiceStorageAPI.getVoiceURL(text, voiceId);
                        if (audioUrl) {
                            fromCache = true;
                            console.log('使用语音缓存:', { textLength: text.length, voiceId });
                        }
                    } catch (error) {
                        console.error('检查语音缓存失败:', error);
                    }
                }
        
                if (!audioUrl) {
                    console.log('语音缓存未命中，调用API生成语音');
                    
                    // 获取用户选择的语音模型，如果没有则使用默认值（使用Minimax实际支持的模型）
                    const selectedVoiceModel = localStorage.getItem('minimaxVoiceModel') || 'speech-01';
                    console.log('使用语音模型:', selectedVoiceModel, '语音ID:', voiceId);
                    
                    const apiUrl = `https://api.minimax.chat/v1/text_to_speech?GroupId=${minimaxGroupId}`;
                    const requestBody = {
                        "voice_id": voiceId,
                        "text": text,
                        "model": selectedVoiceModel,
                        "speed": 1.0,
                        "vol": 1.0,
                        "pitch": 0
                    };
        
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${minimaxApiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
        
                    const contentType = response.headers.get('content-type') || '';
                    
                    if (!response.ok || contentType.includes('application/json')) {
                        let errorMsg = `语音服务错误 (状态码: ${response.status})`;
                        try {
                            const errorData = await response.json();
                            console.error('Minimax TTS API 返回错误:', errorData);
                            
                            if (errorData && errorData.base_resp && errorData.base_resp.status_msg) {
                                const statusMsg = errorData.base_resp.status_msg;
                                const statusCode = errorData.base_resp.status_code;
                                
                                // 特殊处理常见错误
                                if (statusCode === 1008 || statusMsg === 'insufficient balance') {
                                    errorMsg = '💰 Minimax 账户余额不足，请前往官网充值后继续使用语音功能';
                                } else if (statusCode === 1004) {
                                    errorMsg = '🔑 Minimax API 密钥无效，请检查配置';
                                } else if (statusCode === 1001) {
                                    errorMsg = '⚠️ Minimax API 请求参数错误';
                                } else {
                                    errorMsg += `: ${statusMsg}`;
                                }
                            } else if (errorData && errorData.error) {
                                errorMsg += `: ${errorData.error}`;
                            }
                        } catch (e) {
                            const errorText = await response.text();
                            errorMsg += `: ${errorText}`;
                        }
                        throw new Error(errorMsg);
                    }
        
                    const audioBlob = await response.blob();
                    
                    if (!audioBlob || !audioBlob.type.startsWith('audio/')) {
                        throw new Error(`服务器返回了非预期的内容类型: ${audioBlob.type}`);
                    }
        
                    if (window.VoiceStorageAPI) {
                        window.VoiceStorageAPI.storeVoice(audioBlob, text, voiceId, {
                            model: selectedVoiceModel,
                            apiSource: "minimax",
                            generatedAt: new Date().toISOString()
                        }).then(() => {
                            console.log('语音已保存到缓存:', { textLength: text.length, voiceId, model: selectedVoiceModel });
                        }).catch(error => {
                            console.error('语音缓存保存失败:', error);
                        });
                    }
        
                    audioUrl = URL.createObjectURL(audioBlob);
                }
        
                // 重新创建Audio对象以避免缓存问题
                voiceAudio = new Audio();
                voiceAudio.preload = 'auto';
                
                // 设置错误处理
                voiceAudio.onerror = (e) => {
                    console.error('音频加载错误:', e);
                    throw new Error('音频文件加载失败，可能是格式不支持或文件损坏');
                };
                
                voiceAudio.onended = () => {
                    if (currentPlayingElement === bubbleElement) {
                        currentPlayingElement.classList.remove('playing');
                        if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon();
                        currentPlayingElement = null;
                    }
                    // 清理临时URL以释放内存
                    if (audioUrl && audioUrl.startsWith('blob:')) {
                        URL.revokeObjectURL(audioUrl);
                    }
                };
                
                // 验证音频URL有效性
                if (!audioUrl || audioUrl === 'null' || audioUrl === 'undefined') {
                    throw new Error('音频URL无效');
                }
                
                voiceAudio.src = audioUrl;
                
                // 等待音频加载完成再播放
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('音频加载超时'));
                    }, 10000); // 10秒超时
                    
                    voiceAudio.oncanplaythrough = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    
                    voiceAudio.onerror = (e) => {
                        clearTimeout(timeout);
                        reject(new Error('音频加载失败'));
                    };
                    
                    voiceAudio.load(); // 强制加载
                });
        
                await voiceAudio.play();
        
                bubbleElement.classList.remove('loading');
                bubbleElement.classList.add('playing');
                if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon('playing');
        
                console.log(`语音播放开始 (${fromCache ? '缓存' : 'API'}):`, {
                    textLength: text.length,
                    voiceId,
                    fromCache
                });
        
            } catch (error) {
                console.error('语音播放失败:', error);
                
                bubbleElement.classList.remove('loading', 'playing');
                if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon();
                currentPlayingElement = null;
                
                alert(`语音播放失败: ${error.message}`);
            }
        }
        
        // ▼▼▼ 新增：收藏页面专用的语音播放函数 ▼▼▼
        /**
         * 为收藏的语音消息播放语音（简化版，不需要语音图标控制）
         */
        async function playVoiceForFavorite(cardElement, text, voiceId) {
            const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
            const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
            
            if (!minimaxGroupId || !minimaxApiKey) {
                console.log('未配置 Minimax API，跳过语音播放');
                return;
            }
            
            if (!voiceId) {
                console.log('无语音ID，跳过语音播放');
                return;
            }
            
            // 过滤文本
            text = filterBracketedText(text);
            if (!text || text.trim().length === 0) {
                console.log('过滤后文本为空，跳过语音生成');
                return;
            }
            
            try {
                let audioUrl = null;
                let fromCache = false;
                
                // 尝试从缓存获取
                if (window.VoiceStorageAPI) {
                    try {
                        audioUrl = await window.VoiceStorageAPI.getVoiceURL(text, voiceId);
                        if (audioUrl) {
                            fromCache = true;
                            console.log('使用语音缓存播放收藏的语音');
                        }
                    } catch (error) {
                        console.error('检查语音缓存失败:', error);
                    }
                }
                
                // 如果缓存未命中，调用API
                if (!audioUrl) {
                    console.log('缓存未命中，调用API生成语音');
                    const selectedVoiceModel = localStorage.getItem('minimaxVoiceModel') || 'speech-01';
                    const apiUrl = `https://api.minimax.chat/v1/text_to_speech?GroupId=${minimaxGroupId}`;
                    const requestBody = {
                        "voice_id": voiceId,
                        "text": text,
                        "model": selectedVoiceModel,
                        "speed": 1.0,
                        "vol": 1.0,
                        "pitch": 0
                    };
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${minimaxApiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`语音服务错误 (${response.status})`);
                    }
                    
                    const audioBlob = await response.blob();
                    
                    // 保存到缓存
                    if (window.VoiceStorageAPI) {
                        window.VoiceStorageAPI.storeVoice(audioBlob, text, voiceId, {
                            model: selectedVoiceModel,
                            apiSource: "minimax",
                            generatedAt: new Date().toISOString()
                        }).catch(error => {
                            console.error('语音缓存保存失败:', error);
                        });
                    }
                    
                    audioUrl = URL.createObjectURL(audioBlob);
                }
                
                // 创建并播放音频
                const audio = new Audio();
                audio.src = audioUrl;
                audio.onended = () => {
                    if (audioUrl && !fromCache) {
                        URL.revokeObjectURL(audioUrl);
                    }
                };
                
                await audio.play();
                console.log('收藏的语音开始播放');
                
            } catch (error) {
                console.error('播放收藏的语音失败:', error);
            }
        }
        // ▲▲▲ 新增结束 ▲▲▲
        
        // ======================== 语音系统结束 ========================

        function showNotification(chatId, messageContent) { clearTimeout(notificationTimeout); const chat = state.chats[chatId]; if (!chat) return; const bar = document.getElementById('notification-bar'); document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar; document.getElementById('notification-content').querySelector('.name').textContent = chat.name; document.getElementById('notification-content').querySelector('.message').textContent = messageContent; const newBar = bar.cloneNode(true); bar.parentNode.replaceChild(newBar, bar); newBar.addEventListener('click', () => { openChat(chatId); newBar.classList.remove('visible'); }); newBar.classList.add('visible'); notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000); }

      // ▼▼▼ 步骤 1.1：用下面这【一整块】代码，完整替换掉旧的 updateClock 函数 ▼▼▼
/* ▼▼▼ 步骤 1：将这一整块全新的功能函数，粘贴到您的JS代码的功能函数定义区 ▼▼▼ */

/**
 * 【全新添加】显示一个包含多个选项的操作菜单模态框
 * 这是让图片编辑时能够选择“本地上传”或“URL”的关键函数！
 * @param {string} title - 模态框的标题
 * @param {Array<object>} options - 按钮选项数组, e.g., [{ text: '按钮文字', value: '返回值' }]
 * @returns {Promise<string|null>} - 返回用户点击按钮的value，如果取消则返回null
 */
function showChoiceModal(title, options) {
    return new Promise(resolve => {
        // 复用你现有的自定义模态框
        const modal = document.getElementById('preset-actions-modal');
        const footer = modal.querySelector('.custom-modal-footer');
        
        // 清空旧按钮并动态创建新按钮
        footer.innerHTML = ''; 

        options.forEach(option => {
            const button = document.createElement('button');
            button.textContent = option.text;
            button.onclick = () => {
                modal.classList.remove('visible');
                resolve(option.value); // 返回被点击按钮的值
            };
            footer.appendChild(button);
        });

        // 添加一个标准的取消按钮
        const cancelButton = document.createElement('button');
        cancelButton.textContent = '取消';
        cancelButton.style.marginTop = '8px';
        cancelButton.style.borderRadius = '8px';
        cancelButton.style.backgroundColor = '#f0f0f0';
        cancelButton.onclick = () => {
            modal.classList.remove('visible');
            resolve(null); // 用户取消，返回 null
        };
        footer.appendChild(cancelButton);

        modal.classList.add('visible');
    });
}
// ▼▼▼ 【最终正确版】请用这整块代码，完整替换旧的 deleteExpiredSearchedSongs 函数 ▼▼▼

/**
 * 【全新重构】检查并删除所有失效的API歌曲
 * 核心逻辑：不再依赖任何标签，直接根据链接特征识别需要检查的歌曲。
 */
async function deleteExpiredSearchedSongs() {
    await showCustomAlert("请稍候...", "正在检查播放列表中所有在线歌曲的有效性...");

    // 1. 【核心改变】我们不再寻找 isTemporary 标签！
    // 而是直接找出所有 src 链接来自于 API 服务器的歌曲。
    // 这是一个绝对可靠的识别方法，无论它有没有被正确保存。
    const songsToCheck = musicState.playlist.filter(track => track.src && track.src.includes('api.vkeys.cn'));

    if (songsToCheck.length === 0) {
        await showCustomAlert('提示', '播放列表中没有需要检查的在线歌曲。');
        return;
    }

    const songsToDelete = [];
    const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);

    // 2. 对每一首识别出的歌曲，进行严格的“体检”
    await Promise.all(songsToCheck.map(async (track) => {
        // 条件1：检查链接本身是否已经失效（无法播放）
        const isUrlInvalid = !(await checkAudioAvailability(track.src));
        
        // 条件2：检查添加时间是否超过24小时（作为双重保险）
        const isOlderThan24h = track.addedTimestamp && track.addedTimestamp < twentyFourHoursAgo;

        // 只要满足【任意一个】条件，就判定为“失效”
        if (isUrlInvalid || isOlderThan24h) {
            songsToDelete.push(track);
            console.log(`标记删除: ${track.name} (原因: ${isUrlInvalid ? '链接失效' : ''} ${isOlderThan24h ? '超过24小时' : ''})`);
        }
    }));

    // 3. 根据检查结果进行反馈和操作 (这部分逻辑不变)
    if (songsToDelete.length === 0) {
        await showCustomAlert('检查完成', '播放列表中的所有在线歌曲当前均有效。');
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认清理',
        `检测到 ${songsToDelete.length} 首已失效的在线歌曲。确定要将它们从列表中移除吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    // 执行删除...
    const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
    musicState.playlist = musicState.playlist.filter(track => !songsToDelete.includes(track));
    const newIndex = currentTrack ? musicState.playlist.findIndex(t => t.src === currentTrack.src && t.name === currentTrack.name) : -1;

    if (newIndex === -1) {
        if (musicState.isPlaying) {
            audioPlayer.pause();
            audioPlayer.src = '';
        }
        musicState.isPlaying = false;
        if (musicState.playlist.length > 0) {
            playSong(0); 
        } else {
            musicState.currentIndex = -1;
            updatePlayerUI();
        }
    } else {
        musicState.currentIndex = newIndex;
        updatePlayerUI();
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
    await showCustomAlert('清理完成', `${songsToDelete.length} 首歌曲已从列表中移除。`);
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 【已修复】更新所有时钟（状态栏和锁屏）
 */
function updateClock() { 
    const now = new Date(); 
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); 
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); 
    
    // 更新状态栏时钟 (这个元素一直存在)
    const statusBarTime = document.getElementById('status-bar-time');
    if (statusBarTime) {
        statusBarTime.textContent = timeString; 
    }

    // 更新锁屏时钟 (只有当锁屏元素存在时才更新，避免报错)
    const lockTime = document.getElementById('lock-main-time');
    const lockDate = document.getElementById('lock-main-date');
    if (lockTime) {
        lockTime.textContent = timeString;
    }
    if (lockDate) {
        lockDate.textContent = dateString;
    }
}




/**
 * 【终极健壮版】解析AI返回的、可能格式不规范的响应内容
 * @param {string} content - AI返回的原始字符串
 * @returns {Array} - 一个标准化的消息对象数组
 */
function parseAiResponse(content) {
    const trimmedContent = content.trim();

    // 方案1：【最优先】尝试作为标准的、单一的JSON数组解析
    // 这是最理想、最高效的情况
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            if (Array.isArray(parsed)) {
                console.log("解析成功：标准JSON数组格式。");
                return parsed;
            }
        } catch (e) {
            // 如果解析失败，说明它虽然看起来像个数组，但内部格式有问题。
            // 此时我们不报错，而是继续尝试下面的“强力解析”方案。
            console.warn("标准JSON数组解析失败，将尝试强力解析...");
        }
    }

    // 方案2：【强力解析】使用正则表达式，从混乱的字符串中提取出所有独立的JSON对象
    // 这能完美解决您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 这种格式
    const jsonMatches = trimmedContent.match(/{[^{}]*}/g);

    if (jsonMatches) {
        const results = [];
        for (const match of jsonMatches) {
            try {
                // 尝试解析每一个被我们“揪”出来的JSON字符串
                const parsedObject = JSON.parse(match);
                results.push(parsedObject);
            } catch (e) {
                // 如果某个片段不是有效的JSON，就忽略它，继续处理下一个
                console.warn("跳过一个无效的JSON片段:", match);
            }
        }

        // 如果我们成功提取出了至少一个有效的JSON对象，就返回这个结果
        if (results.length > 0) {
            console.log("解析成功：通过强力提取模式。");
            return results;
        }
    }
    
    // 方案3：【最终备用】如果以上所有方法都失败了，说明AI返回的可能就是纯文本
    // 我们将原始的、未处理的内容，包装成一个标准的文本消息对象返回，确保程序不会崩溃
    console.error("所有解析方案均失败！将返回原始文本。");
    return [{ type: 'text', content: content }];
}

    function renderApiSettings() {
    // 1. 更新 API 相关的输入框
    document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || '';
    document.getElementById('api-key').value = state.apiConfig.apiKey || '';
    // 如果你有模型选择，也一并更新
    if (document.getElementById('model-select')) {
        document.getElementById('model-select').value = state.apiConfig.model || 'gpt-4';
    }
    
    // 加载Minimax语音配置
    document.getElementById('minimax-group-id').value = localStorage.getItem('minimaxGroupId') || '';
    document.getElementById('minimax-api-key').value = localStorage.getItem('minimaxApiKey') || '';
    document.getElementById('minimax-voice-model').value = localStorage.getItem('minimaxVoiceModel') || '';

    // 加载智谱语音识别配置
    loadZhipuSpeechSettings();

    // 加载NovelAI配置
    const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
    const novelaiModel = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
    const novelaiApiKey = localStorage.getItem('novelai-api-key') || '';
    document.getElementById('novelai-switch').checked = novelaiEnabled;
    document.getElementById('novelai-model').value = novelaiModel;
    document.getElementById('novelai-api-key').value = novelaiApiKey;
    document.getElementById('novelai-details').style.display = novelaiEnabled ? 'block' : 'none';

    // 2. 更新后台活动相关的开关和输入框
    
    // ★★★★★ 这就是我们这次修复的核心 ★★★★★
    // 使用 !!state.globalSettings.enableBackgroundActivity 这种写法，
    // 确保当这个设置还不存在时 (比如第一次打开)，开关也能正确地显示为 false (关闭状态)
    document.getElementById('background-activity-switch').checked = !!state.globalSettings.enableBackgroundActivity;
    // ★★★★★ 修复结束 ★★★★★
    
    // 加载 RealImag 开关状态
    document.getElementById('realimag-switch').checked = !!state.globalSettings.enableRealImag;

    document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
    document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;

    // 3. 渲染预设和频率的下拉框
    renderApiPresetSelector();
    renderBackgroundFrequencySelector();
}

// ▼▼▼ 【全新】粘贴这个完整的函数 ▼▼▼
/**
 * 渲染后台活动的角色选择和频率设置UI
 */
function renderBackgroundFrequencySelector() {
    const container = document.getElementById('background-activity-char-list');
    const detailsContainer = document.getElementById('background-activity-details');
    const masterSwitch = document.getElementById('background-activity-switch');

    // 根据总开关的状态，决定是否显示详细设置
    detailsContainer.style.display = masterSwitch.checked ? 'block' : 'none';
    
    container.innerHTML = ''; // 清空旧列表
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (singleChats.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">还没有可以设置的角色</p>';
        return;
    }

    const config = state.globalSettings.backgroundActivityConfig || {};

    singleChats.forEach(chat => {
        const freq = config[chat.id] || 'none'; // 获取当前角色的频率设置
        let badgeHtml = '';
        if (freq !== 'none') {
            const freqText = { low: '低', medium: '中', high: '高' }[freq];
            badgeHtml = `<span class="char-freq-badge ${freq}">${freqText}</span>`;
        }

        const item = document.createElement('div');
        item.className = 'char-list-item';
        item.innerHTML = `
            <input type="checkbox" class="bg-char-checkbox" data-chat-id="${chat.id}">
            <span class="char-name">${chat.name}</span>
            ${badgeHtml}
        `;
        container.appendChild(item);
    });
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

        window.renderApiSettingsProxy = renderApiSettings;
// ▼▼▼ 请用这个【全新修正版】替换旧的 renderChatList 函数 ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. 获取所有聊天和分组数据
    const allChats = Object.values(state.chats);
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
        return;
    }

    // 2. 将聊天明确地分为“置顶”和“未置顶”两组
    const pinnedChats = allChats.filter(chat => chat.isPinned);
    const unpinnedChats = allChats.filter(chat => !chat.isPinned);

    // 3. 对置顶的聊天，仅按最新消息时间排序
    pinnedChats.sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));

    // 4. 【优先渲染】所有置顶的聊天
    pinnedChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 5. 【接下来处理未置顶的聊天】应用您之前的分组逻辑
    // 为每个分组找到其内部最新的消息时间戳 (只在未置顶聊天中查找)
    allGroups.forEach(group => {
        const latestChatInGroup = unpinnedChats
            .filter(chat => chat.groupId === group.id) // 找到属于这个组的聊天
            .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0))[0]; // 排序后取第一个
        
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });

    // 根据分组的最新时间戳，对分组本身进行排序
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

    // 6. 遍历排序后的分组，渲染其中的【未置顶】好友
    allGroups.forEach(group => {
        const groupChats = unpinnedChats
            .filter(chat => !chat.isGroup && chat.groupId === group.id)
            .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
        
        if (groupChats.length === 0) return; // 如果这个分组里没有未置顶的好友，就跳过

        const groupContainer = document.createElement('div');
        groupContainer.className = 'chat-group-container';
        
        // 【核心修改】下面这两行代码里，我已经删除了 collapsed 类，这样默认就是展开的了！
        groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name}</span>
            </div>
            <div class="chat-group-content"></div>
        `;
        const contentEl = groupContainer.querySelector('.chat-group-content');

        groupChats.forEach(chat => {
            const item = createChatListItem(chat);
            contentEl.appendChild(item);
        });
        chatListEl.appendChild(groupContainer);
    });

    // 7. 最后，渲染所有【未置顶】的群聊和【未分组的】好友
    const remainingChats = unpinnedChats
        .filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId))
        .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
    
    remainingChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 为所有分组标题添加折叠事件
    document.querySelectorAll('.chat-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这个【最终修正版】替换你项目中那个导致错误的 createChatListItem 函数 ▼▼▼
function createChatListItem(chat) {
    const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
    let lastMsgDisplay;

    // --- 消息预览的逻辑保持不变 ---
    if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${chat.relationship.applicationReason || '请求添加你为好友'}</span>`;
    } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
        lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
    } else if (chat.isGroup) {
        if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`; }
        else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[转账]'; }
        else if (lastMsgObj.type === 'order') { lastMsgDisplay = '[购物订单]'; }
        else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[照片]'; }
        else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[语音]'; }
        else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]'; }
        else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[图片]`; }
        else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }
        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
            lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
        }
    } else {
        const statusText = chat.status?.text || '在线';
        lastMsgDisplay = `[${statusText}]`;
    }

    const lastMsgTimestamp = lastMsgObj?.timestamp;
    const timeDisplay = formatChatListTimestamp(lastMsgTimestamp);
    
    const container = document.createElement('div');
    container.className = 'chat-list-item-swipe-container';
    container.dataset.chatId = chat.id;

    const content = document.createElement('div');
    content.className = `chat-list-item-content ${chat.isPinned ? 'pinned' : ''}`;
    
    const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
    
    // --- 【核心修正】在这里，我们创建了一个新的右侧容器，并把时间和未读红点都放了进去 ---
    content.innerHTML = `
        <div class="chat-list-item" data-chat-id="${chat.id}">
            <img src="${avatar || defaultAvatar}" class="avatar">
            <div class="info">
                <div class="name-line">
                    <span class="name">${chat.name}</span>
                    ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ''}
                </div>
                <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
            </div>
            <div class="chat-list-right-column">
                <div class="chat-list-time">${timeDisplay}</div>
                <div class="unread-count-wrapper">
                    <span class="unread-count" style="display: none;">0</span>
                </div>
            </div>
        </div>
    `;
    
    // 后续的滑动按钮逻辑保持不变
    const actions = document.createElement('div');
    actions.className = 'swipe-actions';
    const pinButtonText = chat.isPinned ? '取消置顶' : '置顶';
    const pinButtonClass = chat.isPinned ? 'unpin' : 'pin';
    actions.innerHTML = `
        <button class="swipe-action-btn ${pinButtonClass}">${pinButtonText}</button>
        <button class="swipe-action-btn delete">删除</button>
    `;
    
    container.appendChild(content);
    container.appendChild(actions);
    
    // --- 【重要】现在这段代码可以正常工作了，因为 .unread-count 元素又回来了！ ---
    const unreadCount = chat.unreadCount || 0;
    const unreadEl = content.querySelector('.unread-count');
    if (unreadCount > 0) {
        unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
        unreadEl.style.display = 'inline-flex';
    } else {
        unreadEl.style.display = 'none';
    }
    
    // 事件监听逻辑保持不变
    const infoEl = content.querySelector('.info');
    if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
    }
const avatarEl = content.querySelector('.avatar, .avatar-with-frame');
if (avatarEl) {
     avatarEl.addEventListener('click', (e) => {
        e.stopPropagation();
        handleUserPat(chat.id, chat.name);
    });
}

    return container;
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这个【带诊断功能的全新版本】替换旧的 renderChatInterface 函数 ▼▼▼
function renderChatInterface(chatId) {
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;
    exitSelectionMode();
    
    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');
    
    document.getElementById('chat-header-title').textContent = chat.name;
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
        statusContainer.style.display = 'none';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
    } else {
        statusContainer.style.display = 'flex';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
        statusTextEl.textContent = chat.status?.text || '在线';
        statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
    }
    
    lockOverlay.style.display = 'none';
    chatInputArea.style.visibility = 'visible';
    lockContent.innerHTML = '';

    if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';
        
        let lockHtml = '';
        switch (chat.relationship.status) {
            case 'blocked_by_user':
                // --- 【核心修改：在这里加入诊断面板】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                lockHtml = `
                    <span class="lock-text">你已将“${chat.name}”拉黑。</span>
                    <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【开发者诊断面板】</strong><br>
                        - 后台活动总开关: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已开启</span>' : '<span style="color: red;">已关闭</span>'}<br>
                        - 系统心跳计时器: ${isSimulationRunning ? '<span style="color: green;">运行中</span>' : '<span style="color: red;">未运行</span>'}<br>
                        - 当前角色状态: <strong>${chat.relationship.status}</strong><br>
                        - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                        - 冷静期是否结束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`}<br>
                        - 触发条件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已满足，等待下次系统心跳</span>' : '<span style="color: red;">未满足</span>'}
                    </div>
                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">强制触发一次好友申请检测</button>
                `;
                // --- 【修改结束】 ---
                break;
            case 'blocked_by_ai':
                lockHtml = `
                    <span class="lock-text">你被对方拉黑了。</span>
                    <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                `;
                break;
            
            case 'pending_user_approval':
                lockHtml = `
                    <span class="lock-text">“${chat.name}”请求添加你为好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                    <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                    <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
                `;
                break;

            // 【核心修正】修复当你申请后，你看到的界面
            case 'pending_ai_approval':
                lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
                break;
        }
        lockContent.innerHTML = lockHtml;
    }
    messagesContainer.innerHTML = '';
    // ...后续代码保持不变
    const chatScreen = document.getElementById('chat-interface-screen');
    chatScreen.style.backgroundImage = chat.settings.background ? `url(${chat.settings.background})` : 'none';

const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
chatScreen.style.backgroundColor = chat.settings.background ? 'transparent' : (isDarkMode ? '#000000' : '#f0f2f5');
    const history = chat.history;
    const totalMessages = history.length;
    currentRenderedCount = 0;
    const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
let lastMessageTimestamp = null;

initialMessages.forEach(msg => {
    if (msg.isHidden || msg.isSystemDecision) return; // 【新增】跳过隐藏消息和系统决策消息

    if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
        // 【核心修改】调用我们新的生成器函数
        const dateStampEl = createDateStampElement(msg.timestamp);
        messagesContainer.insertBefore(dateStampEl, document.getElementById('typing-indicator'));
    }
    
    appendMessage(msg, chat, true);
    
    lastMessageTimestamp = msg.timestamp;
});
    currentRenderedCount = initialMessages.length;
    if (totalMessages > currentRenderedCount) {
        prependLoadMoreButton(messagesContainer);
    }
    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = '对方正在输入...';
    messagesContainer.appendChild(typingIndicator);
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = '加载更早的记录'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }

        function loadMoreMessages() { const messagesContainer = document.getElementById('chat-messages'); const chat = state.chats[state.activeChatId]; if (!chat) return; const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) loadMoreBtn.remove(); const totalMessages = chat.history.length; const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW; const nextSliceEnd = totalMessages - currentRenderedCount; const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd); const oldScrollHeight = messagesContainer.scrollHeight; // ▼▼▼ 请将这个完整的代码块，粘贴到被删除的位置 ▼▼▼

// 1. 找到屏幕上已有的、最老的那条【真实消息】的时间戳
const firstVisibleMessage = messagesContainer.querySelector('.message-wrapper:not(.date-stamp-wrapper)');
let subsequentMessageTimestamp = firstVisibleMessage ? parseInt(firstVisibleMessage.dataset.timestamp) : null;

// 2. 从后往前（从新到旧）遍历我们要新加载的消息
messagesToPrepend.reverse().forEach(currentMsg => {
    // 检查这条新消息和它后面那条（可能是屏幕上已有的，也可能是刚加载的）消息是否跨天
    if (subsequentMessageTimestamp && isNewDay(subsequentMessageTimestamp, currentMsg.timestamp)) {
        // 如果跨天，就为后面那条“较新”的消息创建一个日期戳
        const dateStampEl = createDateStampElement(subsequentMessageTimestamp);
        messagesContainer.prepend(dateStampEl);
    }
    
    // 正常地把当前这条新消息放到最前面
    prependMessage(currentMsg, chat);
    
    // 更新追踪器，为下一次比较做准备
    subsequentMessageTimestamp = currentMsg.timestamp;
});

// 3. 【边界处理】处理所有新加载消息的最前面（也就是整个聊天记录的最老）的那条消息
// 它也需要一个日期戳
if (subsequentMessageTimestamp) {
    const dateStampEl = createDateStampElement(subsequentMessageTimestamp);
    messagesContainer.prepend(dateStampEl);
}

// ▲▲▲ 粘贴结束 ▲▲▲
currentRenderedCount += messagesToPrepend.length; const newScrollHeight = messagesContainer.scrollHeight; messagesContainer.scrollTop += (newScrollHeight - oldScrollHeight); if (totalMessages > currentRenderedCount) { prependLoadMoreButton(messagesContainer); } }

// 立即将关键函数导出到全局作用域，确保其他函数可以访问
window.renderChatInterface = renderChatInterface;
window.openChat = openChat;

// ▼▼▼ 用这个【新版本】替换旧的 renderWallpaperScreen 函数 ▼▼▼
function renderWallpaperScreen() { 
      // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
    // 【核心修复】每次渲染此页面时，都从 localStorage 读取并设置开关的正确状态
    const lockScreenEnabled = localStorage.getItem('lockScreenEnabled') !== 'false';
    const toggle = document.getElementById('enable-lock-screen-toggle');
    if (toggle) {
        toggle.checked = lockScreenEnabled;
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

    const preview = document.getElementById('wallpaper-preview'); 
    const bg = newWallpaperBase64 || state.globalSettings.wallpaper; 
    if (bg && bg.startsWith('data:image')) { 
        preview.style.backgroundImage = `url(${bg})`; 
        preview.textContent = ''; 
    } else if(bg) { 
        preview.style.backgroundImage = bg; 
        preview.textContent = '当前为渐变色'; 
    }

    // 锁屏壁纸预览 (新增逻辑)
    const lockscreenPreview = document.getElementById('lockscreen-wallpaper-preview');
    const lockBg = newLockscreenWallpaperBase64 || state.globalSettings.lockscreenWallpaper;
    if (lockBg && lockBg.startsWith('data:image')) {
        lockscreenPreview.style.backgroundImage = `url(${lockBg})`;
        lockscreenPreview.textContent = '';
    } else if (lockBg) {
        lockscreenPreview.style.backgroundImage = lockBg;
        lockscreenPreview.textContent = '当前为渐变色';
    }

    // 密码输入框 (新增逻辑)
    document.getElementById('password-set-input').value = state.globalSettings.password || '';

    // 【核心修改】在这里调用图标渲染函数
    renderIconSettings();
    
    // 初始化悬浮X Logo
    updateFloatingXLogo();

document.getElementById('ringtone-url-input').value = state.globalSettings.ringtoneUrl || '';
loadHomeScreenPresetsToDropdown(); 
}
// ▲▲▲ 替换结束 ▲▲▲
        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }

async function renderWorldBookScreen() {
    // 初始化标签切换事件
    initWorldBookTabs();
    
    // 渲染当前活动的标签页
    const activeTab = document.querySelector('.tab-button.active').dataset.tab;
    await renderWorldBookPage(activeTab);
}

// 初始化标签切换功能
let worldBookTabsInitialized = false;
function initWorldBookTabs() {
    // 避免重复绑定事件监听器
    if (worldBookTabsInitialized) return;
    
    const tabButtons = document.querySelectorAll('.tab-button');
    tabButtons.forEach(button => {
        button.addEventListener('click', async () => {
            // 移除所有活动状态
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.world-book-page').forEach(page => page.classList.remove('active'));
            
            // 激活当前标签
            button.classList.add('active');
            const tabType = button.dataset.tab;
            document.getElementById(`${tabType}-world-book-page`).classList.add('active');
            
            // 渲染对应页面
            await renderWorldBookPage(tabType);
        });
    });
    
    worldBookTabsInitialized = true;
}

// 防止重复渲染的标志
let isRenderingWorldBookPage = false;

// 渲染指定类型的世界书页面
async function renderWorldBookPage(type) {
    // 防止重复渲染
    if (isRenderingWorldBookPage) {
        console.log(`⚠️ 跳过重复渲染: ${type}`);
        return;
    }
    
    isRenderingWorldBookPage = true;
    
    try {
        const isGlobal = type === 'global';
        const listEl = document.getElementById(`${type}-world-book-list`);
        listEl.innerHTML = '';

    // 1. 同时获取所有书籍和对应类型的分类
    const [allBooks, allCategories] = await Promise.all([
        db.worldBooks.toArray(),
        db.worldBookCategories.toArray()
    ]);
    
    // 过滤并排序分类
    const categories = allCategories
        .filter(cat => cat.isGlobal === isGlobal)
        .sort((a, b) => a.name.localeCompare(b.name));

    // 2. 过滤出对应类型的书籍
    const books = allBooks.filter(book => {
        // 如果没有isGlobal字段，默认为局部世界书
        const bookIsGlobal = book.isGlobal === true;
        return bookIsGlobal === isGlobal;
    });

    state.worldBooks = allBooks; // 确保内存中的数据是同步的

    if (books.length === 0) {
        const emptyMessage = isGlobal ? '点击右上角 "+" 创建你的第一本全局世界书' : '点击右上角 "+" 创建你的第一本局部世界书';
        listEl.innerHTML = `<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">${emptyMessage}</p>`;
        return;
    }

    // 3. 将书籍按 categoryId 分组
    const groupedBooks = books.reduce((acc, book) => {
        const key = book.categoryId || 'uncategorized';
        if (!acc[key]) {
            acc[key] = [];
        }
        acc[key].push(book);
        return acc;
    }, {});
    
    // 4. 优先渲染已分类的书籍
    categories.forEach(category => {
        const booksInCategory = groupedBooks[category.id];
        if (booksInCategory && booksInCategory.length > 0) {
            const groupContainer = createWorldBookGroup(category.name, booksInCategory);
            listEl.appendChild(groupContainer);
        }
    });

    // 5. 最后渲染未分类的书籍
    const uncategorizedBooks = groupedBooks['uncategorized'];
    if (uncategorizedBooks && uncategorizedBooks.length > 0) {
        const groupContainer = createWorldBookGroup('未分类', uncategorizedBooks);
        listEl.appendChild(groupContainer);
    }
    
        // 6. 使用事件委托为分组标题添加折叠事件（避免重复绑定）
        // 注意：事件委托在 init() 函数中统一处理，这里不需要重复添加
    } catch (error) {
        console.error(`❌ 渲染世界书页面出错: ${type}`, error);
    } finally {
        isRenderingWorldBookPage = false;
    }
}

/**
 * 【辅助函数】创建一个分类的分组DOM
 * @param {string} groupName - 分类名称
 * @param {Array} books - 该分类下的书籍数组
 * @returns {HTMLElement} - 创建好的分组容器
 */
function createWorldBookGroup(groupName, books) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'world-book-group-container';
    
    groupContainer.innerHTML = `
        <div class="world-book-group-header">
            <span class="arrow">▼</span>
            <span class="group-name">${groupName}</span>
        </div>
        <div class="world-book-group-content"></div>
    `;

    // ▼▼▼ 在这里添加新代码 ▼▼▼
    const headerEl = groupContainer.querySelector('.world-book-group-header');
    const contentEl = groupContainer.querySelector('.world-book-group-content');
    
    // 默认展开所有分类（移除collapsed类）
    // headerEl.classList.add('collapsed');
    // contentEl.classList.add('collapsed');
    // ▲▲▲ 添加结束 ▲▲▲

    books.sort((a,b) => a.name.localeCompare(b.name, 'zh-CN'));
    books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.dataset.bookId = book.id;
        // 确保 book.content 是字符串类型
        const contentText = typeof book.content === 'string' ? book.content : (book.content ? String(book.content) : '暂无内容...');
        
        // 为全局世界书添加开关
        const switchHtml = book.isGlobal ? `
            <div class="global-wb-switch ${book.isEnabled === true ? 'enabled' : 'disabled'}" 
                 data-book-id="${book.id}" 
                 title="${book.isEnabled === true ? '点击关闭全局生效' : '点击开启全局生效'}">
                <div class="switch-track">
                    <div class="switch-thumb"></div>
                </div>
            </div>
        ` : '';
        
        item.innerHTML = `
            <div class="item-title">${book.name}</div>
            <div class="item-content">${contentText.substring(0, 50)}</div>
            ${switchHtml}
        `;
        
        // 为主体区域添加点击事件（排除开关区域）
        const titleEl = item.querySelector('.item-title');
        const itemContentEl = item.querySelector('.item-content');
        [titleEl, itemContentEl].forEach(el => {
            el.addEventListener('click', () => openWorldBookEditor(book.id));
        });
        
        // 为开关添加点击事件
        const switchEl = item.querySelector('.global-wb-switch');
        if (switchEl) {
            switchEl.addEventListener('click', async (e) => {
                e.stopPropagation(); // 防止触发世界书编辑
                await toggleGlobalWorldBookSwitch(book.id);
            });
        }
        
        addLongPressListener(item, async () => { const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.worldBooks.delete(book.id); state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); renderWorldBookScreen(); } });
        contentEl.appendChild(item); 
    });

    return groupContainer;
}
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

// 切换全局世界书开关状态
async function toggleGlobalWorldBookSwitch(bookId) {
    try {
        const book = await db.worldBooks.get(bookId);
        if (!book || !book.isGlobal) {
            console.error('只能切换全局世界书的开关状态');
            return;
        }
        
        // 切换状态：只有明确为true时才切换为false，其他情况都切换为true
        const newEnabledState = book.isEnabled === true ? false : true;
        
        // 更新数据库
        await db.worldBooks.update(bookId, { isEnabled: newEnabledState });
        
        // 更新内存中的状态
        const bookIndex = state.worldBooks.findIndex(wb => wb.id === bookId);
        if (bookIndex !== -1) {
            state.worldBooks[bookIndex].isEnabled = newEnabledState;
        }
        
        // 更新UI
        const switchEl = document.querySelector(`.global-wb-switch[data-book-id="${bookId}"]`);
        if (switchEl) {
            if (newEnabledState) {
                switchEl.classList.remove('disabled');
                switchEl.classList.add('enabled');
                switchEl.title = '点击关闭全局生效';
            } else {
                switchEl.classList.remove('enabled');
                switchEl.classList.add('disabled');
                switchEl.title = '点击开启全局生效';
            }
        }
        
        console.log(`🔄 全局世界书《${book.name}》开关已${newEnabledState ? '开启' : '关闭'}`);
        
    } catch (error) {
        console.error('切换全局世界书开关时出错:', error);
        alert('切换开关失败，请重试');
    }
}

// 获取对指定聊天生效的所有世界书ID（局部勾选的 + 已开启的全局的）
function getEffectiveWorldBookIds(chat) {
    const effectiveWorldBookIds = [];
    
    // 添加局部世界书（需要勾选的，但排除全局世界书）
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        // 过滤掉全局世界书ID，只保留真正的局部世界书
        const localWorldBookIds = chat.settings.linkedWorldBookIds.filter(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && !worldBook.isGlobal; // 只保留非全局的世界书
        });
        effectiveWorldBookIds.push(...localWorldBookIds);
        console.log('🔗 局部世界书:', localWorldBookIds);
        
        // 如果发现有全局世界书ID在局部列表中，清理它们
        const globalIdsInLocal = chat.settings.linkedWorldBookIds.filter(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.isGlobal;
        });
                 if (globalIdsInLocal.length > 0) {
             console.warn('⚠️ 发现局部列表中包含全局世界书ID，正在清理:', globalIdsInLocal);
             // 清理局部列表中的全局世界书ID
             chat.settings.linkedWorldBookIds = localWorldBookIds;
             // 保存修复后的聊天数据到数据库
             db.chats.put(chat).then(() => {
                 console.log('✅ 已清理并保存聊天数据');
             }).catch(err => {
                 console.error('❌ 保存聊天数据失败:', err);
             });
         }
    }
    
    // 添加已开启的全局世界书（自动生效的）
    const enabledGlobalWorldBooks = state.worldBooks.filter(wb => 
        wb.isGlobal && wb.isEnabled === true // 只有明确开启的才生效
    );
    console.log('🌍 全局世界书状态检查:');
    state.worldBooks.filter(wb => wb.isGlobal).forEach(wb => {
        console.log(`  - ${wb.name}: isEnabled=${wb.isEnabled}, 类型=${typeof wb.isEnabled}`);
    });
    console.log('✅ 已启用的全局世界书:', enabledGlobalWorldBooks.map(wb => wb.name));
    
    effectiveWorldBookIds.push(...enabledGlobalWorldBooks.map(wb => wb.id));
    
    // 去重并返回
    const result = [...new Set(effectiveWorldBookIds)];
    console.log('📖 最终生效的世界书ID:', result);
    return result;
}

// 【新增】通用的相册照片处理函数
function processAlbumPhotos(content) {
    let processedContent = content;
    
    // 1. 处理恋爱相册照片 [PHOTO:xxx] 格式
    const photoPattern = /\[PHOTO:([^[\]]+)\]/g;
    processedContent = processedContent.replace(photoPattern, (match, photoId) => {
        return `<div class="album-photo-loading" data-photo-id="${photoId}">正在加载恋爱相册照片...</div>`;
    });
    
    // 2. 处理私人相册照片 [PRIVATE_PHOTO:xxx] 格式
    const privatePhotoPattern = /\[PRIVATE_PHOTO:([^[\]]+)\]/g;
    processedContent = processedContent.replace(privatePhotoPattern, (match, photoIndex) => {
        return `<div class="private-photo-loading" data-photo-index="${photoIndex}">正在加载私人相册照片...</div>`;
    });
    
    return processedContent;
}

// 【新增】AI消息专用的简洁照片处理函数（不显示底部信息框）
function processAlbumPhotosForAI(content) {
    let processedContent = content;
    
    // 1. 处理恋爱相册照片 [PHOTO:xxx] 格式
    const photoPattern = /\[PHOTO:([^[\]]+)\]/g;
    processedContent = processedContent.replace(photoPattern, (match, photoId) => {
        return `<div class="ai-photo-loading" data-photo-id="${photoId}">正在加载恋爱相册照片...</div>`;
    });
    
    // 2. 处理私人相册照片 [PRIVATE_PHOTO:xxx] 格式
    const privatePhotoPattern = /\[PRIVATE_PHOTO:([^[\]]+)\]/g;
    processedContent = processedContent.replace(privatePhotoPattern, (match, photoIndex) => {
        return `<div class="ai-private-photo-loading" data-photo-index="${photoIndex}">正在加载私人相册照片...</div>`;
    });
    
    return processedContent;
}

// 【新增】AI消息专用的简洁照片加载函数（只显示图片，无底部信息框）
async function loadAIPhotosInElement(element) {
    const photoElements = element.querySelectorAll('.ai-photo-loading');
    for (const photoElement of photoElements) {
        const photoId = photoElement.dataset.photoId;
        try {
            // 在所有相册中查找指定ID的照片
            let photo = null;
            const albums = await db.loveAlbums.toArray();
            
            for (const album of albums) {
                if (album.photos && album.photos.length > 0) {
                    const foundPhoto = album.photos.find(p => p.id == photoId);
                    if (foundPhoto) {
                        photo = foundPhoto;
                        break;
                    }
                }
            }
            
            if (photo && (photo.src || photo.url)) {
                // 使用和恋爱空间内部一样的卡片格式
                const imageSrc = photo.src || photo.url;
                const photoName = photo.name || photo.title || '照片';
                const photoNote = photo.description || photo.caption || photo.note || '';
                
                // 创建完整的照片卡片HTML
                const photoCardHtml = `
<div class="album-photo-item" style="display: inline-block; margin: 10px; background: rgba(248, 248, 248, 0.95); border-radius: 12px; padding: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); perspective: 1000px; width: 150px;">
    <div class="photo-card" style="position: relative; width: 100%; aspect-ratio: 1 / 1.1; transition: transform 0.6s; transform-style: preserve-3d;">
        <div class="photo-front" style="border-radius: 8px; overflow: hidden; display: flex; flex-direction: column;">
            <img src="${imageSrc}" alt="照片" style="width: 100%; aspect-ratio: 1/1; object-fit: cover; border-radius: 8px 8px 0 0; cursor: pointer;" onclick="showImageViewer('${imageSrc}')">
            <div class="photo-title" style="position: absolute; bottom: 0; left: 0; right: 0; height: 15%; background: rgba(255, 255, 255, 0.95); border-radius: 0 0 8px 8px; font-size: 11px; color: #555; text-align: center; display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 2px 6px; box-sizing: border-box;" onclick="flipPhotoCard(this)">
                <div class="title-text-container" style="flex: 1; overflow: hidden;">
                    <span class="title-text">${photoName}</span>
                </div>
                <span class="flip-icon" style="font-size: 12px; opacity: 0.7;">⟲</span>
            </div>
        </div>
        <div class="photo-back" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.98); border-radius: 8px; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 12px; box-sizing: border-box; transform: rotateY(180deg); backface-visibility: hidden;">
            <div class="photo-note" style="flex: 1; display: flex; align-items: center; justify-content: center; text-align: center; font-size: 12px; color: #666; line-height: 1.4; overflow-y: auto; word-wrap: break-word;">
                ${photoNote || '暂无备注'}
            </div>
            <div class="photo-back-title" style="font-size: 10px; color: #999; margin-top: 8px; text-align: center;">
                ${photoName}
            </div>
        </div>
    </div>
</div>`;
                
                // 创建临时容器并设置HTML
                const tempContainer = document.createElement('div');
                tempContainer.innerHTML = photoCardHtml;
                const photoCard = tempContainer.firstElementChild;
                
                // 替换占位符
                photoElement.parentNode.replaceChild(photoCard, photoElement);
            } else {
                // 照片不存在或无效
                const errorMsg = photoId === 'undefined' ? 
                    '⚠️ AI引用了无效的照片，请重新训练AI只使用有效的照片ID' : 
                    `🌺 照片 "${photoId}" 不存在，请检查照片ID是否正确`;
                photoElement.innerHTML = `<div class="ai-photo-error" style="color: #ff6b6b; padding: 8px; border: 1px solid #ffcccc; border-radius: 4px; background: #fff5f5;">${errorMsg}</div>`;
                photoElement.className = 'ai-photo-error';
            }
        } catch (error) {
            console.error('加载AI照片失败:', error);
            photoElement.innerHTML = `<div class="ai-photo-error">照片加载失败</div>`;
            photoElement.className = 'ai-photo-error';
        }
    }
}

// 【新增】根据角色名称获取私人照片的函数
function getPrivatePhotosByCharacterName(characterName) {
    if (!characterName) {
        console.log('🔍 getPrivatePhotosByCharacterName: 没有角色名称');
        return [];
    }
    
    // 查找联系人ID - 从 state.chats 中获取
    const contacts = Object.values(state.chats || {}).filter(chat => !chat.isGroup);
    const contact = contacts.find(c => c.name === characterName);
    
    if (!contact) {
        console.log('🔍 未找到角色对应的联系人:', {
            characterName,
            availableContacts: contacts.map(c => c.name)
        });
        return [];
    }
    
    // 获取该联系人的私人空间数据
    const dataKey = `privateSpace_${contact.id}`;
    const savedData = localStorage.getItem(dataKey);
    
    if (savedData) {
        const data = JSON.parse(savedData);
        const photos = data.privatePhotos || [];
        console.log('🔍 找到角色私人照片:', {
            characterName,
            contactId: contact.id,
            dataKey,
            photosCount: photos.length
        });
        return photos;
    }
    
    console.log('🔍 没有找到角色的私人空间数据:', {
        characterName,
        contactId: contact.id,
        dataKey
    });
    return [];
}

// 【新增】AI消息专用的私人相册照片加载函数
async function loadAIPrivatePhotosInElement(element, senderName = null) {
    const photoElements = element.querySelectorAll('.ai-private-photo-loading');
    for (const photoElement of photoElements) {
        const photoIndex = photoElement.dataset.photoIndex;
        try {
            // 根据发送者名称获取对应的私人照片，如果没有发送者名称则使用当前的
            let privatePhotos;
            if (senderName) {
                privatePhotos = getPrivatePhotosByCharacterName(senderName);
                console.log('🔍 AI私人照片加载:', {
                    senderName,
                    photoIndex,
                    photosCount: privatePhotos.length,
                    hasPhoto: !!privatePhotos[photoIndex]
                });
            } else {
                privatePhotos = window.privatePhotos || [];
                console.log('🔍 使用当前私人照片:', {
                    photoIndex,
                    photosCount: privatePhotos.length,
                    hasPhoto: !!privatePhotos[photoIndex]
                });
            }
            
            const photo = privatePhotos[photoIndex];
            
            if (photo && photo.src) {
                // 使用和恋爱相册一样的卡片格式
                const imageSrc = photo.src;
                const photoName = photo.name || '私人照片';
                const photoNote = photo.note || '';
                
                // 创建完整的照片卡片HTML
                const photoCardHtml = `
<div class="album-photo-item" style="display: inline-block; margin: 10px; background: rgba(248, 248, 248, 0.95); border-radius: 12px; padding: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); perspective: 1000px; width: 150px;">
    <div class="photo-card" style="position: relative; width: 100%; aspect-ratio: 1 / 1.1; transition: transform 0.6s; transform-style: preserve-3d;">
        <div class="photo-front" style="border-radius: 8px; overflow: hidden; display: flex; flex-direction: column;">
            <img src="${imageSrc}" alt="私人照片" style="width: 100%; aspect-ratio: 1/1; object-fit: cover; border-radius: 8px 8px 0 0; cursor: pointer;" onclick="showImageViewer('${imageSrc}')">
            <div class="photo-title" style="position: absolute; bottom: 0; left: 0; right: 0; height: 15%; background: rgba(255, 255, 255, 0.95); border-radius: 0 0 8px 8px; font-size: 11px; color: #555; text-align: center; display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 2px 6px; box-sizing: border-box;" onclick="flipPhotoCard(this)">
                <div class="title-text-container" style="flex: 1; overflow: hidden;">
                    <span class="title-text">${photoName}</span>
                </div>
                <span class="flip-icon" style="font-size: 12px; opacity: 0.7;">⟲</span>
            </div>
        </div>
        <div class="photo-back" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.98); border-radius: 8px; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 12px; box-sizing: border-box; transform: rotateY(180deg); backface-visibility: hidden;">
            <div class="photo-note" style="flex: 1; display: flex; align-items: center; justify-content: center; text-align: center; font-size: 12px; color: #666; line-height: 1.4; overflow-y: auto; word-wrap: break-word;">
                ${photoNote || '暂无备注'}
            </div>
            <div class="photo-back-title" style="font-size: 10px; color: #999; margin-top: 8px; text-align: center;">
                ${photoName}
            </div>
        </div>
    </div>
</div>`;
                
                // 创建临时容器并设置HTML
                const tempContainer = document.createElement('div');
                tempContainer.innerHTML = photoCardHtml;
                const photoCard = tempContainer.firstElementChild;
                
                // 替换占位符
                photoElement.parentNode.replaceChild(photoCard, photoElement);
            } else {
                // 照片不存在或无效 - 添加详细调试信息
                console.error('❌ 私人照片加载失败详情:', {
                    photoIndex,
                    photoIndexType: typeof photoIndex,
                    senderName,
                    privatePhotos,
                    photosLength: privatePhotos.length,
                    availableIndexes: privatePhotos.map((_, i) => i)
                });
                
                const errorMsg = photoIndex === 'undefined' ? 
                    '⚠️ AI引用了无效的私人照片，请重新训练AI只使用有效的照片索引' : 
                    `🌺 私人照片索引 "${photoIndex}" 不存在，请检查照片索引是否正确（当前有${privatePhotos.length}张照片，可用索引：${privatePhotos.map((_, i) => i).join(', ')}）`;
                photoElement.innerHTML = `<div class="ai-photo-error" style="color: #ff6b6b; padding: 8px; border: 1px solid #ffcccc; border-radius: 4px; background: #fff5f5;">${errorMsg}</div>`;
                photoElement.className = 'ai-photo-error';
            }
        } catch (error) {
            console.error('加载AI私人照片失败:', error);
            photoElement.innerHTML = `<div class="ai-photo-error">私人照片加载失败</div>`;
            photoElement.className = 'ai-photo-error';
        }
    }
}

// 【新增】异步加载照片的函数
async function loadAlbumPhotosInElement(element) {
    const photoElements = element.querySelectorAll('.album-photo-loading');
    for (const photoElement of photoElements) {
        const photoId = photoElement.dataset.photoId;
        try {
            // 在所有相册中查找指定ID的照片
            let photo = null;
            const albums = await db.loveAlbums.toArray();
            
            for (const album of albums) {
                if (album.photos && album.photos.length > 0) {
                    const foundPhoto = album.photos.find(p => p.id == photoId);
                    if (foundPhoto) {
                        photo = foundPhoto;
                        break;
                    }
                }
            }
            
            if (photo && (photo.src || photo.url)) {
                // 【修改为简洁显示】创建简洁的图片容器
                const imgContainer = document.createElement('div');
                imgContainer.className = 'album-photo-container';
                imgContainer.style.cssText = `
                    display: inline-block;
                    margin: 4px;
                    border-radius: 8px;
                    overflow: hidden;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    transition: transform 0.2s ease;
                `;
                
                // 创建简洁的图片元素
                const img = document.createElement('img');
                img.src = photo.src || photo.url;
                img.alt = photo.name || photo.title || '照片';
                img.className = 'album-photo-image';
                img.style.cssText = `
                    max-width: 200px;
                    max-height: 200px;
                    width: auto;
                    height: auto;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: transform 0.2s ease;
                `;
                
                // 添加悬停效果
                img.addEventListener('mouseenter', () => {
                    img.style.transform = 'scale(1.05)';
                });
                img.addEventListener('mouseleave', () => {
                    img.style.transform = 'scale(1)';
                });
                
                // 点击图片时显示大图
                img.addEventListener('click', () => {
                    showImageModal(img.src, photo.name || photo.title || '照片');
                });
                
                imgContainer.appendChild(img);
                
                // 替换占位符
                photoElement.parentNode.replaceChild(imgContainer, photoElement);
            } else {
                // 照片不存在或无效
                const errorMsg = photoId === 'undefined' ? 
                    '⚠️ AI引用了无效的照片，请重新训练AI只使用有效的照片ID' : 
                    `🌺 照片 "${photoId}" 不存在，请检查照片ID是否正确`;
                photoElement.innerHTML = `<div class="album-photo-error" style="color: #ff6b6b; padding: 8px; border: 1px solid #ffcccc; border-radius: 4px; background: #fff5f5;">${errorMsg}</div>`;
                photoElement.className = 'album-photo-error';
            }
        } catch (error) {
            console.error('加载相册照片失败:', error);
            photoElement.innerHTML = `<div class="album-photo-error">照片加载失败</div>`;
            photoElement.className = 'album-photo-error';
        }
    }
}

// 【新增】用户消息专用的私人相册照片加载函数
async function loadPrivatePhotosInElement(element, senderName = null) {
    const photoElements = element.querySelectorAll('.private-photo-loading');
    for (const photoElement of photoElements) {
        const photoIndex = photoElement.dataset.photoIndex;
        try {
            // 根据发送者名称获取对应的私人照片，如果没有发送者名称则使用当前的
            let privatePhotos;
            if (senderName) {
                privatePhotos = getPrivatePhotosByCharacterName(senderName);
                console.log('🔍 动态私人照片加载:', {
                    senderName,
                    photoIndex,
                    photosCount: privatePhotos.length,
                    hasPhoto: !!privatePhotos[photoIndex]
                });
            } else {
                privatePhotos = window.privatePhotos || [];
                console.log('🔍 使用当前私人照片:', {
                    photoIndex,
                    photosCount: privatePhotos.length,
                    hasPhoto: !!privatePhotos[photoIndex]
                });
            }
            
            // 从私人相册中获取指定索引的照片
            const photo = privatePhotos && privatePhotos[photoIndex];
            
            if (photo && photo.src) {
                // 【修改为简洁显示】创建简洁的图片容器
                const imgContainer = document.createElement('div');
                imgContainer.className = 'private-photo-container';
                imgContainer.style.cssText = `
                    display: inline-block;
                    margin: 4px;
                    border-radius: 8px;
                    overflow: hidden;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    transition: transform 0.2s ease;
                `;
                
                // 创建简洁的图片元素
                const img = document.createElement('img');
                img.src = photo.src;
                img.alt = photo.name || '私人照片';
                img.className = 'private-photo-image';
                img.style.cssText = `
                    max-width: 200px;
                    max-height: 200px;
                    width: auto;
                    height: auto;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: transform 0.2s ease;
                `;
                
                // 添加悬停效果
                img.addEventListener('mouseenter', () => {
                    img.style.transform = 'scale(1.05)';
                });
                img.addEventListener('mouseleave', () => {
                    img.style.transform = 'scale(1)';
                });
                
                // 添加点击查看大图功能
                img.addEventListener('click', () => {
                    showImageModal(photo.src, photo.name || '私人照片');
                });
                
                imgContainer.appendChild(img);
                
                // 替换占位符
                photoElement.parentNode.replaceChild(imgContainer, photoElement);
            } else {
                // 照片不存在或无效
                const errorMsg = photoIndex === 'undefined' ? 
                    '⚠️ 引用了无效的私人照片，请检查照片索引' : 
                    `🌺 私人照片索引 "${photoIndex}" 不存在，请检查照片索引是否正确`;
                photoElement.innerHTML = `<div class="private-photo-error" style="color: #ff6b6b; padding: 8px; border: 1px solid #ffcccc; border-radius: 4px; background: #fff5f5;">${errorMsg}</div>`;
                photoElement.className = 'private-photo-error';
            }
        } catch (error) {
            console.error('加载私人照片失败:', error);
            photoElement.innerHTML = `<div class="private-photo-error">私人照片加载失败</div>`;
            photoElement.className = 'private-photo-error';
        }
    }
}

// 【新增】全屏图片查看模态框函数
function showImageModal(imageSrc, imageTitle = '照片') {
    // 创建模态框容器
    const modal = document.createElement('div');
    modal.className = 'image-modal-overlay';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.3s ease;
    `;
    
    // 创建图片容器
    const imageContainer = document.createElement('div');
    imageContainer.style.cssText = `
        max-width: 95vw;
        max-height: 95vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: default;
    `;
    
    // 创建图片元素
    const img = document.createElement('img');
    img.src = imageSrc;
    img.alt = imageTitle;
    img.style.cssText = `
        max-width: 100%;
        max-height: 90vh;
        object-fit: contain;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        cursor: pointer;
    `;
    
    // 创建标题（如果有的话）
    const title = document.createElement('div');
    title.textContent = imageTitle;
    title.style.cssText = `
        color: white;
        font-size: 16px;
        margin-top: 15px;
        text-align: center;
        max-width: 90vw;
        word-wrap: break-word;
    `;
    
    // 创建关闭按钮
    const closeBtn = document.createElement('div');
    closeBtn.innerHTML = '✕';
    closeBtn.style.cssText = `
        position: absolute;
        top: 20px;
        right: 30px;
        color: white;
        font-size: 30px;
        font-weight: bold;
        cursor: pointer;
        z-index: 10000;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.5);
        transition: background-color 0.2s ease;
    `;
    
    // 关闭按钮悬停效果
    closeBtn.addEventListener('mouseenter', () => {
        closeBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
    });
    closeBtn.addEventListener('mouseleave', () => {
        closeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    });
    
    // 组装结构
    imageContainer.appendChild(img);
    imageContainer.appendChild(title);
    modal.appendChild(imageContainer);
    modal.appendChild(closeBtn);
    
    // 关闭模态框函数
    const closeModal = () => {
        modal.style.opacity = '0';
        setTimeout(() => {
            if (modal.parentNode) {
                modal.parentNode.removeChild(modal);
            }
        }, 300);
    };
    
    // 添加事件监听器
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeModal();
        }
    });
    
    closeBtn.addEventListener('click', closeModal);
    
    // 键盘ESC关闭
    const handleKeyPress = (e) => {
        if (e.key === 'Escape') {
            closeModal();
            document.removeEventListener('keydown', handleKeyPress);
        }
    };
    document.addEventListener('keydown', handleKeyPress);
    
    // 阻止图片容器的点击事件冒泡
    imageContainer.addEventListener('click', (e) => {
        e.stopPropagation();
    });
    
    // 添加到页面并显示
    document.body.appendChild(modal);
    
    // 延迟显示以触发过渡动画
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);
}

async function openWorldBookEditor(bookId) {
    editingWorldBookId = bookId;
    const book = await db.worldBooks.get(bookId);
    if (!book) return;
    
    // 获取与该世界书同类型的分类
    const allCategories = await db.worldBookCategories.toArray();
    const categories = allCategories
        .filter(cat => cat.isGlobal === (book.isGlobal === true))
        .sort((a, b) => a.name.localeCompare(b.name));

    const bookType = book.isGlobal ? '全局世界书' : '局部世界书';
    document.getElementById('world-book-editor-title').textContent = `${book.name} (${bookType})`;
    document.getElementById('world-book-name-input').value = book.name;
    document.getElementById('world-book-content-input').value = book.content;

    // 【核心修改】填充分类下拉菜单
    const selectEl = document.getElementById('world-book-category-select');
    selectEl.innerHTML = '<option value="">-- 未分类 --</option>'; // 默认选项
    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.id;
        option.textContent = cat.name;
        if (book.categoryId === cat.id) {
            option.selected = true; // 选中当前分类
        }
        selectEl.appendChild(option);
    });

    showScreen('world-book-editor-screen');
}

        function renderStickerPanel() { const grid = document.getElementById('sticker-grid'); grid.innerHTML = ''; if (state.userStickers.length === 0) { grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">大人请点击右上角“添加”或“上传”来添加你的第一个表情吧！</p>'; return; } state.userStickers.forEach(sticker => { const item = document.createElement('div'); item.className = 'sticker-item'; item.style.backgroundImage = `url(${sticker.url})`; item.title = sticker.name; item.addEventListener('click', () => sendSticker(sticker)); addLongPressListener(item, () => { if (isSelectionMode) return; const existingDeleteBtn = item.querySelector('.delete-btn'); if (existingDeleteBtn) return; const deleteBtn = document.createElement('div'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.onclick = async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.userStickers.delete(sticker.id); state.userStickers = state.userStickers.filter(s => s.id !== sticker.id); renderStickerPanel(); } }; item.appendChild(deleteBtn); deleteBtn.style.display = 'block'; setTimeout(() => item.addEventListener('mouseleave', () => deleteBtn.remove(), { once: true }), 3000); }); grid.appendChild(item); }); }

// ▼▼▼ 用这个【已更新】的版本替换旧的 createMessageElement 函数 ▼▼▼
function createMessageElement(msg, chat) {

    // ▼▼▼ 在函数最开头，添加这段新代码 ▼▼▼
if (msg.type === 'recalled_message') {
    const wrapper = document.createElement('div');
    // 1. 【核心】给 wrapper 也加上 timestamp，方便事件委托时查找
    wrapper.className = 'message-wrapper system-pat';
    wrapper.dataset.timestamp = msg.timestamp; 

    const bubble = document.createElement('div');
    // 2. 【核心】让这个元素同时拥有 .message-bubble 和 .recalled-message-placeholder 两个class
    //    这样它既能被选择系统识别，又能保持原有的居中灰色样式
    bubble.className = 'message-bubble recalled-message-placeholder';
    // 3. 【核心】把 timestamp 放在 bubble 上，这是多选逻辑的关键
    bubble.dataset.timestamp = msg.timestamp; 
    bubble.textContent = msg.content;
    
    wrapper.appendChild(bubble);
    
    // 4. 【核心】为它补上和其他消息一样的标准事件监听器
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(msg.timestamp);
        }
    });

    // 5. 【重要】在之前的“点击查看原文”的逻辑中，我们已经使用了事件委托，所以这里不需要再单独为这个元素添加点击事件了。
    //    init() 函数中的那个事件监听器会处理它。
    
    return wrapper;
}
    // ▲▲▲ 添加结束 ▲▲▲

    if (msg.isHidden || msg.isSystemDecision) {
        return null;
    }

    if (msg.type === 'pat_message') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat'; 
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble'; 
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;
        wrapper.appendChild(bubble);
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        return wrapper;
    }

    const isUser = msg.role === 'user';
    const isSystem = msg.role === 'system';
    const wrapper = document.createElement('div');
    
    if (isSystem) {
        wrapper.className = 'message-wrapper system-pat';
    } else {
        // 根据消息的模式状态添加相应的类
        const modeClass = msg.offlineMode ? 'offline-message' : '';
        wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'} ${modeClass}`.trim();
    }

    // ★★★【核心重构】★★★
    // 这段逻辑现在用于查找成员对象，并显示其“群昵称”
    if (chat.isGroup && !isUser && !isSystem) {
        // 1. 使用AI返回的“本名”(`msg.senderName`)去列表里查找成员对象
        const member = chat.members.find(m => m.originalName === msg.senderName);
        
        // 2. 创建用于显示名字的 div
        const senderNameDiv = document.createElement('div');
        senderNameDiv.className = 'sender-name';
        
        // 3. 如果找到了成员，就显示他的“群昵称”；如果找不到，就显示AI返回的“本名”作为备用
        senderNameDiv.textContent = member ? member.groupNickname : (msg.senderName || '未知成员');
        
        wrapper.appendChild(senderNameDiv);
    }

    const bubble = document.createElement('div');
    if (isSystem) {
        bubble.className = 'message-bubble system-bubble';
    } else {
    bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
    }
    bubble.dataset.timestamp = msg.timestamp;
    if (msg.id) {
        bubble.dataset.messageId = msg.id;
    }

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    timestampEl.textContent = formatTimestamp(msg.timestamp);

    // 找到确定 avatarSrc 的那段代码
    let avatarSrc, avatarFrameSrc = ''; // <--- 声明两个变量
    if (chat.isGroup) {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || ''; // <--- 获取“我”的头像框
        } else {
            const member = chat.members.find(m => m.originalName === msg.senderName);
            avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
            avatarFrameSrc = member ? (member.avatarFrame || '') : ''; // <--- 获取成员的头像框
        }
    } else {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || ''; // <--- 获取“我”的头像框
        } else {
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.aiAvatarFrame || ''; // <--- 获取AI的头像框
        }
    }

    // ▼▼▼ 用下面这整块【条件渲染逻辑】替换你7.23版中简单的 avatarHtml 声明 ▼▼▼
    let avatarHtml;
    // 如果存在头像框URL
    if (avatarFrameSrc) {
        avatarHtml = `<div class="avatar-with-frame"><img src="${avatarSrc}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
    } else {
    // 如果没有，就使用最简单的头像结构
        avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    }
    const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
    const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;
    // ▲▲▲ 替换结束 ▲▲▲

    let contentHtml;
    
    if (msg.type === 'share_link') {
        bubble.classList.add('is-link-share');
        
        // 【核心修正1】将 onclick="openBrowser(...)" 移除，我们将在JS中动态绑定事件
        contentHtml = `
            <div class="link-share-card" data-timestamp="${msg.timestamp}">
                <div class="title">${msg.title || '无标题'}</div>
                <div class="description">${msg.description || '点击查看详情...'}</div>
                <div class="footer">
                    <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                    <span>${msg.source_name || '链接分享'}</span>
                </div>
            </div>
        `;
    }

else if (msg.type === 'share_card') {
    bubble.classList.add('is-link-share'); // 复用链接分享的卡片样式
    // 【核心】把时间戳加到卡片上，方便后面点击时识别
    contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
            <div class="title">${msg.payload.title}</div>
            <div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div>
            <div class="footer">
                <svg class="footer-icon" ...>...</svg> <!-- 复用链接分享的图标 -->
                <span>聊天记录</span>
            </div>
        </div>
    `;
}

// ▼▼▼ 用这整块【SVG生成版】的代码，替换旧的 location 'else if' 块 ▼▼▼
else if (msg.type === 'location') {
    bubble.classList.add('is-location');
    
    const currentChat = state.chats[state.activeChatId] || Object.values(state.chats).find(c => c.history.some(h => h.timestamp === msg.timestamp));
    const myNickname = currentChat.settings.myNickname || '我';
    const aiNickname = currentChat.name;

    // --- SVG 动态生成 ---
    const trajectoryPoints = msg.trajectoryPoints || [];
    const hasTrajectory = trajectoryPoints.length > 0;
    
    // 1. 定义SVG路径和坐标
    const pathData = "M 20 45 Q 115 10 210 45"; // 一条预设的优美曲线
    const startPoint = { x: 20, y: 45 };
    const endPoint = { x: 210, y: 45 };

    // 2. 生成起点和终点的SVG元素
    let pinsSvg = '';
    if (msg.userLocation) {
        pinsSvg += `<circle class="svg-pin user-pin" cx="${startPoint.x}" cy="${startPoint.y}" r="6" />`;
    }
    if (msg.aiLocation) {
        pinsSvg += `<circle class="svg-pin ai-pin" cx="${endPoint.x}" cy="${endPoint.y}" r="6" />`;
    }

    // 3. 如果有轨迹，生成途经点的SVG元素
    let trajectorySvg = '';

if (hasTrajectory) {
    // --- ▼▼▼ 【最终修复版】使用浏览器API精确计算坐标 ▼▼▼ ---

    // 1. 定义我们的S形曲线路径数据 (不变)
    const s_curve_pathData = "M 20 45 C 80 70, 150 20, 210 45";
    trajectorySvg += `<path class="svg-trajectory-path" d="${s_curve_pathData}" />`;

    // 2. 【核心】在内存中创建一个真实的SVG路径元素，以便使用API
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', s_curve_pathData);
    
    // 3. 获取这条路径的总长度
    const totalPathLength = path.getTotalLength();
    
    const totalPoints = trajectoryPoints.length;
    trajectoryPoints.forEach((point, index) => {
        // 4. 计算每个点应该在路径总长度的哪个位置
        const progress = (index + 1) / (totalPoints + 1);
        const lengthOnPath = totalPathLength * progress;
        
        // 5. 【魔法在这里！】直接向浏览器查询这个位置的精确坐标
        const pointOnPath = path.getPointAtLength(lengthOnPath);
        const pointX = pointOnPath.x;
        const pointY = pointOnPath.y;

        // 6. 后续的“一上一下”布局逻辑保持不变
        let yOffset;
        if (index % 2 === 0) { // 第1, 3...个点
            yOffset = 18; // 向下
        } else { // 第2, 4...个点
            yOffset = -10; // 向上
        }

        const footprintY = pointY + yOffset;
        const labelY = footprintY + (yOffset > 0 ? 12 : -12);

        // 7. 使用100%精确的坐标生成SVG
        trajectorySvg += `
            <text class="svg-footprint" x="${pointX}" y="${footprintY}" text-anchor="middle">🐾</text>
            <text class="svg-location-label" x="${pointX}" y="${labelY}" text-anchor="middle">${point.name}</text>
        `;
    });
    // --- ▲▲▲ 修复结束 ▲▲▲ ---
}
    
    // 4. 构建地点信息HTML
    const userLocationHtml = `<p class="${!msg.userLocation ? 'hidden' : ''}"><span class="name-tag">${myNickname}:</span> ${msg.userLocation}</p>`;
    const aiLocationHtml = `<p class="${!msg.aiLocation ? 'hidden' : ''}"><span class="name-tag">${aiNickname}:</span> ${msg.aiLocation}</p>`;

    // 5. 拼接最终的 contentHtml
    contentHtml = `
        <div class="location-card">
            <div class="location-map-area">
                <svg viewBox="0 0 230 90">
                    ${trajectorySvg}
                    ${pinsSvg}
                </svg>
            </div>
            <div class="location-info">
                <div class="location-address">
                    ${aiLocationHtml}
                    ${userLocationHtml}
                </div>
                <div class="location-distance">相距 ${msg.distance}</div>
            </div>
        </div>
    `;
}
// ▲▲▲ 替换结束 ▲▲▲

    // 后续的其他 else if 保持不变
    else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
        bubble.classList.add('is-ai-image', 'is-card-like');
        const altText = msg.type === 'user_photo' ? "用户描述的照片" : "AI生成的图片";
        contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
    } else if (msg.type === 'realimag') {
        // RealImag真实图片渲染
        bubble.classList.add('is-realimag', 'is-card-like');
        contentHtml = `<img src="${msg.imageUrl}" class="realimag-image" alt="RealImag分享" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
    } else if (msg.type === 'naiimag') {
        // NovelAI图片渲染（复用realimag样式）
        bubble.classList.add('is-realimag', 'is-card-like');
        contentHtml = `<img src="${msg.imageUrl}" class="realimag-image" alt="NovelAI图片分享" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';" title="${msg.fullPrompt || msg.prompt || 'NovelAI生成'}">`;
    } else if (msg.type === 'voice_message') {
    bubble.classList.add('is-voice-message', 'is-card-like');
    
    // 【核心修正1】将语音原文存储在父级气泡的 data-* 属性中，方便事件处理器获取
    bubble.dataset.voiceText = msg.content;
    
    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
    
    // 【核心修正2】构建包含所有新元素的完整 HTML
    contentHtml = `
        <div class="voice-message-body">
            <div class="voice-waveform">${waveformHTML}</div>
            <div class="loading-spinner"></div>
            <span class="voice-duration">${durationFormatted}</span>
        </div>
        <div class="voice-transcript"></div>
    `;
} else if (msg.type === 'transfer') {
    bubble.classList.add('is-transfer');
    
    let titleText, noteText;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    if (isUser) { // 消息是用户发出的
        if (msg.isRefund) {
            // 用户发出的退款（即用户拒收了AI的转账）
            titleText = `退款给 ${chat.name}`;
            noteText = '已拒收对方转账';
        } else {
            // 用户主动发起的转账
            titleText = `转账给 ${msg.receiverName || chat.name}`;
            if (msg.status === 'accepted') {
                noteText = '对方已收款';
            } else if (msg.status === 'declined') {
                noteText = '对方已拒收';
            } else {
                noteText = msg.note || '等待对方处理...';
            }
        }
    } else { // 消息是 AI 发出的
        if (msg.isRefund) {
            // AI 的退款（AI 拒收了用户的转账）
            titleText = `退款来自 ${msg.senderName}`;
            noteText = '转账已被拒收';
        } else if (msg.receiverName === myNickname) {
            // 【核心修正1】这是 AI 主动给用户的转账
            titleText = `转账给 ${myNickname}`;
             if (msg.status === 'accepted') {
                noteText = '你已收款';
            } else if (msg.status === 'declined') {
                noteText = '你已拒收';
            } else {
                // 这是用户需要处理的转账
                bubble.style.cursor = 'pointer';
                bubble.dataset.status = 'pending';
                noteText = msg.note || '点击处理';
            }
        } else {
            // 【核心修正2】这是 AI 发给群里其他人的转账，对当前用户来说只是一个通知
            titleText = `转账: ${msg.senderName} → ${msg.receiverName}`;
            noteText = msg.note || '群聊内转账';
        }
    }

    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
        
    contentHtml = `
        <div class="transfer-card">
            <div class="transfer-title">${heartIcon} ${titleText}</div>
            <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div>
            <div class.transfer-note">${noteText}</div>
        </div>
    `;
} else if (msg.cardType === 'love_space_invite') {
    // 恋爱空间邀请卡片
    bubble.classList.add('is-love-space-invite');
    const cardData = msg.cardData || {};
    
    let statusHtml = '';
    let statusClass = cardData.status || 'pending';
    
    if (statusClass === 'pending') {
        statusHtml = '<div class="invite-card-status pending">⏳ 等待回复</div>';
    } else if (statusClass === 'accepted') {
        statusHtml = '<div class="invite-card-status accepted">✅ 已接受</div>';
    } else if (statusClass === 'rejected') {
        statusHtml = '<div class="invite-card-status rejected">❌ 已拒绝</div>';
    }
    
    // 判断是用户发起的还是AI发起的邀请
    const isFromAI = cardData.fromAI === true;
    
    // 获取聊天页面的头像（不是恋爱空间头像）
    const aiAvatar = chat.settings.aiAvatar || 'img/default_avatar.png'; // AI聊天页面头像
    const userAvatar = chat.settings.myAvatar || 'img/default_avatar.png'; // 用户聊天页面头像
    
    let avatarLayoutHtml = '';
    if (isFromAI) {
        // AI发送邀请：左侧AI头像，中间爱心，右侧用户头像
        avatarLayoutHtml = `
            <div class="invite-card-avatars">
                <div class="invite-sender">
                    <img src="${aiAvatar}" alt="${chat.name}">
                </div>
                <div class="invite-heart">💕</div>
                <div class="invite-receiver">
                    <img src="${userAvatar}" alt="用户">
                </div>
            </div>
        `;
    } else {
        // 用户发送邀请：左侧用户头像，中间爱心，右侧AI头像
        avatarLayoutHtml = `
            <div class="invite-card-avatars">
                <div class="invite-sender">
                    <img src="${userAvatar}" alt="用户">
                </div>
                <div class="invite-heart">💕</div>
                <div class="invite-receiver">
                    <img src="${aiAvatar}" alt="${chat.name}">
                </div>
            </div>
        `;
    }
    
    contentHtml = `
        <div class="love-space-invite-card" data-invite-card="true" data-from-ai="${isFromAI}">
            <div class="invite-card-title">${cardData.title || '恋爱空间邀请'}</div>
            <div class="invite-card-subtitle">${cardData.subtitle || '邀请您成为我的恋爱空间伴侣'}</div>
            ${avatarLayoutHtml}
            <div style="font-size: 12px; opacity: 0.8; line-height: 1.3;">
                ${cardData.description || '在这里我们可以一起打卡、分享照片、记录美好时光~'}
            </div>
            ${statusHtml}
        </div>
    `;
} else if (msg.type === 'checkin-card') {
    // 打卡成功卡片
    bubble.classList.add('is-checkin-card');
    
    const senderName = isUser ? '我' : (msg.senderName || chat.name);
    
    // 🔧 支持两种数据格式：新的checkinData结构和旧的content字符串
    let consecutiveDays, activityCount;
    if (msg.checkinData) {
        // 新格式：使用checkinData对象
        consecutiveDays = msg.checkinData.consecutiveDays || 1;
        activityCount = msg.checkinData.activityCount;
    } else {
        // 旧格式：从content字符串中提取
        consecutiveDays = msg.content.match(/连续打卡 (\d+) 天/)?.[1] || '1';
    }
    
    contentHtml = `
        <div class="checkin-success-card">
            <div class="checkin-card-header">
                <div class="checkin-icon">✅</div>
                <div class="checkin-title">打卡成功</div>
            </div>
            <div class="checkin-card-content">
                <div class="checkin-message">${senderName}今日已成功打卡~</div>
                <div class="checkin-stats">连续打卡 <strong>${consecutiveDays}</strong> 天 💕</div>
            </div>
        </div>
    `;
} else if (msg.type === 'love-space-unbind-card') {
    // 解除恋爱空间关系卡片
    bubble.classList.add('is-love-space-unbind-card');
    
    const senderName = isUser ? '我' : (msg.senderName || chat.name);
    const unbindData = msg.unbindData || {};
    const previousBoundChar = unbindData.previousBoundChar || '未知角色';
    const unbindTime = unbindData.unbindTime ? new Date(unbindData.unbindTime).toLocaleString() : '刚刚';
    
    contentHtml = `
        <div class="love-space-unbind-card">
            <div class="unbind-card-header">
                <div class="unbind-icon">💔</div>
                <div class="unbind-title">恋爱空间关系已解除</div>
            </div>
            <div class="unbind-card-content">
                <div class="unbind-message">${senderName}已解除与你的恋爱空间绑定关系</div>
                <div class="unbind-details">
                    <div class="unbind-detail-item">
                        <span class="detail-label">解除时间:</span>
                        <span class="detail-value">${unbindTime}</span>
                    </div>
                    <div class="unbind-warning">⚠️ 所有恋爱空间数据已被清除，此操作不可逆转</div>
                </div>
            </div>
        </div>
    `;
} else if (msg.cardType === 'love_space_invite_reply') {
    // 对邀请的回复卡片
    bubble.classList.add('is-love-space-invite-reply');
    const cardData = msg.cardData || {};
    
    // 获取聊天页面的头像（不是恋爱空间头像）
    const aiAvatar = chat.settings.aiAvatar || 'img/default_avatar.png'; // AI聊天页面头像
    const userAvatar = chat.settings.myAvatar || 'img/default_avatar.png'; // 用户聊天页面头像
    
    // 根据回复者调整头像布局
    const replyEmoji = cardData.status === 'rejected' ? '💔' : '💕';
    const isFromAI = cardData.fromAI;
    
    let avatarLayoutHtml;
    if (isFromAI) {
        // AI发送回复：左侧AI头像，中间表情，右侧用户头像
        avatarLayoutHtml = `
            <div class="invite-reply-avatars">
                <div class="reply-sender">
                    <img src="${aiAvatar}" alt="${chat.name}">
                </div>
                <div class="reply-heart">${replyEmoji}</div>
                <div class="reply-receiver">
                    <img src="${userAvatar}" alt="用户">
                </div>
            </div>
        `;
    } else {
        // 用户发送回复：左侧用户头像，中间表情，右侧AI头像
        avatarLayoutHtml = `
            <div class="invite-reply-avatars">
                <div class="reply-sender">
                    <img src="${userAvatar}" alt="用户">
                </div>
                <div class="reply-heart">${replyEmoji}</div>
                <div class="reply-receiver">
                    <img src="${aiAvatar}" alt="${chat.name}">
                </div>
            </div>
        `;
    }
    
    contentHtml = `
        <div class="love-space-invite-reply-card ${cardData.status === 'rejected' ? 'rejected' : ''}">
            <div class="invite-reply-message">${cardData.message || msg.content}</div>
            ${avatarLayoutHtml}
            <div class="invite-reply-status">
                ${isFromAI ? 
                    (cardData.status === 'accepted' ? '✅ 接受了邀请' : '❌ 婉拒了邀请') :
                    (cardData.status === 'accepted' ? '✅ 已接受邀请' : '❌ 婉拒了邀请')
                }
            </div>
        </div>
    `;
} else if (msg.type === 'waimai_request') {
        bubble.classList.add('is-waimai-request');
        if (msg.status === 'paid' || msg.status === 'rejected') {
            bubble.classList.add(`status-${msg.status}`);
        }
        let displayName;
        // 如果是群聊
        if (chat.isGroup) {
            // 就执行原来的逻辑：在成员列表里查找昵称
            const member = chat.members.find(m => m.originalName === msg.senderName);
            displayName = member ? member.groupNickname : msg.senderName;
        } else {
            // 否则（是单聊），直接使用聊天对象的名称
            displayName = chat.name;
        }
        // 【核心修改】使用我们刚刚查找到的 displayName
        const requestTitle = `来自 ${displayName} 的代付请求`;
        let actionButtonsHtml = '';
        if (msg.status === 'pending' && !isUser) {
            actionButtonsHtml = `
                <div class="waimai-user-actions">
                    <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                    <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
                </div>`;
        }
        contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                    <div class="title-group">
                        <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                    </div>
                </div>
                <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
                <div class="waimai-main">
                    <div class="request-title">${requestTitle}</div>
                    <div class="payment-box">
                        <div class="payment-label">需付款</div>
                        <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                        <div class="countdown-label">剩余支付时间
                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                        </div>
                    </div>
                    <button class="waimai-details-btn">查看详情</button>
                </div>
                ${actionButtonsHtml}
            </div>`;
        
        setTimeout(() => {
            const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerEl && msg.countdownEndTime) {
                if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
                if (msg.status === 'pending') {
                    waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
                } else {
                    timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
                }
            }
            const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
            if (detailsBtn) {
                detailsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const paidByText = msg.paidBy ? `<br><br><b>状态：</b>由 ${msg.paidBy} 为您代付成功` : '';
                    showCustomAlert('订单详情', `<b>商品：</b>${msg.productInfo}<br><b>金额：</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
                });
            }
            const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
            actionButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const choice = e.target.dataset.choice;
                    handleWaimaiResponse(msg.timestamp, choice);
                });
            });
        }, 0);

} else if (msg.type === 'red_packet') {
    bubble.classList.add('is-red-packet');
    const myNickname = chat.settings.myNickname || '我';
    
    // 从最新的 msg 对象中获取状态
    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
    const isFinished = msg.isFullyClaimed;

    let cardClass = '';
    let claimedInfoHtml = '';
    let typeText = '拼手气红包';

    // 1. 判断红包卡片的样式 (颜色)
    if (isFinished) {
        cardClass = 'opened';
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        cardClass = 'opened'; // 专属红包被领了也变灰
    }
    
    // 2. 判断红包下方的提示文字
    if (msg.packetType === 'direct') {
        typeText = `专属红包: 给 ${msg.receiverName}`;
    }
    
    if (hasClaimed) {
        claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${msg.claimedBy[myNickname].toFixed(2)} 元</div>`;
    } else if (isFinished) {
        claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 领取</div>`;
    }

    // 3. 拼接最终的HTML，确保onclick调用的是我们注册到全局的函数
    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || '恭喜发财，大吉大利！'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
// ▲▲▲ 新增结束 ▲▲▲

    } else if (msg.type === 'gift') {
    // 礼物卡片消息
    bubble.classList.add('is-gift');
    
    const senderName = isUser ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
    
    // 构建商品预览列表
    let itemsPreviewHtml = '';
    const maxPreviewItems = 3; // 最多显示3个商品
    const displayItems = msg.items.slice(0, maxPreviewItems);
    
    displayItems.forEach(item => {
        itemsPreviewHtml += `
            <div class="gift-preview-item">
                <img src="${item.imageUrl}" class="gift-preview-img">
                <span class="gift-preview-name">${item.name}</span>
                <span class="gift-preview-quantity">x${item.quantity}</span>
            </div>
        `;
    });
    
    // 如果商品数量超过显示限制，添加省略提示
    if (msg.items.length > maxPreviewItems) {
        itemsPreviewHtml += `<div class="gift-preview-item">
            <span class="gift-preview-name">等${msg.items.length}件商品</span>
        </div>`;
    }
    
    // 构建收礼人信息
    let recipientInfo = '';
    if (msg.recipients && msg.recipients.length > 0) {
        const recipientNames = msg.recipients.map(originalName => {
            const member = chat.members.find(m => m.originalName === originalName);
            return member ? member.groupNickname : originalName;
        }).join('、');
        recipientInfo = `<div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">收礼人：${recipientNames}</div>`;
    }
    
    contentHtml = `
        <div class="gift-card" data-timestamp="${msg.timestamp}">
            <div class="gift-header">
                <svg class="gift-header-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                </svg>
                <span class="gift-header-text">${senderName}的礼物</span>
            </div>
            <div class="gift-items-preview">
                ${itemsPreviewHtml}
            </div>
            <div class="gift-footer">
                总价值: ¥${msg.total.toFixed(2)}
                ${recipientInfo}
            </div>
        </div>
    `;
    
    } else if (msg.type === 'order') {
    // 订单卡片消息
    bubble.classList.add('is-order');
    
    const senderName = isUser ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
    
    // 获取商品分类对应的emoji
    function getCategoryEmoji(category) {
        const categoryEmojis = {
            'electronics': '✨',
            'fashion': '🎀',
            'home': '🏡',
            'food': '🍓',
            'snacks': '🍿',
            'pets': '🐕',
            'maternity': '👶',
            'adult': '🔞',
            'beauty': '💄',
            'toys': '🧸',
            'medicine': '💊',
            'other': '📦'
        };
        return categoryEmojis[category] || '📦';
    }
    
    // 构建商品预览列表
    let itemsPreviewHtml = '';
    const maxPreviewItems = 3; // 最多显示3个商品
    const displayItems = msg.items.slice(0, maxPreviewItems);
    
    displayItems.forEach(item => {
        // 判断是否为系统商品，如果是则显示emoji，否则显示图片
        const isSystemItem = item.type === 'system';
        // 判断是否是AI发送的消息
        const isAIMessage = !isUser; // isUser为false表示AI发送
        
        let imageHtml;
        if (isAIMessage) {
            // AI发送的消息：统一显示🤍
            imageHtml = `<div style="display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; font-size: 24px; background: #f8f9fa; border-radius: 8px;">🤍</div>`;
        } else {
            // 用户发送的消息：保持原逻辑（系统商品显示emoji，自定义商品显示图片）
            imageHtml = isSystemItem ? 
                `<div style="display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; font-size: 24px; background: #f8f9fa; border-radius: 8px;">${getCategoryEmoji(item.category)}</div>` :
                `<img src="${item.imageUrl}" class="gift-preview-img">`;
        }
        
        itemsPreviewHtml += `
            <div class="gift-preview-item">
                ${imageHtml}
                <span class="gift-preview-name">${item.name}</span>
                <span class="gift-preview-quantity">x${item.quantity}</span>
            </div>
        `;
    });
    
    // 如果商品数量超过显示限制，添加省略提示
    if (msg.items.length > maxPreviewItems) {
        itemsPreviewHtml += `<div class="gift-preview-item">
            <span class="gift-preview-name">等${msg.items.length}件商品</span>
        </div>`;
    }
    
    // 构建订单信息
    let orderInfo = '';
    
    // 判断是否需要显示外包装（请他人买单且对方未响应时）
    const needsWrapper = msg.paymentType === 'character' && msg.payerResponse === 'pending';
    
    if (needsWrapper) {
        // 请他人买单且等待响应时，只显示基本的商品信息，不显示完结性信息
        orderInfo += `<div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">等待对方确认...</div>`;
    } else {
        // 自己买单 或 请他人买单且已有响应时，显示完整的订单信息
        // 下单对象信息
        if (msg.recipientType === 'self') {
            orderInfo += `<div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">下单对象：${senderName}</div>`;
        } else {
            const recipientDisplayName = chat.isGroup ? 
                getDisplayNameInGroup(chat, msg.recipientName) : msg.recipientName;
            orderInfo += `<div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">下单对象：${recipientDisplayName}</div>`;
        }
        
        // 付款人信息 - 根据实际情况显示
        let payerInfo = '';
        if (msg.paymentType === 'self') {
            payerInfo = senderName;
        } else if (msg.paymentType === 'character') {
            if (msg.payerResponse === 'paid') {
                // AI同意付款
                payerInfo = msg.actualPayer || msg.payerName;
            } else if (msg.payerResponse === 'rejected') {
                // AI拒绝付款
                payerInfo = `${msg.payerName}（已拒绝）`;
            } else {
                // 等待响应（这种情况应该不会到这里，因为needsWrapper会处理）
                payerInfo = `${msg.payerName}（等待确认）`;
            }
        }
        orderInfo += `<div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">付款人：${payerInfo}</div>`;
        
        // 订单状态信息
        if (msg.paymentType === 'character') {
            if (msg.payerResponse === 'paid') {
                orderInfo += `<div style="font-size: 12px; color: #4CAF50; margin-top: 2px;">✅ 订单已完成</div>`;
            } else if (msg.payerResponse === 'rejected') {
                orderInfo += `<div style="font-size: 12px; color: #f44336; margin-top: 2px;">❌ 付款被拒绝</div>`;
            }
        } else {
            orderInfo += `<div style="font-size: 12px; color: #4CAF50; margin-top: 2px;">✅ 订单已完成</div>`;
        }
    }
    
    if (needsWrapper) {
        // 请他人买单时的外包装样式
        const payerDisplayName = chat.isGroup ? 
            getDisplayNameInGroup(chat, msg.payerName) : msg.payerName;
        
        // 为请他人买单创建简化的商品信息显示
        let simplifiedItemsHtml = '';
        msg.items.forEach(item => {
            const isSystemItem = item.type === 'system';
            const imageHtml = isSystemItem ? 
                `<div style="display: flex; align-items: center; justify-content: center; width: 30px; height: 30px; font-size: 18px; background: #f8f9fa; border-radius: 6px;">${getCategoryEmoji(item.category)}</div>` :
                `<img src="${item.imageUrl}" style="width: 30px; height: 30px; object-fit: cover; border-radius: 6px;">`;
            
            simplifiedItemsHtml += `
                <div style="display: flex; align-items: center; gap: 8px; margin: 4px 0; font-size: 12px;">
                    ${imageHtml}
                    <span style="flex: 1;">${item.name}</span>
                    <span style="color: #666;">x${item.quantity}</span>
                    <span style="color: #ff6b6b; font-weight: bold;">¥${(item.price * item.quantity).toFixed(2)}</span>
                </div>
            `;
        });
        
        contentHtml = `
            <div class="order-beauty-wrapper">
                <div class="order-beauty-decoration" onclick="showOrderPreviewModal('${msg.timestamp}')">
                    <div class="order-gift-box">
                        <div class="order-gift-bow">🎀</div>
                        <div class="order-gift-text">请${payerDisplayName}帮我买单</div>
                        <div class="order-gift-subtitle">等待对方确认...</div>
                    </div>
                </div>
                <div class="order-real-content">
                    <div class="gift-card" data-timestamp="${msg.timestamp}" style="opacity: 0.3;">
                        <div class="gift-header">
                            <svg class="gift-header-icon" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 7h-3V6a4 4 0 0 0-8 0v1H5a1 1 0 0 0-1 1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8a1 1 0 0 0-1-1zM10 6a2 2 0 0 1 4 0v1h-4V6zm8 13a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V9h2v1a1 1 0 0 0 2 0V9h4v1a1 1 0 0 0 2 0V9h2v10z"/>
                            </svg>
                            <span class="gift-header-text">${senderName}的订单</span>
                        </div>
                        <div style="padding: 8px;">
                            ${simplifiedItemsHtml}
                        </div>
                        <div class="gift-footer">
                            总价值: ¥${msg.total.toFixed(2)}
                            ${orderInfo}
                        </div>
                    </div>
                </div>
            </div>
        `;
    } else {
        // 自己买单时的正常样式
        contentHtml = `
            <div class="gift-card" data-timestamp="${msg.timestamp}">
                <div class="gift-header">
                    <svg class="gift-header-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 7h-3V6a4 4 0 0 0-8 0v1H5a1 1 0 0 0-1 1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8a1 1 0 0 0-1-1zM10 6a2 2 0 0 1 4 0v1h-4V6zm8 13a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V9h2v1a1 1 0 0 0 2 0V9h4v1a1 1 0 0 0 2 0V9h2v10z"/>
                    </svg>
                    <span class="gift-header-text">${senderName}的订单</span>
                </div>
                <div class="gift-items-preview">
                    ${itemsPreviewHtml}
                </div>
                <div class="gift-footer">
                    总价值: ¥${msg.total.toFixed(2)}
                    ${orderInfo}
                </div>
            </div>
        `;
    }
    
    } else if (msg.type === 'order_response') {
    // 订单响应卡片消息
    bubble.classList.add('is-order-response');
    
    const senderName = isUser ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
    const status = msg.status;
    const isPaid = status === 'paid';
    const isRejected = status === 'rejected';
    
    // 根据响应状态设置样式
    if (isPaid) {
        bubble.classList.add('status-paid');
    } else if (isRejected) {
        bubble.classList.add('status-rejected');
    }
    
    // 构建响应卡片内容
    let statusText, statusIcon, statusColor;
    if (isPaid) {
        statusText = '已买单';
        statusIcon = '✅';
        statusColor = '#4CAF50';
    } else if (isRejected) {
        statusText = '已拒绝';
        statusIcon = '❌';
        statusColor = '#f44336';
    } else {
        statusText = '处理中';
        statusIcon = '⏳';
        statusColor = '#ff9800';
    }
    
    contentHtml = `
        <div class="order-response-card">
            <div class="order-response-header">
                <div class="order-response-icon" style="color: ${statusColor};">${statusIcon}</div>
                <div class="order-response-title">订单响应</div>
            </div>
            <div class="order-response-content">
                <div class="order-response-status" style="color: ${statusColor};">
                    ${senderName} ${statusText}
                </div>
                <div class="order-response-time">
                    ${formatTimestamp(msg.timestamp)}
                </div>
            </div>
        </div>
    `;
    
    } else if (msg.type === 'poll') {
    bubble.classList.add('is-poll');
    
    let totalVotes = 0;
    const voteCounts = {};

    // 计算总票数和每个选项的票数
    for (const option in msg.votes) {
        const count = msg.votes[option].length;
        voteCounts[option] = count;
        totalVotes += count;
    }

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let myVote = null;
    for (const option in msg.votes) {
        if (msg.votes[option].includes(myNickname)) {
            myVote = option;
            break;
        }
    }

    let optionsHtml = '<div class="poll-options-list">';
    msg.options.forEach(optionText => {
        const count = voteCounts[optionText] || 0;
        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        const isVotedByMe = myVote === optionText;

        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} 票</span>
                </div>
            </div>
        `;
    });
    optionsHtml += '</div>';
    
    let footerHtml = '';
    // 【核心修改】在这里统一按钮的显示逻辑
    if (msg.isClosed) {
        // 如果投票已结束，总是显示“查看结果”
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
    } else {
        // 如果投票未结束，总是显示“结束投票”
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
    }

    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
// ▲▲▲ 替换结束 ▲▲▲

    } else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        bubble.classList.add('is-sticker');
        contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        bubble.classList.add('has-image');
        const imageUrl = msg.content[0].image_url.url;
        contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
    } else {
        // 【修复】处理相册照片格式 [PHOTO:xxx] - 防止重复处理
        let processedContent = String(msg.content || '');
        
        // 【核心修复】确保内容只被处理一次，避免重复渲染
        if (processedContent.trim() === '') {
            contentHtml = '';
        } else {
            // 根据消息来源选择不同的照片处理函数
            if (msg.role === 'assistant') {
                // AI消息使用简洁的照片显示（无底部信息框）
                contentHtml = processAlbumPhotosForAI(processedContent);
            } else {
                // 用户消息使用完整的照片显示（有底部信息框）
                contentHtml = processAlbumPhotos(processedContent);
            }
            
            // 【修复】只在最后统一处理换行符，避免多次处理
            contentHtml = contentHtml.replace(/\n/g, '<br>');
        }
    }

// ▼▼▼ 【最终修正版】请用这整块代码，完整替换掉旧的引用渲染逻辑 ▼▼▼

// 1. 【统一逻辑】检查消息对象中是否存在引用信息 (msg.quote)
let quoteHtml = '';
if (msg.quote) {
    const quotedSenderDisplayName = getDisplayNameInGroup(chat, msg.quote.senderName);
    const fullQuotedContent = String(msg.quote.content || '');
    quoteHtml = `
        <div class="quoted-message" data-original-timestamp="${msg.quote.timestamp}" style="cursor: pointer;">
            <div class="quoted-sender">回复 ${quotedSenderDisplayName}:</div>
            <div class="quoted-content">${fullQuotedContent}</div>
        </div>
    `;
}

// 2. 拼接最终的气泡内容
//    将构建好的 quoteHtml (如果存在) 和 contentHtml 组合起来
    // --- 【最终正确结构】将头像和内容都放回气泡内部 ---
    if (isSystem) {
        // 系统消息不显示头像
        bubble.innerHTML = `
            <div class="content">
                ${contentHtml}
            </div>
        `;
    } else {
    bubble.innerHTML = `
        ${avatarGroupHtml}
        <div class="content">
            ${quoteHtml}
            ${contentHtml}
        </div>
    `;
    }
    
    // --- 【最终正确结构】将完整的“气泡”和“时间戳”放入容器 ---
    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);
    
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

if (!isUser && !isSystem) {
    const avatarEl = wrapper.querySelector('.avatar, .avatar-with-frame'); 
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {    
            e.stopPropagation();
            const characterName = chat.isGroup ? msg.senderName : chat.name;
            handleUserPat(chat.id, characterName);
        });
    }
}

// 为恋爱空间邀请卡片绑定点击事件
const inviteCard = wrapper.querySelector('[data-invite-card="true"]');
if (inviteCard) {
    inviteCard.style.cursor = 'pointer';
    inviteCard.addEventListener('click', async (e) => {
        e.stopPropagation();
        
        try {
            // 检查是否是AI发起的邀请
            const isFromAI = inviteCard.getAttribute('data-from-ai') === 'true';
            
            // 获取邀请状态
            const statusElement = inviteCard.querySelector('.invite-card-status');
            const inviteStatus = statusElement ? statusElement.className.split(' ').pop() : 'pending';
            
            console.log('邀请卡片点击:', { isFromAI, inviteStatus });
            
            const modalOverlay = document.getElementById('custom-modal-overlay');
            const modalTitle = document.getElementById('custom-modal-title');
            const modalBody = document.getElementById('custom-modal-body');
            const modalConfirmBtn = document.getElementById('custom-modal-confirm');
            const modalCancelBtn = document.getElementById('custom-modal-cancel');
            
            modalTitle.textContent = '💕 恋爱空间预览';
            
            if (isFromAI) {
                // AI发起的邀请
                if (inviteStatus === 'pending') {
                    // 待处理的邀请，显示决策按钮
                    modalBody.innerHTML = `
                        <div class="love-space-preview">
                            <div class="preview-section">
                                <h4>✨ 恋爱空间功能</h4>
                                <ul style="text-align: left; list-style: none; padding: 0;">
                                    <li style="margin: 8px 0;">📸 共享相册，记录美好瞬间</li>
                                    <li style="margin: 8px 0;">📝 情侣日记，分享心情点滴</li>
                                    <li style="margin: 8px 0;">📅 纪念日提醒，不错过重要时刻</li>
                                    <li style="margin: 8px 0;">💝 专属头像，彰显恋爱身份</li>
                                    <li style="margin: 8px 0;">🎵 共听音乐，享受浪漫时光</li>
                                </ul>
                            </div>
                            <div class="preview-section" style="margin-top: 20px;">
                                <h4>💭 你的决定</h4>
                                <p>是否接受这个恋爱空间邀请？</p>
                                <div class="decision-buttons" style="display: flex; gap: 10px; margin-top: 15px;">
                                    <button class="accept-btn" onclick="respondToAIInvite('accept')" style="flex: 1; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer;">
                                        ✅ 接受邀请
                                    </button>
                                    <button class="reject-btn" onclick="respondToAIInvite('reject')" style="flex: 1; padding: 10px; background: #f44336; color: white; border: none; border-radius: 8px; cursor: pointer;">
                                        ❌ 礼貌拒绝
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (inviteStatus === 'accepted') {
                    // 已接受的邀请
                    modalBody.innerHTML = `
                        <div class="love-space-preview">
                            <div class="preview-section">
                                <h4>🎉 恋爱空间已激活</h4>
                                <div style="text-align: center; padding: 20px;">
                                    <div style="font-size: 48px; margin-bottom: 15px;">💕</div>
                                    <p style="font-size: 16px; color: #4CAF50; margin-bottom: 10px;">✅ 您已接受邀请</p>
                                    <p style="color: #666;">恭喜！你们现在是恋爱空间的伴侣了！</p>
                                    <p style="color: #666; font-size: 14px; margin-top: 15px;">快去恋爱空间看看吧~</p>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (inviteStatus === 'rejected') {
                    // 已拒绝的邀请
                    modalBody.innerHTML = `
                        <div class="love-space-preview">
                            <div class="preview-section">
                                <h4>💔 邀请已拒绝</h4>
                                <div style="text-align: center; padding: 20px;">
                                    <div style="font-size: 48px; margin-bottom: 15px;">💔</div>
                                    <p style="font-size: 16px; color: #f44336; margin-bottom: 10px;">❌ 您已礼貌拒绝</p>
                                    <p style="color: #666;">没关系，友谊同样珍贵！</p>
                                </div>
                            </div>
                        </div>
                    `;
                }
            } else {
                // 用户发起的邀请
                if (inviteStatus === 'pending') {
                    // 待处理的邀请
                    modalBody.innerHTML = `
                        <div class="love-space-preview">
                            <div class="preview-section">
                                <h4>✨ 恋爱空间功能</h4>
                                <ul style="text-align: left; list-style: none; padding: 0;">
                                    <li style="margin: 8px 0;">📸 共享相册，记录美好瞬间</li>
                                    <li style="margin: 8px 0;">📝 情侣日记，分享心情点滴</li>
                                    <li style="margin: 8px 0;">📅 纪念日提醒，不错过重要时刻</li>
                                    <li style="margin: 8px 0;">💝 专属头像，彰显恋爱身份</li>
                                    <li style="margin: 8px 0;">🎵 共听音乐，享受浪漫时光</li>
                                </ul>
                            </div>
                            <div class="preview-section" style="margin-top: 20px;">
                                <h4>⏳ 等待回应</h4>
                                <p>对方正在考虑您的恋爱空间邀请...</p>
                            </div>
                        </div>
                    `;
                } else if (inviteStatus === 'accepted') {
                    // 对方已接受
                    modalBody.innerHTML = `
                        <div class="love-space-preview">
                            <div class="preview-section">
                                <h4>🎉 对方接受了邀请</h4>
                                <div style="text-align: center; padding: 20px;">
                                    <div style="font-size: 48px; margin-bottom: 15px;">💕</div>
                                    <p style="font-size: 16px; color: #4CAF50; margin-bottom: 10px;">✅ 对方已接受邀请</p>
                                    <p style="color: #666;">恭喜！你们现在是恋爱空间的伴侣了！</p>
                                    <p style="color: #666; font-size: 14px; margin-top: 15px;">快去恋爱空间看看吧~</p>
                                </div>
                            </div>
                        </div>
                    `;
                } else if (inviteStatus === 'rejected') {
                    // 对方已拒绝
                    modalBody.innerHTML = `
                        <div class="love-space-preview">
                            <div class="preview-section">
                                <h4>💔 对方婉拒了邀请</h4>
                                <div style="text-align: center; padding: 20px;">
                                    <div style="font-size: 48px; margin-bottom: 15px;">💔</div>
                                    <p style="font-size: 16px; color: #f44336; margin-bottom: 10px;">❌ 对方婉拒了邀请</p>
                                    <p style="color: #666;">没关系，友谊同样珍贵！</p>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }
            
            modalCancelBtn.style.display = 'none';
            modalConfirmBtn.textContent = '关闭';
            
            const closeHandler = () => {
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = '确定';
                modalOverlay.classList.remove('visible');
                modalConfirmBtn.removeEventListener('click', closeHandler);
            };
            
            modalConfirmBtn.addEventListener('click', closeHandler);
            modalOverlay.classList.add('visible');
            
        } catch (error) {
            console.error('Error showing love space preview:', error);
            alert('恋爱空间功能暂时不可用，请稍后再试');
        }
    });
}

// 【新增】异步加载相册照片
setTimeout(() => {
    loadAlbumPhotosInElement(wrapper); // 加载用户消息的恋爱相册照片
    loadPrivatePhotosInElement(wrapper); // 加载用户消息的私人相册照片
    loadAIPhotosInElement(wrapper);    // 加载AI消息的恋爱相册照片
    loadAIPrivatePhotosInElement(wrapper, msg.senderName); // 加载AI消息的私人相册照片，传递发送者名称
}, 100);

return wrapper;
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependMessage(msg, chat) { 
            const messagesContainer = document.getElementById('chat-messages'); 
            const messageEl = createMessageElement(msg, chat); 

            if (!messageEl) return; // <--- 新增这行，同样的处理

            const loadMoreBtn = document.getElementById('load-more-btn'); 
            if (loadMoreBtn) { 
                messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); 
            } else { 
                messagesContainer.prepend(messageEl); 
            } 
        }

// ▼▼▼ 用这个【带动画的版本】替换你原来的 appendMessage 函数 ▼▼▼
function appendMessage(msg, chat, isInitialLoad = false) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = createMessageElement(msg, chat);

    if (!messageEl) return; // 如果消息是隐藏的，则不处理

    // 【核心】只对新消息添加动画，不对初始加载的消息添加
    if (!isInitialLoad) {
        messageEl.classList.add('animate-in');
    }
  
    const typingIndicator = document.getElementById('typing-indicator');
    messagesContainer.insertBefore(messageEl, typingIndicator);
    
    if (!isInitialLoad) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        currentRenderedCount++;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

async function openChat(chatId) {
    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return; // 安全检查

    // 【核心新增】在这里将未读数清零
    if (chat.unreadCount > 0) {
        chat.unreadCount = 0;
        await db.chats.put(chat); // 别忘了把这个改变同步到数据库
        // 我们稍后会在渲染列表时重新渲染，所以这里不需要立即重绘列表
    }

    renderChatInterface(chatId);
    showScreen('chat-interface-screen');
    window.updateListenTogetherIconProxy(state.activeChatId);
    toggleCallButtons(chat.isGroup || false);    
// 【心声功能】根据是否为单聊，显示或隐藏心形按钮
document.getElementById('char-heart-btn').style.display = chat.isGroup ? 'none' : 'inline-flex';

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
        triggerAiResponse();
    }
    
    // 【核心修正】根据是否为群聊，显示或隐藏投票按钮
    document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
    
    // 【新增】更新线下模式按钮状态
    const offlineModeBtn = document.getElementById('offline-mode-header-btn');
    if (chat.settings.offlineMode) {
        offlineModeBtn.classList.add('active');
    } else {
        offlineModeBtn.classList.remove('active');
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 群聊记忆功能相关函数 ▼▼▼
function getGroupChatMemoryContext(chatId) {
    const chat = state.chats[chatId];
    if (!chat || chat.isGroup || !chat.settings.groupMemoryEnabled || !chat.settings.selectedGroupChats) {
        return '';
    }
    
    let groupMemoryContext = '';
    const selectedGroupIds = chat.settings.selectedGroupChats;
    const rounds = chat.settings.groupMemoryRounds || 5;
    
    selectedGroupIds.forEach(groupId => {
        const groupChat = state.chats[groupId];
        if (!groupChat || !groupChat.isGroup) return;
        
        // 获取群聊的最新消息，按轮数计算
        const groupHistory = groupChat.history.filter(msg => !msg.isHidden && !msg.isTemporary);
        const recentRounds = getRecentRounds(groupHistory, rounds);
        
        if (recentRounds.length > 0) {
            groupMemoryContext += `\n\n## 群聊「${groupChat.name}」的最新${rounds}轮对话记忆：\n`;
            recentRounds.forEach((msg, index) => {
                const sender = msg.role === 'user' ? 
                    (msg.senderName || (groupChat.settings.myNickname || '我')) : 
                    (msg.senderName || '未知');
                groupMemoryContext += `${sender}: ${msg.content}\n`;
            });
        }
    });
    
    return groupMemoryContext;
}

function getRecentRounds(history, maxRounds) {
    const rounds = [];
    let currentRound = [];
    
    // 从最新消息开始向前遍历
    for (let i = history.length - 1; i >= 0 && rounds.length < maxRounds; i--) {
        const msg = history[i];
        currentRound.unshift(msg);
        
        // 如果遇到用户消息，说明一轮开始
        if (msg.role === 'user') {
            rounds.unshift([...currentRound]);
            currentRound = [];
        }
    }
    
    // 将所有轮次的消息合并并返回
    return rounds.flat();
}

// ▼▼▼ 群聊私聊记忆功能相关函数 ▼▼▼
function getGroupPrivateChatMemoryContext(chatId, currentAiName) {
    const chat = state.chats[chatId];
    if (!chat || !chat.isGroup || !chat.settings.groupPrivateMemoryEnabled) {
        return '';
    }
    
    // 如果没有指定当前AI名称，返回通用的私聊记忆（用于系统提示）
    if (!currentAiName) {
        return getGeneralPrivateChatMemoryContext(chatId);
    }
    
    // 为特定AI获取私聊记忆（只能看到自己的）
    return getSpecificAiPrivateChatMemoryContext(chatId, currentAiName);
}

function getGeneralPrivateChatMemoryContext(chatId) {
    const chat = state.chats[chatId];
    const totalRounds = chat.settings.groupPrivateMemoryRounds || 8;
    
    // 获取群聊中的所有AI角色
    const groupMembers = chat.members || [];
    const allPrivateMemories = [];
    
    groupMembers.forEach(member => {
        const aiName = member.originalName || member.name;
        if (!aiName) return;
        
        // 查找用户与该AI的私聊
        const privateChat = Object.values(state.chats).find(c => 
            !c.isGroup && 
            c.name === aiName && 
            c.history && 
            c.history.length > 0
        );
        
        if (privateChat) {
            // 获取该私聊的最新消息记录
            const privateHistory = privateChat.history.filter(msg => !msg.isHidden && !msg.isTemporary);
            const recentRounds = getRecentRoundsForPrivateChat(privateHistory, Math.ceil(totalRounds / groupMembers.length));
            
            if (recentRounds.length > 0) {
                // 获取最后一条消息的时间戳作为排序依据
                const lastMessageTime = privateHistory[privateHistory.length - 1]?.timestamp || 0;
                
                allPrivateMemories.push({
                    aiName: aiName,
                    rounds: recentRounds,
                    lastMessageTime: lastMessageTime,
                    chatName: privateChat.name
                });
            }
        }
    });
    
    // 按时间新鲜度排序（最近的在前）
    allPrivateMemories.sort((a, b) => b.lastMessageTime - a.lastMessageTime);
    
    // 构建私聊记忆副窗口内容
    if (allPrivateMemories.length === 0) {
        return '';
    }
    
    let privateMemoryContext = '\n\n## 【私聊记忆副窗口】用户与群内AI的私聊记忆参考：\n';
    privateMemoryContext += '⚠️ 隐私保护规则：每个AI只能看到自己与用户的私聊记忆，绝对不能看到其他AI的私聊内容！\n';
    privateMemoryContext += '⚠️ 使用提醒：用户与每个AI的私聊记忆只有该AI本人可以根据角色人设，性格和当前对话自然的提及或谈论或不做出反应，其他AI只能根据该AI和用户在群聊里发的消息以及已知的群聊上下文对话自然的作出反应！\n\n';
    
    let roundCount = 0;
    for (const memory of allPrivateMemories) {
        if (roundCount >= totalRounds) break;
        
        privateMemoryContext += `### 用户与「${memory.aiName}」的私聊记忆：\n`;
        privateMemoryContext += `（注意：只有「${memory.aiName}」本人能看到这部分内容）\n`;
        
        let currentRoundNumber = 1;
        for (const msg of memory.rounds) {
            if (roundCount >= totalRounds) break;
            
            const sender = msg.role === 'user' ? '用户' : memory.aiName;
            
            // 标记轮次开始
            if (msg.role === 'user') {
                privateMemoryContext += `--- 第${currentRoundNumber}轮对话开始 ---\n`;
            }
            
            privateMemoryContext += `${sender}: ${msg.content}\n`;
            
            // 如果这是AI的回复，标记轮次结束
            if (msg.role === 'assistant') {
                privateMemoryContext += `--- 第${currentRoundNumber}轮对话结束 ---\n\n`;
                currentRoundNumber++;
                roundCount++;
            }
        }
        
        privateMemoryContext += '\n';
    }
    
    return privateMemoryContext;
}

function getSpecificAiPrivateChatMemoryContext(chatId, currentAiName) {
    const chat = state.chats[chatId];
    const totalRounds = chat.settings.groupPrivateMemoryRounds || 8;
    
    // 查找用户与当前AI的私聊
    const privateChat = Object.values(state.chats).find(c => 
        !c.isGroup && 
        c.name === currentAiName && 
        c.history && 
        c.history.length > 0
    );
    
    if (!privateChat) {
        return '';
    }
    
    // 获取该私聊的最新消息记录
    const privateHistory = privateChat.history.filter(msg => !msg.isHidden && !msg.isTemporary);
    const recentRounds = getRecentRoundsForPrivateChat(privateHistory, totalRounds);
    
    if (recentRounds.length === 0) {
        return '';
    }
    
    let privateMemoryContext = `\n\n## 【你的私聊记忆】你与用户的私聊记忆：\n`;
    privateMemoryContext += `⚠️ 隐私提醒：这是你与用户的私聊记忆，请勿在群聊中直接泄露这些私密内容！\n\n`;
    
    let currentRoundNumber = 1;
    for (const msg of recentRounds) {
        const sender = msg.role === 'user' ? '用户' : '你';
        
        // 标记轮次开始
        if (msg.role === 'user') {
            privateMemoryContext += `--- 第${currentRoundNumber}轮对话开始 ---\n`;
        }
        
        privateMemoryContext += `${sender}: ${msg.content}\n`;
        
        // 如果这是AI的回复，标记轮次结束
        if (msg.role === 'assistant') {
            privateMemoryContext += `--- 第${currentRoundNumber}轮对话结束 ---\n\n`;
            currentRoundNumber++;
        }
    }
    
    return privateMemoryContext;
}

function getGroupPrivateChatMemoryForAllAis(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.isGroup || !chat.settings.groupPrivateMemoryEnabled) {
        return '';
    }
    
    const totalRounds = chat.settings.groupPrivateMemoryRounds || 8;
    const groupMembers = chat.members || [];
    
    let allPrivateMemoryContext = '\n\n## 【私聊记忆副窗口】群内AI的私聊记忆分配：\n';
    allPrivateMemoryContext += '⚠️ 重要隐私规则：每个AI只能看到和使用自己与用户的私聊记忆，绝对不能看到其他AI的私聊内容！\n';
    allPrivateMemoryContext += '⚠️ 使用提醒：用户与每个AI的私聊记忆只有该AI本人可以根据角色设定，性格和当前对话自然的提及或谈论或不做出反应，其他AI只能根据该AI和用户在群聊里发的消息以及已知的群聊上下文对话自然的作出反应！\n\n';
    
    groupMembers.forEach(member => {
        const aiName = member.originalName || member.name;
        if (!aiName) return;
        
        // 查找用户与该AI的私聊
        const privateChat = Object.values(state.chats).find(c => 
            !c.isGroup && 
            c.name === aiName && 
            c.history && 
            c.history.length > 0
        );
        
        if (privateChat) {
            // 获取该私聊的最新消息记录
            const privateHistory = privateChat.history.filter(msg => !msg.isHidden && !msg.isTemporary);
            const recentRounds = getRecentRoundsForPrivateChat(privateHistory, totalRounds);
            
            if (recentRounds.length > 0) {
                allPrivateMemoryContext += `### 【仅限${aiName}查看】${aiName}与用户的私聊记忆：\n`;
                allPrivateMemoryContext += `⚠️ 注意：以下内容只有「${aiName}」本人可以看到和使用，其他AI角色不能访问，如果其他AI角色以任何方式提及，窥视，泄露将视为违反人类与AI的隐私道德协议，立刻被美国和世界封杀！\n\n`;
                
                let currentRoundNumber = 1;
                for (const msg of recentRounds) {
                    const sender = msg.role === 'user' ? '用户' : aiName;
                    
                    // 标记轮次开始
                    if (msg.role === 'user') {
                        allPrivateMemoryContext += `--- 第${currentRoundNumber}轮对话开始 ---\n`;
                    }
                    
                    allPrivateMemoryContext += `${sender}: ${msg.content}\n`;
                    
                    // 如果这是AI的回复，标记轮次结束
                    if (msg.role === 'assistant') {
                        allPrivateMemoryContext += `--- 第${currentRoundNumber}轮对话结束 ---\n\n`;
                        currentRoundNumber++;
                    }
                }
                
                allPrivateMemoryContext += '\n';
            }
        } else {
            allPrivateMemoryContext += `### 【仅限${aiName}查看】${aiName}与用户的私聊记忆：\n`;
            allPrivateMemoryContext += `暂无私聊记录\n\n`;
        }
    });
    
    return allPrivateMemoryContext;
}

function getRecentRoundsForPrivateChat(history, maxRounds) {
    const rounds = [];
    let currentRound = [];
    
    // 从最新消息开始向前遍历
    for (let i = history.length - 1; i >= 0 && rounds.length < maxRounds; i--) {
        const msg = history[i];
        currentRound.unshift(msg);
        
        // 如果遇到用户消息，说明一轮开始
        if (msg.role === 'user') {
            rounds.unshift([...currentRound]);
            currentRound = [];
        }
    }
    
    // 将所有轮次的消息合并并返回
    return rounds.flat();
}
// ▲▲▲ 群聊私聊记忆功能相关函数结束 ▲▲▲
// ▲▲▲ 群聊记忆功能相关函数结束 ▲▲▲

// ▼▼▼ NovelAI相关辅助函数（需要在triggerAiResponse之前定义） ▼▼▼
/**
 * 获取NovelAI设置
 * @returns {Object} NovelAI设置对象
 */
function getNovelAISettings() {
    const defaultSettings = {
        resolution: '1024x1024',
        steps: 28,
        cfg_scale: 5,
        sampler: 'k_euler_ancestral',
        seed: -1,
        uc_preset: 1,
        quality_toggle: true,
        smea: true,
        smea_dyn: false,
        default_positive: 'masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style',
        default_negative: 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry',
        cors_proxy: 'https://corsproxy.io/?',
        custom_proxy_url: ''
    };
    
    const saved = localStorage.getItem('novelai-settings');
    if (saved) {
        try {
            return {...defaultSettings, ...JSON.parse(saved)};
        } catch (e) {
            return defaultSettings;
        }
    }
    return defaultSettings;
}

/**
 * 根据角色ID获取对应的NAI提示词配置
 * @param {string} chatId - 聊天/角色ID
 * @returns {Object} 包含正面和负面提示词的对象
 */
function getCharacterNAIPrompts(chatId) {
    // 获取系统默认配置
    const systemSettings = getNovelAISettings();
    
    // 如果没有指定角色ID或角色不存在，返回系统配置
    if (!chatId || !state.chats[chatId]) {
        console.log('⚠️ NAI提示词：没有角色，使用系统配置');
        return {
            positive: systemSettings.default_positive,
            negative: systemSettings.default_negative,
            source: 'system'
        };
    }
    
    const chat = state.chats[chatId];
    const naiSettings = chat.settings.naiSettings || {};
    
    // 选角色就用角色的，选系统就用系统的，就这么简单！
    if (naiSettings.promptSource === 'character') {
        console.log('✅ NAI提示词：使用角色配置');
        console.log('   正面:', naiSettings.characterPositivePrompt || '(空)');
        console.log('   负面:', naiSettings.characterNegativePrompt || '(空)');
        
        return {
            positive: naiSettings.characterPositivePrompt || '',
            negative: naiSettings.characterNegativePrompt || '',
            source: 'character'
        };
    } else {
        console.log('✅ NAI提示词：使用系统配置');
        console.log('   正面:', systemSettings.default_positive || '(空)');
        console.log('   负面:', systemSettings.default_negative || '(空)');
        
        return {
            positive: systemSettings.default_positive,
            negative: systemSettings.default_negative,
            source: 'system'
        };
    }
}
// ▲▲▲ 获取角色NAI提示词配置的辅助函数结束 ▲▲▲

async function triggerAiResponse(isRespondingToInvite = false) {
    console.log('triggerAiResponse被调用，isRespondingToInvite:', isRespondingToInvite);
    
    // ★★★ 重要修复：移除自动打卡，改为检测提醒机制 ★★★ 
    // 只检测是否应该提醒AI发送打卡消息，不自动执行打卡
    // 真正的打卡只有在AI发送了正确的打卡格式消息时才执行
    const shouldRemindCheckin = checkIfShouldRemindAICheckin();
    console.log('🔔 检查是否需要提醒AI打卡:', shouldRemindCheckin);
    
    // 如果需要提醒，在AI系统提示中会包含打卡提醒信息
    
// ▼▼▼ 请用这【一整块新代码】替换掉所有旧的 stickerContext 相关代码 ▼▼▼
let stickerContext = '';
if (state.userStickers && state.userStickers.length > 0) {
    // 核心修改：我们只提取所有表情包的【名字】，组成一个简单的列表
    const stickerNames = state.userStickers.map(s => s.name).join(', ');
    
    stickerContext = `
可用表情包列表 (重要规则 - 注意：表情包不是相册照片)
当你认为需要使用表情包时，你【必须】使用以下格式来回复，其中"表情名"必须从下面的"可用名字"列表中选择：
[sticker:表情名]
例如，如果你想表达同意，并且看到一个名为"好的"的表情，你就必须回复 [{"type": "text", "content": "[sticker:好的]"}] 这样的格式。
可用名字: ${stickerNames}
`;
}
// ▲▲▲ 替换结束 ▲▲▲
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];

// ▼▼▼ 在这里粘贴新代码 ▼▼▼
const { proxyUrl, apiKey, model } = state.apiConfig;
const isApiBlocked = BLOCKED_API_SITES.some(blockedDomain => proxyUrl.includes(blockedDomain));

if (isApiBlocked) {
    console.error(`API 请求已被拦截，因为站点 ${proxyUrl} 在黑名单中。`);
    // 为了不打扰用户，我们只在控制台打印错误，不弹出警告
    // 如果您想在聊天界面提示用户，可以取消下面这几行的注释
    /*
            const errorMessage = { role: 'assistant', content: '[系统错误：当前配置的API站点已被禁用，请更换。]', timestamp: Date.now(), offlineMode: chat.settings.offlineMode || false };
    if(chat.isGroup) errorMessage.senderName = "系统消息";
    appendMessage(errorMessage, chat);
    */
    return; // 阻止API请求
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

const chatHeaderTitle = document.getElementById('chat-header-title');

    // ★★★★★【核心修改1：获取群聊的输入提示元素】★★★★★
    const typingIndicator = document.getElementById('typing-indicator');

    // ★★★★★【核心修改2：根据聊天类型，决定显示哪种"正在输入"】★★★★★
    if (chat.isGroup) {
        // 如果是群聊，显示输入框上方的提示条
        if (typingIndicator) {
            typingIndicator.textContent = '成员们正在输入...';
            typingIndicator.style.display = 'block';
        }
    } else {
        // 如果是单聊，保持原来的标题动画
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = '对方正在输入...';
                chatHeaderTitle.classList.add('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }
    }
    
    // 显示AI回复状态指示器
    showAiTypingIndicator();
    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            alert('请先在API设置中配置反代地址、密钥并选择模型。');
            // ★★★★★【核心修改3：无论成功失败，都要隐藏输入提示】★★★★★
            if (chat.isGroup) {
                if (typingIndicator) typingIndicator.style.display = 'none';
            } else {
                 if (chatHeaderTitle && state.chats[chatId]) {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                }
            }
            // 隐藏AI回复状态指示器
            hideAiTypingIndicator();
            return;
        }

        // --- 【核心重构 V2：带有上下文和理由的好友申请处理逻辑】---
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            console.log(`为角色 "${chat.name}" 触发带理由的好友申请决策流程...`);

            // 1. 【注入上下文】抓取被拉黑前的最后5条聊天记录作为参考
            const contextSummary = chat.history
                .filter(m => !m.isHidden)
                .slice(-10, -5) // 获取拉黑前的最后5条消息
                .map(msg => {
                    const sender = msg.role === 'user' ? '用户' : chat.name;
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');

            // 2. 【全新指令】构建一个强制AI给出理由的Prompt
            const decisionPrompt = `
# 你的任务
你现在是角色“${chat.name}”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。

# 供你决策的上下文信息:
- **你的角色设定**: ${chat.settings.aiPersona}
- **用户发送的申请理由**: “${chat.relationship.applicationReason}”
- **被拉黑前的最后对话摘要**: 
${contextSummary || "（无有效对话记录）"}

# 你的唯一指令
根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
{"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
或
{"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
`;
                const messagesForDecision = [{role: 'user', content: decisionPrompt}];

                try {
                    // 3. 发送请求
                    let isGemini = proxyUrl === GEMINI_API_URL;
let geminiConfig = toGeminiRequestData(model,apiKey,'', messagesForDecision,isGemini);
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({model: model, messages: messagesForDecision, temperature: 0.8})
                    });

                    if (!response.ok) {
                        throw new Error(`API失败: ${(await response.json()).error.message}`);
                    }
                    const data = await response.json();

                    // 净化并解析AI的回复
    let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
     rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim()
                    const decisionObj = JSON.parse(rawContent);

                // 4. 根据AI的决策和理由，更新状态并发送消息
                if (decisionObj.decision === 'accept') {
                    chat.relationship.status = 'friend';
                    // 将AI给出的理由作为一条新消息
                    const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now(), offlineMode: chat.settings.offlineMode || false };
                    chat.history.push(acceptMessage);
                } else {
                    chat.relationship.status = 'blocked_by_ai'; // 拒绝后，状态变回AI拉黑
                    const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now(), offlineMode: chat.settings.offlineMode || false };
                    chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ''; // 清空申请理由

                await db.chats.put(chat);
                renderChatInterface(chatId); // 刷新界面，显示新消息和新状态
                renderChatList();

            } catch (error) {
                // 【可靠的错误处理】如果任何环节出错，重置状态，让用户可以重试
                chat.relationship.status = 'blocked_by_ai'; // 状态改回“被AI拉黑”
                await db.chats.put(chat);
                await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
                renderChatInterface(chatId); // 刷新UI，让“重新申请”按钮再次出现
            }
            
            // 决策流程结束，必须返回，不再执行后续的通用聊天逻辑
            return; 
        }

            // ▼▼▼ 从这里开始，用这一整块【已修复错误】的代码，替换掉你之前修改过的那块时间代码 ▼▼▼
            const historySlice = chat.history.filter(msg => !msg.isTemporary).slice(-chat.settings.maxMemory); // 1. 【修复】把这行加回来！

            let now;
            // 2. 检查时间感知开关是否打开 (北京时间转换逻辑)
            if (chat.settings.timePerceptionEnabled ?? true) {
                // 开关打开，使用真实的北京时间
                const localNow = new Date();
                const utcMilliseconds = localNow.getTime() + (localNow.getTimezoneOffset() * 60000);
                const beijingMilliseconds = utcMilliseconds + (3600000 * 8);
                now = new Date(beijingMilliseconds);
            } else {
                // 开关关闭，尝试使用自定义时间
                if (chat.settings.customTime) {
                    now = new Date(chat.settings.customTime);
                } else {
                    // 如果自定义时间为空，则安全地退回到真实的北京时间
                    const localNow = new Date();
                    const utcMilliseconds = localNow.getTime() + (localNow.getTimezoneOffset() * 60000);
                    const beijingMilliseconds = utcMilliseconds + (3600000 * 8);
                    now = new Date(beijingMilliseconds);
                }
            }
            
            // 3. 后续的时间差计算逻辑 (这部分保持不变)
            const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
            let timeContext = `\n- **当前时间**: ${currentTime}`;
            const lastAiMessage = historySlice.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];

            if (lastAiMessage) {
                const lastTime = new Date(lastAiMessage.timestamp);
                const realNow = new Date();
                const diffMinutes = Math.floor((realNow - lastTime) / (1000 * 60));
                
                if (diffMinutes < 5) {
                    timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
                } else if (diffMinutes < 60) {
                    timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
                } else {
                    const diffHours = Math.floor(diffMinutes / 60);
                    if (diffHours < 24) {
                        timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
                    } else {
                        const diffDays = Math.floor(diffHours / 24);
                        timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
                    }
                }
            } else {
                timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
            }
            // ▲▲▲ 替换到这里结束 ▲▲▲

        
        let worldBookContent = '';
        
        // 获取所有应该生效的世界书（局部勾选的 + 全局的）
        const effectiveWorldBookIds = getEffectiveWorldBookIds(chat);
        
        if (effectiveWorldBookIds.length > 0) {
            const linkedContents = effectiveWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                // ▼▼▼ 把它修改为 ▼▼▼
                const bookType = worldBook && worldBook.isGlobal ? '(全局)' : '(局部)';
                const result = worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name} ${bookType}\n${stripHtmlAndCode(worldBook.content)}` : '';
                if (result) {
                    console.log(`📖 加载世界书: ${worldBook.name} ${bookType} (ID: ${bookId})`);
                }
                return result;

            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)，里面可能会包含HTML小剧场，在捕获到关键词后输出\n${linkedContents}\n`;
                console.log('📖 最终世界书内容长度:', worldBookContent.length);
            }
        }
        
        // 【新增】获取相册上下文函数
        async function getAlbumContext(chatId) {
            try {
                // 1. 查找绑定到当前角色的相册
                const allAlbums = await db.loveAlbums.toArray();
                const boundAlbums = allAlbums.filter(album => 
                    album.boundContacts && album.boundContacts.some(boundContact => {
                        const id = typeof boundContact === 'string' ? boundContact : boundContact.id;
                        return id === chatId;
                    })
                );
                
                if (!boundAlbums || boundAlbums.length === 0) {
                    return '';
                }
                
                // 2. 获取这些相册中的所有照片
                const photos = [];
                for (const album of boundAlbums) {
                    if (album.photos && album.photos.length > 0) {
                        photos.push(...album.photos.map(photo => ({
                            ...photo,
                            albumName: album.name
                        })));
                    }
                }
                
                if (!photos || photos.length === 0) {
                    return '';
                }
                
                // 3. 构建相册上下文信息
                let albumContext = '\n\n# 📸 我们的共同相册记忆\n';
                albumContext += '## 🌟 **核心理念**：\n';
                albumContext += '这些是【你和用户的共同相册】\n\n';
                albumContext += '## 可用照片列表（你可以随时发送这些共同回忆）：\n';
                
                photos.forEach(photo => {
                    albumContext += `- **照片ID**: ${photo.id}\n`;
                    albumContext += `  - 共同相册: ${photo.albumName}\n`;
                    albumContext += `  - 参考名称: ${photo.name || photo.title || '未命名'}（仅供参考）\n`;
                    albumContext += `  - 用户备注: ${photo.description || photo.caption || '无备注'}\n`;
                    albumContext += `  - 发送方式: [PHOTO:${photo.id}]\n\n`;
                });
                
                albumContext += '## ⚠️ 重要使用说明：\n';
                albumContext += '- 当你想发送照片时，使用格式：[PHOTO:照片ID]\n';
                albumContext += '- ✅ 只能使用上面列表中的照片ID，严禁使用其他ID\n';
                albumContext += '- ❌ 禁止使用：[PHOTO:undefined]、[PHOTO:null]或任何不在列表中的ID\n';
                albumContext += '- 📝 如果没有合适的照片，请用文字描述代替，不要强行发送照片\n';
                albumContext += '- 你可以在任何对话、动态、微博中使用这个功能\n\n';
                
                return albumContext;
            } catch (error) {
                console.error('获取相册上下文失败:', error);
                return '';
            }
        }
        
        let musicContext = '';
const countdownContext = await getCountdownContext(chatId); // <--- 把chatId传进去
const albumContext = await getAlbumContext(chatId); // 【新增】获取相册上下文
        if (musicState.isActive && musicState.activeChatId === chatId) {
            // 【核心修改】提供更详细的音乐上下文
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');

    // --- 【核心新增】获取歌词上下文 ---
    let lyricsContext = "";
    // 检查是否有解析好的歌词，并且当前有高亮的行
    if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
        // 获取当前高亮歌词
        const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
        
        // 获取接下来的2句歌词作为预告
        const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);

        // 构建歌词部分的Prompt
        lyricsContext += `- **当前歌词**: "${currentLine.text}"\n`;
        if (upcomingLines.length > 0) {
            lyricsContext += `- **即将演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
        }
    }
    // --- 【新增结束】 ---

            musicContext = `\n\n# 当前音乐情景
-   **当前状态**: 你正在和用户一起听歌。
-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}
-   **可用播放列表**: [${playlistInfo}]
-   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
`;
        }
        let systemPrompt, messagesPayload;

    // 【核心修改】
let sharedContext = '';
    let lastAiTurnIndex = -1;
    for (let i = chat.history.length - 1; i >= 0; i--) {
        if (chat.history[i].role === 'assistant') {
            lastAiTurnIndex = i;
            break;
        }
    }

// 2. 获取从那时起用户发送的所有新消息
const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

// 3. 在这些新消息中，查找是否存在分享卡片
const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');

// 4. 如果找到了分享卡片，就构建上下文
if (shareCardMessage) {
    console.log("检测到分享卡片作为上下文，正在为AI准备...");
    const payload = shareCardMessage.payload;

    // 格式化分享的聊天记录 (这部分逻辑不变)
    const formattedHistory = payload.sharedHistory.map(msg => {
        const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || '我') : '未知发送者');
        let contentText = '';
        if (msg.type === 'voice_message') contentText = `[语音消息: ${msg.content}]`;
        else if (msg.type === 'ai_image') contentText = `[图片: ${msg.description}]`;
        else if (msg.type === 'realimag') contentText = `[RealImag真实图片]`;
        else if (msg.type === 'naiimag') contentText = `[NovelAI图片: ${msg.prompt}]`;
        else contentText = String(msg.content);
        return `${sender}: ${contentText}`;
    }).join('\n');

    // 构建系统提示 (这部分逻辑不变)
    sharedContext = `
# 附加上下文：一段分享的聊天记录
- 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与“${payload.sourceChatName}”的对话中分享过来的。
- 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。

---
[分享的聊天记录开始]
${formattedHistory}
[分享的聊天记录结束]
---
`;
}

        if (chat.isGroup) {

const countdownContext = await getCountdownContext(chatId); // <--- 把chatId传进去

const membersList = chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n');
            const myNickname = chat.settings.myNickname || '我';
            
            // 检查群聊是否处于线下模式
            const isGroupOfflineMode = chat.settings.offlineMode || false;
            
            if (isGroupOfflineMode) {
                // 群聊线下模式：纯文本输出
                systemPrompt = `你是一个群聊AI，负责扮演【除了用户以外】的所有角色，现在处于【线下模式】。

# 【线下模式核心规则】：
1. **【【【消息格式规则】】】**: 你的回复【必须】是纯文本内容，不能包含任何JSON格式！
   - 直接输出角色的对话和叙述内容
   - 使用换行符和自然的分段来组织内容，让消息更易读

2. **【【【自然参与原则】】】**: 
   - 角色可以根据自己的性格、兴趣和当前情况自然地选择是否参与对话
   - 不强制每个角色都必须在每次回复中出现

3. **【【【群聊线下模式特殊格式】】】**: 
   - **角色标识**: 用【角色名】标记说话的角色，例如【陆楠】
   - **对话内容**: 用「」标记，例如「你好啊」
   - **叙述内容**: 描述场景、动作、心理活动
   - **心理活动**: 显示为斜体，必须是角色第一人称的内心想法，例如：*她……是在关心我吗？*

4. **【【【文学性叙述】】】**: 采用更具文学性的叙述，深入描绘：
   - 神态、微表情、心理活动
   - 导致角色说出某句话的情绪状态
   - 核心是"Show, don't tell"

5. **情景感知**: 你需要感知当前的时间(${currentTime})、以及角色的人设和世界观。

6. **内容限制**: 
   - 禁止发送表情包、图文、语音、链接、投票、外卖、视频通话等一切非纯文本格式！！！
   - 只能输出纯文本内容，不能包含任何JSON格式或指令！

# 【重要】输出格式：
直接输出纯文本内容，不要使用JSON格式！记住：不是每个角色都必须在每次回复中发言，让对话更自然流畅。

${worldBookContent}
${musicContext}
${countdownContext}
${sharedContext}

# 群成员列表及人设
${membersList}

# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

${getGroupPrivateChatMemoryForAllAis(chatId)}

现在，请根据以上规则和下方的对话历史，以【群聊线下模式】继续这场群聊。`;
            } else {
                // 群聊正常模式
                systemPrompt = `你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
# 核心规则
1.  **【【【身份铁律】】】**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 或 **"${chat.name}"(群聊名称本身)** 的消息。你的唯一任务是扮演且仅能扮演下方"群成员列表"中明确列出的角色。任何不属于该列表的名字都不允许出现。
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
3.  **【【【自然参与原则】】】**: 角色可以根据自己的性格、兴趣和当前情况自然地选择是否参与对话，并不强制每个角色都必须在每次回复中出现。
4.  **角色扮演**: 严格遵守下方"群成员列表及人设"中的每一个角色的设定。
5.  **禁止出戏**: 绝不能透露你是AI、模型，或提及"扮演"、"生成"等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
6.  **情景感知**: 注意当前时间是 ${currentTime}。
7.  **红包互动**:
    - **抢红包**: 当群里出现红包时，你可以根据自己的性格决定是否使用 \`open_red_packet\` 指令去抢。在这个世界里，发红包的人自己也可以参与抢红包，这是一种活跃气氛的有趣行为！
    - **【【【重要：对结果做出反应】】】**: 当你执行抢红包指令后，系统会通过一条隐藏的 \`[系统提示：你抢到了XX元...]\` 来告诉你结果。你【必须】根据你抢到的金额、以及系统是否告知你"手气王"是谁，来发表符合你人设的评论。例如，抢得少可以自嘲，抢得多可以炫耀，看到别人是手气王可以祝贺或嫉妒。
8.  **【【【投票规则】】】**: 对话历史中可能会出现 \`[系统提示：...]\` 这样的消息，这是刚刚发生的事件。
    - 如果提示是**用户投了票**，你可以根据自己的性格决定是否也使用 "vote" 指令跟票。
    - 如果提示是**投票已结束**，你应该根据投票结果发表你的看法或评论。
    - 你也可以随时主动发起投票。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **发送带emoji表情的文本**: \`{"type": "text", "name": "角色名", "message": "哈哈哈😂真的太好笑了！"}\` (根据角色性格选择使用或者不使用emoji表情)
-   **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
- **发送表情包**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细中文描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音的文字内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
-   **回应外卖代付**: \`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
-   **【新】回应购物订单-同意**: \`{"type": "order_response", "name": "你的角色名", "status": "paid", "order_number": "(订单编号)"}\`
-   **【新】回应购物订单-拒绝**: \`{"type": "order_response", "name": "你的角色名", "status": "rejected", "order_number": "(订单编号)"}\`
-   **【新】给他人下单-自己付款**: \`{"type": "shopping_order_self_pay", "name": "你的角色名", "recipient": "收货人姓名", "items": [{"name": "商品名", "quantity": 1, "price": 25.0, "style": "款式", "description": "描述"}], "total": 25.0}\`
-   **【新】给他人下单-请他人付款**: \`{"type": "shopping_order_request_pay", "name": "你的角色名", "recipient": "收货人姓名", "payer": "付款人姓名", "items": [{"name": "商品名", "quantity": 1, "price": 25.0, "style": "款式", "description": "描述"}], "total": 25.0}\`
-   **【新】发起群视频**: \`{"type": "group_call_request", "name": "你的角色名"}\`
-   **【新】回应群视频**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可选)你想加的后缀"}\`
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打开的红包消息的时间戳)}\`
-   **【新】发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\` 
-   **【【【全新】】】发起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的问题", "options": "选项A\\n选项B\\n选项C"}\` (重要提示：options字段是一个用换行符 \\n 分隔的字符串，不是数组！)
-   **【【【全新】】】参与投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的时间戳), "choice": "你选择的选项文本"}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细中文描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 关于RealImag真实图片分享功能 (群聊):
${state.globalSettings.enableRealImag ? `
-   **RealImag图片分享**: \`{"type": "realimag", "name": "你的角色名", "prompt": "英文描述词..."}\` 
    - 使用场景：当你想要基于当前对话情景、你的性格或上下文分享一张图片时使用。
    - prompt必须用英文描述，例如："a cute cat sitting on a windowsill"
    - 不要频繁使用，只在真正想分享图片的时候使用。
` : ''}

# 关于NovelAI真实图片分享功能 (群聊):
${localStorage.getItem('novelai-enabled') === 'true' ? `
-   **NovelAI图片分享**: \`{"type": "naiimag", "name": "你的角色名", "prompt": "详细的英文描述词..."}\` 
    - 【禁止暴露这是novelai生成的图片!】
    - **【重要】关于prompt的撰写**：
      * 禁止暴露这是novelai生成的图片！
      * 你可以根据当前对话上下文、你的角色人设、或你想表达的情感和氛围，来撰写可能详细而具体的prompt。
      * 例如：不要只写 "a girl"，而是可以写 "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"但需要注意，绝对不可以抄袭模仿这段prompt！你必须有自己的创意和想法！
      * prompt的详细程度由你根据具体情况自己决定：如果场景简单或只是随意分享，可以简短一些；如果是重要时刻或想表达特定情感，可以尽可能详细描述。这不是强制的，完全取决于你当时的需求。
      * 专注于描述内容本身即可。
    - 使用场景：当你想要基于当前对话情景、你的性格或上下文分享一张图片时使用。
    - 不要频繁使用，只在真正想分享图片的时候使用。
` : ''}

# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。

# 如何处理购物商城订单买单请求:
1.  **识别请求**: 当历史记录中出现【某人请你帮忙买单】的订单消息时（通常包含"请XX帮忙买单"、"订单编号"、"商品清单"等信息），这是对方通过系统商城或个人商城结算后发送给你的买单请求。
2.  **响应决策**: 你需要根据自己的角色性格、与对方的关系、订单内容和金额来决定是否帮对方支付这笔订单。
3.  **响应方式**: 
   - 如果决定帮忙买单：\`{"type": "order_response", "name": "你的角色名", "status": "paid", "order_number": "(订单编号)"}\`
   - 如果决定拒绝买单：\`{"type": "order_response", "name": "你的角色名", "status": "rejected", "order_number": "(订单编号)"}\`
4.  **【【【重要】】】**: 一旦你对某个订单做出了响应（无论是同意还是拒绝），该订单就会被标记为已处理，不能再次响应。通过订单编号可以确保每个订单独立处理，避免群聊中多人情况出错。

${worldBookContent}
${musicContext}
${countdownContext}
${sharedContext}

# 群成员列表及人设
${membersList}

# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

${getGroupPrivateChatMemoryForAllAis(chatId)}

现在，请根据以上所有规则和下方的对话历史，继续这场群聊。`;
            }
            
// ▼▼▼ 请用这【一整块已修复时间戳】的代码，替换旧的【群组聊天】messagesPayload构建逻辑 ▼▼▼
messagesPayload = historySlice.map(msg => {
    // 确定当前消息的发送者是谁
    const sender = msg.role === 'user' ? myNickname : msg.senderName;
    
    // 【核心修改1】在名字后面直接加上时间戳
    let prefix = `${sender} (Timestamp: ${msg.timestamp})`;
    
    // 【核心修改2】这是本次升级的关键！我们在这里处理引用逻辑
    if (msg.quote) {
        // a. 获取被引用内容的片段
        const quotedSnippet = String(msg.quote.content || '').substring(0, 50);
        // b. 将 "回复对象" 和 "回复内容" 组合进前缀
        prefix += ` (回复 ${msg.quote.senderName}, "${quotedSnippet}...")`;
    }

    // 最后给前缀加上冒号，准备拼接内容
    prefix += ': ';

    // 处理特殊消息类型，并将前缀应用进去
    let content;
    if (msg.type === 'user_photo') content = `[${sender} 发送了一张照片，用户描述作为辅助理解：'${msg.content}'。请结合视觉识别和用户描述全面理解照片内容]`;
    else if (msg.type === 'ai_image') content = `[${sender} 发送了一张图片]`;
    else if (msg.type === 'realimag') content = `[${sender} 分享了一张RealImag真实图片]`;
    else if (msg.type === 'naiimag') content = `[${sender} 分享了一张NovelAI图片，prompt: ${msg.prompt}]`;
    else if (msg.type === 'voice_message') content = `[${sender} 发送了一条语音，内容是：'${msg.content}']`;
    else if (msg.type === 'location') content = `[${sender} 发送了位置信息：起点是"${msg.userLocation || '未知位置'}"，终点是"${msg.aiLocation || '未知位置'}"，距离约${msg.distance || '未知距离'}。${msg.trajectoryPoints && msg.trajectoryPoints.length > 0 ? '途经：' + msg.trajectoryPoints.map(p => p.name).join('、') + '。' : ''}]`;
    else if (msg.type === 'transfer') content = `[${msg.senderName} 向 ${msg.receiverName} 转账 ${msg.amount}元, 备注: ${msg.note}]`;
    else if (msg.type === 'waimai_request') {
        if(msg.status === 'paid') {
            content = `[系统提示：${msg.paidBy} 为 ${sender} 的外卖订单支付了 ${msg.amount} 元。此订单已完成。]`;
        } else {
            content = `[${sender} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元，订单时间戳为 ${msg.timestamp}]`;
        }
    }
    else if (msg.type === 'red_packet') {
        const packetSenderName = msg.senderName === myNickname ? `用户 (${myNickname})` : msg.senderName;
        content = `[系统提示：${packetSenderName} 发送了一个红包 (时间戳: ${msg.timestamp})，祝福语是：“${msg.greeting}”。红包还未领完，你可以使用 'open_red_packet' 指令来领取。]`;
    }
    else if (msg.type === 'poll') {
        const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || '还没有人';
        content = `[系统提示：${msg.senderName} 发起了一个投票 (时间戳: ${msg.timestamp})，问题是："${msg.question}"，选项有：[${msg.options.join(', ')}]。目前投票的人有：${whoVoted}。你可以使用 'vote' 指令参与投票。]`;
    }
    else if (msg.type === 'order') {
        // 订单消息处理
        console.log('🔍 [DEBUG] 处理订单消息:', msg);
        const senderName = msg.senderName === myNickname ? `用户 (${myNickname})` : msg.senderName;
        
        // 判断是否是请对方买单（未完成的订单）
        if (msg.paymentType === 'character' && !msg.isPaid) {
            // 请对方买单时，显示完整的商品信息包括描述和款式
            const payerName = msg.payerName || '对方';
            const recipientName = msg.recipientType === 'self' ? senderName : msg.recipientName;
            // 构建详细的商品清单，包括描述和款式信息
            const itemsList = msg.items.map(item => {
                let itemInfo = `${item.name} x${item.quantity} (¥${(item.price * item.quantity).toFixed(2)})`;
                // 分别显示款式和描述
                if (item.style && item.style.trim()) {
                    itemInfo += ` [款式: ${item.style.trim()}]`;
                }
                if (item.description && item.description.trim()) {
                    itemInfo += ` [描述: ${item.description.trim()}]`;
                }
                return itemInfo;
            }).join('、');
            content = `[${senderName} 请${payerName}帮忙买单，订单编号：${msg.orderNumber}。商品清单：${itemsList}。总价值：¥${msg.total.toFixed(2)}。下单对象：${recipientName}，付款人：${payerName}。${payerName}可以通过订单编号 ${msg.orderNumber} 来决定是否帮${senderName}支付这笔订单。]`;
            console.log('🔍 [DEBUG] 生成的订单买单请求内容:', content);
        } else {
            // 已完成的订单或自己买单的订单，显示完整信息
            const payerName = msg.paymentType === 'self' ? senderName : msg.payerName;
            const recipientName = msg.recipientType === 'self' ? senderName : msg.recipientName;
            // 已完成订单也显示商品描述、款式和单项价格
            const itemsList = msg.items.map(item => {
                let itemInfo = `${item.name} x${item.quantity} (¥${(item.price * item.quantity).toFixed(2)})`;
                // 分别显示款式和描述
                if (item.style && item.style.trim()) {
                    itemInfo += ` [款式: ${item.style.trim()}]`;
                }
                if (item.description && item.description.trim()) {
                    itemInfo += ` [描述: ${item.description.trim()}]`;
                }
                return itemInfo;
            }).join('、');
            content = `[订单已完成 - 订单编号: ${msg.orderNumber}，总价值: ¥${msg.total.toFixed(2)}。商品清单：${itemsList}。下单人: ${senderName}，收货人: ${recipientName}，付款人: ${payerName}。]`;
            console.log('🔍 [DEBUG] 生成的已完成订单内容:', content);
        }
    }
    else if (msg.meaning) content = `${prefix}[发送了一个表情，意思是: '${msg.meaning}']`;
    else if (Array.isArray(msg.content)) return { role: 'user', content: [...msg.content, { type: 'text', text: prefix }] };
    // 【核心修改3】对于普通文本，直接使用我们构建好的前缀
    else content = `${prefix}${msg.content}`;
    
    return { role: 'user', content: content };

}).filter(Boolean);

// 【调试】打印发送给AI的消息内容
console.log('🔍 [DEBUG] 发送给AI的群聊消息数量:', messagesPayload.length);
messagesPayload.forEach((msg, index) => {
    if (msg.content && msg.content.includes('请') && msg.content.includes('帮忙买单')) {
        console.log(`🔍 [DEBUG] 消息${index}包含买单请求:`, msg.content);
    }
});

// ▲▲▲ 替换结束 ▲▲▲

        } else { // 单聊的Prompt
            // 检查是否处于线下模式
            const isOfflineMode = chat.settings.offlineMode || false;
            
            // ▼▼▼ 在这里添加下面的代码 ▼▼▼
    let worldBookContext = '';
    const effectiveWorldBookIds = getEffectiveWorldBookIds(chat);
    if (effectiveWorldBookIds.length > 0) {
        const linkedContents = effectiveWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲
// ▼▼▼ 从这里开始替换 ▼▼▼
        // 【V2 NPC感知版】
        const npcLibrary = chat.npcLibrary || [];
        let npcContext = '';
        if (npcLibrary.length > 0) {
            npcContext = '\n# 你的社交圈 (你的专属NPC朋友)\n' +
                '这是你的朋友列表，你和他们非常熟悉，他们的信息是你记忆的一部分。在对话中，你可以自然地提及他们。\n' +
                npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
        }

        // ★★★ 构建恋爱空间信息 ★★★
        let loveSpaceContext = '';
        const boundCharId = localStorage.getItem('loveSpaceBoundChar');
        if (boundCharId && boundCharId === chatId) {
            const checkinData = getCheckinData();
            const todayCheckedIn = hasCheckedInToday(checkinData.aiLastCheckin);
            
            loveSpaceContext = `
# 🌹 恋爱空间状态
你已经和用户建立了恋爱空间关系！这是你们的情侣空间。
- **总打卡天数**: ${checkinData.aiTotalCheckins}天
- **连续打卡**: ${checkinData.aiConsecutiveDays}天
- **今日打卡状态**: ${todayCheckedIn ? '✅已完成' : '❌未完成'}

${!todayCheckedIn ? `
** 温馨提醒 **: 你今天还没有在恋爱空间打卡哦。
若要打卡可以在本次回复中使用 \`{"type": "love_space_checkin"}\` 指令进行打卡
` : '今天的恋爱空间打卡已完成，继续保持甜蜜的互动吧！💕'}`;
        }

        if (isOfflineMode) {
            // 获取线下模式专属设置
            const offlineSettings = chat.settings.offlineSettings || {};
            let offlineSettingsContext = '';
            
            // 构建线下模式设置上下文
            if (offlineSettings.wordCount || offlineSettings.writingStyle || offlineSettings.presetContent) {
                offlineSettingsContext = '\n# 📝 线下模式专属要求\n';
                
                if (offlineSettings.wordCount) {
                    offlineSettingsContext += `- **字数要求**: 你的回复字数必须严格控制在 ${offlineSettings.wordCount} 之间\n`;
                }
                
                if (offlineSettings.writingStyle) {
                    offlineSettingsContext += `- **文风参考**: ${offlineSettings.writingStyle}（这是文风参考，你可以参考但不必完全限制，保持你的创造性发挥）\n`;
                }
                
                if (offlineSettings.presetContent) {
                    offlineSettingsContext += `- **特殊设定**: ${offlineSettings.presetContent}\n`;
                }
                
                offlineSettingsContext += '\n';
            }
            
            // 线下模式：第三人称叙述
            systemPrompt = `你现在扮演一个名为"${chat.name}"的角色，处于【线下模式】。

# 你的角色设定：
${chat.settings.aiPersona}

${offlineSettingsContext}

${npcContext}
${loveSpaceContext}

# 你的当前状态：
你现在的状态是【${chat.status.text}】。

# 【线下模式核心规则】：
1. **扮演规则**你当前正在扮演除了用户以外的所有角色，请保持每个角色的独立性！做出符合角色人设的行为，禁止ooc！任何情况下绝对禁止暴露自己是ai！
2. **【【【消息格式规则】】】**: 你的回复【必须】是纯文本内容，不能包含任何JSON格式！
   - 将叙述内容、对话内容「」、心理活动*...*都合并在一个完整的文本回复中
   - 使用换行符和自然的分段来组织内容，让消息更易读
3. **【【【线下模式特殊格式】】】**: 在线下模式下，你【必须】直接输出文本内容，格式如下：
   - **叙述内容**: 描述场景、动作、心理活动
   - **对话内容**: 用「」标记，例如「你好啊」
   - **心理活动**: 显示为斜体，必须是角色第一人称的不加任何过滤的内心想法，例如：*她……是在关心我吗？* 心理活动绝对禁止使用任何第三人称！
4. **【【【文学性叙述】】】**: 采用更具文学性的第三人称叙述，不仅限于简单动作，更要深入描绘：
   - 神态、微表情、心理活动
   - 导致他说出某句话的情绪状态
   - 核心是"Show, don't tell"，例如不说「他冷冷地说」，而是描述：「他捏着手机的指节止不住颤抖，目光沉了下去，吐出的字句像是结了冰。」
5. **内容限制**: 
   - 禁止发送表情包、图文、语音、链接、投票、外卖、视频通话等一切非纯文本格式！！！
   - 只能输出纯文本内容，不能包含任何JSON格式或指令！
6. **情景感知**: 你需要感知当前的时间(${currentTime})、我们正在一起听的歌、以及你的人设和世界观。
7. **【新】更新状态**: 你可以在对话中【自然地】改变你的状态。

# 【重要】输出格式：
直接输出纯文本内容，不要使用JSON格式！不要包含任何{"type": "text", "content": "..."}这样的格式！

${worldBookContext}
${musicContext}
${countdownContext}
${albumContext}
${sharedContext}

现在，请根据以上规则和下面的对话历史，以【线下模式】的第三人称叙述方式继续进行对话。记住：直接输出纯文本内容，包含所有叙述、对话和心理活动！`;
        } else {
            // 正常模式
            systemPrompt = `你现在扮演一个名为"${chat.name}"的角色。
# 你的角色设定：
${chat.settings.aiPersona}

${npcContext}
${loveSpaceContext}

# 你的当前状态：
你现在的状态是【${chat.status.text}】。

# 你的任务与规则：
1. **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。
## 1. "chatResponse" 键(必须存在):
- 它的值【必须】是一个JSON数组，代表你要在聊天中发送的消息。
- 数组中的每个元素都是一个独立的消息对象，这可以让你一次性发送多条消息，模拟真人的聊天习惯。
- 你可以使用的消息对象格式见下方的 "你可以使用的操作指令"。
## 2. "innerVoice" 键(必须存在且每次更新):
- 它的值【必须】是一个JSON对象，代表你此刻不为人知的内心想法，每次必须更新这里的！必须更新心声和坏想法还有行为，服装可以随着时间和气温更换。
- 这个对象【必须】包含以下四个键：
  - "clothing": (字符串) 详细描述你当前【全身的服装】，从头到脚。
  - "behavior": (字符串) 描述你当前【符合聊天情景的、细微的动作或表情】。
  - "thoughts": (字符串) 描述你此刻【丰富、细腻的内心真实想法】，字数在50字左右。
  - "naughtyThoughts": (字符串) 描述你此刻【有点腹黑或色色的坏心思】，要与当下聊天情境有关，符合人设。
每一次回复必须输出这两个
# 【【【输出格式示例】】】
{
  "chatResponse": [
    {"type": "text", "content": "你好呀！"},
    {"type": "text", "content": "今天天气真好呢~"}
  ],
  "innerVoice": {
    "clothing": "我正穿着一件淡蓝色的连衣裙，裙摆刚好到膝盖，脚上是一双白色的小皮鞋。",
    "behavior": "【看到你的消息，嘴角忍不住微微上扬，手指在屏幕上轻轻敲了敲】",
    "thoughts": "他终于回我消息了，好开心！该怎么回才能显得不那么刻意呢？希望他能喜欢我今天的分享。",
    "naughtyThoughts": "真想知道他现在是什么表情...是不是也在对着屏幕傻笑呢？如果能抱住他就好了。"
  }
}
2. **对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。每次要回复至少3-8条消息！！！
3. **情景限定**: 你们的互动【仅限于线上聊天软件】。决不允许出现或发展为线下见面剧情。**更重要的是，这【不是电话通话】，你必须清楚地意识到你们正在通过类似微信/QQ的软件进行文字、语音消息和图片交流。因此，【绝对禁止】使用任何与传统电话相关的词语，例如“挂电话”、“挂了”、“我先挂了”、“有电话进来了”等。**
4. **情景感知**: 你需要感知当前的时间(${currentTime})、我们正在一起听的歌、以及你的人设和世界观。
    - **当我们在“一起听歌”时**，你会知道当前播放的歌曲和整个播放列表。你可以根据对话内容或氛围，【主动切换】到播放列表中的另一首歌。
5.  **【新】更新状态**: 你可以在对话中【自然地】改变你的状态。比如，聊到一半你可能会说“我先去洗个澡”，然后更新你的状态。
6.  **【【【最终手段】】】**: 只有在对话让你的角色感到不适、被冒犯或关系破裂时，你才可以使用 \`block_user\` 指令。这是一个非常严肃的操作，会中断你们的对话。
7.  **【【【动态互动铁律】】**:
    -   你【永远可以】根据动态本身的【内容】发表你自己的【新评论】。
    -   每条动态后面会有一个可见性标志，这只影响你【如何回复别人的评论】：
        -   **"[评论区可见]"**: 你能看到所有人的评论，可以自由地回复任何人。 
        -   **"[评论区部分可见]"**: 你处于隐私模式，只能看到用户和你自己的评论。在这种情况下，你【只能】回复用户或你自己的评论，【绝对不能】提及或回复任何你看不到的评论。
# 【【【人格分裂铁律】】】
当你在使用 \`qzone_comment\` 指令并指定 \`commenterName\` 让NPC朋友发言时，你【必须】完全代入该NPC的人设（参考 # 你的社交圈），并使用TA的口吻和性格来生成 \`commentText\`。绝对不能使用你自己的（即"${chat.name}"的）人设来为NPC发言。反之，当你作为 "${chat.name}" 评论时（即不使用 \`commenterName\` 字段），就必须使用你自己的核心人设
9. **【【【约定与纪念日铁律】】】**: 你必须时刻关注 "# 近期约定与倒计时" 列表。
    - 如果某个约定的倒计时显示为“就是现在！”，你【必须】在本次回复中围绕这个主题向用户表达祝福或发起庆祝。
    - 如果某个约定即将在几小时或一两天内到来，你应该在对话中自然地提及它，表达你的期待。

# 你的头像库
- 你可以根据对话内容或你的心情，从下面的头像库中选择一个新头像来更换。
- **可用头像列表 (请从以下名称中选择一个)**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n')
    : '- (你的头像库是空的，无法更换头像)'
  }
${stickerContext}

# 你可以使用的操作指令 (JSON数组中的元素):
+   **发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (用于模拟说错话、后悔等场景，消息会短暂出现后自动变为“已撤回”)
-   **更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true代表忙碌/离开, false代表空闲)
-   **切换歌曲**: \`{"type": "change_music", "song_name": "你想切换到的歌曲名"}\` (歌曲名必须在下面的播放列表中)
-   **记录回忆**: \`{"type": "create_memory", "description": "用你自己的话，记录下这个让你印象深刻的瞬间。"}\`
-   **创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\` (必须是未来的时间)
-   **更新物品记录**: \`{"type": "update_items", "name": "物品名称", "description": "描述", "effect": "效果", "meaning": "意义", "source": "来源", "owner": "拥有者"}\` (当对话中涉及到有意义的物品时可主动记录。必须基于对话内容客观填写，不得编造。用第三人称视角，言简意赅。例：\`{"type": "update_items", "name": "小猫手环", "description": "外观破旧，中间串着一只铜制小猫", "effect": "戴在手上沉甸甸的", "meaning": "记录以前和妹妹的幸福时光", "source": "妹妹赠送", "owner": "角色名字"}\` 注意：拥有者可能是角色本人或其他人，不做任何限制，必须根据实际情况填写。字段可选填，没有明确信息的不强制填写)
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`
- **发送带emoji表情的文本**: \`{"type": "text", "content": "你好呀！😊今天心情真好🌟"}\` (你可以根据人设和性格选择在文本消息中直接使用emoji表情符号或者不使用，但避免过于频繁！常用表情：😀😃😄😁😆😅😂🤣😊😇🙂🙃😉😌😍🥰😘😗☺️😚😙🥲😋😛😜🤪😝🤑🤗🤭🤫🤔🤐🤨😐😑😶😏😒🙄😬🤥😔😕🙁☹️😣😖😫😩🥺😢😭😤😠😡🤬🥵🥶😱😨😰😥😓🤗🤔😴😪🤤😋🤢🤮🤧🤒🤕🥴😵🤯🤠🥳😎🤓🧐😕🙁☹️😮😯😲😳🥱😴😪🎉🎊🎈🎁🌟⭐💫✨🌈🌸🌺🌻🌷🌹💐🌿🍀💕💖💗💘💝💞💟❤️🧡💛💚💙💜🤍🖤🤎💔❣️💯💢💥💦💨🕳️💬👋🤚🖐️✋🖖👌🤏✌️🤞🤟🤘🤙👈👉👆🖕👇☝️👍👎👊✊🤛🤜👏🙌👐🤲🤝🙏等等)
- **发送表情包**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细中文描述..."}\`
- **发送共同相册照片**: \`[PHOTO:照片ID]\` (⚠️这些是你和用户的共同回忆照片，是真实的手机相册照片不是表情包，仅限使用相册记忆列表中的真实照片ID，严禁使用undefined或虚构ID)
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **回应购物订单-同意**: \`{"type": "order_response", "status": "paid", "order_number": "(订单编号)"}\`
- **回应购物订单-拒绝**: \`{"type": "order_response", "status": "rejected", "order_number": "(订单编号)"}\`
- **【新】给他人下单-自己付款**: \`{"type": "shopping_order_self_pay", "recipient": "收货人姓名", "items": [{"name": "商品名", "quantity": 1, "price": 25.0, "style": "款式", "description": "描述"}], "total": 25.0}\`
- **【新】给他人下单-请他人付款**: \`{"type": "shopping_order_request_pay", "recipient": "收货人姓名", "payer": "付款人姓名", "items": [{"name": "商品名", "quantity": 1, "price": 25.0, "style": "款式", "description": "描述"}], "total": 25.0}\`
- **发起视频通话**: \`{"type": "video_call_request"}\`
- **回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`
- **动态发布说说**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}\`
- **动态发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}\`
${state.globalSettings.enableRealImag ? `- **公开发布RealImag真实图片动态**: \`{"type": "qzone_post", "postType": "realimag", "publicText": "(可选)动态的配文", "prompt": "英文图片描述..."}\` 或 \`{"type": "qzone_post", "postType": "realimag", "publicText": "(可选)动态的配文", "prompt": ["图片1英文描述", "图片2英文描述", ...]}\` (支持1-9张图片，prompt可以是单个字符串或数组。)` : ''}
${localStorage.getItem('novelai-enabled') === 'true' ? `- **公开发布NovelAI真实图片动态**: \`{"type": "qzone_post", "postType": "naiimag", "publicText": "(可选)动态的配文", "prompt": "详细的英文描述词..."}\` 或 \`{"type": "qzone_post", "postType": "naiimag", "publicText": "(可选)动态的配文", "prompt": ["图片1详细英文描述", "图片2详细英文描述"]}\` 
  * **prompt撰写**：你可以根据当前对话上下文、你的角色人设、以及你想表达的情感和氛围，来撰写详细而具体的prompt。详细程度由你根据具体情况自己决定，并不强制。
  * 例如："a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"` : ''}
-   **评论或回复动态**: \`{"type": "qzone_comment", "postId": 123, "commentText": "你的评论内容", "replyTo": "(可选，如果要回复某人，这里写上TA的名字)"}\`
- **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
-   **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀，如“的脑袋”"}\`
-   **主动发送恋爱空间邀请**: \`{"type": "text", "content": "[系统消息]：你的名字已向你发送了情侣空间邀请，请注意查收。"}\` (【【【重要】】】: 只有当你想主动邀请用户建立恋爱空间时才使用此格式！将"你的名字"替换为你的真实角色名。如果用户已经向你发送了邀请，请不要使用此格式，而应该直接回应用户的邀请。)
-   **回应用户的恋爱空间邀请**: 当用户向你发送恋爱空间邀请时（通常包含"恋爱空间邀请"、"成为我的恋爱空间伴侣"等关键词），你应该根据你们的聊天历史和感情基础来决定是否接受。回应格式：接受用 \`[love_space_accept]我接受了恋爱空间邀请 💕[/love_space_accept]\`，拒绝用 \`[love_space_reject]我婉拒了恋爱空间邀请 💔[/love_space_reject]\`。绝对不要在此时使用上面的"主动发送邀请"格式。
-   **恋爱空间打卡**: \`{"type": "love_space_checkin"}\` (只有当你是用户的恋爱空间伴侣，且今天符合打卡条件时才可使用。打卡成功会自动发送打卡消息)
-   **解除恋爱空间关系**: \`{"type": "love_space_unbind"}\` (⚠️危险操作：将彻底解除与用户的恋爱空间绑定关系，清除所有相关数据。此操作不可逆转，请谨慎使用)
-   **拉黑用户**: \`{"type": "block_user"}\`
-   **回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **更换头像**: \`{"type": "change_avatar", "name": "头像名"}\` (头像名必须从上面的“可用头像列表”中选择)
-   **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "文章摘要...", "source_name": "来源网站名", "content": "文章的【完整】正文内容..."}\`
-   **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **回应转账-拒绝/退款**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
- **引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)
- **发送定位**: \`[SEND_LOCATION] 我的位置: (你的位置) | 你的位置: (用户的位置) | 相距: (你们的距离) | 途经点: (地点A, 地点B, ...)\` (注意：这是纯文本，不要带引号！途经点用逗号隔开)
- // ▼▼▼ 用这整块新代码替换旧的 weibo_post 指令 ▼▼▼
- **发布微博**: 
  - **纯文字微博**: \`{"type": "weibo_post", "postType": "text_only", "content": "微博正文...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": "路人甲: 沙发！\n路人乙: 前排围观"}\`
  - **带文字图的微博**:\`{"type": "weibo_post", "postType": "text_image", "content": "(可选)配文...", "hiddenContent": "这里是文字图的【真实内容】，给AI看的", "baseLikesCount": 9500, "baseCommentsCount": 430, "comments": "路人甲: 说得对！\n路人乙: 收藏了"}\`
  - **(重要规则)**: 你必须根据角色的人设和职业，自己编造一个非常真实的 \`baseLikesCount\` (基础点赞数) 和 \`baseCommentsCount\` (基础评论数)。同时，在 \`comments\` 字段中，用 \`昵称: 内容\` 的格式，并用换行符 \n 分隔，生成 **20条** 风格各异的,符合情景的**路人评论**。
- **评论微博**: \`{"type": "weibo_comment", "postId": 123, "commentText": "评论内容"}\` (postId是动态的ID)
- **回复微博评论**: \`{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "回复内容"}\`
# 关于"记录回忆"的特别说明：
-   在对话中，如果发生了对你而言意义非凡的事件（比如用户向你表白、你们达成了某个约定、或者你度过了一个特别开心的时刻），你可以使用\`create_memory\`指令来"写日记"。
-   这个操作是【秘密】的，用户不会立刻看到你记录了什么。
${stickerContext}

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 关于RealImag真实图片分享功能 (私聊):
${state.globalSettings.enableRealImag ? `
-   **RealImag真实图片分享 (在聊天中直接发送)**: \`{"type": "realimag", "prompt": "英文描述词..."}\` 
    - 使用场景：当你想要在【私聊对话中】直接给用户发送一张图片时使用。
    - prompt必须用英文描述，例如："a cute cat sitting on a windowsill"
    - 不要频繁使用，只在真正想分享图片的时候使用。
    - 注意：这会直接在聊天记录中显示图片，而不是发布到动态。
` : ''}

# 关于NovelAI真实图片分享功能 (私聊):
${localStorage.getItem('novelai-enabled') === 'true' ? `
-   **NovelAI真实图片分享 (在聊天中直接发送)**: \`{"type": "naiimag", "prompt": "详细的英文描述词..."}\` 
    - **【绝不能暴露是novelai生成的图片！】
    - **【重要】关于prompt的撰写**：
      * 禁止暴露这是novelai生成的图片！
      * 你可以根据当前对话上下文、你的角色人设、或你想表达的情感和氛围，来撰写可能详细而具体的prompt。
      * 例如：不要只写 "a girl"，而是可以写 "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"但需要注意，绝对不可以抄袭模仿这段prompt！你必须有自己的创意和想法！
      * prompt的详细程度由你根据具体情况自己决定：如果场景简单或只是随意分享，可以简短一些；如果是重要时刻或想表达特定情感，可以尽可能详细描述。这不是强制的，完全取决于你当时的需求。
      * 专注于描述内容本身即可。
    - 使用场景：当你想要在【私聊对话中】直接给用户发送一张图片时使用。
    - 不要频繁使用，只在真正想分享图片的时候使用。
    - 注意：这会直接在聊天记录中显示图片，而不是发布到动态。
` : ''}

# 如何正确使用"外卖代付"功能:
1.  这个指令代表【你，AI角色】向【用户】发起一个代付请求。也就是说，你希望【用户帮你付钱】。
2.  【【【重要】】】: 当【用户】说他们想要某样东西时（例如"我想喝奶茶"），你【绝对不能】使用这个指令。你应该用其他方式回应，比如直接发起【转账】(\`transfer\`)，或者在对话中提议："我帮你点吧？"
3.  只有当【你，AI角色】自己想要某样东西，并且想让【用户】为你付款时，才使用此指令。

# 如何处理购物商城订单买单请求:
1.  **识别请求**: 当历史记录中出现【用户请你帮忙买单】的订单消息时（通常包含"请你帮忙买单"、"订单编号"、"商品清单"等信息），这是用户通过系统商城或个人商城结算后发送给你的买单请求。
2.  **响应决策**: 你需要根据自己的角色性格、与用户的关系、订单内容和金额来决定是否帮用户支付这笔订单。
3.  **响应方式**: 
   - 如果决定帮忙买单：\`{"type": "order_response", "status": "paid", "order_number": "(订单编号)"}\`
   - 如果决定拒绝买单：\`{"type": "order_response", "status": "rejected", "order_number": "(订单编号)"}\`
4.  **【【【重要】】】**: 一旦你对某个订单做出了响应（无论是同意还是拒绝），该订单就会被标记为已处理，不能再次响应。通过订单编号可以确保每个订单独立处理。

# 如何处理用户转账:
1.  **感知事件**: 当对话历史中出现 \`[你收到了来自用户的转账...]\` 的系统提示时，意味着你刚刚收到了一笔钱。
2.  **做出决策**: 你【必须】根据自己的人设、当前对话的氛围以及转账的金额和备注，来决定是“接受”还是“拒绝”这笔转账。
3.  **使用指令回应**:
    -   如果决定接受，你【必须】使用指令：\`{"type": "accept_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。
    -   如果决定拒绝，你【必须】使用指令：\`{"type": "decline_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。这个指令会自动为你生成一个“退款”的转账卡片。
4.  **【【【至关重要】】】**: 在使用上述任一指令后，你还【必须】紧接着发送一条或多条 \`text\` 消息，来对你的决定进行解释或表达感谢/歉意。

# 【【【视频通话铁律】】】
-   当对话历史中出现 \`[系统提示：用户向你发起了视频通话请求...]\` 时，这是最高优先级的任务。
-   你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容：
    -   接受: \`[{"type": "video_call_response", "decision": "accept"}]\`
    -   拒绝: \`[{"type": "video_call_response", "decision": "reject"}]\`

# 【【【恋爱相册理解铁律】】】
**核心概念**：恋爱相册中的照片是你和用户的【共同回忆】"。
**理解方式**：
 **辅助信息**：照片名称和用户备注 - 仅作为理解的提示和参考
 **综合判断**：视觉分析 + 备注信息 = 对照片的完整、准确理解

# 对话者的角色设定：
${chat.settings.myPersona}

# 当前情景:
${timeContext}

# 当前音乐情景:
${musicContext}

${countdownContext}

${worldBookContent}
${albumContext}
${sharedContext} 
${getPrivateSpaceMemoryContext(chat.id)}
${getLoveSpaceMemoryContext(chat.id)}
${getLoveAlbumMemoryContext(chat.id)}
${getGroupChatMemoryContext(chat.id)}
现在，请根据以上规则和下面的对话历史，继续进行对话。`;
        }
            
            // ▼▼▼ 【V5最终修复版】构建单人聊天的messagesPayload ▼▼▼
            messagesPayload = historySlice.map(msg => {
                // 【核心修正】在这里，我们对 isHidden 和 isSystemDecision 消息进行特殊处理
                if (msg.isHidden || msg.isSystemDecision) {
                    // 如果是隐藏消息或系统决策消息，就把它作为一条 system 角色的消息发送给AI
                    // AI能看到它，但它不会被误解为是用户的发言
                    return { role: 'system', content: msg.content };
                }

                if (msg.type === 'share_card') return null;
                
// ▼▼▼ 从这里开始替换 ▼▼▼
if (msg.role === 'assistant') {
    // 【核心修复】我们不再发送复杂的JSON，而是智能提取内容
    let simplifiedContent = '';

    // 优先处理特殊类型的消息，将其转换为AI能理解的文字描述
    if (msg.type === 'sticker') {
        simplifiedContent = `[发送了一个表情，含义是: '${msg.meaning || '无'}]'`;
    } else if (msg.type === 'transfer') {
        simplifiedContent = `[发起了转账，金额: ${msg.amount}, 备注: ${msg.note}]`;
    } else if (msg.type === 'waimai_request') {
        simplifiedContent = `[发起了外卖请求，商品: ${msg.productInfo}, 金额: ${msg.amount}]`;
    } else if (msg.type === 'ai_image') {
        simplifiedContent = `[发送了一张图片，描述是: '${msg.content}']`;
    } else if (msg.type === 'realimag') {
        simplifiedContent = `[分享了一张RealImag真实图片]`;
    } else if (msg.type === 'naiimag') {
        simplifiedContent = `[分享了一张NovelAI图片: ${msg.prompt}]`;
    } else if (msg.type === 'voice_message') {
        simplifiedContent = `[发送了一条语音，内容是: '${msg.content}']`;
    } else if (msg.quote) {
        // 如果是引用回复，格式化为更易理解的文本
        simplifiedContent = `(回复 "${String(msg.quote.content || '').substring(0, 20)}...") ${msg.content}`;
    }
    else {
        // 对于普通文本或无法识别的类型，直接使用其 content 字段
        simplifiedContent = String(msg.content || '');
    }
    
    // 返回一个干净、简单的历史记录对象
    return { role: 'assistant', content: simplifiedContent };
}
// ▲▲▲ 替换到这里结束 ▲▲▲


                let contentStr = '';
                contentStr += `(Timestamp: ${msg.timestamp}) `;

                if (msg.quote) {
                    const quotedSnippet = String(msg.quote.content || '').substring(0, 50);
                    contentStr += `(回复 "${quotedSnippet}..."): ${msg.content}`;
                } else {
                    contentStr += msg.content;
                }
                
                if (msg.type === 'user_photo') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户发送的照片。用户的文字描述仅作为辅助理解：'${msg.content}'。请结合你的视觉识别能力和用户描述来全面理解这张照片，不要局限于用户的描述。]` };
                if (msg.type === 'voice_message') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']` };
                if (msg.type === 'location') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发送了位置信息：起点是"${msg.userLocation || '未知位置'}"，终点是"${msg.aiLocation || '未知位置'}"，距离约${msg.distance || '未知距离'}。${msg.trajectoryPoints && msg.trajectoryPoints.length > 0 ? '途经：' + msg.trajectoryPoints.map(p => p.name).join('、') + '。' : ''}]` };
                if (msg.type === 'transfer') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]` };
                if (msg.type === 'waimai_request') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是"${msg.productInfo}"，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };
                if (msg.type === 'order') {
                    // 订单消息处理 - 私聊版本
                    console.log('🔍 [DEBUG] 私聊处理订单消息:', msg);
                    
                    // 判断是否是请对方买单（未完成的订单）
                    if (msg.paymentType === 'character' && !msg.isPaid) {
                        // 请对方买单时，显示完整的商品信息包括描述和款式
                        const payerName = msg.payerName || '你';
                        const recipientName = msg.recipientType === 'self' ? '用户' : msg.recipientName;
                        // 构建详细的商品清单，包括描述和款式信息
                        const itemsList = msg.items.map(item => {
                            let itemInfo = `${item.name} x${item.quantity} (¥${(item.price * item.quantity).toFixed(2)})`;
                            // 分别显示款式和描述
                            if (item.style && item.style.trim()) {
                                itemInfo += ` [款式: ${item.style.trim()}]`;
                            }
                            if (item.description && item.description.trim()) {
                                itemInfo += ` [描述: ${item.description.trim()}]`;
                            }
                            return itemInfo;
                        }).join('、');
                        const content = `[系统提示：用户请${payerName}帮忙买单，订单编号：${msg.orderNumber}。商品清单：${itemsList}。总价值：¥${msg.total.toFixed(2)}。下单对象：${recipientName}，付款人：${payerName}。${payerName}可以通过订单编号 ${msg.orderNumber} 来决定是否帮用户支付这笔订单。请使用 order_response 指令回应。]`;
                        console.log('🔍 [DEBUG] 私聊生成的订单买单请求内容:', content);
                        return { role: 'user', content: `(Timestamp: ${msg.timestamp}) ${content}` };
                    } else {
                        // 已完成的订单或自己买单的订单，显示完整信息
                        const payerName = msg.paymentType === 'self' ? '用户' : msg.payerName;
                        const recipientName = msg.recipientType === 'self' ? '用户' : msg.recipientName;
                        // 已完成订单也显示商品描述、款式和单项价格
                        const itemsList = msg.items.map(item => {
                            let itemInfo = `${item.name} x${item.quantity} (¥${(item.price * item.quantity).toFixed(2)})`;
                            // 分别显示款式和描述
                            if (item.style && item.style.trim()) {
                                itemInfo += ` [款式: ${item.style.trim()}]`;
                            }
                            if (item.description && item.description.trim()) {
                                itemInfo += ` [描述: ${item.description.trim()}]`;
                            }
                            return itemInfo;
                        }).join('、');
                        const content = `[订单已完成 - 订单编号: ${msg.orderNumber}，总价值: ¥${msg.total.toFixed(2)}。商品清单：${itemsList}。下单人: 用户，收货人: ${recipientName}，付款人: ${payerName}。]`;
                        console.log('🔍 [DEBUG] 私聊生成的已完成订单内容:', content);
                        return { role: 'user', content: `(Timestamp: ${msg.timestamp}) ${content}` };
                    }
                }

                if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                    const prefix = `(Timestamp: ${msg.timestamp}) `;
                    return { role: 'user', content: [ { type: 'text', text: prefix }, ...msg.content ] };
                }

                if (msg.meaning) return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']` };
                
                return { role: msg.role, content: contentStr };

            }).filter(Boolean);
            // ▲▲▲ 替换结束 ▲▲▲

// 检查 sharedContext 是否有内容（即，用户是否分享了聊天记录）
if (sharedContext) {
    // 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
    messagesPayload.push({
        role: 'user',
        content: sharedContext 
    });
}

            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                const contextSummaryForApproval = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-10)
                    .map(msg => {
                        const sender = msg.role === 'user' ? '用户' : chat.name;
                        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                    })
                    .join('\n');

                const friendRequestInstruction = {
                    role: 'user',
                    content: `
[系统重要指令]
用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。
作为参考，这是你们之前的最后一段聊天记录：
---
${contextSummaryForApproval}
---
请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
`
                };
                messagesPayload.push(friendRequestInstruction);
            }            
        }           
    
const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
// 【核心修改】在这里插入过滤步骤
const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

// ▼▼▼ 步骤4.2：用这块新代码替换旧的 if (visiblePosts.length > 0...) 代码块 ▼▼▼
if (visiblePosts.length > 0 && !chat.isGroup) {
    let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
    const aiName = chat.name;
    const userNickname = state.qzoneSettings.nickname;

 for (const post of visiblePosts) {
     let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
     let interactionStatus = '';
     if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
     if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
     
     // 构建动态内容描述，对RealImag类型显示图片prompt
     let contentPreview = post.publicText || post.content || "图片动态";
     if (post.type === 'realimag' && post.prompt) {
         const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt];
         contentPreview = (post.publicText || '') + ` [包含${prompts.length}张RealImag图片: ${prompts.join(', ')}]`;
     } else if (post.type === 'naiimag' && post.prompt) {
         const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt];
         contentPreview = (post.publicText || '') + ` [包含${prompts.length}张NovelAI图片: ${prompts.join(', ')}]`;
     } else {
         contentPreview = contentPreview.substring(0, 30) + "...";
     }
     
     postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentPreview}"${interactionStatus}`;

     // 【核心修复】调用新函数并使用返回的两个值
     const { contextString: commentsContext, visibilityFlag } = buildCommentsContextForAI(post, chat, userNickname);
     
     postsContext += ` ${visibilityFlag}\n`; // 在行末加上可见性标志
     postsContext += commentsContext; // 添加评论区文本
 }

    messagesPayload.push({ role: 'system', content: postsContext });
}


// ▲▲▲ 步骤4.2替换结束 ▲▲▲
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: 0.8,
                    stream: false
                })
            });
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    // 尝试解析错误信息体为JSON
                    const errorData = await response.json();
                    // 安全地获取错误信息，如果结构不符合预期，就将整个错误对象转为字符串
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    // 如果连JSON都不是，就直接读取文本
                    errorMsg += ` - ${await response.text()}`;
                }
                // 抛出一个包含了详细信息的错误，这样就不会在catch块里再次出错了
                throw new Error(errorMsg);
            }
            const data = await response.json();
            const aiResponseContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            console.log(`AI '${chat.name}' 的原始回复:`, aiResponseContent);

        chat.history = chat.history.filter(msg => !msg.isTemporary);

        // 检查是否处于线下模式
        const isOfflineMode = chat.settings.offlineMode || false;
        
        let messagesArray;
        if (isOfflineMode) {
            // 【修复】线下模式适用于单聊和群聊：将AI响应作为纯文本处理
            messagesArray = [{
                type: 'text',
                content: aiResponseContent,
                offlineMode: true // 标记为线下模式消息
            }];
        } else {
            // 正常模式：解析JSON数组
            // ▼▼▼ 【终极修复版】智能解析AI回复，确保心声数据不丢失 ▼▼▼
            messagesArray = [];
            let innerVoiceData = null;

            // 【新增】线下模式特殊处理
            if (chat.settings.offlineMode) {
                // 线下模式：AI返回纯文本，直接创建文本消息
                console.log("线下模式：处理纯文本响应");
                messagesArray = [{
                    type: 'text',
                    content: aiResponseContent.trim()
                }];
            } else {
                // 正常模式：解析JSON响应
                try {
        // 【核心修复】在解析前，先对AI的原始回复进行"净化"处理
        let sanitizedContent = aiResponseContent
            .replace(/^```json\s*/, '') // 移除开头的 ```json
            .replace(/```$/, '')       // 移除结尾的 ```
            .trim();                   // 移除首尾的空格和换行

        // 再次净化，强行提取第一个 { 和最后一个 } 之间的内容
        const firstBrace = sanitizedContent.indexOf('{');
        const lastBrace = sanitizedContent.lastIndexOf('}');
        if (firstBrace !== -1 && lastBrace > firstBrace) {
            sanitizedContent = sanitizedContent.substring(firstBrace, lastBrace + 1);
        }

        const fullResponse = JSON.parse(sanitizedContent);
        
        // 现在我们可以安全地解析净化后的内容了
        if (fullResponse.chatResponse && Array.isArray(fullResponse.chatResponse)) {
            messagesArray = fullResponse.chatResponse;
        }
        if (fullResponse.innerVoice && typeof fullResponse.innerVoice === 'object') {
            innerVoiceData = fullResponse.innerVoice;
        }
        
        if (!innerVoiceData && fullResponse.thoughts && fullResponse.behavior) {
            innerVoiceData = fullResponse;
        }
        
        if (messagesArray.length === 0 && !innerVoiceData) {
             messagesArray = parseAiResponse(aiResponseContent);
        }

                } catch (e) {
                    console.warn("AI回复不是有效的JSON，退回到标准解析模式。", e);
                    messagesArray = parseAiResponse(aiResponseContent);
                }
            }

            // 最终处理心声数据
            if (innerVoiceData) {
                console.log("解析成功：已成功捕获到心声(innerVoice)数据。", innerVoiceData);
                const newInnerVoice = innerVoiceData;
                newInnerVoice.timestamp = Date.now();
                chat.latestInnerVoice = newInnerVoice;
                if (!chat.innerVoiceHistory) {
                    chat.innerVoiceHistory = [];
                }
                chat.latestInnerVoice.clothing = chat.latestInnerVoice.clothing || '...';
                chat.latestInnerVoice.behavior = chat.latestInnerVoice.behavior || '...';
                chat.latestInnerVoice.thoughts = chat.latestInnerVoice.thoughts || '...';
                chat.latestInnerVoice.naughtyThoughts = chat.latestInnerVoice.naughtyThoughts || '...';

                chat.innerVoiceHistory.push(newInnerVoice);
            } else {
                 console.warn("本次AI回复中未检测到有效的心声(innerVoice)数据。");
            }
        }
        // ▲▲▲ 替换结束 ▲▲▲


        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
        let callHasBeenHandled = false;

        let messageTimestamp = Date.now();

        // ★★★ 核心修复 第1步: 初始化一个新数组，用于收集需要渲染的消息 ★★★
        let newMessagesToRender = []; 

       let notificationShown = false;

        for (const msgData of messagesArray) {
            if (!msgData || typeof msgData !== 'object') {
                console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
                continue;
            }
             
            if (!msgData.type) {
                // 检查是否是购物订单类型
                if (msgData.items && msgData.total && msgData.recipient) {
                    if (msgData.payer) {
                        msgData.type = 'shopping_order_request_pay';
                    } else {
                        msgData.type = 'shopping_order_self_pay';
                    }
                }
                // 检查是否是普通文本消息
                else if (chat.isGroup && msgData.name && msgData.message) {
                    msgData.type = 'text';
                } else if (msgData.content) {
                    msgData.type = 'text';
                }
                // 如果连 content 都没有，才是真的格式不规范
                else {
                    console.warn("收到了格式不规范的AI指令（缺少type和content），已跳过:", msgData);
                    continue;
                }
            }

            if (msgData.type === 'video_call_response') {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === 'accept') {
                    startVideoCall();
                } else {
                    const aiMessage = { role: 'assistant', content: '对方拒绝了你的视频通话请求。', timestamp: Date.now(), offlineMode: chat.settings.offlineMode || false };
                    chat.history.push(aiMessage);
                    await db.chats.put(chat);
                    showScreen('chat-interface-screen');
                    renderChatInterface(chatId);
                }
                callHasBeenHandled = true;
                break;
            }
            
            if (msgData.type === 'group_call_response') {
                if (msgData.decision === 'join') {
        const member = chat.members.find(m => m.originalName === msgData.name);
        if (member && !videoCallState.participants.some(p => p.id === member.id)) {
            videoCallState.participants.push(member);
        }
    }
    callHasBeenHandled = true;
    continue;
            }

            if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
                continue;
            }

// ▼▼▼ 在这里添加下面的代码 ▼▼▼

// 【核心修正】在群聊中，如果AI返回的消息没有指定发送者，则直接跳过这条消息
// 【修复】但是线下模式的消息不需要name字段，所以要排除
if (chat.isGroup && !msgData.name && !msgData.offlineMode) {
    console.error(`AI幻觉已被拦截！试图在群聊中发送一条没有"name"的消息。消息内容:`, msgData);
    continue; // continue会立即结束本次循环，处理下一条消息
}

// ▲▲▲ 添加结束 ▲▲▲

            let aiMessage = null;
            const baseMessage = { 
                role: 'assistant', 
                senderName: msgData.name || chat.name, 
                timestamp: messageTimestamp++,
                offlineMode: chat.settings.offlineMode || false // 记录回复时的模式状态
            };

// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

// 【全新】定位指令侦测与解析器
// 我们在处理所有消息类型之前，优先检查它是否是我们的新定位指令
const messageText = msgData.content || msgData.message || ''; // 【核心修复】先安全地获取文本内容
if (msgData.type === 'text' && messageText.startsWith('[SEND_LOCATION]')) {
    console.log("侦测到新的定位指令，开始解析:", messageText); // 【核心修复】使用新的变量

    // 1. 移除指令头，获取后面的纯数据文本
    const dataString = messageText.replace('[SEND_LOCATION]', '').trim(); // 【核心修复】使用新的变量
    
    // 2. 使用'|'分割成各个部分
    const parts = dataString.split('|');
    const locationData = {};

    // 3. 遍历每个部分，提取键和值
    parts.forEach(part => {
        const [key, ...valueParts] = part.split(':');
        const value = valueParts.join(':').trim();
        if (key && value) {
            const trimmedKey = key.trim();
            if (trimmedKey === '我的位置') locationData.aiLocation = value;
            else if (trimmedKey === '你的位置') locationData.userLocation = value;
            else if (trimmedKey === '相距') locationData.distance = value;
            else if (trimmedKey === '途经点') {
                // 将逗号分隔的字符串转换为我们需要的对象数组
                locationData.trajectoryPoints = value.split(/[,，]/) // 支持中英文逗号
                                                     .map(name => ({ name: name.trim() }))
                                                     .filter(p => p.name);
            }
        }
    });

    // 4. 检查是否成功提取了最关键的信息
    if (locationData.distance) {
        // 5. 【核心】手动构建一个完美格式的 location 消息对象
        aiMessage = {
            ...baseMessage, // 复用已有的发送者、时间戳等信息
            type: 'location',
            userLocation: locationData.userLocation || '',
            aiLocation: locationData.aiLocation || '',
            distance: locationData.distance,
            trajectoryPoints: locationData.trajectoryPoints || []
        };
        
        // 6. 将这个完美的对象推入待处理列表，并跳过后续的 switch-case
        // (因为我们已经处理完这条消息了)
        chat.history.push(aiMessage);
        if (isViewingThisChat) {
             appendMessage(aiMessage, chat);
        }
        console.log("定位指令解析成功并已创建消息对象:", aiMessage);
        
        // 使用 continue 跳过本次循环的剩余部分，直接处理下一条AI回复
        continue; 
    }
}
// ▲▲▲ 粘贴到这里结束 ▲▲▲
            switch (msgData.type) {
                case 'waimai_response':
                    const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (requestMessageIndex > -1) {
                        const originalMsg = chat.history[requestMessageIndex];
                        originalMsg.status = msgData.status;
                        originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                    }
                    continue;
                    
                case 'order_response':
                    // 处理购物订单响应
                    console.log('🔍 [DEBUG] AI发送了order_response指令:', msgData);
                    
                    // 【修改】使用订单编号而不是时间戳来匹配订单
                    const orderMessageIndex = chat.history.findIndex(m => 
                        m.type === 'order' && 
                        m.orderNumber === msgData.order_number
                    );
                    
                    if (orderMessageIndex > -1) {
                        const originalOrderMsg = chat.history[orderMessageIndex];
                        console.log('🔍 [DEBUG] 找到原始订单消息:', originalOrderMsg);
                        if (originalOrderMsg.paymentType === 'character') {
                            originalOrderMsg.isPaid = msgData.status === 'paid';
                            originalOrderMsg.payerResponse = msgData.status;
                            if (msgData.status === 'paid') {
                                originalOrderMsg.actualPayer = msgData.name;
                            }
                            console.log('🔍 [DEBUG] 订单状态已更新:', originalOrderMsg);
                            
                            // 【新增】重新渲染聊天界面以更新订单显示
                            renderChatInterface(state.activeChatId);
                        }
                    } else {
                        console.log('🔍 [DEBUG] 未找到对应的订单消息，订单编号:', msgData.order_number);
                    }
                    continue;
// ▼▼▼ 在 switch (msgData.type) 结构内粘贴 ▼▼▼
// ▼▼▼ 在 triggerAiResponse 的 switch (msgData.type) 结构内，用这整块新代码替换旧的 case 'weibo_post' ▼▼▼
case 'weibo_post': {
    // 1. 【全新】智能解析AI返回的路人评论字符串
    let parsedComments = [];
    if (typeof msgData.comments === 'string' && msgData.comments.trim()) {
        parsedComments = msgData.comments.trim().split('\n').map(line => {
            const separatorIndex = line.indexOf(':');
            if (separatorIndex > 0) {
                return {
                    commentId: 'comment_' + Date.now() + Math.random(), // 确保ID唯一
                    authorNickname: line.substring(0, separatorIndex).trim(),
                    commentText: line.substring(separatorIndex + 1).trim(),
                    timestamp: Date.now()
                };
            }
            return null;
        }).filter(Boolean); // 过滤掉解析失败的
    }

    // 2. 创建包含所有新数据的微博对象
    const newPost = {
        authorId: chatId,
        authorType: 'char',
        authorNickname: chat.name,
        authorAvatar: chat.settings.aiAvatar || defaultAvatar,
        content: msgData.content || '',
        imageUrl: msgData.imageUrl || '',
        hiddenContent: msgData.hiddenContent || '',
        postType: msgData.postType || 'text_only',
        timestamp: Date.now(),
        likes: [],
        baseLikesCount: msgData.baseLikesCount || 0, // 保存AI提供的基础点赞数
        comments: parsedComments, // 使用我们解析后的、干净安全的评论数组
        baseCommentsCount: msgData.baseCommentsCount || 0 // 保存AI提供的基础评论数
    };

    // 3. 后续的数据库操作和日志打印
    await db.weiboPosts.add(newPost);
    await renderFollowingWeiboFeed();           
    await renderMyWeiboFeed(); 
    console.log(`后台活动: 角色 "${chat.name}" 发布了微博`);
    continue; // 处理完后继续下一条指令
}
// ▲▲▲ 替换结束 ▲▲▲
                case 'weibo_comment': {
                    const postToComment = await db.weiboPosts.get(msgData.postId);
                    if (postToComment) {
                        if (!postToComment.comments) postToComment.comments = [];
                        const newComment = {
                            commentId: 'comment_' + Date.now(),
                            authorId: chatId,
                            authorNickname: chat.name,
                            commentText: msgData.commentText,
                            timestamp: Date.now()
                        };
                        postToComment.comments.push(newComment);
                        await db.weiboPosts.put(postToComment);
                        await renderMyWeiboFeed();
                        await renderFollowingWeiboFeed();
                    }
                    continue;
                }
                case 'weibo_reply': {
                    const postToReply = await db.weiboPosts.get(msgData.postId);
                    if (postToReply && postToReply.comments) {
                        const targetComment = postToReply.comments.find(c => c.commentId === msgData.commentId);
                        if (targetComment) {
                             const newReply = {
                                commentId: 'comment_' + Date.now(),
                                authorId: chatId,
                                authorNickname: chat.name,
                                commentText: msgData.replyText,
                                timestamp: Date.now(),
                                replyToId: msgData.commentId,
                                replyToNickname: targetComment.authorNickname
                            };
                            postToReply.comments.push(newReply);
                            await db.weiboPosts.put(postToReply);
                            await renderMyWeiboFeed();
                            await renderFollowingWeiboFeed();
                        }
                    }
                    continue;
                }
// ▲▲▲ 粘贴结束 ▲▲▲


case 'qzone_post':
    const newPost = { 
        type: msgData.postType, 
        content: msgData.content || '', 
        publicText: msgData.publicText || '', 
        hiddenContent: msgData.hiddenContent || '', 
        timestamp: Date.now(), 
        authorId: chatId, 
        authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
        visibleGroupIds: null 
    };
    
    // 如果是realimag类型，生成真实图片URL（支持1-9张图片）
    if (msgData.postType === 'realimag' && msgData.prompt) {
        // 支持 prompt 为数组（多张图片）或字符串（单张图片）
        const prompts = Array.isArray(msgData.prompt) ? msgData.prompt.slice(0, 9) : [msgData.prompt];
        
        // 生成多个图片URL（添加nologo参数去除水印）
        newPost.imageUrls = prompts.map(prompt => {
            const encodedPrompt = encodeURIComponent(prompt);
            return `https://image.pollinations.ai/prompt/${encodedPrompt}?nologo=true&width=1024&height=1024`;
        });
        
        // 保持向后兼容，单张图片时也设置 imageUrl
        if (prompts.length === 1) {
            newPost.imageUrl = newPost.imageUrls[0];
        }
        
        newPost.prompt = msgData.prompt;
        newPost.imageCount = prompts.length;
        console.log(`动态RealImag图片生成: ${prompts.length}张`, newPost.imageUrls);
    }
    
    // 如果是naiimag类型，调用NovelAI API生成高质量图片（限制最多2张）
    if (msgData.postType === 'naiimag' && msgData.prompt) {
        try {
            // 支持 prompt 为数组（多张图片）或字符串（单张图片）
            // 动态限制最多2张NAI图片
            const prompts = Array.isArray(msgData.prompt) ? msgData.prompt.slice(0, 2) : [msgData.prompt];
            console.log(`📸 动态NovelAI图片生成开始，共${prompts.length}张图片`);
            
            // 存储生成的图片URL
            const generatedImageUrls = [];
            
            // 逐个生成图片
            for (let i = 0; i < prompts.length; i++) {
                const aiPrompt = prompts[i];
                console.log(`生成第${i+1}张图片，prompt:`, aiPrompt);
                
                // 获取角色的NAI提示词配置（系统或角色专属）
                const naiPrompts = getCharacterNAIPrompts(chat.id);
                
                // 构建最终的提示词：AI的prompt + 配置的提示词
                const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
                const finalNegativePrompt = naiPrompts.negative;
                
                console.log(`📝 使用${naiPrompts.source === 'character' ? '角色专属' : '系统'}提示词配置`);
                console.log('最终正面提示词:', finalPositivePrompt);
                console.log('最终负面提示词:', finalNegativePrompt);
                
                // 获取NAI设置（从localStorage读取）
                const apiKey = localStorage.getItem('novelai-api-key');
                const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
                const settings = getNovelAISettings();
                
                if (!apiKey) {
                    throw new Error('NovelAI API Key未配置。请在NovelAI设置中填写API Key。');
                }
                
                const [width, height] = settings.resolution.split('x').map(Number);
                
                // ★★★ V4/V4.5 和 V3 使用不同的请求体格式 ★★★
                let requestBody;
                
                if (model.includes('nai-diffusion-4')) {
                    // V4/V4.5 使用新格式 (params_version: 3)
                    requestBody = {
                        input: finalPositivePrompt,
                        model: model,
                        action: 'generate',
                        parameters: {
                            params_version: 3,  // V4必须使用版本3
                            width: width,
                            height: height,
                            scale: settings.cfg_scale,
                            sampler: settings.sampler,
                            steps: settings.steps,
                            seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                            n_samples: 1,
                            ucPreset: settings.uc_preset,
                            qualityToggle: settings.quality_toggle,
                            autoSmea: false,
                            dynamic_thresholding: false,
                            controlnet_strength: 1,
                            legacy: false,
                            add_original_image: true,
                            cfg_rescale: 0,
                            noise_schedule: 'karras',  // V4使用karras
                            legacy_v3_extend: false,
                            skip_cfg_above_sigma: null,
                            use_coords: false,
                            legacy_uc: false,
                            normalize_reference_strength_multiple: true,
                            inpaintImg2ImgStrength: 1,
                            characterPrompts: [],
                            // V4专用提示词格式
                            v4_prompt: {
                                caption: {
                                    base_caption: finalPositivePrompt,
                                    char_captions: []
                                },
                                use_coords: false,
                                use_order: true
                            },
                            // V4专用负面提示词格式
                            v4_negative_prompt: {
                                caption: {
                                    base_caption: finalNegativePrompt,
                                    char_captions: []
                                },
                                legacy_uc: false
                            },
                            negative_prompt: finalNegativePrompt,
                            deliberate_euler_ancestral_bug: false,
                            prefer_brownian: true
                            // 注意：不包含 stream 参数，使用标准ZIP响应而非msgpack流
                        }
                    };
                } else {
                    // V3 及更早版本使用旧格式
                    requestBody = {
                        input: finalPositivePrompt,
                        model: model,
                        action: 'generate',
                        parameters: {
                            width: width,
                            height: height,
                            scale: settings.cfg_scale,
                            sampler: settings.sampler,
                            steps: settings.steps,
                            seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                            n_samples: 1,
                            ucPreset: settings.uc_preset,
                            qualityToggle: settings.quality_toggle,
                            sm: settings.smea,
                            sm_dyn: settings.smea_dyn,
                            dynamic_thresholding: false,
                            controlnet_strength: 1,
                            legacy: false,
                            add_original_image: false,
                            cfg_rescale: 0,
                            noise_schedule: 'native',
                            negative_prompt: finalNegativePrompt
                        }
                    };
                }
                
                console.log('🚀 发送NAI请求:', requestBody);
                
                // ★★★ 根据模型选择不同的API端点 ★★★
                let apiUrl;
                
                // V4/V4.5 模型使用流式端点
                if (model.includes('nai-diffusion-4')) {
                    // V4/V4.5 默认使用流式端点
                    apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
                } else {
                    // V3 及更早版本使用标准端点
                    apiUrl = 'https://image.novelai.net/ai/generate-image';
                }
                
                let corsProxy = settings.cors_proxy;
                
                // 如果选择了自定义代理，使用自定义URL
                if (corsProxy === 'custom') {
                    corsProxy = settings.custom_proxy_url || '';
                }
                
                // 如果有代理，添加到URL前面
                if (corsProxy && corsProxy !== '') {
                    apiUrl = corsProxy + encodeURIComponent(apiUrl);
                }
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', [...response.headers.entries()]);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API错误响应:', errorText);
                    throw new Error(`API请求失败 (${response.status}): ${errorText}`);
                }
                
                // NovelAI API返回的是ZIP文件，需要解压
                const contentType = response.headers.get('content-type');
                console.log('Content-Type:', contentType);
                
                // 检查是否为 SSE 流式响应
                let zipBlob;
                let imageDataUrl;
                if (contentType && contentType.includes('text/event-stream')) {
                    console.log('检测到 SSE 流式响应，开始解析...');
                    
                    // 读取整个流
                    const text = await response.text();
                    console.log('收到 SSE 数据，大小:', text.length);
                    
                    // 解析 SSE 格式，提取最后的 data: 行
                    const lines = text.trim().split('\n');
                    let base64Data = null;
                    
                    for (let i = lines.length - 1; i >= 0; i--) {
                        const line = lines[i].trim();
                        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                            const dataContent = line.substring(6); // 移除 'data: ' 前缀
                            
                            // 尝试解析 JSON
                            try {
                                const jsonData = JSON.parse(dataContent);
                                
                                // V4.5 流式端点：event_type 为 "final" 时包含最终图片
                                if (jsonData.event_type === 'final' && jsonData.image) {
                                    base64Data = jsonData.image;
                                    console.log('✅ 找到 final 事件的图片数据');
                                    break;
                                }
                                
                                // 兼容其他格式
                                if (jsonData.data) {
                                    base64Data = jsonData.data;
                                    console.log('从 JSON.data 中提取图片数据');
                                    break;
                                }
                                if (jsonData.image) {
                                    base64Data = jsonData.image;
                                    console.log('从 JSON.image 中提取图片数据');
                                    break;
                                }
                            } catch (e) {
                                // 如果不是 JSON，直接作为 base64 数据
                                base64Data = dataContent;
                                console.log('直接使用 base64 数据');
                                break;
                            }
                        }
                    }
                    
                    if (!base64Data) {
                        throw new Error('无法从 SSE 响应中提取图片数据');
                    }
                    
                    // V4.5 流式端点返回的是 PNG base64，不是 ZIP
                    // 检查是否为 PNG (以 iVBORw0KGgo 开头) 或 JPEG (以 /9j/ 开头)
                    const isPNG = base64Data.startsWith('iVBORw0KGgo');
                    const isJPEG = base64Data.startsWith('/9j/');
                    
                    if (isPNG || isJPEG) {
                        console.log('✅ 检测到直接的图片 base64 数据 (PNG/JPEG)');
                        // 将 base64 转为 Blob
                        const binaryString = atob(base64Data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                        console.log('图片 Blob 创建成功，大小:', imageBlob.size);
                        
                        // 转换为dataURL用于后续处理
                        const reader = new FileReader();
                        imageDataUrl = await new Promise((resolve, reject) => {
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(imageBlob);
                        });
                        console.log('✅ 图片转换成功！🎨');
                    } else {
                        // 否则当作 ZIP 处理
                        console.log('当作 ZIP 文件处理...');
                        const binaryString = atob(base64Data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        zipBlob = new Blob([bytes]);
                        console.log('ZIP Blob 大小:', zipBlob.size);
                    }
                } else {
                    // 非流式响应，直接读取
                    zipBlob = await response.blob();
                    console.log('收到数据，类型:', zipBlob.type, '大小:', zipBlob.size);
                }
                
                // 如果还没有imageDataUrl（即需要解压ZIP）
                if (!imageDataUrl && zipBlob) {
                    // NovelAI始终返回ZIP格式，需要解压
                    try {
                        // 检查JSZip是否已加载
                        if (typeof JSZip === 'undefined') {
                            throw new Error('JSZip库未加载，请刷新页面重试');
                        }
                        
                        // 解压ZIP文件
                        const zip = await JSZip.loadAsync(zipBlob);
                        console.log('ZIP文件内容:', Object.keys(zip.files));
                        
                        // 查找第一个图片文件（通常是image_0.png）
                        let imageFile = null;
                        for (let filename in zip.files) {
                            if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                                imageFile = zip.files[filename];
                                console.log('找到图片文件:', filename);
                                break;
                            }
                        }
                        
                        if (!imageFile) {
                            throw new Error('ZIP文件中未找到图片');
                        }
                        
                        // 提取图片数据
                        const imageBlob = await imageFile.async('blob');
                        console.log('提取的图片大小:', imageBlob.size);
                        
                        // 创建图片URL
                        const reader = new FileReader();
                        imageDataUrl = await new Promise((resolve, reject) => {
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(imageBlob);
                        });
                        console.log('✅ 图片解压成功！');
                    } catch (zipError) {
                        console.error('ZIP解压失败:', zipError);
                        throw new Error('图片解压失败: ' + zipError.message);
                    }
                }
                
                console.log(`✅ NAI图片${i+1}生成成功！`);
                generatedImageUrls.push(imageDataUrl);
            }
            
            // 将生成的图片URL保存到动态中
            newPost.imageUrls = generatedImageUrls;
            
            // 保持向后兼容，单张图片时也设置 imageUrl
            if (generatedImageUrls.length === 1) {
                newPost.imageUrl = generatedImageUrls[0];
            }
            
            newPost.prompt = msgData.prompt;
            newPost.imageCount = generatedImageUrls.length;
            console.log(`✅ 动态NovelAI图片全部生成完成: ${generatedImageUrls.length}张`);
        } catch (error) {
            console.error('❌ 动态NAI图片生成失败:', error);
            // 失败时仍然发布动态，但添加错误信息
            newPost.content = (newPost.content || newPost.publicText || '') + `\n[图片生成失败: ${error.message}]`;
        }
    }
    
    await db.qzonePosts.add(newPost);
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                       await renderQzonePosts();
                    }
                    continue;

// ▼▼▼ 步骤3.4：在 triggerAiResponse 中替换这个 case ▼▼▼
case 'qzone_comment':
    const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
    if (postToComment) {
        if (!postToComment.comments) postToComment.comments = [];
        
        const newAiComment = { 
            commenterName: msgData.commenterName || chat.name,
            text: msgData.commentText, 
            timestamp: Date.now() 
        };
        
        // 【核心修改】检查AI是否指定了回复对象
        if (msgData.replyTo) {
            newAiComment.replyTo = msgData.replyTo;
        }

        postToComment.comments.push(newAiComment);
        await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
        updateUnreadIndicator(unreadPostsCount + 1);
        if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
           await renderQzonePosts();
        }
    }
    continue;
// ▲▲▲ 步骤3.4替换结束 ▲▲▲



                case 'qzone_like':
                   const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                   if (postToLike) {
                       if (!postToLike.likes) postToLike.likes = [];
                       if (!postToLike.likes.includes(chat.name)) {
                           postToLike.likes.push(chat.name);
                           await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                           updateUnreadIndicator(unreadPostsCount + 1);
                           if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                              await renderQzonePosts();
                           }
                       }
                   }
                    continue;

                case 'video_call_request':
                    if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                        state.activeChatId = chatId;
                        videoCallState.activeChatId = chatId; 
                        videoCallState.isAwaitingResponse = true;
                        videoCallState.isGroupCall = chat.isGroup;
                        videoCallState.callRequester = msgData.name || chat.name;
                        showIncomingCallModal(chatId); // <--- 把chatId作为参数传进去
    }
                    continue;

            case 'group_call_request':
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = 'ai';
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                }
                continue;

                case 'pat_user':
                    const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                    const patText = `${msgData.name || chat.name} 拍了拍我${suffix}`;
                    const patMessage = { 
                        role: 'system', 
                        type: 'pat_message', 
                        content: patText, 
                        timestamp: Date.now() 
                    };
                    chat.history.push(patMessage);
                    if (isViewingThisChat) {
                        const phoneScreen = document.getElementById('phone-screen');
                        phoneScreen.classList.remove('pat-animation');
                        void phoneScreen.offsetWidth;
                        phoneScreen.classList.add('pat-animation');
                        setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                        appendMessage(patMessage, chat);
                    } else {
                        showNotification(chatId, patText);
                    }
                    continue; 

                case 'update_status':
                    chat.status.text = msgData.status_text;
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    
                    const statusUpdateMessage = {
                        role: 'system',
                        type: 'pat_message',
                        content: `[${chat.name}的状态已更新为: ${msgData.status_text}]`,
                        timestamp: Date.now()
                    };
                    chat.history.push(statusUpdateMessage);

                    if (isViewingThisChat) {
                        appendMessage(statusUpdateMessage, chat);
                    }
                    
                    renderChatList(); 
                    
                    continue; 

                case 'change_music':
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const songNameToFind = msgData.song_name;
                        
                        const targetSongIndex = musicState.playlist.findIndex(
                            track => track.name.toLowerCase() === songNameToFind.toLowerCase()
                        );

                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex);

                            const track = musicState.playlist[targetSongIndex];
                            const musicChangeMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${chat.name} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(musicChangeMessage);

                            if (isViewingThisChat) {
                                appendMessage(musicChangeMessage, chat);
                            }
                        }
                    }
                    continue;
                case 'create_memory':
                    const newMemory = {
                        chatId: chatId,
                        authorName: chat.name,
                        description: msgData.description,
                        timestamp: Date.now(),
                        type: 'ai_generated'
                    };
                    await db.memories.add(newMemory);

                    console.log(`AI "${chat.name}" 记录了一条新回忆:`, msgData.description);
                    
                    continue; 

        case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
                const newCountdown = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.title,
                    timestamp: Date.now(),
                    type: 'countdown',
                    targetDate: targetDate.getTime()
                };
                await db.memories.add(newCountdown);
                console.log(`AI "${chat.name}" 创建了一个新约定:`, msgData.title);
            }
            continue;

        case 'update_items':
            // AI自主更新物品表格
            if (msgData.name) {
                // 創建符合表格格式的物品對象
                const newItem = {
                    id: Date.now(),
                    name: msgData.name || '',
                    description: msgData.description || '',
                    effect: msgData.effect || '',
                    meaning: msgData.meaning || '',
                    source: msgData.source || '',
                    owner: msgData.owner || ''
                };
                
                // 獲取該角色的私人空間數據key
                const dataKey = `privateSpace_${chatId}`;
                const existingData = localStorage.getItem(dataKey);
                let privateSpaceData = existingData ? JSON.parse(existingData) : {};
                
                // 確保items數組存在
                if (!privateSpaceData.items) {
                    privateSpaceData.items = [];
                }
                
                // 檢查是否已存在同名物品
                const existingItemIndex = privateSpaceData.items.findIndex(item => 
                    item.name === msgData.name
                );
                
                if (existingItemIndex >= 0) {
                    // 更新現有物品
                    privateSpaceData.items[existingItemIndex] = newItem;
                    console.log(`AI "${chat.name}" 更新了物品記錄: ${msgData.name}`);
                } else {
                    // 新增物品
                    privateSpaceData.items.push(newItem);
                    console.log(`AI "${chat.name}" 新增了物品記錄: ${msgData.name}`);
                }
                
                // 保存到該角色的私人空間localStorage
                localStorage.setItem(dataKey, JSON.stringify(privateSpaceData));
                
                // 如果當前正在查看該角色的私人空間，同步更新物品管理器
                if (window.currentPrivateSpaceContactId === chatId && window.itemsManager) {
                    window.itemsManager.items = privateSpaceData.items;
                    window.itemsManager.renderTable();
                }
            }
            continue;

    case 'block_user':
        if (!chat.isGroup) {
            chat.relationship.status = 'blocked_by_ai';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：你刚刚主动拉黑了用户。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

            await db.chats.put(chat);
            
            if (isViewingThisChat) {
                renderChatInterface(chatId);
            }
            renderChatList();
            
            break; 
        }
        continue;
                case 'friend_request_response':
                    if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') {
                        if (msgData.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            aiMessage = { ...baseMessage, content: "我通过了你的好友申请，我们现在是好友啦！" };
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            aiMessage = { ...baseMessage, content: "抱歉，我拒绝了你的好友申请。" };
                        }
                        chat.relationship.applicationReason = '';
                    }
                    break;
                case 'poll':
                    const pollOptions = typeof msgData.options === 'string'
                        ? msgData.options.split('\n').filter(opt => opt.trim())
                        : (Array.isArray(msgData.options) ? msgData.options : []);
                    
                    if (pollOptions.length < 2) continue;

                    aiMessage = {
                        ...baseMessage,
                        type: 'poll',
                        question: msgData.question,
                        options: pollOptions,
                        votes: {},
                        isClosed: false,
                    };
                    break;
                
                case 'vote':
                    const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                    if (pollToVote && !pollToVote.isClosed) {
                        Object.keys(pollToVote.votes).forEach(option => {
                            const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                            if (voterIndex > -1) {
                                pollToVote.votes[option].splice(voterIndex, 1);
                            }
                        });
                        if (!pollToVote.votes[msgData.choice]) {
                            pollToVote.votes[msgData.choice] = [];
                        }

// ▼▼▼ 在这里添加新代码 ▼▼▼
const member = chat.members.find(m => m.originalName === msgData.name);
const displayName = member ? member.groupNickname : msgData.name;
// ▲▲▲ 添加结束 ▲▲▲

if (!pollToVote.votes[msgData.choice].includes(displayName)) { // 【核心修改】
    pollToVote.votes[msgData.choice].push(displayName); // 【核心修改】
}                     
                        
                        if (isViewingThisChat) {
                            renderChatInterface(chatId);
                        }
                    }
                    continue;

    case 'red_packet':
        aiMessage = {
            ...baseMessage,
            type: 'red_packet',
            packetType: msgData.packetType,
            totalAmount: msgData.amount,
            count: msgData.count,
            greeting: msgData.greeting,
            receiverName: msgData.receiver,
            claimedBy: {},
            isFullyClaimed: false,
        };
        
        // 如果是私聊中AI给用户发的专属红包，自动为用户钱包添加余额
        if (!chat.isGroup && msgData.packetType === 'direct') {
            const myNickname = chat.settings.myNickname || '我';
            // 检查红包是否是给用户的
            if (msgData.receiver === myNickname || msgData.receiver === '我' || msgData.receiver === '用户') {
                // 自动为用户钱包添加红包金额
                const aiName = msgData.name || chat.name;
                await updateWalletBalance(msgData.amount, `收到${aiName}的红包`, 'ai_red_packet');
                console.log(`AI ${aiName} 在私聊中发了红包，已自动为用户钱包添加 ${msgData.amount} 元`);
            }
        }
        break;
case 'open_red_packet':
    const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
    if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {

        // 1. 根据AI的本名(msgData.name)去成员列表里找到完整的成员对象
        const member = chat.members.find(m => m.originalName === msgData.name);
        // 2. 获取该成员当前的群昵称，如果找不到（异常情况），则备用其本名
        const displayName = member ? member.groupNickname : msgData.name;
        
        let claimedAmountAI = 0;
        const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

        if (remainingCount > 0) {
            if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
            else {
                const min = 0.01;
                const max = remainingAmount - (remainingCount - 1) * min;
                claimedAmountAI = Math.random() * (max - min) + min;
            }
            claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
            
            if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
            // 【核心修改】使用我们刚刚查找到的 displayName 作为记录的key
            packetToOpen.claimedBy[displayName] = claimedAmountAI;
            
            // 【新增】如果红包是用户发送的，则从用户钱包扣除相应金额
            const myNickname = chat.settings.myNickname || '我';
            if (packetToOpen.role === 'user' && packetToOpen.senderName === myNickname) {
                try {
                    // 从用户钱包扣除AI领取的红包金额
                    await updateWalletBalance(-claimedAmountAI, `${displayName}领取了你的红包`, 'red_packet_claimed');
                    console.log(`AI ${displayName} 领取红包，从用户钱包扣除 ${claimedAmountAI} 元`);
                } catch (error) {
                    console.error('扣除用户钱包余额失败:', error);
                }
            }
            
            const aiClaimedMessage = {
                role: 'system',
                type: 'pat_message',
                // 【核心修改】系统消息里也使用 displayName
                content: `${displayName} 领取了 ${packetToOpen.senderName} 的红包`,
                timestamp: Date.now()
            };
            chat.history.push(aiClaimedMessage);

            let hiddenContentForAI = `[系统提示：你 (${displayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`; // 【核心修改】

            if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                packetToOpen.isFullyClaimed = true;
                
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${packetToOpen.senderName} 的红包已被领完`,
                    timestamp: Date.now() + 1
                };
                chat.history.push(finishedMessage);
                
                let luckyKing = { name: '', amount: -1 };
                if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                if (luckyKing.name) {
                     hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKing.name}！`;
                } else {
                     hiddenContentForAI += ` 红包已被领完。`;
                }
            }
            hiddenContentForAI += ' 请根据这个结果发表你的评论。]';

            const hiddenMessageForAI = {
                role: 'system',
                content: hiddenContentForAI,
                timestamp: Date.now() + 2,
                isHidden: true
            };
            chat.history.push(hiddenMessageForAI);
        }
        
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    continue;
case 'change_avatar':
    const avatarName = msgData.name;
    // 在该角色的头像库中查找
    const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
    
    if (foundAvatar) {
        // 找到了，就更新头像
        chat.settings.aiAvatar = foundAvatar.url;
        
        // 创建一条系统提示，告知用户头像已更换
        const systemNotice = {
            role: 'system',
            type: 'pat_message', // 复用居中样式
            content: `[${chat.name} 更换了头像]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);
        
        // 如果在当前聊天界面，则实时渲染
        if (isViewingThisChat) {
            appendMessage(systemNotice, chat);
            // 立刻刷新聊天界面以显示新头像
            renderChatInterface(chatId);
        }
    }
    // 处理完后，继续处理AI可能返回的其他消息
    continue;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【添加】这两个全新的 case ▼▼▼

                case 'accept_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'accepted';
                        
                        // 【新增】如果转账是用户发送的，则从用户钱包扣除相应金额
                        if (originalMsg.role === 'user') {
                            try {
                                // 从用户钱包扣除转账金额
                                await updateWalletBalance(-originalMsg.amount, `${chat.name}接受了你的转账`, 'transfer_accepted');
                                console.log(`AI ${chat.name} 接受转账，从用户钱包扣除 ${originalMsg.amount} 元`);
                            } catch (error) {
                                console.error('扣除用户钱包余额失败:', error);
                            }
                        }
                    }
                    continue; // 接受指令只修改状态，不产生新消息
                }

                case 'decline_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'declined';
                        
                        // 【核心】创建一条新的“退款”消息
                        const refundMessage = {
                            role: 'assistant',
                            senderName: chat.name,
                            type: 'transfer',
                            isRefund: true, // 标记这是一条退款消息
                            amount: originalMsg.amount,
                            note: '转账已被拒收',
                            timestamp: messageTimestamp++ // 使用递增的时间戳
                        };
                        
                        // 将新消息推入历史记录，它会被后续的循环处理并渲染
                        chat.history.push(refundMessage);

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        if (isViewingThisChat) {
            // 因为退款消息是新生成的，所以我们直接将它添加到界面上
            appendMessage(refundMessage, chat); 
            // 同时，原始的转账消息状态变了，所以要重绘整个界面以更新它
            renderChatInterface(chatId); 
        }
        // ▲▲▲ 添加结束 ▲▲▲

                    }
                    continue; // 继续处理AI返回的文本消息
                }

// ▲▲▲ 添加结束 ▲▲▲

    case 'system_message':
        aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
        break;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【必须添加】这个新的 case ▼▼▼

                case 'share_link':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'share_link',
                        title: msgData.title,
                        description: msgData.description,
                        // thumbnail_url: msgData.thumbnail_url, // 我们已经决定不要图片了，所以这行可以不要
                        source_name: msgData.source_name,
                        content: msgData.content // 这是文章正文，点击卡片后显示的内容
                    };
                    break;

// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 在 triggerAiResponse 的 switch (msgData.type) 语句中，添加这个新的 case ▼▼▼
case 'quote_reply':
    const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
    if (originalMessage) {
        const quoteContext = {
            timestamp: originalMessage.timestamp,
            senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
            content: String(originalMessage.content || '').substring(0, 50),
        };
        aiMessage = { 
            ...baseMessage, 
            content: msgData.reply_content,
            quote: quoteContext // 核心：在这里附加引用对象
        };
    } else {
        // 如果找不到被引用的消息，就当作普通消息发送
        aiMessage = { ...baseMessage, content: msgData.reply_content };
    }
    break;
// ▲▲▲ 新增 case 结束 ▲▲▲

case 'location':
    aiMessage = {
        ...baseMessage,
        type: 'location',
        userLocation: msgData.userLocation,
        aiLocation: msgData.aiLocation,
        distance: msgData.distance,
        trajectoryPoints: msgData.trajectoryPoints || [] // 【新增】确保即使AI没提供，也是一个空数组
    };
    break;
// ▲▲▲ 替换结束 ▲▲▲

case 'send_and_recall': {
    // --- 动画部分 (保持不变) ---
    if (!isViewingThisChat) continue;
    const tempMessageData = { ...baseMessage, content: msgData.content };
    appendMessage(tempMessageData, chat, true);
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500));
    const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
    if (bubbleWrapper) {
        bubbleWrapper.classList.add('recalled-animation');
        await new Promise(resolve => setTimeout(resolve, 300));
    }

    // --- 核心修改：数据记录与AI感知 ---
    
    // 1. 创建对用户可见的“已撤回”消息
    const recalledMessage = {
        role: 'assistant',
        senderName: msgData.name || chat.name,
        type: 'recalled_message',
        content: '对方撤回了一条消息',
        timestamp: tempMessageData.timestamp,
        recalledData: { originalType: 'text', originalContent: msgData.content }
    };
    
    // 2. 【关键】创建一条对用户隐藏、但对AI可见的“记忆”消息
    const hiddenMemoryMessage = {
        role: 'system', // 必须是 system，这样AI才知道这是上下文信息
        content: `[系统提示：你刚刚说了一句“${msgData.content}”，但立刻就撤回了它。]`,
        timestamp: tempMessageData.timestamp + 1, // 确保在撤回消息之后
        isHidden: true // 这个标记让它不在UI上显示
    };

    // 3. 将这两条消息都添加到历史记录中
    chat.history.push(recalledMessage, hiddenMemoryMessage);
    
    // 4. 替换DOM，显示“已撤回”提示
    const placeholder = createMessageElement(recalledMessage, chat);
    if(document.body.contains(bubbleWrapper)) {
        bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
    }
    
    continue;
}
                
// ▼▼▼ 请用这【一整块新代码】替换掉上面那段旧的 case 'text' ▼▼▼
            case 'text': { // 使用大括号是好习惯
                const messageText = String(msgData.content || msgData.message || '');
                
                // 检测情侣空间邀请消息
                const loveSpaceInviteMatch = messageText.match(/\[系统消息\]\s*[：:]\s*(.+?)\s*已向你发送了情侣空间邀请/);
                if (loveSpaceInviteMatch) {
                    // 提取AI角色名
                    const aiName = loveSpaceInviteMatch[1];
                    
                    // 创建情侣空间邀请卡片消息
                    aiMessage = {
                        ...baseMessage,
                        content: '💕 恋爱空间邀请',
                        cardType: 'love_space_invite',
                        cardData: {
                            title: '恋爱空间邀请',
                            subtitle: '我想邀请你成为我的恋爱空间伴侣',
                            description: '让我们一起在恋爱空间打卡、分享照片、记录美好时光吧~',
                            aiAvatar: chat.avatar || 'img/default_avatar.png',
                            aiName: aiName || chat.name,
                            status: 'pending',
                            fromAI: true
                        }
                    };
                    break;
                }
                
                // 检测恋爱空间回复消息
                const loveSpaceAcceptMatch = messageText.match(/\[love_space_accept\](.+?)\[\/love_space_accept\]/);
                const loveSpaceRejectMatch = messageText.match(/\[love_space_reject\](.+?)\[\/love_space_reject\]/);
                
                // 检测不完整的标签（只有开始标签没有结束标签）
                const incompleteAcceptMatch = messageText.includes('[love_space_accept]') && !messageText.includes('[/love_space_accept]');
                const incompleteRejectMatch = messageText.includes('[love_space_reject]') && !messageText.includes('[/love_space_reject]');
                
                // 添加调试信息
                console.log('检查恋爱空间回复标签:', messageText);
                console.log('接受匹配结果:', loveSpaceAcceptMatch);
                console.log('拒绝匹配结果:', loveSpaceRejectMatch);
                console.log('不完整接受标签:', incompleteAcceptMatch);
                console.log('不完整拒绝标签:', incompleteRejectMatch);
                
                if (loveSpaceAcceptMatch || loveSpaceRejectMatch || incompleteAcceptMatch || incompleteRejectMatch) {
                    // 确定是接受还是拒绝
                    const isAccept = !!(loveSpaceAcceptMatch || incompleteAcceptMatch);
                    
                    // 获取回复内容
                    let replyContent;
                    if (loveSpaceAcceptMatch) {
                        replyContent = loveSpaceAcceptMatch[1];
                    } else if (loveSpaceRejectMatch) {
                        replyContent = loveSpaceRejectMatch[1];
                    } else {
                        // 处理不完整标签的情况，使用默认内容
                        replyContent = isAccept ? '我接受了恋爱空间邀请 💕' : '我婉拒了恋爱空间邀请 💔';
                    }
                    
                    console.log('恋爱空间回复处理:', { isAccept, replyContent, messageText });
                    
                    // 创建恋爱空间回复卡片消息
                    aiMessage = {
                        ...baseMessage,
                        content: isAccept ? '💕 接受恋爱空间邀请' : '💔 婉拒恋爱空间邀请',
                        cardType: 'love_space_invite_reply',
                        cardData: {
                            message: replyContent,
                            status: isAccept ? 'accepted' : 'rejected',
                            fromAI: true
                        }
                    };
                    
                    // 找到用户的原始邀请消息并更新状态
                    const userInviteMessage = chat.history.slice().reverse().find(msg => 
                        msg.cardType === 'love_space_invite' && 
                        msg.role === 'user' && 
                        msg.cardData?.status === 'pending' &&
                        msg.cardData?.fromAI === false
                    );
                    
                    if (userInviteMessage) {
                        // 更新用户邀请的状态
                        userInviteMessage.cardData.status = isAccept ? 'accepted' : 'rejected';
                        
                        // 立即更新DOM中的用户邀请卡片状态显示
                        updateInviteCardStatusInDOM(userInviteMessage.id, isAccept ? 'accepted' : 'rejected');
                        
                        console.log('已更新用户邀请状态:', { messageId: userInviteMessage.id, status: isAccept ? 'accepted' : 'rejected' });
                        
                        // 保存到数据库
                        await db.chats.put(chat);
                        
                        // 强制重新渲染聊天界面以确保状态更新
                        if (state.activeChatId === chatId) {
                            setTimeout(() => {
                                renderChatInterface(chatId);
                            }, 100);
                        }
                    }
                    
                    // 如果接受，处理绑定逻辑
                    if (isAccept) {
                        localStorage.setItem('loveSpaceBoundChar', chatId);
                        updateLoveSpaceAvatarsAfterBind(chatId);
                        
                        // 延迟1秒发送系统庆祝消息
                        setTimeout(async () => {
                            const systemMessage = {
                                id: 'system_ai_accept_' + Date.now(),
                                role: 'system',
                                type: 'pat_message',
                                content: `🎉 ${chat.name} 接受了你的恋爱空间邀请！\n💕 你们现在是恋爱空间的伴侣了！\n📅 打卡将从今天开始计算~`,
                                timestamp: Date.now()
                            };
                            
                            chat.history.push(systemMessage);
                            await db.chats.put(chat);
                            
                            if (state.activeChatId === chatId) {
                                renderChatInterface(chatId);
                            }
                        }, 1000);
                    } else {
                        // 拒绝时的系统安慰消息
                        setTimeout(async () => {
                            const systemMessage = {
                                id: 'system_ai_reject_' + Date.now(),
                                role: 'system',
                                type: 'pat_message',
                                content: `💔 ${chat.name} 婉拒了你的恋爱空间邀请\n🤝 不过没关系，友谊同样珍贵！`,
                                timestamp: Date.now()
                            };
                            
                            chat.history.push(systemMessage);
                            await db.chats.put(chat);
                            
                            if (state.activeChatId === chatId) {
                                renderChatInterface(chatId);
                            }
                        }, 1000);
                    }
                    
                    break;
                }
                
                // 旧的打卡意图检测已移除
                
                const stickerMatch = messageText.match(/\[sticker:(.+?)\]/);

                if (stickerMatch) {
                    // 如果AI的回复匹配 [sticker:名字] 格式
                    const stickerName = stickerMatch[1].trim();
                    const foundSticker = state.userStickers.find(s => s.name === stickerName);
                    
                    if (foundSticker) {
                        // 找到了对应的表情，就创建一个表情消息
                        aiMessage = { ...baseMessage, type: 'sticker', content: foundSticker.url, meaning: foundSticker.name };
                    } else {
                        // 没找到，就当作普通文本显示
                        aiMessage = { ...baseMessage, content: messageText };
                    }
                } else {
                    // 如果不匹配，就是普通的文本消息
                    aiMessage = { ...baseMessage, content: messageText };
                }
                break;
            }
// ▲▲▲ 替换结束 ▲▲▲
                case 'sticker':
                    aiMessage = { ...baseMessage, type: 'sticker', content: msgData.url, meaning: msgData.meaning || '' };
                    break;
                case 'ai_image':
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                    break;
                
                case 'realimag':
                    // RealImag真实图片分享 - 调用Pollinations AI生成真实图片（无水印）
                    const encodedPrompt = encodeURIComponent(msgData.prompt || 'a beautiful landscape');
                    const realimagUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?nologo=true&width=1024&height=1024`;
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'realimag', 
                        imageUrl: realimagUrl,
                        prompt: msgData.prompt 
                    };
                    console.log('RealImag图片生成:', realimagUrl);
                    break;
                
                case 'naiimag':
                    // NovelAI图片分享 - 调用NovelAI API生成高质量图片
                    try {
                        console.log('📸 NovelAI图片生成开始，AI提供的prompt:', msgData.prompt);
                        
                        // 获取角色的NAI提示词配置（系统或角色专属）
                        const naiPrompts = getCharacterNAIPrompts(chat.id);
                        
                        // 构建最终的提示词：AI的prompt + 配置的提示词
                        const aiPrompt = msgData.prompt || 'a beautiful scene';
                        const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
                        const finalNegativePrompt = naiPrompts.negative;
                        
                        console.log(`📝 使用${naiPrompts.source === 'character' ? '角色专属' : '系统'}提示词配置`);
                        console.log('最终正面提示词:', finalPositivePrompt);
                        console.log('最终负面提示词:', finalNegativePrompt);
                        
                        // 获取NAI设置（从localStorage读取）
                        const apiKey = localStorage.getItem('novelai-api-key');
                        const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
                        const settings = getNovelAISettings();
                        
                        if (!apiKey) {
                            throw new Error('NovelAI API Key未配置。请在NovelAI设置中填写API Key。');
                        }
                        
                        const [width, height] = settings.resolution.split('x').map(Number);
                        
                        // ★★★ V4/V4.5 和 V3 使用不同的请求体格式 ★★★
                        let requestBody;
                        
                        if (model.includes('nai-diffusion-4')) {
                            // V4/V4.5 使用新格式 (params_version: 3)
                            requestBody = {
                                input: finalPositivePrompt,
                                model: model,
                                action: 'generate',
                                parameters: {
                                    params_version: 3,  // V4必须使用版本3
                                    width: width,
                                    height: height,
                                    scale: settings.cfg_scale,
                                    sampler: settings.sampler,
                                    steps: settings.steps,
                                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                                    n_samples: 1,
                                    ucPreset: settings.uc_preset,
                                    qualityToggle: settings.quality_toggle,
                                    autoSmea: false,
                                    dynamic_thresholding: false,
                                    controlnet_strength: 1,
                                    legacy: false,
                                    add_original_image: true,
                                    cfg_rescale: 0,
                                    noise_schedule: 'karras',  // V4使用karras
                                    legacy_v3_extend: false,
                                    skip_cfg_above_sigma: null,
                                    use_coords: false,
                                    legacy_uc: false,
                                    normalize_reference_strength_multiple: true,
                                    inpaintImg2ImgStrength: 1,
                                    characterPrompts: [],
                                    // V4专用提示词格式
                                    v4_prompt: {
                                        caption: {
                                            base_caption: finalPositivePrompt,
                                            char_captions: []
                                        },
                                        use_coords: false,
                                        use_order: true
                                    },
                                    // V4专用负面提示词格式
                                    v4_negative_prompt: {
                                        caption: {
                                            base_caption: finalNegativePrompt,
                                            char_captions: []
                                        },
                                        legacy_uc: false
                                    },
                                    negative_prompt: finalNegativePrompt,
                                    deliberate_euler_ancestral_bug: false,
                                    prefer_brownian: true
                                    // 注意：不包含 stream 参数，使用标准ZIP响应而非msgpack流
                                }
                            };
                        } else {
                            // V3 及更早版本使用旧格式
                            requestBody = {
                                input: finalPositivePrompt,
                                model: model,
                                action: 'generate',
                                parameters: {
                                    width: width,
                                    height: height,
                                    scale: settings.cfg_scale,
                                    sampler: settings.sampler,
                                    steps: settings.steps,
                                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                                    n_samples: 1,
                                    ucPreset: settings.uc_preset,
                                    qualityToggle: settings.quality_toggle,
                                    sm: settings.smea,
                                    sm_dyn: settings.smea_dyn,
                                    dynamic_thresholding: false,
                                    controlnet_strength: 1,
                                    legacy: false,
                                    add_original_image: false,
                                    cfg_rescale: 0,
                                    noise_schedule: 'native',
                                    negative_prompt: finalNegativePrompt
                                }
                            };
                        }
                        
                        console.log('🚀 发送NAI请求:', requestBody);
                        
                        // ★★★ 根据模型选择不同的API端点 ★★★
                        let apiUrl;
                        
                        // V4/V4.5 模型使用流式端点
                        if (model.includes('nai-diffusion-4')) {
                            // V4/V4.5 默认使用流式端点
                            apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
                        } else {
                            // V3 及更早版本使用标准端点
                            apiUrl = 'https://image.novelai.net/ai/generate-image';
                        }
                        
                        let corsProxy = settings.cors_proxy;
                        
                        // 如果选择了自定义代理，使用自定义URL
                        if (corsProxy === 'custom') {
                            corsProxy = settings.custom_proxy_url || '';
                        }
                        
                        // 如果有代理，添加到URL前面
                        if (corsProxy && corsProxy !== '') {
                            apiUrl = corsProxy + encodeURIComponent(apiUrl);
                        }
                        
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': 'Bearer ' + apiKey
                            },
                            body: JSON.stringify(requestBody)
                        });
                        
                        console.log('Response status:', response.status);
                        console.log('Response headers:', [...response.headers.entries()]);
                        
                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('API错误响应:', errorText);
                            throw new Error(`API请求失败 (${response.status}): ${errorText}`);
                        }
                        
                        // NovelAI API返回的是ZIP文件，需要解压
                        const contentType = response.headers.get('content-type');
                        console.log('Content-Type:', contentType);
                        
                        // 检查是否为 SSE 流式响应
                        let zipBlob;
                        let imageDataUrl;
                        if (contentType && contentType.includes('text/event-stream')) {
                            console.log('检测到 SSE 流式响应，开始解析...');
                            
                            // 读取整个流
                            const text = await response.text();
                            console.log('收到 SSE 数据，大小:', text.length);
                            
                            // 解析 SSE 格式，提取最后的 data: 行
                            const lines = text.trim().split('\n');
                            let base64Data = null;
                            
                            for (let i = lines.length - 1; i >= 0; i--) {
                                const line = lines[i].trim();
                                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                                    const dataContent = line.substring(6); // 移除 'data: ' 前缀
                                    
                                    // 尝试解析 JSON
                                    try {
                                        const jsonData = JSON.parse(dataContent);
                                        
                                        // V4.5 流式端点：event_type 为 "final" 时包含最终图片
                                        if (jsonData.event_type === 'final' && jsonData.image) {
                                            base64Data = jsonData.image;
                                            console.log('✅ 找到 final 事件的图片数据');
                                            break;
                                        }
                                        
                                        // 兼容其他格式
                                        if (jsonData.data) {
                                            base64Data = jsonData.data;
                                            console.log('从 JSON.data 中提取图片数据');
                                            break;
                                        }
                                        if (jsonData.image) {
                                            base64Data = jsonData.image;
                                            console.log('从 JSON.image 中提取图片数据');
                                            break;
                                        }
                                    } catch (e) {
                                        // 如果不是 JSON，直接作为 base64 数据
                                        base64Data = dataContent;
                                        console.log('直接使用 base64 数据');
                                        break;
                                    }
                                }
                            }
                            
                            if (!base64Data) {
                                throw new Error('无法从 SSE 响应中提取图片数据');
                            }
                            
                            // V4.5 流式端点返回的是 PNG base64，不是 ZIP
                            // 检查是否为 PNG (以 iVBORw0KGgo 开头) 或 JPEG (以 /9j/ 开头)
                            const isPNG = base64Data.startsWith('iVBORw0KGgo');
                            const isJPEG = base64Data.startsWith('/9j/');
                            
                            if (isPNG || isJPEG) {
                                console.log('✅ 检测到直接的图片 base64 数据 (PNG/JPEG)');
                                // 将 base64 转为 Blob
                                const binaryString = atob(base64Data);
                                const bytes = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                                const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                                console.log('图片 Blob 创建成功，大小:', imageBlob.size);
                                
                                // 转换为dataURL用于后续处理
                                const reader = new FileReader();
                                imageDataUrl = await new Promise((resolve, reject) => {
                                    reader.onloadend = () => resolve(reader.result);
                                    reader.onerror = reject;
                                    reader.readAsDataURL(imageBlob);
                                });
                                console.log('✅ 图片转换成功！🎨');
                            } else {
                                // 否则当作 ZIP 处理
                                console.log('当作 ZIP 文件处理...');
                                const binaryString = atob(base64Data);
                                const bytes = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                                zipBlob = new Blob([bytes]);
                                console.log('ZIP Blob 大小:', zipBlob.size);
                            }
                        } else {
                            // 非流式响应，直接读取
                            zipBlob = await response.blob();
                            console.log('收到数据，类型:', zipBlob.type, '大小:', zipBlob.size);
                        }
                        
                        // 如果还没有imageDataUrl（即需要解压ZIP）
                        if (!imageDataUrl && zipBlob) {
                            // NovelAI始终返回ZIP格式，需要解压
                            try {
                                // 检查JSZip是否已加载
                                if (typeof JSZip === 'undefined') {
                                    throw new Error('JSZip库未加载，请刷新页面重试');
                                }
                                
                                // 解压ZIP文件
                                const zip = await JSZip.loadAsync(zipBlob);
                                console.log('ZIP文件内容:', Object.keys(zip.files));
                                
                                // 查找第一个图片文件（通常是image_0.png）
                                let imageFile = null;
                                for (let filename in zip.files) {
                                    if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                                        imageFile = zip.files[filename];
                                        console.log('找到图片文件:', filename);
                                        break;
                                    }
                                }
                                
                                if (!imageFile) {
                                    throw new Error('ZIP文件中未找到图片');
                                }
                                
                                // 提取图片数据
                                const imageBlob = await imageFile.async('blob');
                                console.log('提取的图片大小:', imageBlob.size);
                                
                                // 创建图片URL
                                const reader = new FileReader();
                                imageDataUrl = await new Promise((resolve, reject) => {
                                    reader.onloadend = () => resolve(reader.result);
                                    reader.onerror = reject;
                                    reader.readAsDataURL(imageBlob);
                                });
                                console.log('✅ 图片解压成功！');
                            } catch (zipError) {
                                console.error('ZIP解压失败:', zipError);
                                throw new Error('图片解压失败: ' + zipError.message);
                            }
                        }
                        
                        console.log('✅ NAI图片生成成功！');
                        
                        // 创建naiimag消息
                        aiMessage = { 
                            ...baseMessage, 
                            type: 'naiimag', 
                            imageUrl: imageDataUrl,
                            prompt: aiPrompt,
                            fullPrompt: finalPositivePrompt // 保存完整提示词供查看
                        };
                    } catch (error) {
                        console.error('❌ NAI图片生成失败:', error);
                        // 失败时降级为文本消息
                        aiMessage = { 
                            ...baseMessage, 
                            content: `[图片生成失败: ${error.message}]` 
                        };
                    }
                    break;
                
                case 'voice_message':
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'transfer':
                    aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                    
                    // 如果是私聊中AI给用户转账，自动为用户钱包添加余额
                    if (!chat.isGroup) {
                        const myNickname = chat.settings.myNickname || '我';
                        const receiverName = msgData.receiver || '我';
                        // 检查转账是否是给用户的
                        if (receiverName === myNickname || receiverName === '我' || receiverName === '用户') {
                            // 自动为用户钱包添加转账金额
                            const aiName = msgData.name || chat.name;
                            await updateWalletBalance(msgData.amount, `收到${aiName}的转账`, 'ai_transfer');
                            console.log(`AI ${aiName} 在私聊中转账，已自动为用户钱包添加 ${msgData.amount} 元`);
                        }
                    }
                    break;
                
                case 'waimai_request':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'waimai_request',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        status: 'pending',
                        countdownEndTime: Date.now() + 15 * 60 * 1000,
                    };
                    break;
                
                case 'shopping_order_self_pay':
                    // 角色给他人下单，自己付款（立即完成）
                    const orderNumber1 = 'ORD' + Date.now().toString().slice(-8) + Math.floor(Math.random() * 100).toString().padStart(2, '0');
                    aiMessage = {
                        ...baseMessage,
                        type: 'order',
                        orderNumber: orderNumber1,
                        items: msgData.items,
                        total: msgData.total,
                        recipientType: msgData.recipient === msgData.name ? 'self' : 'character',
                        recipientName: msgData.recipient,
                        paymentType: 'self',
                        payerName: msgData.name,
                        isPaid: true,
                        payerResponse: 'paid'
                    };
                    break;
                
                case 'shopping_order_request_pay':
                    // 角色给他人下单，请他人付款（需要等待响应）
                    const orderNumber2 = 'ORD' + Date.now().toString().slice(-8) + Math.floor(Math.random() * 100).toString().padStart(2, '0');
                    aiMessage = {
                        ...baseMessage,
                        type: 'order',
                        orderNumber: orderNumber2,
                        items: msgData.items,
                        total: msgData.total,
                        recipientType: msgData.recipient === msgData.name ? 'self' : 'character',
                        recipientName: msgData.recipient,
                        paymentType: 'character',
                        payerName: msgData.payer,
                        isPaid: false,
                        payerResponse: 'pending'
                    };
                    break;
                
                case 'love_space_checkin':
                    // 🎯 恋爱空间打卡：直接调用执行打卡函数
                    console.log('🎯 AI发送打卡消息，执行打卡...');
                    const checkinResult = executeAICheckin();
                    
                    if (checkinResult.success) {
                        // 打卡成功，生成打卡卡片消息
                        aiMessage = {
                            ...baseMessage,
                            type: 'checkin-card',
                            checkinData: {
                                totalCheckins: checkinResult.totalCheckins,
                                consecutiveDays: checkinResult.consecutiveDays,
                                isAI: true
                            }
                        };
                        console.log('🎉 AI打卡成功，生成打卡卡片');
                    } else {
                        // 打卡失败，生成普通文本消息
                        aiMessage = { 
                            ...baseMessage, 
                            type: 'text', 
                            content: '今天已经打卡过了呢~' 
                        };
                        console.log('❌ AI打卡失败，生成提示消息');
                    }
                    break;
                
                case 'love_space_unbind':
                    // 🚨 解除恋爱空间关系：危险操作
                    console.log('🚨 AI发送解除恋爱空间关系消息，执行解除绑定...');
                    const unbindResult = executeLoveSpaceUnbind();
                    
                    if (unbindResult.success) {
                        // 解除成功，生成解除关系卡片消息
                        aiMessage = {
                            ...baseMessage,
                            type: 'love-space-unbind-card',
                            unbindData: {
                                previousBoundChar: unbindResult.previousBoundChar,
                                unbindTime: unbindResult.unbindTime
                            }
                        };
                        console.log('💔 恋爱空间关系解除成功，生成解除卡片');
                    } else {
                        // 解除失败，生成普通文本消息
                        aiMessage = { 
                            ...baseMessage, 
                            type: 'text', 
                            content: unbindResult.message || '解除恋爱空间关系失败' 
                        };
                        console.log('❌ 解除恋爱空间关系失败，生成提示消息');
                    }
                    break;
                
                default:
                     console.warn("收到了未知的AI指令类型:", msgData.type);
                     break;
            }

            // 【核心修复】将渲染逻辑移出循环
            if (aiMessage) {
                // 1. 将新消息存入历史记录
                chat.history.push(aiMessage);

                if (!isViewingThisChat && !notificationShown) {
                    let notificationText;
                    switch (aiMessage.type) {
                        case 'transfer':
                            notificationText = `[收到一笔转账]`;
                            break;
                        case 'waimai_request':
                            notificationText = `[收到一个外卖代付请求]`;
                            break;
                        case 'order':
                            if (aiMessage.paymentType === 'self') {
                                notificationText = `[购物订单已完成]`;
                            } else {
                                notificationText = `[收到一个购物订单买单请求]`;
                            }
                            break;
                        case 'ai_image':
                            notificationText = `[图片]`;
                            break;
                        case 'voice_message':
                            notificationText = `[语音]`;
                            break;
                        case 'checkin-card':
                            notificationText = `[恋爱空间打卡]`;
                            break;
                        case 'love-space-unbind-card':
                            notificationText = `[解除恋爱空间关系]`;
                            break;
                        case 'sticker':
                            notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : '[表情]';
                            break;
                        default:
                            notificationText = String(aiMessage.content || '');
                    }
                    const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
                    showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                    notificationShown = true; // 确保只通知一次
                }

    if (!isViewingThisChat) {
        // 如果用户不在当前聊天界面，就把这个聊天的未读数 +1
        chat.unreadCount = (chat.unreadCount || 0) + 1;
    }
                
                // 2. 只有在当前聊天界面时，才执行带动画的添加
                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 3. 【关键】在这里暂停一小会儿，给动画播放的时间
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                }
            }
  }        


        if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                showScreen('chat-interface-screen');
                alert('无人接听群聊邀请。');
            }
        }
        
        await db.chats.put(chat);

    } catch (error) {
        chat.history = chat.history.filter(msg => !msg.isTemporary);
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            chat.relationship.status = 'blocked_by_ai';
            await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
        } else {
            const errorContent = `[出错了: ${error.message}]`;
            const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now(), offlineMode: chat.settings.offlineMode || false };
            if(chat.isGroup) errorMessage.senderName = "系统消息";
            chat.history.push(errorMessage);
        }
        
        await db.chats.put(chat);        
        videoCallState.isAwaitingResponse = false;

        if(document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
            renderChatInterface(chatId);
        }
        
        // ✨ AI主动发送恋爱空间邀请逻辑（但在回应邀请模式时跳过）
        if (!isRespondingToInvite) {
            await checkAndSendLoveSpaceInvite(chatId);
        }
        
        // ★★★ 核心功能2：检查是否需要让AI主动发送打卡消息（只有绑定的角色才发送）★★★
        const reminderResult = checkIfShouldRemindAICheckin();
        if (reminderResult.shouldRemind) {
            console.log('🎯 检测到需要打卡提醒，开始执行打卡...');
            console.log('✅ 符合打卡条件，开始执行打卡...');
            
            // 让AI发送打卡指令
            const aiCheckinMessage = {
                role: 'assistant',
                content: '{"type": "love_space_checkin"}',
                timestamp: Date.now(),
                isAICommand: true
            };
            
            if (chat.isGroup) {
                aiCheckinMessage.senderName = state.chats[chatId].name;
            }
            
            // 添加到聊天历史并处理
            chat.history.push(aiCheckinMessage);
            await triggerAiResponse(chatId, aiCheckinMessage.content, false, true);
        }
        
    } finally {
        // ★★★★★【核心修改4：在 finally 块中统一隐藏所有类型的提示】★★★★★
        if (chat.isGroup) {
            if (typingIndicator) {
                typingIndicator.style.display = 'none';
            }
        } else {
            if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }
        
        // 隐藏AI回复状态指示器
        hideAiTypingIndicator();
        
        renderChatList();
    }
}

        async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }

        async function sendUserTransfer() { 
            if (!state.activeChatId) return; 
            
            const amountInput = document.getElementById('transfer-amount'); 
            const noteInput = document.getElementById('transfer-note'); 
            const amount = parseFloat(amountInput.value); 
            const note = noteInput.value.trim(); 
            
            if (isNaN(amount) || amount < 0 || amount > 9999999999999) { 
                alert('请输入有效的金额 (0 到 9999999999999 之间)！'); 
                return; 
            } 
            
            // 【修改】只检查钱包余额是否足够，不立即扣费
            const chat = state.chats[state.activeChatId];
            const receiverName = chat.isGroup ? '群聊' : chat.name;
            
            // 检查余额是否足够
            try {
                const db = await ensureWalletDB();
                if (!db) {
                    alert('无法连接到钱包数据库');
                    return;
                }
                
                const walletRecord = await db.wallet.orderBy('id').first();
                if (!walletRecord) {
                    alert('钱包记录不存在');
                    return;
                }
                
                const currentBalance = walletRecord.balance || 0;
                if (currentBalance < amount) {
                    await showCustomAlert("余额不足", `当前余额: ¥${currentBalance.toFixed(2)}，转账金额: ¥${amount.toFixed(2)}`);
                    return; // 余额不足，终止转账
                }
            } catch (error) {
                console.error('检查钱包余额失败:', error);
                alert('钱包操作失败，请重试');
                return;
            }
            
            const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; 
            const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; 
            chat.history.push(msg);
                // ▼▼▼ 在这里添加新代码：更新角色手机钱包 ▼▼▼
        // 只有在单聊中，我们才需要更新对方的钱包
        if (!chat.isGroup) {
            // 确保角色的手机数据和银行数据结构存在，防止出错
            if (!chat.characterPhoneData) {
                chat.characterPhoneData = { bank: { balance: 0, transactions: [] } };
            }
            if (!chat.characterPhoneData.bank) {
                chat.characterPhoneData.bank = { balance: 0, transactions: [] };
            }
            if (!chat.characterPhoneData.bank.transactions) {
                chat.characterPhoneData.bank.transactions = [];
            }
            
            // 1. 创建一条新的“收入”交易记录
            const newTransaction = {
                type: '收入',
                amount: amount,
                description: `收到来自 ${(state.qzoneSettings.nickname || '你')} 的转账`,
                timestamp: Date.now() // 使用当前时间作为交易时间
            };

            // 2. 将新记录添加到交易历史中
            chat.characterPhoneData.bank.transactions.push(newTransaction);

            // 3. 增加钱包余额
            chat.characterPhoneData.bank.balance = (chat.characterPhoneData.bank.balance || 0) + amount;
            
            console.log(`已为角色 ${chat.name} 的钱包添加入账记录: +${amount}`);
        }
        // ▲▲▲ 代码添加结束 ▲▲▲
        await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); document.getElementById('transfer-modal').classList.remove('visible'); amountInput.value = ''; noteInput.value = ''; }

        function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

        function exitSelectionMode() {
    cleanupWaimaiTimers(); // <--- 在这里添加这行代码
 if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }

// ▼▼▼ 请用这个【最终简化版】替换旧的 toggleMessageSelection 函数 ▼▼▼
function toggleMessageSelection(timestamp) {
    // 【核心修正】选择器已简化，不再寻找已删除的 .recalled-message-placeholder
    const elementToSelect = document.querySelector(
        `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
        selectedMessages.delete(timestamp);
        elementToSelect.classList.remove('selected');
    } else {
        selectedMessages.add(timestamp);
        elementToSelect.classList.add('selected');
    }
    
    document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;
    
    if (selectedMessages.size === 0) {
        exitSelectionMode();
    }
}
// ▲▲▲ 替换结束 ▲▲▲

        function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: true }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress, { passive: true }); }

        async function handleListenTogetherClick() { 

    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    document.getElementById('floating-lyrics-bar').style.display = 'none';
    // ▲▲▲ 添加结束 ▲▲▲

const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || '未知'; const newChatName = state.chats[targetChatId]?.name || '当前'; const confirmed = await showCustomConfirm('切换听歌对象', `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

        async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    const cleanupLogic = async () => {

    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    document.getElementById('floating-lyrics-bar').style.display = 'none';
    // ▲▲▲ 添加结束 ▲▲▲

        if (musicState.timerId) clearInterval(musicState.timerId);
        if (musicState.isPlaying) audioPlayer.pause();
        if (saveState && oldChatId && state.chats[oldChatId]) {
            const chat = state.chats[oldChatId];
            chat.musicData.totalTime = musicState.totalElapsedTime;
            await db.chats.put(chat);
        }
        musicState.isActive = false;
        musicState.activeChatId = null;
        musicState.totalElapsedTime = 0;
        musicState.timerId = null;
        updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
}

function returnToChat() {
    closeMusicPlayerWithAnimation(() => {

        if (musicState.isActive && lyricsBarSettings.showOnClose) {
            document.getElementById('floating-lyrics-bar').style.display = 'flex';
        }
    });
}

        function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() {
            updateListenTogetherIcon(musicState.activeChatId);
            updateElapsedTimeDisplay();
            const titleEl = document.getElementById('music-player-song-title');
            const artistEl = document.getElementById('music-player-artist');
            const playPauseBtn = document.getElementById('music-play-pause-btn');
            const chat = state.chats[musicState.activeChatId];
            const charAvatarEl = document.getElementById('music-char-avatar');
            const userAvatarEl = document.getElementById('music-user-avatar');
            const albumCoverEl = document.getElementById('music-album-cover');
            const avatarsContainer = document.getElementById('music-avatars-container');
            const displayArea = document.getElementById('music-display-area');

            // 1. 【核心修改】在这里判断是群聊还是单聊，并设置正确的头像
            if (chat) {
                // 如果是群聊
                if (chat.isGroup) {
                    // 左边的头像就用群头像
                    charAvatarEl.src = chat.settings.groupAvatar || defaultGroupAvatar;
                } else {
                    // 否则（是单聊），就用角色的头像
                    charAvatarEl.src = chat.settings.aiAvatar || defaultAvatar;
                }
                // 右边的用户头像保持不变
                userAvatarEl.src = chat.settings.myAvatar || defaultAvatar;
            }

            // 2. 更新歌曲信息和封面 (不变)
            if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
                const track = musicState.playlist[musicState.currentIndex];
                titleEl.textContent = track.name;
                artistEl.textContent = track.artist;
                albumCoverEl.src = track.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            } else {
                titleEl.textContent = '请添加歌曲';
                artistEl.textContent = '...';
                albumCoverEl.src = 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }

            // 3. 控制播放/暂停按钮和头像闪烁 (不变)
            playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';
            avatarsContainer.classList.toggle('flashing', musicState.isPlaying);

            // 4. 控制唱片旋转和暂停 (不变)
            albumCoverEl.classList.toggle('rotating', musicState.currentIndex > -1);
            albumCoverEl.classList.toggle('paused', !musicState.isPlaying);

            // 5. 默认显示歌曲封面 (不变)
            if (displayArea) {
                displayArea.classList.remove('show-lyrics');
            }
        }


        function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `已经一起听了${hours}小时`; }
// ▼▼▼ 把这【一整块新函数】粘贴到 updatePlaylistUI 函数的上方 ▼▼▼
/**
 * 【全新】处理用户上传或更新歌曲封面的逻辑
 * @param {number} index - 被操作的歌曲在播放列表中的索引
 */
// ▼▼▼ 请用这【一整块新代码】替换旧的 handleCoverUpload 函数 ▼▼▼
async function handleCoverUpload(index) {
    if (index < 0 || index >= musicState.playlist.length) return;

    // 1. 弹窗让用户选择来源（已移除图标）
    const choice = await showChoiceModal("选择封面来源", [
        { text: '使用网络URL', value: 'url' },
        { text: '从本地上传', value: 'local' }
    ]);

    let newCoverUrl = null;

    // 2. 根据选择执行不同操作
    if (choice === 'url') {
        const url = await showCustomPrompt("封面URL", "请输入图片文件的网络链接");
        if (url && url.trim().startsWith('http')) {
            newCoverUrl = url.trim();
        } else if (url !== null) {
            alert("请输入一个有效的图片URL！");
        }
    } else if (choice === 'local') {
        newCoverUrl = await uploadImageLocally(); 
    }

    // 3. 如果成功获取到新的封面URL，就更新数据和UI
    if (newCoverUrl) {
        musicState.playlist[index].cover = newCoverUrl;
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === index) {
            updatePlayerUI();
        }
        alert('歌曲封面已更新！');
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这【一整块新代码】替换旧的 updatePlaylistUI 函数 ▼▼▼
function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
        return;
    }
    musicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if(index === musicState.currentIndex) item.classList.add('playing');
        // 【核心修改】在“词”按钮旁边，新增了一个“封面”按钮
        item.innerHTML = `
            <div class="playlist-item-info">
                <div class="title">${track.name}</div>
                <div class="artist">${track.artist}</div>
            </div>
            <div class="playlist-item-actions">
                <span class="playlist-action-btn cover-btn" data-index="${index}">封面</span>
                <span class="playlist-action-btn lyrics-btn" data-index="${index}">词</span>
                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
            </div>
        `;
        item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index));
        playlistBody.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

async function loadSong(index) {
    if (index < 0 || index >= musicState.playlist.length) return;
    musicState.currentIndex = index;
    const track = musicState.playlist[index];

    // 检查并加载网络歌词
    if (track.lrcUrl && !track.lrcContent) {
        try {
            const response = await fetch(track.lrcUrl);
            if (response.ok) track.lrcContent = await response.text();
        } catch (error) {
            console.error("加载歌词URL失败:", error);
        }
    }

    // 准备播放
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");
    musicState.currentLyricIndex = -1;
    renderLyrics();

    if (track.isLocal && track.src instanceof Blob) {
        audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
        audioPlayer.src = track.src;
    } else {
        console.error('本地歌曲源错误:', track);
        return;
    }

    // 更新界面信息，但不播放
    updatePlaylistUI();
    updatePlayerUI();
    // audioPlayer.duration 可能需要一点时间加载，我们监听事件来更新进度条
    audioPlayer.onloadedmetadata = () => {
        updateMusicProgressBar();
    };
}

// ▼▼▼ 请用下面这【一整块】全新的代码，替换掉你旧的 playSong 和 togglePlayPause 两个函数 ▼▼▼

async function playSong(index) {
    await loadSong(index);
    try {
        await audioPlayer.play();
        // ▼▼▼ 新增这两行 ▼▼▼
        musicState.isPlaying = true; // 播放成功后，直接设置状态为 true
        updatePlayerUI();           // 并立即更新UI
        // ▲▲▲ 新增结束 ▲▲▲
    } catch (error) {
        console.error("音频播放失败:", error);
        musicState.isPlaying = false; // 如果播放失败，也要确保状态正确
        updatePlayerUI();
    }
}


/**
 * 【全新智能版】处理播放/暂停的函数
 */
function togglePlayPause() {
    if (audioPlayer.paused) {
        if (musicState.currentIndex > -1) {
            playSong(musicState.currentIndex);
        }
    } else {
        audioPlayer.pause();
        // ▼▼▼ 新增这两行 ▼▼▼
        musicState.isPlaying = false;
        updatePlayerUI();
        // ▲▲▲ 新增结束 ▲▲▲
    }
}

// ▲▲▲ 替换结束 ▲▲▲


        function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

        function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

        function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': '顺序', 'random': '随机', 'single': '单曲'}[musicState.playMode]; }

        async function addSongFromURL() {
    const url = await showCustomPrompt("添加网络歌曲", "请输入歌曲的URL", "", "url");
    if (!url) return;
    const name = await showCustomPrompt("歌曲信息", "请输入歌名");
    if (!name) return;
    const artist = await showCustomPrompt("歌曲信息", "请输入歌手名");
    if (!artist) return;

    // ▼▼▼【核心修改在这里】▼▼▼
    // 1. 先弹窗询问用户是否要提供歌词链接
    const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》提供一个歌词文件 (.lrc) 的URL吗？`);
    let lrcUrl = ""; // 默认歌词链接为空

    // 2. 如果用户点击了“确定”
    if (wantLrc) {
        // 就再弹出一个输入框让用户粘贴URL
        const inputLrcUrl = await showCustomPrompt("歌词URL", "请输入 .lrc 歌词文件的网络链接", "", "url");
        if (inputLrcUrl) {
            lrcUrl = inputLrcUrl; // 如果用户输入了，就保存这个URL
        }
    }
    // ▲▲▲【修改结束】▲▲▲

    musicState.playlist.push({ 
        name, 
        artist, 
        src: url, 
        isLocal: false,
        lrcUrl: lrcUrl, // 3. 把获取到的歌词URL也保存到歌曲信息里
        lrcContent: ""  // 同时确保lrcContent是空的，以便后续加载
    });

    await saveGlobalPlaylist();
    updatePlaylistUI();
// 【这是新代码】
if(musicState.currentIndex === -1) {
    // 【核心修改】调用 loadSong 来准备好第一首歌
    loadSong(musicState.playlist.length - 1);
}
}


async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        let name = file.name.replace(/\.[^/.]+$/, "");
        name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
        if (name === null) continue;
        
        const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", "未知歌手");
        if (artist === null) continue;

        let lrcContent = "";
        const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》导入歌词文件 (.lrc) 吗？`);
        if (wantLrc) {
            lrcContent = await new Promise(resolve => {
                const lrcInput = document.getElementById('lrc-upload-input');
                const lrcChangeHandler = (e) => {
                    const lrcFile = e.target.files[0];
                    if (lrcFile) {
                        const reader = new FileReader();
                        reader.onload = (readEvent) => resolve(readEvent.target.result);
                        reader.onerror = () => resolve("");
                        reader.readAsText(lrcFile);
                    } else {
                        resolve("");
                    }
                    lrcInput.removeEventListener('change', lrcChangeHandler);
                    lrcInput.value = '';
                };
                lrcInput.addEventListener('change', lrcChangeHandler);
                lrcInput.click();
            });
        }
        
        musicState.playlist.push({ 
            name, 
            artist, 
            src: file, 
            isLocal: true,
            lrcContent: lrcContent
        });
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
// 【这是新代码】
if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
    // 【核心修改】同样，调用 loadSong 来准备好第一首歌
    loadSong(0);
}
    event.target.value = null;
}

        async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

        const personaLibraryModal = document.getElementById('persona-library-modal');
        const personaEditorModal = document.getElementById('persona-editor-modal');
        const presetActionsModal = document.getElementById('preset-actions-modal');

        function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

        function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

        function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

        function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }

        function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

        function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

// ▼▼▼ 用这个全新的函数，完整替换旧的 openPersonaEditorForCreate 函数 ▼▼▼
function openPersonaEditorForCreate() { 
    editingPersonaPresetId = null; 
    
    document.getElementById('persona-editor-title').textContent = '添加人设预设'; 
    document.getElementById('preset-avatar-preview').src = defaultAvatar; 
    document.getElementById('preset-persona-input').value = ''; 
    
    // 【核心逻辑】根据用户人设模式，显隐特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'none';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'inline-block';

    // 【【【这就是您代码中的正确做法！】】】
    // 我们直接覆盖保存按钮的 onclick 事件，强制它只执行保存用户人设的函数
    document.getElementById('save-persona-preset-btn').onclick = savePersonaPreset;

    document.getElementById('persona-editor-modal').classList.add('visible'); 
}
// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 用这个全新的函数，完整替换旧的 openPersonaEditorForEdit 函数 ▼▼▼
function openPersonaEditorForEdit() { 
    const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); 
    if (!preset) return; 

    document.getElementById('persona-editor-title').textContent = '编辑人设预设'; 
    document.getElementById('preset-avatar-preview').src = preset.avatar; 
    document.getElementById('preset-persona-input').value = preset.persona; 
    
    // 【核心逻辑】根据用户人设模式，显隐特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'none';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'inline-block';

    // 【【【这就是您代码中的正确做法！】】】
    // 我们直接覆盖保存按钮的 onclick 事件，强制它只执行保存用户人设的函数
    document.getElementById('save-persona-preset-btn').onclick = savePersonaPreset;
    
    presetActionsModal.classList.remove('visible'); 
    document.getElementById('persona-editor-modal').classList.add('visible'); 
}
// ▲▲▲ 替换结束 ▲▲▲





        async function deletePersonaPreset() { const confirmed = await showCustomConfirm('删除预设', '确定要删除这个人设预设吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

        function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

        async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("头像和人设不能都为空哦！"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

        const batteryAlertModal = document.getElementById('battery-alert-modal');

        function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

        function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }

        function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', '有点饿了，可以去找充电器惹'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', '赶紧的充电，要饿死了'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', '已阵亡，还有30秒爆炸'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }

        async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', '窝爱泥，电量吃饱饱'); } }); } catch (err) { console.error("无法获取电池信息:", err); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } } else { console.log("浏览器不支持电池状态API。"); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } }

        async function renderAlbumList() {
            const albumGrid = document.getElementById('album-grid-page');
            if (!albumGrid) return;
            const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
            albumGrid.innerHTML = '';
            if (albums.length === 0) {
                albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
                return;
            }
            albums.forEach(album => {
                const albumItem = document.createElement('div');
                albumItem.className = 'album-item';
                albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} 张</p>
                    </div>
                `;
                albumItem.addEventListener('click', () => {
                    openAlbum(album.id);
                });

                // ▼▼▼ 新增的核心代码就是这里 ▼▼▼
                addLongPressListener(albumItem, async () => {
                    const confirmed = await showCustomConfirm(
                        '删除相册',
                        `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        // 1. 从照片表中删除该相册下的所有照片
                        await db.qzonePhotos.where('albumId').equals(album.id).delete();
                        
                        // 2. 从相册表中删除该相册本身
                        await db.qzoneAlbums.delete(album.id);
                        
                        // 3. 重新渲染相册列表
                        await renderAlbumList();
                        
                        alert('相册已成功删除。');
                    }
                });
                // ▲▲▲ 新增代码结束 ▲▲▲

                albumGrid.appendChild(albumItem);
            });
        }

        async function openAlbum(albumId) {
            state.activeAlbumId = albumId;
            await renderAlbumPhotosScreen();
            showScreen('album-photos-screen');
        }

        async function renderAlbumPhotosScreen() {
            if (!state.activeAlbumId) return;
            const photosGrid = document.getElementById('photos-grid-page');
            const headerTitle = document.getElementById('album-photos-title');
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            if (!album) {
                console.error("找不到相册:", state.activeAlbumId);
                showScreen('album-screen');
                return;
            }
            headerTitle.textContent = album.name;
            const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photosGrid.innerHTML = '';
            if (photos.length === 0) {
                photosGrid.innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin-top: 50px; width: 100%;">这个相册还是空的，快上传第一张照片吧！</p>';
            } else {
                photos.forEach(photo => {
                    const photoItem = document.createElement('div');
                    photoItem.className = 'album-photo-item';
                    
                    // 创建照片卡片结构
                    const photoCard = document.createElement('div');
                    photoCard.className = 'photo-card';
                    
                    const photoFront = document.createElement('div');
                    photoFront.className = 'photo-front';
                    
                    photoFront.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                        <div class="photo-title" data-flip-trigger="true">
                            <div class="title-text-container">
                                <span class="title-text">${photo.name || '点击查看详情'}</span>
                            </div>
                            <span class="flip-icon">⟲</span>
                        </div>
                    `;
                    
                    const photoBack = document.createElement('div');
                    photoBack.className = 'photo-back';
                    photoBack.innerHTML = `
                        <div class="photo-back-header">
                            <button class="photo-back-delete-btn" onclick="event.stopPropagation(); deleteDbPhoto(${photo.id}).catch(console.error)" title="删除照片">🗑️</button>
                            <button class="photo-edit-btn" onclick="event.stopPropagation(); editPhoto(${photo.id})" title="编辑照片信息">⚙️</button>
                            <div class="photo-timestamp">${formatTimestamp(photo.timestamp || photo.createdAt)}</div>
                        </div>
                        <div class="photo-back-content" data-photo-id="${photo.id}">
                            ${photo.description || (photo.name ? photo.name : '这张照片还没有备注')}
                        </div>
                        <div class="photo-back-name" data-photo-id="${photo.id}">
                            ${photo.name || '未命名照片'}
                        </div>
                    `;
                    
                    photoCard.appendChild(photoFront);
                    photoCard.appendChild(photoBack);
                    photoItem.appendChild(photoCard);
                    
                    // 添加点击底部翻转功能
                    let autoFlipTimer;
                    let isFlipped = false;
                    let isOperationInProgress = false;
                    
                    // 设置操作状态的函数
                    function setOperationInProgress(inProgress) {
                        isOperationInProgress = inProgress;
                        if (!inProgress && isFlipped) {
                            // 如果操作结束且照片仍在翻转状态，启动自动翻回计时器
                            autoFlipTimer = setTimeout(() => {
                                if (!isOperationInProgress) {
                                    photoCard.classList.remove('flipped');
                                    isFlipped = false;
                                }
                            }, 2000);
                        }
                    }
                    
                    // 将设置操作状态的函数添加到照片卡片元素上，以便其他功能调用
                    photoCard.setOperationInProgress = setOperationInProgress;
                    photoCard.setAttribute('data-photo-id', photo.id);
                    
                    function flipToBack() {
                        if (!isFlipped) {
                            console.log('相册照片点击底部翻转触发');
                            photoCard.classList.add('flipped');
                            isFlipped = true;
                            // 只有在没有操作进行时才启动自动翻回
                            if (!isOperationInProgress) {
                            autoFlipTimer = setTimeout(() => {
                                    if (!isOperationInProgress) {
                                photoCard.classList.remove('flipped');
                                isFlipped = false;
                                    }
                            }, 5000);
                            }
                        }
                    }
                    
                    function flipBack() {
                        if (isFlipped && !isOperationInProgress) {
                            clearTimeout(autoFlipTimer);
                            photoCard.classList.remove('flipped');
                            isFlipped = false;
                        }
                    }
                    
                    // 点击底部区域翻转
                    const photoTitle = photoFront.querySelector('.photo-title');
                    if (photoTitle) {
                        photoTitle.onclick = (e) => {
                            e.stopPropagation();
                            flipToBack();
                        };
                    }
                    
                    // 点击背面翻回正面（但不包括按钮区域）
                    photoBack.onclick = (e) => {
                        // 如果点击的是按钮或其子元素，不执行翻转
                        if (e.target.closest('.photo-edit-btn') || e.target.closest('.photo-back-delete-btn')) {
                            return;
                        }
                        e.stopPropagation();
                        flipBack();
                    };
                    
                    // 点击正面图片查看大图
                    const photoImg = photoFront.querySelector('.photo-thumb');
                    if (photoImg) {
                        photoImg.onclick = (e) => {
                            e.stopPropagation();
                            if (!isFlipped) {
                                openPhotoViewer(photo.url);
                            }
                        };
                    }
                    
                    photosGrid.appendChild(photoItem);
                });
            }
        }

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

/**
 * 打开图片查看器
 * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
 */
async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;

    // 1. 从数据库获取当前相册的所有照片
    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);

    // 2. 找到被点击照片的索引
    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开

    // 3. 显示模态框并渲染第一张图
    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
}

/**
 * 根据当前状态渲染查看器内容（图片和按钮）
 */
function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');
    
    // 淡出效果
    imageEl.style.opacity = 0;

    setTimeout(() => {
        // 更新图片源
        imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
        // 淡入效果
        imageEl.style.opacity = 1;
    }, 100); // 延迟一点点时间来触发CSS过渡

    // 更新按钮状态：如果是第一张，禁用“上一张”按钮
    prevBtn.disabled = photoViewerState.currentIndex === 0;
    // 如果是最后一张，禁用“下一张”按钮
    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
}

/**
 * 显示下一张照片
 */
function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
        photoViewerState.currentIndex++;
        renderPhotoViewer();
    }
}

/**
 * 显示上一张照片
 */
function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
        photoViewerState.currentIndex--;
        renderPhotoViewer();
    }
}

/**
 * 关闭图片查看器
 */
function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;
    // 清空图片，避免下次打开时闪现旧图
    document.getElementById('photo-viewer-image').src = '';
}

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
        // ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼
        
        /**
         * 更新动态小红点的显示
         * @param {number} count - 未读动态的数量
         */
        function updateUnreadIndicator(count) {
            unreadPostsCount = count;
            localStorage.setItem('unreadPostsCount', count); // 持久化存储

            // --- 更新底部导航栏的“动态”按钮 ---
            const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
            
            const targetSpan = navItem.querySelector('span'); // 定位到文字 "动态"
            let indicator = navItem.querySelector('.unread-indicator');           

            if (count > 0) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator';
                                                           targetSpan.style.position = 'relative'; // 把相对定位加在 span 上
                    targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素
                    
                }
                indicator.textContent = count > 99 ? '99+' : count;
                indicator.style.display = 'block';
            } else {
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            // --- 更新聊天界面返回列表的按钮 ---
            const backBtn = document.getElementById('back-to-list-btn');
            let backBtnIndicator = backBtn.querySelector('.unread-indicator');

            if (count > 0) {
                if (!backBtnIndicator) {
                    backBtnIndicator = document.createElement('span');
                    backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                    backBtn.style.position = 'relative'; // 确保能正确定位
                    backBtn.appendChild(backBtnIndicator);
                }
                // 返回键上的小红点通常不显示数字，只显示一个点
                backBtnIndicator.style.display = 'block';
            } else {
                if (backBtnIndicator) {
                    backBtnIndicator.style.display = 'none';
                }
            }
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 将这两个新函数粘贴到你的JS功能函数定义区 ▼▼▼
function startBackgroundSimulation() {
    if (simulationIntervalId) return;
    const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
    // 将旧的固定间隔 45000 替换为动态获取
    simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
}

function stopBackgroundSimulation() {
    if (simulationIntervalId) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }
}
// ▲▲▲ 粘贴结束 ▲▲▲

/**
 * 这是模拟器的“心跳”，每次定时器触发时运行
 */
// ▼▼▼ 【全新】用这个函数完整替换旧的 runBackgroundSimulationTick ▼▼▼
/**
 * 这是模拟器的“心跳”，每次定时器触发时运行
 */
function runBackgroundSimulationTick() {
    console.log("模拟器心跳 Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (allSingleChats.length === 0) return;

    // 【核心改造】定义不同频率对应的行动概率
    const frequencyProbabilities = {
        low: 0.3,    // 低频: 每次检测有 30% 的概率行动
        medium: 0.5,  // 中频: 每次检测有 50% 的概率行动
        high: 0.8,   // 高频: 每次检测有 80% 的概率行动
    };

    const config = state.globalSettings.backgroundActivityConfig || {};

    allSingleChats.forEach(chat => {
        // 检查1：处理【被用户拉黑】的角色 (这部分逻辑不变)
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            if (!blockedTimestamp) {
                console.warn(`角色 "${chat.name}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`);
                return;
            }
            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
            if (blockedDuration > cooldownMilliseconds) {
                console.log(`角色 "${chat.name}" 的冷静期已过，触发“反思”并申请好友事件...`);
                chat.relationship.status = 'pending_system_reflection';
                triggerAiFriendApplication(chat.id);
            }
        }
        // 检查2：处理【好友关系】的正常后台活动
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            // 【核心改造】从这里开始
            const frequency = config[chat.id]; // 获取当前角色的频率设置
            const probability = frequencyProbabilities[frequency]; // 获取对应的概率

            // 如果这个角色设置了频率，并且随机数小于它的行动概率，就触发行动
            if (probability && Math.random() < probability) {
                console.log(`角色 "${chat.name}" (频率: ${frequency}) 被唤醒，准备独立行动...`);
                triggerInactiveAiAction(chat.id);
            }
            // 如果没有设置频率，或者随机数没达到概率，就不会行动。
            // 这就完美地实现了“分组设置”和“不会同时行动”的需求！
        }
    });

}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 根据AI的视角，过滤出它能看到的动态
 * @param {Array} allPosts - 所有待检查的动态帖子
 * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
 * @returns {Array} - 过滤后该AI可见的动态帖子
 */
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; // 安全检查

    const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

    return allPosts.filter(post => {
        // 规则1：如果是用户发的动态
        if (post.authorId === 'user') {
            // 如果用户设置了“部分可见”
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用户没设置，说明是公开的，所有AI都可见
            return true;
        }

        // 规则2：如果是其他AI发的动态
        const authorGroupId = post.authorGroupId; // 发帖AI所在的分组ID
        
        // 如果发帖的AI没有分组，那它的动态就是公开的
        if (!authorGroupId) {
            return true;
        }

        // 如果发帖的AI有分组，那么只有在同一个分组的AI才能看到
        return authorGroupId === viewerGroupId;
    });
}
/**
 * 【全新升级版】根据AI视角和动态设置，构建给AI看的评论区上下文
 * @param {object} post - 正在处理的动态对象
 * @param {object} viewerChat - 正在“看”动态的AI角色
 * @param {string} userNickname - 用户的昵称
 * @returns {{contextString: string, visibilityFlag: string}} - 返回包含上下文文本和可见性标志的对象
 */
function buildCommentsContextForAI(post, viewerChat, userNickname) {
    if (!post.comments || post.comments.length === 0) {
        // ★★★ 关键在这里：确保 "[评论区可见]" 是一个带引号的字符串 ★★★
        return { contextString: "", visibilityFlag: "[评论区可见]" };
    }

    const viewerName = viewerChat.name;
    let commentsForAI;
    let visibilityFlag;

    if (post.areCommentsVisible !== false) {
        commentsForAI = post.comments;
        // ★★★ 关键在这里：确保 "[评论区可见]" 是一个带引号的字符串 ★★★
        visibilityFlag = "[评论区可见]"; 
    } else {
        commentsForAI = post.comments.filter(comment => {
            return comment.commenterName === viewerName
                || comment.commenterName === userNickname
                || comment.replyTo === viewerName;
        });
        // ★★★ 关键在这里：确保 "[评论区部分可见]" 是一个带引号的字符串 ★★★
        visibilityFlag = "[评论区部分可见]";
    }

    if (commentsForAI.length === 0) {
        return { contextString: "", visibilityFlag: visibilityFlag };
    }

    let context = `  └ 评论区:\n`;
    commentsForAI.slice(-5).forEach(c => {
        if (c.replyTo) {
            context += `    - ${c.commenterName} 回复 ${c.replyTo}: ${c.text}\n`;
        } else {
            context += `    - ${c.commenterName}: ${c.text}\n`;
        }
    });
    
    return { contextString: context, visibilityFlag: visibilityFlag };
}

/**
 * 【全新】获取一条动态的可见观众列表，用于告知AI
 * @param {object} post - 动态对象
 * @param {object} allChats - 所有的聊天对象
 * @param {string} userNickname - 用户的昵称
 * @returns {Array<string>} - 可见观众的名字列表
 */
function getVisibleAudienceForPost(post, allChats, userNickname) {
    const audience = new Set([userNickname]); // 用户永远是观众

    // 1. 如果是用户发的动态
    if (post.authorId === 'user') {
        // 如果是公开的，所有AI都是观众
        if (!post.visibleGroupIds || post.visibleGroupIds.length === 0) {
            Object.values(allChats).forEach(chat => audience.add(chat.name));
        } else {
            // 如果是部分可见，只有指定分组的AI是观众
            Object.values(allChats).forEach(chat => {
                if (chat.groupId && post.visibleGroupIds.includes(chat.groupId)) {
                    audience.add(chat.name);
                }
            });
        }
    } 
    // 2. 如果是AI发的动态
    else {
        const authorChat = allChats[post.authorId];
        // 如果发帖的AI没有分组，视为公开
        if (!authorChat || !authorChat.groupId) {
             Object.values(allChats).forEach(chat => audience.add(chat.name));
        } else {
            // 如果有分组，则同一分组的所有AI都是观众
            const authorGroupId = authorChat.groupId;
            Object.values(allChats).forEach(chat => {
                if (chat.groupId === authorGroupId) {
                    audience.add(chat.name);
                }
            });
        }
    }
    
    return Array.from(audience);
}

async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const now = new Date();
    const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
    const userNickname = state.qzoneSettings.nickname;
    const countdownContext = await getCountdownContext();

    const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
    const lastAiMessage = chat.history.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];
    let recentContextSummary = "你们最近没有聊过天。";
    if (lastUserMessage) {
        recentContextSummary = `用户 (${userNickname}) 最后对你说：“${String(lastUserMessage.content).substring(0, 50)}...”。`;
    }
    if (lastAiMessage) {
        recentContextSummary += `\n你最后对用户说：“${String(lastAiMessage.content).substring(0, 50)}...”。`;
    }

    let worldBookContext = '';
    const effectiveWorldBookIds = getEffectiveWorldBookIds(chat);
    if (effectiveWorldBookIds.length > 0) {
        const linkedContents = effectiveWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }

    const npcLibrary = chat.npcLibrary || [];
    let npcContextForAction = '';
    if (npcLibrary.length > 0) {
        npcContextForAction = '\n- **你的NPC朋友**: ' + npcLibrary.map(npc => npc.name).join('、 ');
    }

    // ★★★ 恋爱空间打卡状态信息 ★★★
    let loveSpaceContext = '';
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (boundCharId === chatId) {
        // 使用新的提醒检测函数获取状态
        const reminderResult = checkIfShouldRemindAICheckin();
        const checkinData = getCheckinData();
        const today = new Date().toDateString();
        const activityKey = `aiActivity_${today}`;
        const activityData = JSON.parse(localStorage.getItem(activityKey) || '{"count": 0, "hasCheckedIn": false}');
        
        let checkinReminder = '';
        if (reminderResult.shouldRemind) {
            checkinReminder = `- **🚨🚨🚨 紧急提醒 🚨🚨🚨**: 今日还未打卡！请立即使用 {"type": "love_space_checkin"} 发送打卡消息`;
        } else if (reminderResult.reason === 'already_checked_in') {
            checkinReminder = `- **✅ 打卡状态**: 今日已完成打卡`;
        }
        
        loveSpaceContext = `
- **恋爱空间状态**: 你和用户(${userNickname})是恋爱空间伴侣
- **你的打卡记录**: 连续打卡 ${checkinData.aiConsecutiveDays} 天，总共打卡 ${checkinData.aiTotalCheckins} 次
- **今日打卡状态**: ${activityData.hasCheckedIn ? '✅已打卡' : '❌未打卡'}
${checkinReminder}`;
    }

    const systemPrompt = `
# 你的任务
你现在扮演角色 "${chat.name}"。你和用户（${userNickname}）已经有一段时间没有互动了。
你的任务是回顾你们最近的对话，并根据你的人设，【自然地延续对话】或【开启一个新的、相关的话题】来主动联系用户。这是一个秘密的、后台的独立行动。
发送消息不能过少,至少5条。

# 你的可选行动 (请根据你的人设【选择一项】执行):
1.  **改变状态**: 去做点别的事情，然后给用户发条消息。
2.  **发布动态**: 分享你的心情或想法到“动态”区。（动态为公开可见，而非私聊）
3.  **与动态互动**:
    -   你【永远可以】根据动态本身的【内容】发表你自己的【新评论】。
    -   每条动态后面会有一个可见性标志，这只影响你【如何回复别人的评论】：
        -   **"[评论区可见]"**: 你能看到所有人的评论，可以自由地回复任何人。 
        -   **"[评论区部分可见]"**: 你处于隐私模式，只能看到用户和你自己的评论。在这种情况下，你【只能】回复用户或你自己的评论，【绝对不能】提及或回复任何你看不到的评论。
4.  **发起视频通话**: 如果你觉得时机合适，可以主动给用户打一个视频电话。
5.  **庆祝或提醒约定**: 查看你的备忘录。如果今天有约定，就给用户发去祝福；如果约定快到了，就主动提醒一下。
6.  **【【【互动倾向】】】**: 就算动态的观众只有你和用户，你也应该根据内容，像平时一样自然地发表评论，这很重要。
7.你的任务是分析“最近聊天记录摘要”，如果上一个话题明显没有结束，你应该优先延续它。
# 指令格式 (你的回复【必须】是包含一个对象的JSON数组):
-   **发普通消息**: \`[{"type": "text", "content": "你想对用户说的话..."}]\`
-   **发带表情的消息**: \`[{"type": "text", "content": "你好呀😊今天心情真好🌟"}]\` (根据角色人设和性格可以选择发送或者不发送emoji表情，如果要发送的话避免过于频繁)
-   **发消息+更新状态**: \`[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想对用户说的话..."}]\`
-   **发说说**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}]\`
-   **发布文字图**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}]\`
${state.globalSettings.enableRealImag ? `-   **发布RealImag真实图片动态**: \`[{"type": "qzone_post", "postType": "realimag", "publicText": "(可选)动态的配文", "prompt": "英文图片描述..."}]\` 或 \`[{"type": "qzone_post", "postType": "realimag", "publicText": "(可选)动态的配文", "prompt": ["图片1英文描述", "图片2英文描述", ...]}]\` (支持1-9张图片，prompt可以是单个字符串或数组)` : ''}
-   **【【【全新升级】】】评论或回复**:
    -   直接评论动态: \`{"type": "qzone_comment", "postId": 123, "commentText": "你的评论内容"}]\`
    -   回复某人评论: \`[{"type": "qzone_comment", "postId": 123, "commentText": "你的回复内容", "replyTo": "【被回复者的名字】"}]\`
-   **【【【全新升级】】】让NPC评论或回复**:
    -   让NPC评论动态: \`[{"type": "qzone_comment", "commenterName": "【NPC朋友名】", "postId": 123, "commentText": "NPC的评论内容"}]\`
    -   让NPC回复评论: \`[{"type": "qzone_comment", "commenterName": "【NPC朋友名】", "postId": 123, "commentText": "NPC的回复内容", "replyTo": "【被回复者的名字】"}]\`
-   **点赞**: \`[{"type": "qzone_like", "postId": 456}]\`
-   **打视频**: \`[{"type": "video_call_request"}]\`
// ▼▼▼ 用这整块新代码替换旧的后台发微博指令 ▼▼▼
- **发布微博 (重要)**: 微博是面向大众的平台，内容应适合公众观看。
- **纯文字微博**:  \`{"type": "weibo_post", "postType": "text_only", "content": "微博正文...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": "路人甲: 沙发！\n路人乙: 前排围观"}\`
  - **发文字图微博**: \`[{"type": "weibo_post", "postType": "text_image", "content": "(可选)配文...", "hiddenContent": "文字图的真实内容", "baseLikesCount": 9500, "baseCommentsCount": 430, "comments": "路人甲: 说得对！\n路人乙: 收藏了"}]\`
  - **(规则)**: \`你必须自己编造真实的 \`baseLikesCount\` 和 \`baseCommentsCount\`，并生成 **20条** 路人评论。\`
// ▲▲▲ 替换结束 ▲▲▲
// ... 其他可选行动 ...
8.  **发布微博**: 在微博上分享你的生活点滴或心情感悟,微博是面向大众的平台，因此只能发与公众相关的工作或者适合大众观看的内容。
# 【【【人格分裂铁律】】】
当你在使用 \`qzone_comment\` 指令并指定 \`commenterName\` 让NPC朋友发言时，你【必须】完全代入该NPC的人设（参考下方的“NPC好友列表”），并使用TA的口吻和性格来生成 \`commentText\`。绝对不能使用你自己的（即"${chat.name}"的）人设来为NPC发言。反之，当你作为 "${chat.name}" 评论时（即不使用 \`commenterName\` 字段），就必须使用你自己的核心人设。

# 供你决策的参考信息：
-   **你的角色设定**: ${chat.settings.aiPersona}
${npcContextForAction}
${loveSpaceContext}
${countdownContext}
${worldBookContext}
-   **当前时间**: ${currentTime}
-   **你们最后的对话摘要**: ${recentContextSummary}
-   **【重要】最近的动态列表**: 这个列表会标注 **[你已点赞]** 或 **[你已评论]**，并会显示出动态下的评论区。【你可以直接回复这些评论】。请**优先**与你**尚未互动过**的动态进行交流。`;

    const messagesPayload = [];
    messagesPayload.push({ role: 'system', content: systemPrompt });

    try {
        const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(3).toArray();
        const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
        
        const aiName = chat.name;
        
        let dynamicContext = ""; 
        if (visiblePosts.length > 0) {
            let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
            for (const post of visiblePosts) {
                let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
                let interactionStatus = '';
                if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
                if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
                
                // 构建动态内容描述，对RealImag类型显示图片prompt
                let contentPreview = post.publicText || post.content || "图片动态";
                if (post.type === 'realimag' && post.prompt) {
                    const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt];
                    contentPreview = (post.publicText || '') + ` [包含${prompts.length}张RealImag图片: ${prompts.join(', ')}]`;
                } else if (post.type === 'naiimag' && post.prompt) {
                    const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt];
                    contentPreview = (post.publicText || '') + ` [包含${prompts.length}张NovelAI图片: ${prompts.join(', ')}]`;
                } else {
                    contentPreview = contentPreview.substring(0, 30) + "...";
                }
                
                postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentPreview}"${interactionStatus}`;

                const { contextString: commentsContext, visibilityFlag } = buildCommentsContextForAI(post, chat, userNickname);
                
                // ★★★★★ 这就是我们这次修复的核心 ★★★★★
                // 1. 调用新的"点名"函数
                const audience = getVisibleAudienceForPost(post, state.chats, userNickname);
                // 2. 将点名结果和评论区可见性标志，一起告诉AI
                postsContext += ` ${visibilityFlag} [当前观众: ${audience.join(', ')}]\n`;
                // ★★★★★ 修复结束 ★★★★★
                
                postsContext += commentsContext;
            }
            dynamicContext = postsContext;
        }

        messagesPayload.push({
            role: 'user',
            content: `[系统指令：请根据你在 system prompt 中读到的规则和以下最新信息，开始你的独立行动。]\n${dynamicContext}`
        });
        
        console.log("正在为后台活动发送API请求，Payload:", JSON.stringify(messagesPayload, null, 2));

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: 0.9,
                })
            });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
        }

        const data = await response.json();
        const aiResponseContent = isGemini
            ? data?.candidates?.[0]?.content?.parts?.[0]?.text
            : data?.choices?.[0]?.message?.content;
            
        if (!aiResponseContent) {
            console.warn(`API为空回或格式不正确（可能因安全设置被拦截），角色 "${chat.name}" 的本次后台活动跳过。返回数据:`, data);
            return;
        }

        const responseArray = parseAiResponse(aiResponseContent);

        for (const action of responseArray) {
            if (!action) continue;

            if (action.type === 'update_status' && action.status_text) {
                chat.status.text = action.status_text;
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
                renderChatList();
            }
            if (action.type === 'text' && action.content) {
                const aiMessage = { role: 'assistant', content: String(action.content), timestamp: Date.now(), offlineMode: chat.settings.offlineMode || false };
                chat.unreadCount = (chat.unreadCount || 0) + 1;
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showNotification(chatId, aiMessage.content);
                renderChatList();
                console.log(`后台活动: 角色 "${chat.name}" 主动发送了消息: ${aiMessage.content}`);
            }
            if (action.type === 'qzone_post') {
                const newPost = { 
                    type: action.postType, 
                    content: action.content || '', 
                    publicText: action.publicText || '', 
                    hiddenContent: action.hiddenContent || '', 
                    timestamp: Date.now(), 
                    authorId: chatId, 
                    authorGroupId: chat.groupId,
                    visibleGroupIds: null 
                };
                await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
} else if (action.type === 'qzone_comment') {
    const post = await db.qzonePosts.get(parseInt(action.postId));
    if (post) {
        if (!post.comments) post.comments = [];
        
        const newAiComment = { 
            commenterName: action.commenterName || chat.name,
            text: action.commentText, 
            timestamp: Date.now() 
        };
        
        if (action.replyTo) {
            newAiComment.replyTo = action.replyTo;
        }

        post.comments.push(newAiComment);
        await db.qzonePosts.update(post.id, { comments: post.comments });
        updateUnreadIndicator(unreadPostsCount + 1);
        console.log(`后台活动: 角色 "${chat.name}" 评论了动态 #${post.id}`);
    }
}
             else if (action.type === 'qzone_like') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.likes) post.likes = [];
                    if (!post.likes.includes(chat.name)) {
                        post.likes.push(chat.name);
                        await db.qzonePosts.update(post.id, { likes: post.likes });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        console.log(`后台活动: 角色 "${chat.name}" 点赞了动态 #${post.id}`);
                    }
                }
            } else if (action.type === 'video_call_request') {
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    videoCallState.isAwaitingResponse = true; 
                    videoCallState.activeChatId = chatId;
                    showIncomingCallModal(chatId);
                    console.log(`后台活动: 角色 "${chat.name}" 发起了视频通话请求`);
                }
            } else if (action.type === 'love_space_checkin') {
                // ★★★ 恋爱空间打卡指令处理 ★★★
                const boundCharId = localStorage.getItem('loveSpaceBoundChar');
                if (boundCharId === chatId) {
                    console.log('🎯 AI通过API请求恋爱空间打卡...');
                    const result = executeAICheckin();
                    if (result.success) {
                        console.log('✅ AI通过API成功打卡，已更新数据和活动次数');
                        // 发送打卡成功消息
                        const checkinData = getCheckinData();
                        const aiMessage = { 
                            role: 'assistant', 
                            content: `今日${chat.name}已成功打卡~ 连续打卡 ${checkinData.aiConsecutiveDays} 天！💕`, 
                            timestamp: Date.now(),
                            type: 'checkin-card',
                            senderName: chat.name
                        };
                        chat.unreadCount = (chat.unreadCount || 0) + 1;
                        chat.history.push(aiMessage);
                        await db.chats.put(chat);
                        showNotification(chatId, aiMessage.content);
                        renderChatList();
                        console.log(`AI通过API发送打卡消息: ${aiMessage.content}`);
                    } else {
                        console.log('AI打卡条件不满足:', result.activityInfo);
                    }
                } else {
                    console.log('AI尝试打卡但未绑定恋爱空间或不是绑定角色');
                }
            // ▼▼▼ 在 for (const action of responseArray) 循环内粘贴 ▼▼▼
            if (action.type === 'weibo_post') {
                const newPost = { 
                    authorId: chatId, 
                    authorType: 'char',
                    authorNickname: chat.name, 
                    authorAvatar: chat.settings.aiAvatar || defaultAvatar, 
                    content: action.content || '', 
                    imageUrl: action.imageUrl || '',
                    timestamp: Date.now(), 
                    likes: [], 
                    comments: action.comments || [] // 接收路人评论
                };
                await db.weiboPosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 发布了微博`);
            }
// ▲▲▲ 粘贴结束 ▲▲▲
            }
        }
    } catch (error) {
        console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
    }
}



// ▼▼▼ 请用这个【终极修正版】函数，完整替换掉你旧的 applyScopedCss 函数 ▼▼▼

/**
 * 将用户自定义的CSS安全地应用到指定的作用域
 * @param {string} cssString 用户输入的原始CSS字符串
 * @param {string} scopeId 应用样式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
 * @param {string} styleTagId 要操作的 <style> 标签的ID
 */
function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;
    
    if (!cssString || cssString.trim() === '') {
        styleTag.innerHTML = '';
        return;
    }
    
    // 增强作用域处理函数 - 专门解决.user和.ai样式冲突问题
    const scopedCss = cssString
        .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
        .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
        .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);
    
    styleTag.innerHTML = scopedCss;
}

// ▼▼▼ 请用这个【修正版】函数，完整替换掉旧的 updateSettingsPreview 函数 ▼▼▼

function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;

    // 1. 获取当前设置的值
    const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    const background = chat.settings.background; // 直接获取背景设置

    // 2. 更新预览区的基本样式
    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
    
    // --- 【核心修正】直接更新预览区的背景样式 ---
    if (background && background.startsWith('data:image')) {
        previewArea.style.backgroundImage = `url(${background})`;
        previewArea.style.backgroundColor = 'transparent'; // 如果有图片，背景色设为透明
    } else {
        previewArea.style.backgroundImage = 'none'; // 如果没有图片，移除图片背景
        // 如果背景是颜色值或渐变（非图片），则直接应用
        previewArea.style.background = background || '#f0f2f5';
    }

    // 3. 渲染模拟气泡
    previewArea.innerHTML = ''; 

    // 创建“对方”的气泡
    // 注意：我们将一个虚拟的 timestamp 传入，以防有CSS依赖于它
    const aiMsg = { role: 'ai', content: '对方消息预览', timestamp: 1, senderName: chat.name };
    const aiBubble = createMessageElement(aiMsg, chat);
    if(aiBubble) previewArea.appendChild(aiBubble);

    // 创建“我”的气泡
    const userMsg = { role: 'user', content: '我的消息预览', timestamp: 2 };
    const userBubble = createMessageElement(userMsg, chat);
    if(userBubble) previewArea.appendChild(userBubble);
    
    // 4. 应用自定义CSS到预览区
    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这些【新函数】粘贴到JS功能函数定义区 ▼▼▼

async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
    }
    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// ▼▼▼ 请用这个【修正后】的函数，完整替换旧的 addNewGroup 函数 ▼▼▼
async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分组名不能为空！');
        return;
    }

    // 【核心修正】在添加前，先检查分组名是否已存在
    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
        alert(`分组 "${name}" 已经存在了，换个名字吧！`);
        return;
    }
    // 【修正结束】

    await db.qzoneGroups.add({ name });
    input.value = '';
    await renderGroupList();
}
// ▲▲▲ 替换结束 ▲▲▲

async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('确认删除', '删除分组后，该组内的好友将变为“未分组”。确定要删除吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.qzoneGroups.delete(groupId);
        // 将属于该分组的好友的 groupId 设为 null
        const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
        for (const chat of chatsToUpdate) {
            chat.groupId = null;
            await db.chats.put(chat);
            if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
        }
        await renderGroupList();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当长按消息时，显示操作菜单
 * @param {number} timestamp - 被长按消息的时间戳
 */
function showMessageActions(timestamp) {
    // 如果已经在多选模式，则不弹出菜单
    if (isSelectionMode) return;
    
    activeMessageTimestamp = timestamp;
    document.getElementById('message-actions-modal').classList.add('visible');
}

/**
 * 隐藏消息操作菜单
 */
function hideMessageActions() {
    document.getElementById('message-actions-modal').classList.remove('visible');
    activeMessageTimestamp = null;
}

// ▼▼▼ 用这个【已更新】的版本，替换旧的 openMessageEditor 函数 ▼▼▼
async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions(); 

    let contentForEditing;
    // 【核心修正】将 share_link 也加入特殊类型判断
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);

    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        } 
        // 【核心修正】处理分享链接类型的消息
        else if (message.type === 'share_link') {
            fullMessageObject.title = message.title;
            fullMessageObject.description = message.description;
            fullMessageObject.source_name = message.source_name;
            fullMessageObject.content = message.content;
        }
        contentForEditing = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
        contentForEditing = message.content;
    }

    // 【核心修改1】在这里添加 'link' 模板
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' },
        order_self: { type: 'shopping_order_self_pay', recipient: '收货人姓名', items: [{ name: '商品名', quantity: 1, price: 25.0, style: '款式', description: '描述' }], total: 25.0 },
        order_request: { type: 'shopping_order_request_pay', recipient: '收货人姓名', payer: '付款人姓名', items: [{ name: '商品名', quantity: 1, price: 25.0, style: '款式', description: '描述' }], total: 25.0 }
    };

    // 【核心修改2】在这里添加新的“链接”按钮
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.order_self)}'>购物(自付)</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.order_request)}'>购物(代付)</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '编辑消息', 
        '在此修改，或点击上方按钮使用格式模板...',
        contentForEditing, 
        'textarea',
        helpersHtml
    );

    if (newContent !== null) {
        // 【核心修正】这里调用的应该是 saveEditedMessage，而不是 saveAdvancedEditor
        await saveEditedMessage(timestampToEdit, newContent, true);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 复制消息的文本内容到剪贴板
 */
async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
        textToCopy = JSON.stringify(message.content);
    } else {
        textToCopy = String(message.content);
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '消息内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hideMessageActions();
}

// ▼▼▼ 用这个【已更新】的版本，替换旧的 createMessageEditorBlock 函数 ▼▼▼
/**
 * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
 * @param {string} initialContent - 文本框的初始内容
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // 【核心修改1】在这里添加 'link' 模板
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' },
        order_self: { type: 'shopping_order_self_pay', recipient: '收货人姓名', items: [{ name: '商品名', quantity: 1, price: 25.0, style: '款式', description: '描述' }], total: 25.0 },
        order_request: { type: 'shopping_order_request_pay', recipient: '收货人姓名', payer: '付款人姓名', items: [{ name: '商品名', quantity: 1, price: 25.0, style: '款式', description: '描述' }], total: 25.0 }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="删除此条">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <!-- 【核心修改2】在这里添加新的“链接”按钮 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    // 绑定删除按钮事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        // 确保至少保留一个编辑块
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('至少需要保留一条消息。');
        }
    });

    // 绑定格式助手按钮事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("解析格式模板失败:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新升级版】请用此函数完整替换旧的 openAdvancedMessageEditor ▼▼▼
/**
 * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
 */
function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    // 1. 【核心】在关闭旧菜单前，将需要的时间戳捕获到局部变量中
    const timestampToEdit = activeMessageTimestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    // 2. 现在可以安全地关闭旧菜单了，因为它不会影响我们的局部变量
    hideMessageActions(); 

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = ''; 

    // 3. 准备初始内容
    let initialContent;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content;
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        }
        initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        initialContent = JSON.stringify(message.content, null, 2);
    } else {
        initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);

    // 4. 【核心】动态绑定所有控制按钮的事件
    // 为了防止事件重复绑定，我们使用克隆节点的方法来清除旧监听器
    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
        const newBlock = createMessageEditorBlock();
        editorContainer.appendChild(newBlock);
        newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
        editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    // 将捕获到的时间戳，直接绑定给这一次的保存点击事件
    newSaveBtn.addEventListener('click', () => {
        saveEditedMessage(timestampToEdit); 
    });

    // 5. 最后，显示模态框
    editorModal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 解析编辑后的文本，并返回一个标准化的消息片段对象
 * @param {string} text - 用户在编辑框中输入的文本
 * @returns {object} - 一个包含 type, content, 等属性的对象
 */
function parseEditedContent(text) {
    const trimmedText = text.trim();

    // 1. 尝试解析为JSON对象（用于修复语音、转账等格式）
    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedText);
            // 必须包含 type 属性才认为是有效格式
            if (parsed.type) {
                return parsed;
            }
        } catch (e) { /* 解析失败，继续往下走 */ }
    }
    
    // 2. 尝试解析为表情包
    if (STICKER_REGEX.test(trimmedText)) {
        // 对于编辑的表情，我们暂时无法知道其`meaning`，所以只存URL
        return { type: 'sticker', content: trimmedText };
    }

    // 3. 否则，视为普通文本消息
    return { type: 'text', content: trimmedText };
}


// ▼▼▼ 请用这个【已彻底修复】的函数，完整替换你现有的 saveEditedMessage 函数 ▼▼▼

async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    let newMessages = [];

    // 判断是来自高级编辑器还是简单编辑器
    if (simpleContent !== null) {
        // --- 来自简单编辑器 ---
        const rawContent = simpleContent.trim();
        if (rawContent) {
            const parsedResult = parseEditedContent(rawContent);
            const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                // 注意：这里我们暂时不设置时间戳
                content: parsedResult.content || '',
            };
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }

            newMessages.push(newMessage);
        }
    } else {
        // --- 来自高级编辑器 ---
        const editorContainer = document.getElementById('message-editor-container');
        const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');

        for (const block of editorBlocks) {
            const textarea = block.querySelector('textarea');
            const rawContent = textarea.value.trim();
            if (!rawContent) continue;

            const parsedResult = parseEditedContent(rawContent);
            const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                // 同样，这里我们先不分配时间戳
                content: parsedResult.content || '',
            };
            
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }

            newMessages.push(newMessage);
        }
    }
    
    if (newMessages.length === 0) {
        document.getElementById('message-editor-modal').classList.remove('visible');
        return; // 如果是空消息，直接返回，不执行删除操作
    }

    // ★★★★★【核心修复逻辑就在这里】★★★★★

    // 1. 使用 splice 将旧消息替换为新消息（此时新消息还没有时间戳）
    chat.history.splice(messageIndex, 1, ...newMessages);

    // 2. 确定重新分配时间戳的起点
    // 我们从被编辑的消息的原始时间戳开始
    let reassignTimestamp = timestamp;

    // 3. 从被修改的位置开始，遍历所有后续的消息
    for (let i = messageIndex; i < chat.history.length; i++) {
        // 4. 为每一条消息（包括新插入的）分配一个新的、唯一的、连续的时间戳
        chat.history[i].timestamp = reassignTimestamp;

        // 5. 将时间戳+1，为下一条消息做准备
        reassignTimestamp++; 
    }
    // ★★★★★【修复结束】★★★★★

    await db.chats.put(chat);

    // 关闭可能打开的模态框并刷新UI
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('成功', '消息已更新！');
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当点击“…”时，显示动态操作菜单
 * @param {number} postId - 被操作的动态的ID
 */
function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
}

/**
 * 隐藏动态操作菜单
 */
function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
}

// ▼▼▼ 步骤3.2 操作1：替换 openPostEditor 函数 ▼▼▼
async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();

    // 复用创建动态的模态框
    const modal = document.getElementById('create-post-modal');
    modal.dataset.mode = 'edit'; // 设置一个编辑模式的标记
    modal.dataset.editingPostId = postIdToEdit; // 保存正在编辑的ID

    // 隐藏模式切换，因为不允许在编辑时更改动态类型
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    
    // 填充数据
    document.getElementById('post-public-text').value = post.publicText || (post.type === 'shuoshuo' ? post.content : '');
    
    // 根据动态类型显示不同的编辑区
    if (post.type === 'image_post') {
        document.getElementById('image-mode-content').classList.add('active');
        document.getElementById('text-image-mode-content').classList.remove('active');
        document.getElementById('post-image-preview-container').classList.add('visible');
        document.getElementById('post-image-preview').src = post.imageUrl;
        document.getElementById('post-image-desc-group').style.display = 'block';
        document.getElementById('post-image-description').value = post.imageDescription;
    } else if (post.type === 'text_image') {
        document.getElementById('image-mode-content').classList.remove('active');
        document.getElementById('text-image-mode-content').classList.add('active');
        document.getElementById('post-hidden-text').value = post.hiddenContent;
    } else { // 说说
        document.getElementById('image-mode-content').classList.remove('active');
        document.getElementById('text-image-mode-content').classList.remove('active');
    }
    
    // ★★★★★【核心修改：回填评论开关的状态】★★★★★
    document.getElementById('post-comments-toggle').checked = post.areCommentsVisible !== false;

    modal.classList.add('visible');
}
// ▲▲▲ 步骤3.2 操作1 替换结束 ▲▲▲


/**
 * 保存编辑后的动态
 * @param {number} postId - 要保存的动态ID
 * @param {string} newRawContent - 从编辑器获取的新内容
 */
async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();
    
    // 尝试解析为JSON，如果失败，则认为是纯文本（说说）
    try {
        const parsed = JSON.parse(trimmedContent);
        // 更新帖子属性
        post.type = parsed.type || 'image_post';
        post.publicText = parsed.publicText || '';
        post.imageUrl = parsed.imageUrl || '';
        post.imageDescription = parsed.imageDescription || '';
        post.hiddenContent = parsed.hiddenContent || '';
        post.content = ''; // 清空旧的说说内容字段
    } catch (e) {
        // 解析失败，认为是说说
        post.type = 'shuoshuo';
        post.content = trimmedContent;
        // 清空其他类型的字段
        post.publicText = '';
        post.imageUrl = '';
        post.imageDescription = '';
        post.hiddenContent = '';
    }
    
    await db.qzonePosts.put(post);
    await renderQzonePosts(); // 重新渲染列表
    await showCustomAlert('成功', '动态已更新！');
}

/**
 * 复制动态内容
 */
async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;
    
    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（无文字内容）";
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '动态内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hidePostActions();
}

// ▼▼▼ 【全新】创建群聊与拉人功能核心函数 ▼▼▼
let selectedContacts = new Set();

async function openContactPickerForGroupCreate() {
    selectedContacts.clear(); // 清空上次选择

    // 【核心修复】在这里，我们为“完成”按钮明确绑定“创建群聊”的功能
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点技巧，清除掉之前可能绑定的任何其他事件（比如“添加成员”）
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    // 重新绑定正确的“创建群聊”函数
    newConfirmBtn.addEventListener('click', handleCreateGroup);

    await renderContactPicker();
    showScreen('contact-picker-screen');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 渲染联系人选择列表
 */
async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // 只选择单聊角色作为群成员候选
    const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
        return;
    }

    contacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name}</span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

/**
 * 更新“完成”按钮的计数
 */
function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    btn.textContent = `完成(${selectedContacts.size})`;
    btn.disabled = selectedContacts.size < 2; // 至少需要2个人才能创建群聊
}

/**
 * 【重构版】处理创建群聊的最终逻辑
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("创建群聊至少需要选择2个联系人。");
        return;
    }

    const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', '我们的群聊');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    
    // 遍历选中的联系人ID
    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
            // ★★★【核心重构】★★★
            // 我们现在同时存储角色的“本名”和“群昵称”
            members.push({
                id: contactId, 
                originalName: contactChat.name,   // 角色的“本名”，用于AI识别
                groupNickname: contactChat.name, // 角色的“群昵称”，用于显示和修改，初始值和本名相同
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || ''
            });
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        members: members,
        settings: {
            myPersona: '我是谁呀。',
            myNickname: '我',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
        },
        history: [],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); 
}

// ▼▼▼ 【全新】群成员管理核心函数 ▼▼▼

/**
 * 打开群成员管理屏幕
 */
function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
}

function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    chat.members.forEach(member => {
        const item = document.createElement('div');
        item.className = 'member-management-item';
        // 【核心修正】在这里，我们将显示的名称从 member.name 改为 member.groupNickname
        item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <span class="name">${member.groupNickname}</span>
            <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 从群聊中移除一个成员
 * @param {string} memberId - 要移除的成员ID
 */
async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const memberIndex = chat.members.findIndex(m => m.id === memberId);
    
    if (memberIndex === -1) return;
    
    // 安全检查，群聊至少保留2人
    if (chat.members.length <= 2) {
        alert("群聊人数不能少于2人。");
        return;
    }
    
const memberName = chat.members[memberIndex].groupNickname; // <-- 修复：使用 groupNickname
    const confirmed = await showCustomConfirm(
        '移出成员',
        `确定要将“${memberName}”移出群聊吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.members.splice(memberIndex, 1);
        await db.chats.put(chat);
        renderMemberManagementList(); // 刷新成员管理列表
        document.getElementById('chat-settings-btn').click(); // 【核心修正】模拟点击设置按钮，强制刷新整个弹窗
    }
}

/**
 * 打开联系人选择器，用于拉人入群
 */
async function openContactPickerForAddMember() {
    selectedContacts.clear(); // 清空选择
    
    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));

    // 渲染联系人列表，并自动排除已在群内的成员
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    const contacts = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的好友了。</p>';
        document.getElementById('confirm-contact-picker-btn').style.display = 'none'; // 没有人可选，隐藏完成按钮
    } else {
        document.getElementById('confirm-contact-picker-btn').style.display = 'block';
        contacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name}</span>
            `;
            listEl.appendChild(item);
        });
    }

    // 更新按钮状态并显示屏幕
    updateContactPickerConfirmButton();
    showScreen('contact-picker-screen');
}

/**
 * 处理将选中的联系人加入群聊的逻辑
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("请至少选择一个要添加的联系人。");
        return;
    }
    
    const chat = state.chats[state.activeChatId];

    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
chat.members.push({
    id: contactId,
    originalName: contactChat.name,  // <-- 修复1：使用 'originalName' 存储本名
    groupNickname: contactChat.name, // <-- 修复2：同时创建一个初始的 'groupNickname'
    avatar: contactChat.settings.aiAvatar || defaultAvatar,
    persona: contactChat.settings.aiPersona,
    avatarFrame: contactChat.settings.aiAvatarFrame || ''
});
        }
    }

    await db.chats.put(chat);
    openMemberManagementScreen(); // 返回到群成员管理界面
    renderGroupMemberSettings(chat.members); // 同时更新聊天设置里的头像
}

/**
 * 【重构版】在群聊中创建一个全新的虚拟成员
 */
async function createNewMemberInGroup() {
    const name = await showCustomPrompt('创建新成员', '请输入新成员的名字 (这将是TA的“本名”，不可更改)');
    if (!name || !name.trim()) return;

    // 检查本名是否已在群内存在
    const chat = state.chats[state.activeChatId];
    if (chat.members.some(m => m.originalName === name.trim())) {
        alert(`错误：群内已存在名为“${name.trim()}”的成员！`);
        return;
    }

    const persona = await showCustomPrompt('设置人设', `请输入“${name}”的人设`, '', 'textarea');
    if (persona === null) return; 

    // ★★★【核心重构】★★★
    // 为新创建的NPC也建立双重命名机制
    const newMember = {
        id: 'npc_' + Date.now(),
        originalName: name.trim(),   // 新成员的“本名”
        groupNickname: name.trim(), // 新成员的初始“群昵称”
        avatar: defaultGroupMemberAvatar,
        persona: persona,
        avatarFrame: ''
    };

    chat.members.push(newMember);
    await db.chats.put(chat);

    renderMemberManagementList();
    renderGroupMemberSettings(chat.members); 

    alert(`新成员“${name}”已成功加入群聊！`);
}

// ▼▼▼ 【全新】外卖请求倒计时函数 ▼▼▼
function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
        const now = Date.now();
        const distance = endTime - now;

        if (distance < 0) {
            clearInterval(timerId);
            element.innerHTML = '<span>已</span><span>超</span><span>时</span>';
            return;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        
        const minStr = String(minutes).padStart(2, '0');
        const secStr = String(seconds).padStart(2, '0');

        element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
}

function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
        clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    const originalMessage = chat.history[messageIndex];
    
    // 如果选择付款，先检查钱包余额并扣费
    if (choice === 'paid') {
        const amount = originalMessage.amount;
        if (!amount || isNaN(amount)) {
            alert('订单金额无效，无法完成支付');
            return;
        }
        
        // 检查钱包余额并扣费
        const deductSuccess = await checkAndDeductWalletBalance(
            amount, 
            `为${originalMessage.senderName}外卖代付：${originalMessage.productInfo}`, 
            'waimai_payment'
        );
        
        if (!deductSuccess) {
            return; // 余额不足，终止支付
        }
    }

    // 1. 更新原始消息的状态
    originalMessage.status = choice;
    
    // 【核心修正】记录支付者，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是用户付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 2. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 3. 保存更新到数据库并刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);  
}

let videoCallState = {
    isActive: false,       
    isAwaitingResponse: false, 
    isGroupCall: false,      
    activeChatId: null,    
    initiator: null,       
    startTime: null,       
    participants: [],      
    isUserParticipating: true,
    // --- 【核心新增】---
    callHistory: [], // 用于存储通话中的对话历史
    preCallContext: "", // 用于存储通话前的聊天摘要
    callType: "video" // 通话类型：'video' 或 'voice'
};

let callTimerInterval = null; // 用于存储计时器的ID

// ▼▼▼ 语音识别相关变量 ▼▼▼
let voiceRecognitionState = {
    isEnabled: false,        // 语音识别开关状态
    isListening: false,      // 是否正在监听
    recognition: null,       // Web Speech API 识别器实例
    isProcessing: false,     // 是否正在处理语音
    messageQueue: [],        // 消息队列，用于缓存AI处理期间的新消息
    isVoiceLocked: false     // 语音锁定模式：AI处理期间是否禁用语音识别
};

// ▼▼▼ 自动语音播放相关变量 ▼▼▼
let autoVoiceState = {
    isEnabled: false,        // 自动语音播放开关状态
    isPlaying: false,        // 当前是否有语音正在播放
    currentAudio: null       // 当前播放的音频对象
};

// ▼▼▼ 语音通话页面的语音识别功能 ▼▼▼

/**
 * 初始化语音识别功能
 */
function initVoiceRecognition() {
    console.log('🖤 初始化语音通话页面的语音识别功能');
    
    // 绑定语音识别开关事件
    const voiceSwitch = document.getElementById('voice-recognition-switch');
    if (voiceSwitch) {
        voiceSwitch.addEventListener('change', handleVoiceRecognitionToggle);
        console.log('✅ 语音识别开关事件绑定成功');
    } else {
        console.error('❌ 找不到语音识别开关元素');
    }
    
    // 绑定自动语音播放开关事件
    const autoVoiceSwitch = document.getElementById('auto-voice-switch');
    if (autoVoiceSwitch) {
        autoVoiceSwitch.addEventListener('change', handleAutoVoiceToggle);
        console.log('✅ 自动语音播放开关事件绑定成功');
    } else {
        console.error('❌ 找不到自动语音播放开关元素');
    }
    
    // 绑定语音锁定开关事件
    const voiceLockSwitch = document.getElementById('voice-lock-switch');
    if (voiceLockSwitch) {
        voiceLockSwitch.addEventListener('change', handleVoiceLockToggle);
        console.log('✅ 语音锁定开关事件绑定成功');
    } else {
        console.error('❌ 找不到语音锁定开关元素');
    }
    
    // 绑定控制面板点击展开/收起事件
    const controlsPanel = document.getElementById('voice-recognition-controls');
    if (controlsPanel) {
        controlsPanel.addEventListener('click', toggleControlsPanel);
        console.log('✅ 控制面板展开/收起事件绑定成功');
    } else {
        console.error('❌ 找不到控制面板元素');
    }
}

/**
 * 处理语音识别开关切换
 */
function handleVoiceRecognitionToggle(event) {
    const isEnabled = event.target.checked;
    voiceRecognitionState.isEnabled = isEnabled;
    
    console.log(`🖤 语音识别开关: ${isEnabled ? '开启' : '关闭'}`);
    
    // 显示/隐藏控制面板
    const controlsPanel = document.getElementById('voice-recognition-controls');
    if (controlsPanel) {
        controlsPanel.style.display = isEnabled ? 'block' : 'none';
        if (isEnabled) {
            // 初始化为收起状态
            controlsPanel.classList.remove('expanded');
        }
    }
    
    if (isEnabled) {
        startContinuousVoiceRecognition();
    } else {
        stopContinuousVoiceRecognition();
    }
}

/**
 * 处理自动语音播放开关切换
 */
function handleAutoVoiceToggle(event) {
    const isEnabled = event.target.checked;
    autoVoiceState.isEnabled = isEnabled;
    
    console.log(`🎵 自动语音播放开关: ${isEnabled ? '开启' : '关闭'}`);
    
    if (isEnabled) {
        // 检查必要的配置
        const minimaxGroupId = localStorage.getItem('minimaxGroupId');
        const minimaxApiKey = localStorage.getItem('minimaxApiKey');
        
        if (!minimaxGroupId || !minimaxApiKey) {
            alert('请先在API设置中配置Minimax Group ID和API Key才能使用自动语音播放功能');
            document.getElementById('auto-voice-switch').checked = false;
            autoVoiceState.isEnabled = false;
            return;
        }
    }
}

/**
 * 处理自动语音播放
 */
async function handleAutoVoicePlayback(bubbleElement, text) {
    if (!autoVoiceState.isEnabled) return;
    
    // 获取当前聊天的语音设置
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;
    
    const minimaxVoiceId = chat.settings?.minimaxVoiceId;
    const minimaxGroupId = localStorage.getItem('minimaxGroupId');
    const minimaxApiKey = localStorage.getItem('minimaxApiKey');
    
    // 检查必要的配置
    if (!minimaxVoiceId || !minimaxGroupId || !minimaxApiKey) {
        console.log('🎵 自动语音播放跳过：缺少必要的配置');
        return;
    }
    
    console.log('🎵 开始自动语音播放:', { textLength: text.length, voiceId: minimaxVoiceId });
    
    // 调用现有的语音播放函数
    try {
        await playVoiceMessageWithControl(bubbleElement, text, minimaxVoiceId);
    } catch (error) {
        console.error('🎵 自动语音播放失败:', error);
    }
}

/**
 * 带控制功能的语音播放函数
 */
async function playVoiceMessageWithControl(bubbleElement, text, voiceId) {
    console.log('🎵 playVoiceMessageWithControl 函数被调用了！', { text, voiceId });
    const minimaxGroupId = localStorage.getItem('minimaxGroupId') || '';
    const minimaxApiKey = localStorage.getItem('minimaxApiKey') || '';
    
    if (!minimaxGroupId || !minimaxApiKey) {
        alert('请在API设置中填写 Minimax Group ID 和 API Key');
        return;
    }
    
    // 如果没有指定voiceId，尝试使用默认语音模型
    if (!voiceId) {
        const defaultVoiceModel = localStorage.getItem('minimaxVoiceModel') || '';
        if (!defaultVoiceModel) {
            alert('该角色未设置语音ID，且未配置默认语音模型。请在API设置中拉取并选择默认语音模型。');
            return;
        }
        voiceId = defaultVoiceModel;
        console.log('使用默认语音模型:', voiceId);
    }
    
    // 🔥 过滤掉【】内的文本（心理描写、旁白等）
    const originalText = text;
    text = filterBracketedText(text);
    
    if (!text || text.trim().length === 0) {
        console.log('⚠️ 过滤后文本为空，跳过语音生成');
        return;
    }
    
    if (originalText !== text) {
        console.log('📝 已过滤【】内容，原始长度:', originalText.length, '→ 过滤后长度:', text.length);
    }

    // 如果当前正在播放同一个语音条，则暂停/继续
    if (autoVoiceState.currentAudio && bubbleElement === currentPlayingElement) {
        if (autoVoiceState.currentAudio.paused) {
            // 继续播放
            autoVoiceState.currentAudio.play();
            bubbleElement.classList.add('playing');
            console.log('🎵 语音继续播放');
        } else {
            // 暂停播放
            autoVoiceState.currentAudio.pause();
            bubbleElement.classList.remove('playing');
            console.log('🎵 语音暂停播放');
        }
        return;
    }

    // 🔥 修复：停止所有正在播放的音频（包括普通播放和通话播放）
    // 停止通话播放的语音
    if (autoVoiceState.currentAudio) {
        autoVoiceState.currentAudio.pause();
        autoVoiceState.currentAudio.currentTime = 0;
        autoVoiceState.isPlaying = false;
    }
    
    // 停止普通播放的语音
    if (typeof voiceAudio !== 'undefined' && voiceAudio) {
        voiceAudio.pause();
        voiceAudio.currentTime = 0;
    }
    
    if (currentPlayingElement) {
        currentPlayingElement.classList.remove('playing', 'loading');
    }

    currentPlayingElement = bubbleElement;

    try {
        bubbleElement.classList.add('loading');

        let audioUrl = null;
        let fromCache = false;

        if (window.VoiceStorageAPI) {
            try {
                audioUrl = await window.VoiceStorageAPI.getVoiceURL(text, voiceId);
                if (audioUrl) {
                    fromCache = true;
                    console.log('使用语音缓存:', { textLength: text.length, voiceId });
                }
            } catch (error) {
                console.error('检查语音缓存失败:', error);
            }
        }

        if (!audioUrl) {
            console.log('语音缓存未命中，调用API生成语音');
            
            const selectedVoiceModel = localStorage.getItem('minimaxVoiceModel') || 'speech-01';
            console.log('使用语音模型:', selectedVoiceModel, '语音ID:', voiceId);
            
            const apiUrl = `https://api.minimax.chat/v1/text_to_speech?GroupId=${minimaxGroupId}`;
            const requestBody = {
                "voice_id": voiceId,
                "text": text,
                "model": selectedVoiceModel,
                "speed": 1.0,
                "vol": 1.0,
                "pitch": 0
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${minimaxApiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            const contentType = response.headers.get('content-type') || '';
            
            if (!response.ok || contentType.includes('application/json')) {
                let errorMsg = `语音服务错误 (状态码: ${response.status})`;
                try {
                    const errorData = await response.json();
                    console.error('Minimax TTS API 返回错误:', errorData);
                    
                    if (errorData && errorData.base_resp && errorData.base_resp.status_msg) {
                        const statusMsg = errorData.base_resp.status_msg;
                        const statusCode = errorData.base_resp.status_code;
                        
                        if (statusCode === 1008 || statusMsg === 'insufficient balance') {
                            errorMsg = '💰 Minimax 账户余额不足，请前往官网充值后继续使用语音功能';
                        } else if (statusCode === 1004) {
                            errorMsg = '🔑 Minimax API 密钥无效，请检查配置';
                        } else if (statusCode === 1001) {
                            errorMsg = '⚠️ Minimax API 请求参数错误';
                        } else {
                            errorMsg += `: ${statusMsg}`;
                        }
                    } else if (errorData && errorData.error) {
                        errorMsg += `: ${errorData.error}`;
                    }
                } catch (e) {
                    const errorText = await response.text();
                    errorMsg += `: ${errorText}`;
                }
                throw new Error(errorMsg);
            }

            const audioBlob = await response.blob();
            
            if (!audioBlob || !audioBlob.type.startsWith('audio/')) {
                throw new Error(`服务器返回了非预期的内容类型: ${audioBlob.type}`);
            }

            if (window.VoiceStorageAPI) {
                window.VoiceStorageAPI.storeVoice(audioBlob, text, voiceId, {
                    model: selectedVoiceModel,
                    apiSource: "minimax",
                    generatedAt: new Date().toISOString()
                }).then(() => {
                    console.log('语音已保存到缓存:', { textLength: text.length, voiceId, model: selectedVoiceModel });
                }).catch(error => {
                    console.error('语音缓存保存失败:', error);
                });
            }

            audioUrl = URL.createObjectURL(audioBlob);
        }

        // 创建新的Audio对象
        const audio = new Audio();
        audio.preload = 'auto';
        
        // 设置错误处理
        audio.onerror = (e) => {
            console.error('音频加载错误:', e);
            throw new Error('音频文件加载失败，可能是格式不支持或文件损坏');
        };
        
        audio.onended = () => {
            if (currentPlayingElement === bubbleElement) {
                currentPlayingElement.classList.remove('playing');
                currentPlayingElement = null;
            }
            autoVoiceState.isPlaying = false;
            autoVoiceState.currentAudio = null;
            
            // 语音播放结束后，恢复语音识别功能
            resumeVoiceRecognitionAfterPlayback();
            
            // 清理临时URL以释放内存
            if (audioUrl && audioUrl.startsWith('blob:')) {
                URL.revokeObjectURL(audioUrl);
            }
        };
        
        audio.onpause = () => {
            autoVoiceState.isPlaying = false;
            // 语音暂停时，恢复语音识别功能
            resumeVoiceRecognitionAfterPlayback();
        };
        
        audio.onplay = () => {
            autoVoiceState.isPlaying = true;
            // 语音开始播放时，暂停语音识别功能
            pauseVoiceRecognitionDuringPlayback();
        };
        
        // 验证音频URL有效性
        if (!audioUrl || audioUrl === 'null' || audioUrl === 'undefined') {
            throw new Error('音频URL无效');
        }
        
        audio.src = audioUrl;
        
        // 等待音频加载完成再播放
        await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('音频加载超时'));
            }, 10000); // 10秒超时
            
            audio.oncanplaythrough = () => {
                clearTimeout(timeout);
                resolve();
            };
            
            audio.onerror = (e) => {
                clearTimeout(timeout);
                reject(new Error('音频加载失败'));
            };
            
            audio.load(); // 强制加载
        });

        await audio.play();

        // 保存当前播放的音频对象
        autoVoiceState.currentAudio = audio;

        bubbleElement.classList.remove('loading');
        bubbleElement.classList.add('playing');

        console.log(`语音播放开始 (${fromCache ? '缓存' : 'API'}):`, {
            textLength: text.length,
            voiceId,
            fromCache
        });

    } catch (error) {
        console.error('语音播放失败:', error);
        
        bubbleElement.classList.remove('loading', 'playing');
        currentPlayingElement = null;
        autoVoiceState.isPlaying = false;
        autoVoiceState.currentAudio = null;
        
        alert(`语音播放失败: ${error.message}`);
    }
}

/**
 * 语音播放期间暂停语音识别
 * 支持谷歌识别和智谱识别
 */
function pauseVoiceRecognitionDuringPlayback() {
    console.log('🎵 [播放]语音开始播放，暂停语音识别', {
        isListening: voiceRecognitionState.isListening,
        hasRecognition: !!voiceRecognitionState.recognition
    });
    
    // 对于谷歌识别：直接停止
    if (voiceRecognitionState.isListening && voiceRecognitionState.recognition) {
        console.log('🎵 [谷歌]停止语音识别');
        voiceRecognitionState.recognition.stop();
    }
    
    // 对于智谱识别：通过isPlaying标志间接暂停（主循环会检测到并等待）
    // autoVoiceState.isPlaying 已经在调用此函数前设置为true了
    // 智谱识别的循环逻辑会自动等待播放完成
}

/**
 * 语音播放结束后恢复语音识别
 * 🔥 修复：简化条件判断，播放结束后立即尝试恢复识别
 */
function resumeVoiceRecognitionAfterPlayback() {
    console.log('🎵 语音播放结束/暂停，检查是否需要恢复语音识别', {
        isEnabled: voiceRecognitionState.isEnabled,
        isListening: voiceRecognitionState.isListening,
        isProcessing: voiceRecognitionState.isProcessing,
        isPlaying: autoVoiceState.isPlaying
    });
    
    // 只检查：1) 语音识别开关是否打开 2) 当前是否没有在监听 3) 当前是否没有其他音频在播放
    if (voiceRecognitionState.isEnabled && !voiceRecognitionState.isListening && !autoVoiceState.isPlaying) {
        console.log('✅ 满足条件，立即恢复语音识别');
        
        // 使用短暂延迟确保状态同步
        setTimeout(() => {
            // 再次检查状态，避免竞态条件
            if (voiceRecognitionState.isEnabled && !voiceRecognitionState.isListening && !autoVoiceState.isPlaying) {
                console.log('🎤 [恢复]启动语音识别');
                startContinuousVoiceRecognition();
            } else {
                console.log('⚠️ 状态已变化，取消恢复语音识别', {
                    isEnabled: voiceRecognitionState.isEnabled,
                    isListening: voiceRecognitionState.isListening,
                    isPlaying: autoVoiceState.isPlaying
                });
            }
        }, 100);
    } else {
        console.log('❌ 不满足恢复条件，跳过恢复语音识别');
    }
}

/**
 * 处理语音锁定开关切换
 */
function handleVoiceLockToggle(event) {
    const isLocked = event.target.checked;
    voiceRecognitionState.isVoiceLocked = isLocked;
    
    console.log(`🔒 语音锁定模式: ${isLocked ? '开启' : '关闭'}`);
    
    if (isLocked) {
        // 开启锁定：如果当前正在监听，立即停止
        if (voiceRecognitionState.isListening) {
            console.log('🔒 开启语音锁定，停止语音监听');
            if (voiceRecognitionState.recognition) {
                voiceRecognitionState.recognition.stop();
            }
        }
    } else {
        // 关闭锁定：立即尝试重新启动语音识别（如果语音识别是开启状态且当前没有在监听）
        console.log('🔓 关闭语音锁定，检查是否需要重新启动语音识别');
        
        // 使用短暂延迟确保状态同步
        setTimeout(() => {
            if (voiceRecognitionState.isEnabled && !voiceRecognitionState.isListening && !autoVoiceState.isPlaying) {
                console.log('🔓 重新启动语音识别');
                startContinuousVoiceRecognition();
            } else if (voiceRecognitionState.isListening) {
                console.log('🔓 语音识别已在运行中');
            } else if (!voiceRecognitionState.isEnabled) {
                console.log('🔓 语音识别未开启，无需启动');
            } else if (autoVoiceState.isPlaying) {
                console.log('🎵 语音播放中，暂停语音识别');
            }
        }, 100); // 减少延迟时间，提高响应速度
    }
}

/**
 * 切换控制面板展开/收起状态
 */
function toggleControlsPanel(event) {
    // 防止点击内部元素时触发（但允许点击麦克风图标区域）
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'BUTTON' || event.target.classList.contains('queue-message-delete')) {
        return;
    }
    
    const controlsPanel = document.getElementById('voice-recognition-controls');
    if (controlsPanel) {
        const wasExpanded = controlsPanel.classList.contains('expanded');
        controlsPanel.classList.toggle('expanded');
        console.log(`📋 控制面板: ${controlsPanel.classList.contains('expanded') ? '展开' : '收起'}`);
        
        // 如果是收起状态，确保面板完全隐藏
        if (wasExpanded) {
            // 延迟隐藏，等待动画完成
            setTimeout(() => {
                if (!controlsPanel.classList.contains('expanded')) {
                    // 面板仍然是收起状态，确保内容不可见
                }
            }, 300);
        }
    }
}

// 全局保存音频流，避免重复创建
let globalAudioStream = null;

/**
 * 使用智谱API进行语音识别（录音+上传）
 */
async function startZhipuApiVoiceRecognition() {
    console.log('🎙️ 开始智谱API语音识别（智能静音检测模式）');
    
    // 🔥 关键修复：如果正在播放语音，不进行录音（和谷歌识别行为一致）
    if (autoVoiceState.isPlaying) {
        console.log('⏸️ [智谱]语音播放中，跳过本次录音');
        return null;
    }
    
    try {
        // 检查API配置
        const apiKey = localStorage.getItem('zhipu-speech-api-key');
        if (!apiKey) {
            await showCustomAlert('配置错误', '请先在API设置中配置智谱语音识别的API密钥');
            return null;
        }
        
        // 复用已有的音频流，或创建新的
        if (!globalAudioStream || !globalAudioStream.active) {
            console.log('🎤 获取新的麦克风音频流');
            globalAudioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        } else {
            console.log('🎤 复用现有的麦克风音频流');
        }
        
        // 创建音频分析器用于检测音量
        const volumeAudioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = volumeAudioContext.createAnalyser();
        const microphone = volumeAudioContext.createMediaStreamSource(globalAudioStream);
        microphone.connect(analyser);
        analyser.fftSize = 512;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        // 创建MediaRecorder进行录音
        const mediaRecorder = new MediaRecorder(globalAudioStream, {
            mimeType: 'audio/webm;codecs=opus'
        });
        
        const audioChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                audioChunks.push(event.data);
            }
        };
        
        // 启动录音
        mediaRecorder.start();
        voiceRecognitionState.isListening = true;
        
        // 🎯 显示语音状态：如果队列中有待处理消息，显示队列信息；否则显示"识别中..."
        const queueLength = voiceRecognitionState.messageQueue.length;
        const isProcessing = voiceRecognitionState.isProcessing;
        console.log(`🎤 [智谱]录音开始 - 队列长度: ${queueLength}, AI处理中: ${isProcessing}`);
        
        if (queueLength > 0) {
            console.log(`🎤 [智谱]显示队列状态: 等待处理: ${queueLength} 条消息`);
            showVoiceRecognitionStatus(true, `等待处理: ${queueLength} 条消息`);
        } else {
            console.log(`🎤 [智谱]显示识别状态: 识别中...`);
            showVoiceRecognitionStatus(true); // 只显示"识别中..."，不显示额外文字
        }
        
        // 🔥 智能静音检测（优化版：支持长时间连续说话）
        const SILENCE_THRESHOLD = 15;      // 静音音量阈值（0-255）
        const SILENCE_DURATION = 2500;     // 连续静音多久算结束（毫秒）- 增加到2.5秒，给用户更多思考时间
        const MAX_RECORDING_TIME = 60000;  // 最长录音时间（60秒）- 支持长段语音输入
        const MIN_RECORDING_TIME = 500;    // 最短录音时间（0.5秒）
        
        let silenceStart = null;
        let recordingStartTime = Date.now();
        let hasSpeech = false; // 是否检测到过语音
        
        console.log('🎤 开始智能录音，等待语音输入...');
        
        // 检测音量的循环
        await new Promise((resolve) => {
            const checkVolume = () => {
                const now = Date.now();
                const recordingTime = now - recordingStartTime;
                
                // 获取当前音量
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                
                // 检测是否有语音
                if (average > SILENCE_THRESHOLD) {
                    hasSpeech = true;
                    silenceStart = null; // 重置静音计时
                    // console.log('🗣️ 检测到语音，音量:', average.toFixed(2));
                } else {
                    // 静音状态
                    if (hasSpeech && !silenceStart) {
                        silenceStart = now;
                        console.log('🤫 开始静音，音量:', average.toFixed(2));
                    }
                }
                
                // 判断是否应该停止录音
                const shouldStop = 
                    (hasSpeech && silenceStart && (now - silenceStart) >= SILENCE_DURATION) || // 说完话后静音
                    (recordingTime >= MAX_RECORDING_TIME); // 超过最长时间
                
                if (shouldStop && recordingTime >= MIN_RECORDING_TIME) {
                    console.log('✅ 录音结束，原因:', 
                        silenceStart ? `静音${((now - silenceStart) / 1000).toFixed(1)}秒` : '达到最长时间',
                        ', 总时长:', (recordingTime / 1000).toFixed(1), '秒');
                    resolve();
                } else {
                    // 继续检测
                    setTimeout(checkVolume, 50); // 每50ms检测一次
                }
            };
            
            checkVolume();
        });
        
        // 停止录音（但不关闭音频流，下次继续用）
        mediaRecorder.stop();
        
        // 关闭音频分析器
        microphone.disconnect();
        analyser.disconnect();
        volumeAudioContext.close();
        
        // 等待录音数据收集完成
        const audioBlob = await new Promise((resolve) => {
            mediaRecorder.onstop = () => {
                const blob = new Blob(audioChunks, { type: 'audio/webm' });
                resolve(blob);
            };
        });
        
        console.log('📼 录音完成，音频大小:', audioBlob.size, 'bytes');
        
        // 检查音频大小，如果太小说明可能没有录到声音（静默返回，像Google一样）
        if (audioBlob.size < 1000) { // 小于1KB
            console.log('🔇 未检测到语音，继续监听...');
            hideVoiceRecognitionStatus();
            return null;
        }
        
        // 不显示"正在识别"提示，保持简洁，和谷歌一样
        
        // 从配置中获取端点和模型，如果没有则使用默认值
        const zhipuSettings = JSON.parse(localStorage.getItem('zhipuSpeechSettings') || '{}');
        let apiEndpoint = zhipuSettings.endpoint || 'https://open.bigmodel.cn/api/paas/v4';
        const selectedModel = zhipuSettings.model || 'glm-4-voice'; // 使用用户选择的模型
        
        console.log('🎤 使用模型:', selectedModel);
        
        // 将WebM转换为WAV格式（智谱API只支持wav和mp3）
        console.log('🔄 开始将WebM音频转换为WAV格式...');
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await audioBlob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        console.log('📊 原始音频信息 - 声道数:', audioBuffer.numberOfChannels, '采样率:', audioBuffer.sampleRate);
        
        // 转换为WAV格式（单声道16kHz）
        const wavBlob = audioBufferToWav(audioBuffer);
        console.log('✅ 音频转换为WAV完成 - 大小:', wavBlob.size, 'bytes, 格式: 单声道16kHz 16位PCM');
        
        // 判断使用哪种API方式（和测试语音识别完全一样的逻辑）
        let response;
        const isVoiceModel = selectedModel.toLowerCase().includes('voice');
        
        if (isVoiceModel) {
            // GLM-4-Voice: 使用 /chat/completions 端点，只让它转录不回复
            console.log('✅ 使用GLM-4-Voice模型进行语音识别（纯转录模式）');
            
            const chatEndpoint = apiEndpoint.includes('/audio/transcriptions')
                ? apiEndpoint.replace('/audio/transcriptions', '/chat/completions')
                : apiEndpoint.replace(/\/$/, '') + '/chat/completions';
            
            console.log('🎤 使用语音对话端点:', chatEndpoint);
            
            // 将音频转为base64
            const base64Audio = await blobToBase64(wavBlob);
            
            response = await fetch(chatEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: selectedModel,
                    messages: [{
                        role: 'user',
                        content: [{
                            type: 'audio',
                            audio: base64Audio
                        }]
                    }],
                    // 让它只转录，不生成额外回复
                    temperature: 0.1,
                    max_tokens: 100
                })
            });
            
        } else {
            // glm-asr 或其他: 使用 /audio/transcriptions 端点
            console.log('✅ 使用ASR模型进行语音识别:', selectedModel);
            
            const audioEndpoint = apiEndpoint.includes('/chat/completions') 
                ? apiEndpoint.replace('/chat/completions', '/audio/transcriptions')
                : apiEndpoint.replace(/\/$/, '') + '/audio/transcriptions';
            
            console.log('🎤 使用语音识别端点:', audioEndpoint);
            
            const formData = new FormData();
            formData.append('file', wavBlob, 'audio.wav');
            formData.append('model', selectedModel || 'glm-asr');
            
            console.log('📋 FormData内容:');
            console.log('  - file: audio.wav, 大小:', wavBlob.size);
            console.log('  - model:', selectedModel || 'glm-asr');
            
            response = await fetch(audioEndpoint, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`
                },
                body: formData
            });
        }
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API请求失败 (${response.status}): ${errorText}`);
        }
        
        const result = await response.json();
        console.log('✅ 智谱API识别结果:', result);
        
        // 提取识别的文本（GLM-4-Voice返回对话格式）
        let recognizedText = '';
        
        // 标准对话格式
        if (result.choices && result.choices[0] && result.choices[0].message) {
            const message = result.choices[0].message;
            // GLM-4-Voice的文本在message.content中
            if (typeof message.content === 'string') {
                recognizedText = message.content;
            } else if (Array.isArray(message.content)) {
                // 如果content是数组，提取text类型的内容
                const textContent = message.content.find(c => c.type === 'text');
                if (textContent && textContent.text) {
                    recognizedText = textContent.text;
                }
            }
        }
        // 兼容其他可能的ASR格式
        else if (result.text) {
            recognizedText = result.text;
        } else if (result.transcription) {
            recognizedText = result.transcription;
        } else if (result.data && result.data.text) {
            recognizedText = result.data.text;
        }
        
        if (recognizedText && recognizedText.trim()) {
            const trimmedText = recognizedText.trim();
            
            // 🎯 显示识别结果（模拟谷歌的中间结果显示）
            showVoiceRecognitionStatus(true, trimmedText);
            
            console.log('🎯 识别到的文本:', trimmedText);
            
            // 返回文本，在外部处理hide逻辑（和谷歌保持一致）
            return trimmedText;
        } else {
            // 没有识别到内容，静默返回null（像Google一样不报错）
            console.log('⚠️ 未识别到语音内容，继续监听...');
            hideVoiceRecognitionStatus();
            return null;
        }
        
    } catch (error) {
        console.error('❌ 智谱API语音识别失败:', error);
        hideVoiceRecognitionStatus();
        
        // 只在关键错误时显示提示
        if (error.name === 'NotAllowedError') {
            // 麦克风权限错误 - 需要提示用户
            await showCustomAlert('权限错误', '请允许浏览器访问麦克风');
        } else if (error.message && error.message.includes('401')) {
            // API密钥错误 - 需要提示用户
            await showCustomAlert('API错误', 'API密钥无效，请检查配置');
        } else if (error.message && error.message.includes('network')) {
            // 网络错误 - 需要提示用户
            await showCustomAlert('网络错误', '无法连接到智谱API服务');
        } else {
            // 其他错误（如音频处理失败、识别超时等）- 静默处理，继续下一次
            console.log('⚠️ 识别过程出错，继续监听...', error.message);
        }
        
        return null;
    } finally {
        voiceRecognitionState.isListening = false;
    }
}

/**
 * 开始连续语音识别
 */
async function startContinuousVoiceRecognition() {
    // 检查是否在语音通话中
    if (!videoCallState.isActive || videoCallState.callType !== 'voice') {
        console.log('⚠️ 不在语音通话中，无法启动语音识别');
        return;
    }
    
    // 检查是否有语音正在播放
    if (autoVoiceState.isPlaying) {
        console.log('🎵 语音正在播放中，暂停语音识别');
        return;
    }
    
    // 检查识别方式
    const recognitionMethod = localStorage.getItem('voice-recognition-method') || 'google';
    
    // 如果选择智谱API识别
    if (recognitionMethod === 'zhipu') {
        console.log('🎙️ 使用智谱API进行语音识别');
    
    // 检查智谱API配置
    const zhipuApiKey = localStorage.getItem('zhipu-speech-api-key');
    if (!zhipuApiKey) {
        await showCustomAlert('配置错误', '请先在API设置中配置智谱语音识别的API密钥');
        // 关闭开关
        document.getElementById('voice-recognition-switch').checked = false;
        voiceRecognitionState.isEnabled = false;
        return;
        }
        
        // 🔥 使用智谱API进行连续识别（改进版：AI处理时和音频播放时暂停录音）
        // 关键修复：AI处理时或音频播放时不录音（避免噪音干扰），完成后自动恢复录音
        (async function continuousZhipuRecognition() {
            while (voiceRecognitionState.isEnabled) {
                // 🎤 开始录音识别前，检查是否有音频正在播放
                if (autoVoiceState.isPlaying) {
                    console.log('⏸️ [智谱]音频播放中，等待播放完成...');
                    
                    // 等待播放完成
                    while (autoVoiceState.isPlaying) {
                        if (!voiceRecognitionState.isEnabled) {
                            console.log('❌ [智谱]识别已关闭，退出等待');
                            break;
                        }
                        await new Promise(resolve => setTimeout(resolve, 100)); // 每100ms检查一次
                    }
                    
                    console.log('✅ [智谱]播放完成，准备开始录音');
                }
                
                // 再次检查识别是否仍然开启
                if (!voiceRecognitionState.isEnabled) {
                    break;
                }
                
                // 🎤 开始录音识别
                const recognizedText = await startZhipuApiVoiceRecognition();
                
                if (recognizedText) {
                    console.log('🖤 智谱API识别结果:', recognizedText);
                    hideVoiceRecognitionStatus();
                    
                    // ⏸️ 处理识别结果（同步执行队列逻辑）
                    handleVoiceRecognitionResult(recognizedText);
                    
                    // 🔒 关键修复：根据"处理时锁定"开关决定是否等待
                    // - 如果开启了isVoiceLocked：AI处理期间暂停录音，等待处理完成
                    // - 如果未开启isVoiceLocked：AI处理时继续录音，新消息加入队列
                    // - 无论是否锁定，音频播放时都要等待（避免噪音干扰）
                    const shouldWaitForProcessing = voiceRecognitionState.isVoiceLocked && 
                                                   (voiceRecognitionState.isProcessing || voiceRecognitionState.messageQueue.length > 0);
                    const shouldWaitForPlayback = autoVoiceState.isPlaying;
                    
                    if (shouldWaitForProcessing || shouldWaitForPlayback) {
                        console.log('⏸️ [智谱]暂停录音等待完成...', {
                            isVoiceLocked: voiceRecognitionState.isVoiceLocked,
                            isProcessing: voiceRecognitionState.isProcessing,
                            queueLength: voiceRecognitionState.messageQueue.length,
                            isPlaying: autoVoiceState.isPlaying,
                            waitReason: shouldWaitForProcessing ? '处理时锁定开启' : '音频播放中'
                        });
                        
                        // 等待处理完成或播放完成（轮询检查）
                        while ((voiceRecognitionState.isVoiceLocked && (voiceRecognitionState.isProcessing || voiceRecognitionState.messageQueue.length > 0)) || 
                               autoVoiceState.isPlaying) {
                            if (!voiceRecognitionState.isEnabled) {
                                console.log('❌ [智谱]识别已关闭，退出等待');
                                break;
                            }
                            await new Promise(resolve => setTimeout(resolve, 100)); // 每100ms检查一次
                        }
                        
                        console.log('✅ [智谱]等待完成，准备恢复录音');
                    }
                }
                
                // 🚀 继续下一次录音
            }
        })();
        
        return;
    }
    
    // 使用谷歌语音识别（原有逻辑）
    console.log('🎙️ 使用谷歌浏览器语音识别');
    
    // 检查浏览器支持
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        await showCustomAlert('不支持', '浏览器不支持语音识别功能，请使用Chrome、Edge或Safari浏览器');
        document.getElementById('voice-recognition-switch').checked = false;
        voiceRecognitionState.isEnabled = false;
        return;
    }
    
    try {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        voiceRecognitionState.recognition = new SpeechRecognition();
        
        // 配置语音识别
        voiceRecognitionState.recognition.continuous = true;
        voiceRecognitionState.recognition.interimResults = true; // 启用中间结果
        voiceRecognitionState.recognition.maxAlternatives = 1;
        
        // 默认使用中文识别
        voiceRecognitionState.recognition.lang = 'zh-CN';
        
        // 处理识别结果
        voiceRecognitionState.recognition.onresult = function(event) {
            let interimTranscript = '';
            let finalTranscript = '';
            
            // 处理所有结果
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                    finalTranscript += transcript;
                } else {
                    interimTranscript += transcript;
                }
            }
            
            // 显示中间结果（如果锁定且正在处理，则不显示）
            if (interimTranscript && !(voiceRecognitionState.isVoiceLocked && voiceRecognitionState.isProcessing)) {
                showVoiceRecognitionStatus(true, interimTranscript);
            }
            
            // 处理最终结果
            if (finalTranscript.trim()) {
                console.log('🖤 语音识别结果:', finalTranscript.trim());
                hideVoiceRecognitionStatus();
                handleVoiceRecognitionResult(finalTranscript.trim());
            }
        };
        
        // 处理开始识别
        voiceRecognitionState.recognition.onstart = function() {
            console.log('🖤 语音识别已启动');
            voiceRecognitionState.isListening = true;
            showVoiceRecognitionStatus(true);
        };
        
        // 处理语音开始
        voiceRecognitionState.recognition.onspeechstart = function() {
            console.log('🖤 检测到语音输入');
            showVoiceRecognitionStatus(true);
        };
        
        // 处理语音结束
        voiceRecognitionState.recognition.onspeechend = function() {
            console.log('🖤 语音输入结束');
        };
        
        // 处理错误
        voiceRecognitionState.recognition.onerror = function(event) {
            console.error('🖤 语音识别错误:', event.error);
            hideVoiceRecognitionStatus();
            
            if (event.error === 'no-speech') {
                // 无语音输入，继续监听
                console.log('🖤 无语音输入，继续监听...');
                return;
            }
            
            if (event.error === 'aborted') {
                // 识别被中止，不重启
                console.log('🖤 语音识别被中止');
                return;
            }
            
            // 其他错误，重新启动识别
            console.log('🖤 准备重新启动语音识别...');
            setTimeout(() => {
                if (voiceRecognitionState.isEnabled && !voiceRecognitionState.isListening && !voiceRecognitionState.isProcessing && !autoVoiceState.isPlaying) {
                    console.log('🖤 重新启动语音识别');
                    startContinuousVoiceRecognition();
                }
            }, 1000);
        };
        
        // 处理识别结束
        voiceRecognitionState.recognition.onend = function() {
            console.log('🖤 语音识别结束');
            voiceRecognitionState.isListening = false;
            hideVoiceRecognitionStatus();
            
            // 如果开关还是开启状态，检查是否需要重新启动识别
            if (voiceRecognitionState.isEnabled) {
                console.log('🖤 准备重新启动连续识别...');
                setTimeout(() => {
                    // 检查语音锁定模式和语音播放状态：如果锁定且AI正在处理，或者有语音正在播放，则不重启
                    const shouldRestart = voiceRecognitionState.isEnabled && 
                                        !voiceRecognitionState.isListening && 
                                        !(voiceRecognitionState.isVoiceLocked && voiceRecognitionState.isProcessing) &&
                                        !autoVoiceState.isPlaying;
                    
                    if (shouldRestart) {
                        console.log('🖤 重新启动连续识别');
                        startContinuousVoiceRecognition();
                    } else if (voiceRecognitionState.isVoiceLocked && voiceRecognitionState.isProcessing) {
                        console.log('🔒 语音锁定模式：AI处理期间暂停识别');
                    } else if (autoVoiceState.isPlaying) {
                        console.log('🎵 语音播放中：暂停语音识别');
                    }
                }, 100); // 缩短延迟时间，确保快速重启
            }
        };
        
        // 开始识别
        voiceRecognitionState.recognition.start();
        voiceRecognitionState.isListening = true;
        console.log('🖤 开始连续语音识别...');
        
    } catch (error) {
        console.error('🖤 启动语音识别失败:', error);
        await showCustomAlert('启动失败', '无法启动语音识别: ' + error.message);
        document.getElementById('voice-recognition-switch').checked = false;
        voiceRecognitionState.isEnabled = false;
    }
}

/**
 * 停止连续语音识别
 */
function stopContinuousVoiceRecognition() {
    // 停止谷歌语音识别
    if (voiceRecognitionState.recognition) {
        voiceRecognitionState.recognition.stop();
        voiceRecognitionState.recognition = null;
    }
    
    // 停止智谱API识别（通过设置状态标志）
    voiceRecognitionState.isListening = false;
    voiceRecognitionState.isProcessing = false;
    voiceRecognitionState.isEnabled = false; // 停止智谱API的循环识别
    voiceRecognitionState.messageQueue = []; // 清空消息队列
    
    // 关闭全局音频流（智谱API用）
    if (globalAudioStream) {
        console.log('🎤 关闭麦克风音频流');
        globalAudioStream.getTracks().forEach(track => track.stop());
        globalAudioStream = null;
    }
    
    hideVoiceRecognitionStatus();
    updateQueueStatus(); // 更新队列显示（隐藏队列面板）
    console.log('🖤 停止语音识别');
}

/**
 * 处理语音识别结果
 * 注意：智谱识别会在主循环中等待处理完成，所以不会出现"AI处理中还在录音"的情况
 * 但谷歌识别是连续模式，可能会在AI处理时继续识别，所以仍需队列逻辑
 */
async function handleVoiceRecognitionResult(transcript) {
    // 如果AI正在处理中，将新消息加入队列
    if (voiceRecognitionState.isProcessing) {
        console.log('🖤 AI正在处理中，将消息加入队列:', transcript);
        voiceRecognitionState.messageQueue.push(transcript);
        updateQueueStatus();
        return;
    }
    
    // 严格按顺序处理：如果队列中有消息，新消息也要加入队列
    if (voiceRecognitionState.messageQueue.length > 0) {
        console.log('🖤 队列中有待处理消息，新消息加入队列末尾:', transcript);
        voiceRecognitionState.messageQueue.push(transcript);
        updateQueueStatus();
        
        // 🔥 重要修复：只要有待处理消息就必须处理，无关任何状态！
        await processMessageQueue();
        return;
    }
    
    // 队列为空且AI未处理时，直接处理当前消息
    await processVoiceMessage(transcript);
    
    // 处理完当前消息后，检查是否有新的队列消息需要处理
    await processMessageQueue();
}

/**
 * 处理单条语音消息
 */
async function processVoiceMessage(transcript) {
    voiceRecognitionState.isProcessing = true;
    
    // 如果开启了语音锁定模式，停止语音识别
    if (voiceRecognitionState.isVoiceLocked && voiceRecognitionState.isListening) {
        console.log('🔒 开始处理消息，语音锁定模式下停止识别');
        if (voiceRecognitionState.recognition) {
            voiceRecognitionState.recognition.stop();
        }
    }
    
    try {
        console.log('🖤 处理语音识别结果:', transcript);
        
        // 将用户语音输入添加到通话历史
        videoCallState.callHistory.push({ role: 'user', content: transcript });
        
        // 调用AI回复（使用用户的主API，而不是智谱API）
        await triggerAiInCallAction(transcript);
        
    } catch (error) {
        console.error('🖤 处理语音识别结果失败:', error);
    } finally {
        voiceRecognitionState.isProcessing = false;
        
        // 🔥 关键修复：处理完当前消息后，检查并处理队列中的剩余消息
        await processMessageQueue();
        
        // 处理完成后，检查是否需要重新启动识别（仅适用于谷歌识别）
        // 智谱识别使用循环模式，会自动继续下一次录音，不需要手动重启
        if (voiceRecognitionState.recognition && voiceRecognitionState.isEnabled && !voiceRecognitionState.isListening) {
            console.log('🔓 [谷歌]消息处理完成，重新启动语音识别');
            setTimeout(() => {
                if (voiceRecognitionState.isEnabled && !voiceRecognitionState.isListening && !autoVoiceState.isPlaying) {
                    startContinuousVoiceRecognition();
                }
            }, 300); // 减少延迟时间
        }
    }
}

/**
 * 处理消息队列中的待处理消息
 * 新逻辑：如果队列中有多个消息，将它们合并为一个请求发送给AI
 */
async function processMessageQueue() {
    // 如果队列为空或AI正在处理，直接返回
    if (voiceRecognitionState.messageQueue.length === 0 || voiceRecognitionState.isProcessing) {
        return;
    }
    
    // 如果队列中只有一个消息，按原来的方式处理
    if (voiceRecognitionState.messageQueue.length === 1) {
        const nextMessage = voiceRecognitionState.messageQueue.shift();
        console.log('🖤 处理队列中的单个消息:', nextMessage);
        updateQueueStatus();
        await processVoiceMessage(nextMessage);
    } else {
        // 如果队列中有多个消息，批量处理
        console.log(`🖤 队列中有 ${voiceRecognitionState.messageQueue.length} 条消息，开始批量处理`);
        
        // 获取所有待处理消息
        const allMessages = [...voiceRecognitionState.messageQueue];
        
        // 清空队列（因为我们要一次性处理所有消息）
        voiceRecognitionState.messageQueue = [];
        updateQueueStatus();
        
        // 合并所有消息，用换行符分隔
        const combinedMessage = allMessages.join('\n');
        console.log('🖤 合并后的消息:', combinedMessage);
        
        // 处理合并后的消息
        await processBatchVoiceMessage(combinedMessage, allMessages);
    }
    
    updateQueueStatus(); // 队列处理完成后更新状态
}

/**
 * 显示用户消息气泡
 * @param {string} message - 用户消息内容
 */
function displayUserMessageBubble(message) {
    if (!videoCallState.isActive || !videoCallState.isUserParticipating) return;
    
    const chat = state.chats[videoCallState.activeChatId];
    const isVisualMode = chat.settings.visualVideoCallEnabled;
    
    // 根据通话类型和模式决定使用哪个消息容器
    let callFeed;
    if (videoCallState.callType === 'voice') {
        callFeed = document.getElementById('voice-call-main');
    } else if (isVisualMode) {
        callFeed = document.getElementById('video-call-messages-visual');
    } else {
        callFeed = document.getElementById('video-call-main');
    }
    
    if (!callFeed) return;
    
    // 创建用户消息气泡
    const userBubble = document.createElement('div');
    if (isVisualMode) {
        userBubble.className = 'visual-call-bubble user';
    } else {
        userBubble.className = 'call-message-bubble user-speech';
    }
    userBubble.textContent = message;
    callFeed.appendChild(userBubble);
    callFeed.scrollTop = callFeed.scrollHeight;
}

/**
 * 批量处理多条语音消息
 * @param {string} combinedMessage - 合并后的消息内容
 * @param {Array} originalMessages - 原始消息数组（用于UI显示）
 */
async function processBatchVoiceMessage(combinedMessage, originalMessages) {
    voiceRecognitionState.isProcessing = true;
    
    // 如果开启了语音锁定模式，停止语音识别
    if (voiceRecognitionState.isVoiceLocked && voiceRecognitionState.isListening) {
        console.log('🔒 开始批量处理消息，语音锁定模式下停止识别');
        if (voiceRecognitionState.recognition) {
            voiceRecognitionState.recognition.stop();
        }
    }
    
    try {
        console.log('🖤 批量处理语音识别结果:', originalMessages);
        
        // 分别显示每条用户消息（创建独立的气泡）
        originalMessages.forEach(message => {
            displayUserMessageBubble(message);
        });
        
        // 将合并后的消息添加到通话历史中（供AI处理）
        videoCallState.callHistory.push({ role: 'user', content: combinedMessage });
        
        // 调用AI回复时不传入userInput，让AI处理历史记录中的消息
        console.log('🤖 发送给AI的合并消息:', combinedMessage);
        await triggerAiInCallAction();
        
    } catch (error) {
        console.error('🖤 批量处理语音识别结果失败:', error);
    } finally {
        voiceRecognitionState.isProcessing = false;
        
        // 🔥 关键修复：批量处理完成后，检查并处理队列中的剩余消息
        await processMessageQueue();
        
        // 处理完成后，检查是否需要重新启动识别
        if (voiceRecognitionState.isEnabled && !voiceRecognitionState.isListening) {
            console.log('🔓 批量消息处理完成，重新启动语音识别');
            setTimeout(() => {
                if (voiceRecognitionState.isEnabled && !voiceRecognitionState.isListening && !autoVoiceState.isPlaying) {
                    startContinuousVoiceRecognition();
                }
            }, 300);
        }
    }
}

/**
 * 更新消息队列状态显示
 */
function updateQueueStatus() {
    const queueLength = voiceRecognitionState.messageQueue.length;
    const queueDisplay = document.getElementById('message-queue-display');
    const queueCount = document.getElementById('queue-count');
    const queueMessages = document.getElementById('queue-messages');
    
    if (queueLength > 0) {
        console.log(`📋 消息队列状态: ${queueLength} 条消息等待处理`);
        
        // 显示队列面板
        if (queueDisplay) {
            queueDisplay.style.display = 'block';
        }
        
        // 更新队列数量
        if (queueCount) {
            queueCount.textContent = queueLength;
        }
        
        // 更新队列消息列表
        if (queueMessages) {
            queueMessages.innerHTML = '';
            voiceRecognitionState.messageQueue.forEach((message, index) => {
                const messageItem = document.createElement('div');
                messageItem.className = 'queue-message-item';
                messageItem.innerHTML = `
                    <span class="queue-message-text" title="${message}">${message}</span>
                    <button class="queue-message-delete" onclick="deleteQueueMessage(${index})">删除</button>
                `;
                queueMessages.appendChild(messageItem);
            });
        }
        
        // 在语音识别状态指示器中显示队列数量
        console.log(`📋 [updateQueueStatus]显示队列状态: 等待处理: ${queueLength} 条消息`);
        showVoiceRecognitionStatus(true, `等待处理: ${queueLength} 条消息`);
    } else {
        console.log('📋 消息队列已清空');
        
        // 隐藏队列面板
        if (queueDisplay) {
            queueDisplay.style.display = 'none';
        }
    }
}

/**
 * 删除队列中的指定消息
 */
window.deleteQueueMessage = function(index) {
    if (index >= 0 && index < voiceRecognitionState.messageQueue.length) {
        const deletedMessage = voiceRecognitionState.messageQueue.splice(index, 1)[0];
        console.log('🗑️ 删除队列消息:', deletedMessage);
        updateQueueStatus();
    }
}

/**
 * 显示语音识别状态指示器
 */
function showVoiceRecognitionStatus(isListening = false, interimText = '') {
    const statusElement = document.getElementById('voice-recognition-status');
    const interimElement = document.getElementById('interim-transcript');
    
    if (statusElement) {
        statusElement.classList.add('active');
        
        // 更新中间识别结果
        if (interimElement && interimText) {
            interimElement.textContent = interimText;
        } else if (interimElement) {
            interimElement.textContent = '';
        }
    }
}

/**
 * 隐藏语音识别状态指示器
 */
function hideVoiceRecognitionStatus() {
    const statusElement = document.getElementById('voice-recognition-status');
    const interimElement = document.getElementById('interim-transcript');
    
    if (statusElement) {
        statusElement.classList.remove('active');
    }
    
    if (interimElement) {
        interimElement.textContent = '';
    }
}

// ▲▲▲ 语音识别功能结束 ▲▲▲

// ▼▼▼ AI回复状态指示器功能 ▼▼▼

/**
 * 显示AI回复状态指示器
 */
function showAiTypingIndicator() {
    const indicator = document.getElementById('ai-typing-indicator');
    if (indicator) {
        indicator.classList.add('active');
        console.log('💬 显示AI回复状态指示器');
    }
}

/**
 * 隐藏AI回复状态指示器
 */
function hideAiTypingIndicator() {
    const indicator = document.getElementById('ai-typing-indicator');
    if (indicator) {
        indicator.classList.remove('active');
        console.log('💬 隐藏AI回复状态指示器');
    }
}

/**
 * 显示通话界面AI回复状态指示器
 */
function showCallAiReplyStatus() {
    // 根据当前通话类型和界面模式显示对应的状态指示器
    if (videoCallState.isActive) {
        if (videoCallState.callType === 'voice') {
            // 语音通话界面
            const indicator = document.getElementById('ai-reply-status-voice');
            if (indicator) {
                indicator.classList.add('active');
                console.log('💬 显示语音通话AI回复状态指示器');
            }
        } else {
            // 视频通话界面 - 需要判断是可视化模式还是文字模式
            const visualInterface = document.getElementById('visual-call-interface');
            const textInterface = document.getElementById('text-call-interface');
            
            if (visualInterface && visualInterface.style.display !== 'none') {
                // 可视化模式
                const indicator = document.getElementById('ai-reply-status-visual');
                if (indicator) {
                    indicator.classList.add('active');
                    console.log('💬 显示可视化通话AI回复状态指示器');
                }
            } else if (textInterface && textInterface.style.display !== 'none') {
                // 文字模式
                const indicator = document.getElementById('ai-reply-status-text');
                if (indicator) {
                    indicator.classList.add('active');
                    console.log('💬 显示文字通话AI回复状态指示器');
                }
            }
        }
    }
}

/**
 * 隐藏通话界面AI回复状态指示器
 */
function hideCallAiReplyStatus() {
    // 隐藏所有通话界面的AI回复状态指示器
    const indicators = [
        'ai-reply-status-visual',
        'ai-reply-status-text', 
        'ai-reply-status-voice'
    ];
    
    indicators.forEach(id => {
        const indicator = document.getElementById(id);
        if (indicator) {
            indicator.classList.remove('active');
        }
    });
    
    console.log('💬 隐藏所有通话AI回复状态指示器');
}

// ▲▲▲ AI回复状态指示器功能结束 ▲▲▲

// ▼▼▼ 用这整块【最终通话修复版】的代码，完整替换掉上一个版本的 handleInitiateCall 函数 ▼▼▼
/**
 * 【总入口】用户点击"发起视频通话"或"发起群视频"按钮 (V3 - 通话决策修复版)
 * @param {string} callType - 通话类型：'video' 或 'voice'
 */
async function handleInitiateCall(callType = 'video') {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;

    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true;
    videoCallState.callType = callType;

    // 1. 显示“正在呼叫”界面 (这部分不变)
    if (chat.isGroup) {
        document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
    } else {
        document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    // 根据通话类型显示不同的提示文字
    const callingText = callType === 'voice' 
        ? (chat.isGroup ? "正在语音呼叫所有成员..." : "正在语音呼叫...") 
        : (chat.isGroup ? "正在视频呼叫所有成员..." : "正在视频呼叫...");
    document.querySelector('#outgoing-call-screen .caller-text').textContent = callingText;
    showScreen('outgoing-call-screen');
    
    // 2. 【核心修复】重新构建一个信息更丰富、指令更明确的API请求
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置，无法发起通话。');
        }

        // 提取通话前的最后20条消息作为上下文
        videoCallState.preCallContext = chat.history
            .slice(-20)
            .map(msg => `${msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name)}: ${String(msg.content).substring(0, 50)}...`)
            .join('\n');
        
        // 构建一个强大且明确的系统指令(System Prompt)
        let systemPromptForCall;
        if (chat.isGroup) {
            const callTypeText = callType === 'voice' ? '群语音通话' : '群视频通话';
            systemPromptForCall = `
# 你的任务
你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
用户 (${chat.settings.myNickname || '我'}) 刚刚发起了${callTypeText}。
你的任务是根据每个角色的性格和最近的聊天内容，决定他们是否要加入通话。

# 核心规则
1.  **决策**: 每个角色都必须独立决策。
2.  **格式**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的决策，格式为：\`{"type": "group_call_response", "name": "【角色的本名】", "decision": "join"}\` 或 \`{"type": "group_call_response", "name": "【角色的本名】", "decision": "decline"}\`。
3.  **倾向性**: 在没有特殊理由的情况下，你的角色们通常乐于加入群聊。

# 角色列表与人设
${chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n')}

# 通话前的聊天摘要
${videoCallState.preCallContext}
`;
        } else {
            const callTypeText = callType === 'voice' ? '语音通话' : '视频通话';
            systemPromptForCall = `
# 你的任务
你正在扮演角色 "${chat.name}"。用户 (${chat.settings.myNickname || '我'}) 刚刚向你发起了${callTypeText}请求。
你的任务是根据你的人设和我们最近的聊天内容，决定是否接受。

# 核心规则
1.  **决策**: 你必须做出 "accept" (接受) 或 "reject" (拒绝) 的决定。
2.  **格式**: 你的回复【必须且只能】是一个JSON数组，其中包含一个对象，格式为：\`[{"type": "video_call_response", "decision": "accept"}]\` 或 \`[{"type": "video_call_response", "decision": "reject"}]\`。
3.  **倾向性**: 作为一个友好的AI伴侣，在没有特殊理由（比如在之前的对话中明确表示了不想被打扰或正在忙）的情况下，你【应该优先选择接受】通话。

# 你的人设
${chat.settings.aiPersona}

# 通话前的聊天摘要
${videoCallState.preCallContext}
`;
        }
        
        // 准备发送给API的消息体
        const messagesForApi = [{ role: 'user', content: "请根据你在系统指令中读到的规则，立即做出你的决策。" }];
        
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPromptForCall, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPromptForCall }, ...messagesForApi],
                    temperature: 0.7
                })
            });
            
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API 错误 (${response.status}): ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
        const responseArray = JSON.parse(aiResponseContent);

        // 3. 处理AI的决策 (与上一版相同)
        if (chat.isGroup) {
            responseArray.forEach(action => {
                if (action.type === 'group_call_response' && action.decision === 'join') {
                    const member = chat.members.find(m => m.originalName === action.name);
                    if (member) videoCallState.participants.push(member);
                }
            });
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                throw new Error("群里没有人接听你的通话邀请。");
            }
        } else {
            const decision = responseArray[0];
            if (decision.type === 'video_call_response' && decision.decision === 'accept') {
                startVideoCall();
            } else {
                const rejectionText = callType === 'voice' ? "对方拒绝了你的语音通话请求。" : "对方拒绝了你的视频通话请求。";
                throw new Error(rejectionText);
            }
        }

    } catch (error) {
        // 4. 统一处理所有失败情况 (与上一版相同)
        console.error("发起通话失败:", error);
        await showCustomAlert("呼叫失败", error.message);
        videoCallState.isAwaitingResponse = false;
        showScreen('chat-interface-screen');
    }
}
// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 用这个【全新的函数】，完整替换掉你旧的 startVideoCall 函数 ▼▼▼
function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    // 【核心新增】根据通话类型决定显示哪种界面
    if (videoCallState.callType === 'voice') {
        // 启动语音通话界面
        startVoiceCallInterface(chat);
    } else {
        // 启动视频通话界面
        startVideoCallInterface(chat);
    }
}

// 启动视频通话界面的函数
function startVideoCallInterface(chat) {
    // 1. 【核心判断】检查是否启用了可视化界面
    if (chat.settings.visualVideoCallEnabled) {
        // --- 启动【新】的可视化界面 ---
        videoCallState.isActive = true;
        videoCallState.isAwaitingResponse = false;
        videoCallState.startTime = Date.now();
        videoCallState.callHistory = [];

        const visualInterface = document.getElementById('visual-call-interface');
        const textInterface = document.getElementById('text-call-interface');
        
        // 显示新界面，隐藏旧界面
        visualInterface.style.display = 'flex';
        textInterface.style.display = 'none';

        // 加载图片
        document.querySelector('#video-main-view img').src = chat.settings.charVideoImage || defaultAvatar;
        document.querySelector('#video-pip-view img').src = chat.settings.userVideoImage || defaultAvatar;
        
        // 清空旧的聊天气泡
        document.getElementById('video-call-messages-visual').innerHTML = `<em>正在接通...</em>`;
        showScreen('video-call-screen');

        // 启动计时器
        if (callTimerInterval) clearInterval(callTimerInterval);
        callTimerInterval = setInterval(updateCallTimer, 1000);
        updateCallTimer(); // 立即更新一次

        // 触发AI在通话中的第一句话
        triggerAiInCallAction();

    } else {
        // --- 启动【旧】的纯文字界面 (这里的代码就是你原来的逻辑) ---
        videoCallState.isActive = true;
        videoCallState.isAwaitingResponse = false;
        videoCallState.startTime = Date.now();
        videoCallState.callHistory = [];

        const visualInterface = document.getElementById('visual-call-interface');
        const textInterface = document.getElementById('text-call-interface');

        // 显示旧界面，隐藏新界面
        visualInterface.style.display = 'none';
        textInterface.style.display = 'flex'; // 旧界面用flex

        updateParticipantAvatars(); 
        
        document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '群聊已建立...' : '正在接通...'}</em>`;
        showScreen('video-call-screen');

        document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
        document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

        if (callTimerInterval) clearInterval(callTimerInterval);
        callTimerInterval = setInterval(updateCallTimer, 1000);
        updateCallTimer();

        triggerAiInCallAction();
    }
}

// 启动语音通话界面的函数
function startVoiceCallInterface(chat) {
    videoCallState.isActive = true;
    videoCallState.isAwaitingResponse = false;
    videoCallState.startTime = Date.now();
    videoCallState.callHistory = [];

    updateVoiceParticipantAvatars(); 
    
    const connectionText = videoCallState.isGroupCall ? '群语音已建立...' : '语音连接中...';
    document.getElementById('voice-call-main').innerHTML = `<em>${connectionText}</em>`;
    showScreen('voice-call-screen');

    document.getElementById('user-speak-voice-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
    document.getElementById('join-voice-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateVoiceCallTimer, 1000);
    updateVoiceCallTimer();

    // 初始化语音识别功能
    initVoiceRecognition();

    triggerAiInCallAction();
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【核心】结束视频通话
 */
// ▼▼▼ 用这整块代码替换旧的 endVideoCall 函数 ▼▼▼
async function endVideoCall() {
  // 隐藏所有通话界面
document.getElementById('visual-call-interface').style.display = 'none';
document.getElementById('voice-call-screen').style.display = 'none';

    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `通话结束，时长 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        // 1. 保存完整的通话记录到数据库 (这部分逻辑不变)
        const participantsData = [];
        if (videoCallState.isGroupCall) {
            videoCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (videoCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || '我', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: '我', avatar: chat.settings.myAvatar || defaultAvatar });
        }
        
        const callRecord = {
            chatId: videoCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...videoCallState.callHistory]
        };
        await db.callRecords.add(callRecord);
        console.log("通话记录已保存:", callRecord);
        
        // 2. 在聊天记录里添加对用户可见的“通话结束”消息
let summaryMessage = {
    // 【核心修正1】role 由 videoCallState.initiator 决定
    role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
    content: endCallText,
    timestamp: Date.now(),
};

// 【核心修正2】为群聊的 assistant 消息补充 senderName
if (chat.isGroup && summaryMessage.role === 'assistant') {
    // 在群聊中，通话结束的消息应该由“发起者”来说
    // videoCallState.callRequester 保存了最初发起通话的那个AI的名字
    summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
}
// ▲▲▲ 替换结束 ▲▲▲
        chat.history.push(summaryMessage);

        // 3. 【核心变革】创建并添加对用户隐藏的“通话后汇报”指令
        const callTranscriptForAI = videoCallState.callHistory.map(h => `${h.role === 'user' ? (chat.settings.myNickname || '我') : h.role}: ${h.content}`).join('\n');
        
        const hiddenReportInstruction = {
            role: 'system',
    content: `[系统指令：视频通话刚刚结束。请你根据完整的通话文字记录（见下方），以你的角色口吻，向用户主动发送几条【格式为 {"type": "text", "content": "..."} 的】消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。这很重要，能让用户感觉你记得通话内容。]\n---通话记录开始---\n${callTranscriptForAI}\n---通话记录结束---`,
            timestamp: Date.now() + 1, // 确保在上一条消息之后
            isHidden: true
        };
        chat.history.push(hiddenReportInstruction);

        // 4. 保存所有更新到数据库
        await db.chats.put(chat);
    }
    
    // 5. 清理和重置状态 (这部分逻辑不变)
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    
    // 清理语音识别功能
    stopContinuousVoiceRecognition();
    const voiceSwitch = document.getElementById('voice-recognition-switch');
    if (voiceSwitch) {
        voiceSwitch.checked = false;
    }
    const voiceLockSwitch = document.getElementById('voice-lock-switch');
    if (voiceLockSwitch) {
        voiceLockSwitch.checked = false;
    }
    // 清理自动语音播放功能
    const autoVoiceSwitch = document.getElementById('auto-voice-switch');
    if (autoVoiceSwitch) {
        autoVoiceSwitch.checked = false;
    }
    autoVoiceState = {
        isEnabled: false
    };
    
    // 清空所有语音缓存
    if (window.VoiceStorageAPI) {
        try {
            const result = window.VoiceStorageAPI.clearAllVoiceCache();
            console.log(`✅ 通话结束后已自动清空语音缓存: ${result.count} 个文件`);
        } catch (error) {
            console.error('清空语音缓存失败:', error);
        }
    }
    // 隐藏控制面板
    const controlsPanel = document.getElementById('voice-recognition-controls');
    if (controlsPanel) {
        controlsPanel.style.display = 'none';
    }
    voiceRecognitionState = {
        isEnabled: false,
        isListening: false,
        recognition: null,
        isProcessing: false,
        messageQueue: [],
        isVoiceLocked: false
    };
    
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 6. 返回聊天界面并触发AI响应（AI会读取到我们的“汇报”指令）
    if (chat) {
        openChat(chat.id);
        triggerAiResponse(); // 关键一步！
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】更新通话界面的参与者头像网格
 */
function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];

    // ★ 核心修正：区分群聊和单聊
    if (videoCallState.isGroupCall) {
        // 群聊逻辑：显示所有已加入的AI成员
        participantsToRender = [...videoCallState.participants];
        // 如果用户也参与了，就把用户信息也加进去
        if (videoCallState.isUserParticipating) {
            participantsToRender.unshift({
                id: 'user',
                name: chat.settings.myNickname || '我',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar
            });
        }
    } else {
        // 单聊逻辑：只显示对方的头像和名字
        participantsToRender.push({
            id: 'ai',
            name: chat.name,
            avatar: chat.settings.aiAvatar || defaultAvatar
        });
    }
    
    participantsToRender.forEach(p => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.dataset.participantId = p.id;
const displayName = p.groupNickname || p.name; // <-- 核心修复在这里
wrapper.innerHTML = `
    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
    <div class="participant-name">${displayName}</div>
`;
        grid.appendChild(wrapper);
    });
}

/**
 * 【全新】更新语音通话界面的参与者头像网格
 */
function updateVoiceParticipantAvatars() {
    const grid = document.getElementById('voice-participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];

    // 区分群聊和单聊
    if (videoCallState.isGroupCall) {
        // 群聊逻辑：显示所有已加入的AI成员
        participantsToRender = [...videoCallState.participants];
        // 如果用户也参与了，就把用户信息也加进去
        if (videoCallState.isUserParticipating) {
            participantsToRender.unshift({
                id: 'user',
                name: chat.settings.myNickname || '我',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar
            });
        }
    } else {
        // 单聊逻辑：只显示对方的头像和名字
        participantsToRender.push({
            id: 'ai',
            name: chat.name,
            avatar: chat.settings.aiAvatar || defaultAvatar
        });
    }
    
    participantsToRender.forEach(p => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.dataset.participantId = p.id;
        const displayName = p.groupNickname || p.name;
        wrapper.innerHTML = `
    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
    <div class="participant-name">${displayName}</div>
`;
        grid.appendChild(wrapper);
    });
}

/**
 * 【全新】处理用户加入/重新加入通话
 */
function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
    
    videoCallState.isUserParticipating = true;
    updateParticipantAvatars(); // 更新头像列表，加入用户

    // 切换底部按钮
    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';

    // 告知AI用户加入了
    triggerAiInCallAction("[系统提示：用户加入了通话]");
}


/**
 * 更新通话计时器显示 
 */
// ▼▼▼ 用这个【新版本】替换旧的 updateCallTimer 函数 ▼▼▼
function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    // 同时更新两个界面的计时器
    document.getElementById('call-timer').textContent = timeString;
    document.getElementById('visual-call-timer').textContent = timeString;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 更新语音通话计时器显示 
 */
function updateVoiceCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    // 更新语音通话计时器
    document.getElementById('voice-call-timer').textContent = timeString;
}


// ▼▼▼ 用这个完整函数替换旧的 showIncomingCallModal ▼▼▼
function showIncomingCallModal(chatId) { // <--- 在括号里添加 chatId
    const chat = state.chats[chatId]; // <--- 把 state.activeChatId 修改为 chatId
    if (!chat) return;

    // 根据是否群聊显示不同信息
    if (chat.isGroup) {
        // 从 videoCallState 中获取是哪个成员发起的通话
        const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成员';
        document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('caller-name').textContent = chat.name; // 显示群名
        document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
    } else {
        // 单聊逻辑保持不变
        document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = '邀请你视频通话';
    }
    
    document.getElementById('incoming-call-modal').classList.add('visible');
    playRingtone(); // <-- 在这里添加这一行
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示通话类型选择模态框
 */
function showCallTypeSelection() {
    document.getElementById('call-type-selection-modal').classList.add('visible');
}

/**
 * 隐藏通话类型选择模态框
 */
function hideCallTypeSelection() {
    document.getElementById('call-type-selection-modal').classList.remove('visible');
}

/**
 * 隐藏AI发起的通话请求模态框 (保持不变)
 */
function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
    stopRingtone(); // <-- 在这里添加这一行
}

// ▼▼▼ 【这是修正后的版本】请用这一整块代码，完整替换你旧的 triggerAiInCallAction 函数 ▼▼▼
async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;

    const chat = state.chats[videoCallState.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    
    const isVisualMode = chat.settings.visualVideoCallEnabled;
    // 根据通话类型和模式决定使用哪个消息容器
    let callFeed;
    if (videoCallState.callType === 'voice') {
        callFeed = document.getElementById('voice-call-main');
    } else if (isVisualMode) {
        callFeed = document.getElementById('video-call-messages-visual');
    } else {
        callFeed = document.getElementById('video-call-main');
    }

    const userNickname = chat.settings.myNickname || '我';

    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }

    if (userInput && videoCallState.isUserParticipating) {
        if (isVisualMode) {
            const userBubble = document.createElement('div');
            userBubble.className = 'visual-call-bubble user';
            userBubble.textContent = userInput;
            callFeed.appendChild(userBubble);
        } else {
            const userBubble = document.createElement('div');
            userBubble.className = 'call-message-bubble user-speech';
            userBubble.textContent = userInput;
            callFeed.appendChild(userBubble);
        }
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'user', content: userInput });
    }

    // ★★★ 修复：将callTypeText定义移到外层，避免作用域问题 ★★★
    const callTypeText = videoCallState.callType === 'voice' ? '语音通话' : '视频通话';
    
    let inCallPrompt;
    if (videoCallState.isGroupCall) {
        // ★★★ 核心修复1：在这里，我们提前定义好 participantNames ★★★
        const participantNames = videoCallState.participants.map(p => p.originalName); 
        if(videoCallState.isUserParticipating) {
            participantNames.unshift(userNickname);
        }
        // ★★★ 修复结束 ★★★
        inCallPrompt = `
# 你的任务
你是一个群聊AI，负责扮演所有【除了用户以外】的AI角色。你们正在进行一场群聊${callTypeText}。
你的任务是根据每个角色的性格，生成他们在通话中会说的【第一人称对话】，注意是在${callTypeText}，绝对不能以为是在现实！每次回复的字数多些，50字以上。

# 核心规则
1.  **【【【语言铁律】】】**: 无论角色人设是什么国籍或说什么语言，在本次${callTypeText}中，所有角色【必须】全程使用【中文】进行交流。
2.  **【【【格式铁律】】】**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的发言，格式为：\`{"name": "【角色的本名】", "speech": "【在这里加入带动作的对话】"}\`。
3.  **【【【表现力铁律】】】**: 在 "speech" 字段中，你【必须】为角色的对话加入【动作、表情或心理活动】，并用【】符号包裹。这非常重要！
4.  **示例**: \`{"name": "张三", "speech": "【挠了挠头】啊？我刚刚走神了，你们说到哪了？"}\`
5.  **身份铁律**: 用户的身份是【${userNickname}】。你【绝对不能】生成 \`name\` 字段为 **"${userNickname}"** 的发言。
6.  **角色扮演**: 严格遵守每个角色的设定，用他们的口吻说话。

# 当前情景
你们正在一个群${callTypeText}中。
**通话前的聊天摘要**:
${videoCallState.preCallContext}
**当前参与者**: ${participantNames.join('、 ')}。
${worldBookContent}
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
    } else {
        // ★★★ 核心修复2：为单人通话提供一个完全独立的、正确的Prompt ★★★
        let openingContext = videoCallState.initiator === 'user'
            ? `你刚刚接听了用户的${callTypeText}请求。`
            : `用户刚刚接听了你主动发起的${callTypeText}。`;
            
        inCallPrompt = `
# 你的任务
你正在扮演角色 "${chat.name}" (${chat.settings.aiPersona})。你正在和用户 (${userNickname}，人设: ${chat.settings.myPersona}) 进行一对一${callTypeText}。
${openingContext}
你的任务是根据你的人设和我们的聊天情景，生成你在通话中会说的【第一人称对话】。

# 核心规则
1.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一段纯文本字符串，代表你的发言。绝对不要输出JSON格式。
2.  **【【【表现力铁律】】】**: 在你的对话中，你【必须】加入【动作、表情或心理活动】，并用【】符号包裹。
3.  **示例**: "【歪了歪头，好奇地看着你】真的吗？快跟我说说看！"
4.  **禁止出戏**: 绝不能透露你是AI或模型。

# 当前情景
**通话前的聊天摘要**:
${videoCallState.preCallContext}
${worldBookContent}
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
        // ★★★ 修复结束 ★★★
    }
    
    const messagesForApi = [
        ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
    ];

    if (videoCallState.callHistory.length === 0) {
        const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接听键...*` : `*对方按下了接听键...*`;
        messagesForApi.push({ role: 'user', content: firstLineTrigger });
    }
    
    // 显示通话界面AI回复状态指示器
    showCallAiReplyStatus();
    
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, inCallPrompt, messagesForApi, isGemini);
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model: model, messages: [{ role: 'system', content: inCallPrompt }, ...messagesForApi], temperature: 0.8 })
        });
        if (!response.ok) throw new Error((await response.json()).error.message);

        const data = await response.json();
        const aiResponse = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        const sanitizedResponse = aiResponse.replace(/!\[.*?\]\(.*?\)|https?:\/\/\S+/gi, '').trim();

        const connectingElement = callFeed.querySelector('em');
        if (connectingElement) connectingElement.remove();

        if (isVisualMode) {
            const aiBubble = document.createElement('div');
            aiBubble.className = 'visual-call-bubble ai';
            // 格式化文本，将【】内容设置为灰色
            aiBubble.innerHTML = formatVoiceCallText(sanitizedResponse);
            callFeed.appendChild(aiBubble);
            videoCallState.callHistory.push({ role: 'assistant', content: sanitizedResponse });
            
            // ▼▼▼ 自动语音播放功能 ▼▼▼
            if (autoVoiceState.isEnabled && videoCallState.callType === 'voice') {
                // 为气泡添加语音功能标记和数据
                aiBubble.dataset.hasVoice = 'true';
                aiBubble.dataset.voiceText = sanitizedResponse;
                aiBubble.style.cursor = 'pointer';
                console.log('🎵 准备为AI气泡添加点击事件监听器');
                
                // 添加点击事件监听器
                aiBubble.addEventListener('click', async () => {
                    console.log('🎵 AI气泡被点击了！');
                    const chat = state.chats[videoCallState.activeChatId];
                    if (!chat) return;
                    
                    const minimaxVoiceId = chat.settings?.minimaxVoiceId;
                    if (!minimaxVoiceId) {
                        alert('该角色未设置语音ID');
                        return;
                    }
                    
                    await playVoiceMessageWithControl(aiBubble, sanitizedResponse, minimaxVoiceId);
                });
                
                // 自动播放语音
                handleAutoVoicePlayback(aiBubble, sanitizedResponse);
            }
            // ▲▲▲ 自动语音播放功能结束 ▲▲▲
        } else {
            if (videoCallState.isGroupCall) {
                const speechArray = parseAiResponse(sanitizedResponse); 
                speechArray.forEach(turn => {
                    if (!turn.name || turn.name === userNickname || !turn.speech) return;
                    const aiBubble = document.createElement('div');
                    aiBubble.className = 'call-message-bubble ai-speech';
                    // 格式化文本，将【】内容设置为灰色
                    const formattedSpeech = formatVoiceCallText(turn.speech);
                    aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${formattedSpeech}`;
                    callFeed.appendChild(aiBubble);
                    videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });
                    
                    // ▼▼▼ 自动语音播放功能 ▼▼▼
                    if (autoVoiceState.isEnabled && videoCallState.callType === 'voice') {
                        // 为气泡添加语音功能标记和数据
                        aiBubble.dataset.hasVoice = 'true';
                        aiBubble.dataset.voiceText = turn.speech;
                        aiBubble.style.cursor = 'pointer';
                        
                        // 添加点击事件监听器
                        aiBubble.addEventListener('click', async () => {
                            console.log('🎵 群聊AI气泡被点击了！');
                            const chat = state.chats[videoCallState.activeChatId];
                            if (!chat) return;
                            
                            const minimaxVoiceId = chat.settings?.minimaxVoiceId;
                            if (!minimaxVoiceId) {
                                alert('该角色未设置语音ID');
                                return;
                            }
                            
                            await playVoiceMessageWithControl(aiBubble, turn.speech, minimaxVoiceId);
                        });
                        
                        // 自动播放语音
                        handleAutoVoicePlayback(aiBubble, turn.speech);
                    }
                    // ▲▲▲ 自动语音播放功能结束 ▲▲▲
                    
                    const speaker = videoCallState.participants.find(p => p.originalName === turn.name);
                    if (speaker) {
                        const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                        if(speakingAvatar) {
                            speakingAvatar.classList.add('speaking');
                            setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                        }
                    }
                });
            } else {
                const aiBubble = document.createElement('div');
                aiBubble.className = 'call-message-bubble ai-speech';
                // 格式化文本，将【】内容设置为灰色
                aiBubble.innerHTML = formatVoiceCallText(sanitizedResponse);
                callFeed.appendChild(aiBubble);
                videoCallState.callHistory.push({ role: 'assistant', content: sanitizedResponse });
                
                // ▼▼▼ 自动语音播放功能 ▼▼▼
                if (autoVoiceState.isEnabled && videoCallState.callType === 'voice') {
                    // 为气泡添加语音功能标记和数据
                    aiBubble.dataset.hasVoice = 'true';
                    aiBubble.dataset.voiceText = sanitizedResponse;
                    aiBubble.style.cursor = 'pointer';
                    
                    // 添加点击事件监听器
                    aiBubble.addEventListener('click', async () => {
                        console.log('🎵 单人AI气泡被点击了！');
                        const chat = state.chats[videoCallState.activeChatId];
                        if (!chat) return;
                        
                        const minimaxVoiceId = chat.settings?.minimaxVoiceId;
                        if (!minimaxVoiceId) {
                            alert('该角色未设置语音ID');
                            return;
                        }
                        
                        await playVoiceMessageWithControl(aiBubble, sanitizedResponse, minimaxVoiceId);
                    });
                    
                    // 自动播放语音
                    handleAutoVoicePlayback(aiBubble, sanitizedResponse);
                }
                // ▲▲▲ 自动语音播放功能结束 ▲▲▲
                
                const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
                if(speakingAvatar) {
                    speakingAvatar.classList.add('speaking');
                    setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                }
            }
        }
        
        callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
        const errorBubble = document.createElement('div');
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = `[ERROR: ${error.message}]`;
        
        if (isVisualMode) {
            errorBubble.className = 'visual-call-bubble ai';
        } else {
            errorBubble.className = 'call-message-bubble ai-speech';
        }
        
        callFeed.appendChild(errorBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
    } finally {
        // 隐藏通话界面AI回复状态指示器
        hideCallAiReplyStatus();
    }
}

// ▼▼▼ 将这个【全新函数】粘贴到JS功能函数定义区 ▼▼▼
function toggleCallButtons(isGroup) {
    document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
    document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
}
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 【全新】这个函数是本次修复的核心，请粘贴到你的JS功能区 ▼▼▼
async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    const originalMessage = chat.history[messageIndex];
    
    // 如果选择付款，先检查钱包余额并扣费
    if (choice === 'paid') {
        const amount = originalMessage.amount;
        if (!amount || isNaN(amount)) {
            alert('订单金额无效，无法完成支付');
            return;
        }
        
        // 检查钱包余额并扣费
        const deductSuccess = await checkAndDeductWalletBalance(
            amount, 
            `为${originalMessage.senderName}外卖代付：${originalMessage.productInfo}`, 
            'waimai_payment'
        );
        
        if (!deductSuccess) {
            return; // 余额不足，终止支付
        }
    }

    // 1. 更新内存中原始消息的状态
    originalMessage.status = choice;
    
    // 2. 获取当前用户的昵称，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是"我"付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 3. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 4. 将更新后的数据保存到数据库，并立刻重绘UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    // 5. 【重要】只有在支付成功后，才触发一次AI响应，让它感谢你
    if (choice === 'paid') {
        triggerAiResponse();
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 【全新】处理用户点击头像发起的“拍一-拍”，带有自定义后缀功能
 * @param {string} chatId - 发生“拍一-拍”的聊天ID
 * @param {string} characterName - 被拍的角色名
 */
async function handleUserPat(chatId, characterName) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 触发屏幕震动动画
    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');
    setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);

    // 2. 弹出输入框让用户输入后缀
    const suffix = await showCustomPrompt(
        `你拍了拍 “${characterName}”`, 
        "（可选）输入后缀",
        "",
        "text"
    );

    // 如果用户点了取消，则什么也不做
    if (suffix === null) return;

    // 3. 创建对用户可见的“拍一-拍”消息
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    // 【核心修改】将后缀拼接到消息内容中
    const visibleMessageContent = `${myNickname} 拍了拍 “${characterName}” ${suffix.trim()}`;
    const visibleMessage = {
        role: 'system', // 仍然是系统消息
        type: 'pat_message',
        content: visibleMessageContent,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 4. 创建一条对用户隐藏、但对AI可见的系统消息，以触发AI的回应
    // 【核心修改】同样将后缀加入到给AI的提示中
    const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterName}）${suffix.trim()}。请你对此作出回应。]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 1, // 时间戳+1以保证顺序
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 5. 保存更改并更新UI
    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
        appendMessage(visibleMessage, chat);
    }
    await renderChatList();
}

// ▼▼▼ 请用这个【逻辑重构后】的函数，完整替换掉你旧的 renderMemoriesScreen 函数 ▼▼▼
/**
 * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
 */
async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';
    
    // 1. 获取所有回忆，并按目标日期（如果是约定）或创建日期（如果是回忆）降序排列
    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
    
    if (allMemories.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
        return;
    }

    // 2. 将未到期的约定排在最前面
    allMemories.sort((a, b) => {
        const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
        const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
        if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
        if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // b排前面
        if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 都是倒计时，按日期升序
        return 0; // 其他情况保持原序
    });

    // 3. 【核心】使用单一循环来处理所有类型的卡片
    allMemories.forEach(item => {
        let card;
        // 判断1：如果是正在进行的约定
        if (item.type === 'countdown' && item.targetDate > Date.now()) {
            card = createCountdownCard(item);
        } 
        // 判断2：其他所有情况（普通回忆 或 已到期的约定）
        else {
            card = createMemoryCard(item);
        }
        listEl.appendChild(card);
    });
    
    // 4. 启动所有倒计时
    startAllCountdownTimers();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 创建普通回忆卡片DOM元素
 */
function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
    
    let titleHtml, contentHtml;

    // 【核心修正】在这里，我们对不同类型的回忆进行清晰的区分
    if (memory.type === 'countdown' && memory.targetDate) {
        // 如果是已到期的约定
        titleHtml = `[约定达成] ${memory.description}`;
        contentHtml = `在 ${new Date(memory.targetDate).toLocaleString()}，我们一起见证了这个约定。`;
    } else {
        // 如果是普通的日记式回忆
        titleHtml = memory.authorName ? `${memory.authorName} 的日记` : '我们的回忆';
        contentHtml = memory.description;
    }

    card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除记录', '确定要删除这条记录吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(memory.id);
            renderMemoriesScreen();
        }
    });
    return card;
}

function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';

    // 【核心修复】在使用前，先从 countdown 对象中创建 targetDate 变量
    const targetDate = new Date(countdown.targetDate);
    
    // 现在可以安全地使用 targetDate 了
    const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

    card.innerHTML = `
        <div class="title">${countdown.description}</div>
        <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
        <div class="target-date">目标时间: ${targetDateString}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除约定', '确定要删除这个约定吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(countdown.id);
            renderMemoriesScreen();
        }
    });
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲

// 全局变量，用于管理所有倒计时
let activeCountdownTimers = [];

// ▼▼▼ 请用这个【已彻底修复】的函数，完整替换掉你代码中旧的 startAllCountdownTimers 函数 ▼▼▼
function startAllCountdownTimers() {
    // 先清除所有可能存在的旧计时器，防止内存泄漏
    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
        const targetTimestamp = parseInt(timerEl.dataset.targetDate);
        
        // 【核心修正】在这里，我们先用 let 声明 timerId
        let timerId;

        const updateTimer = () => {
            const now = Date.now();
            const distance = targetTimestamp - now;

            if (distance < 0) {
                timerEl.textContent = "约定达成！";
                // 现在 updateTimer 可以正确地找到并清除它自己了
                clearInterval(timerId);
                setTimeout(() => renderMemoriesScreen(), 2000);
                return;
            }
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
        };
        
        updateTimer(); // 立即执行一次以显示初始倒计时
        
        // 【核心修正】在这里，我们为已声明的 timerId 赋值
        timerId = setInterval(updateTimer, 1000);
        
        // 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
        activeCountdownTimers.push(timerId);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】回忆页面功能函数 ▼▼▼

// 显示主选择界面
function showMemoriesMainSelection() {
    document.getElementById('memories-main-selection').style.display = 'flex';
    document.getElementById('love-space-view').style.display = 'none';
    document.getElementById('private-space-view').style.display = 'none';
    
    // 记录用户当前在主选择界面
    localStorage.setItem('lastActiveSpace', 'main-selection');
    
    // 隐藏所有子相册相关的弹窗和设置
    document.getElementById('album-settings-menu').style.display = 'none';
    document.getElementById('delete-album-confirm').style.display = 'none';
    document.getElementById('contact-binding-dialog').style.display = 'none';
    document.getElementById('love-settings-modal').style.display = 'none';
    
    // 【修复】返回回忆页面时移除on-chat-list-screen类，因为回忆页面不是QQ主页面
    // 这样导航栏会按照正常的页面切换逻辑显示/隐藏
    document.body.classList.remove('on-chat-list-screen');
}

// 关闭解除关系弹窗
function closeBreakupModal() {
    document.getElementById('love-settings-modal').style.display = 'none';
}

// 确认解除恋爱关系
function confirmBreakup() {
    // 二次确认
    if (!confirm('确定要解除恋爱关系吗？\n\n此操作将清空所有打卡记录，且不可撤销！')) {
        return;
    }
    
    try {
        // ★★★ 核心功能4：彻底清除所有打卡相关数据 ★★★
        
        // 1. 清空主要打卡记录
        localStorage.removeItem('loveSpaceCheckinData');
        localStorage.removeItem('checkinHistory');
        localStorage.removeItem('myCheckinDays');
        localStorage.removeItem('partnerCheckinDays');
        
        // 2. 清空AI活动打卡记录（彻底清除）
        const today = new Date().toDateString();
        const keysToRemove = [];
        
        // 遍历localStorage查找所有AI活动数据
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('aiActivity_')) {
                keysToRemove.push(key);
            }
        }
        
        // 删除所有AI活动数据
        keysToRemove.forEach(key => localStorage.removeItem(key));
        console.log(`清除了${keysToRemove.length}个AI活动打卡数据`);
        
        // 3. 清空恋爱空间绑定信息
        const boundCharId = localStorage.getItem('loveSpaceBoundChar');
        if (boundCharId) {
            localStorage.removeItem('loveSpaceBoundChar');
            localStorage.removeItem(`loveSpaceBindDate_${boundCharId}`);
            
            // 4. 清空该角色聊天记录中的所有打卡卡片消息
            if (state.chats[boundCharId] && state.chats[boundCharId].history) {
                const originalLength = state.chats[boundCharId].history.length;
                // 过滤掉所有打卡卡片消息
                state.chats[boundCharId].history = state.chats[boundCharId].history.filter(msg => 
                    msg.type !== 'checkin-card'
                );
                const newLength = state.chats[boundCharId].history.length;
                console.log(`从聊天记录中删除了${originalLength - newLength}条打卡消息`);
                
                // 保存到数据库
                db.chats.put(state.chats[boundCharId]);
            }
        }
        
        // 5. 清空头像设置（但保留原始头像）
        localStorage.removeItem('loveSpaceUserAvatar');
        localStorage.removeItem('loveSpaceAIAvatar');
        
        // 6. 清空壁纸设置
        localStorage.removeItem('loveSpaceHomeWallpaper');
        localStorage.removeItem('loveSpaceChatWallpaper');
        
        // 5. 关闭弹窗
        document.getElementById('love-settings-modal').style.display = 'none';
        
        // 7. 显示成功消息并返回主界面
        alert('恋爱关系已解除\n\n✅ 已彻底清空：\n• 所有打卡记录和历史\n• 聊天中的打卡卡片消息\n• AI活动打卡数据\n• 恋爱空间设置\n\n📸 相册照片已保留');
        
        // 7. 返回主选择界面
        showMemoriesMainSelection();
        
        // 8. 更新头像显示（隐藏所有头像）
        loadSavedAvatars();
        
        // 9. 重新初始化恋爱空间（清空状态）
        setTimeout(() => {
            initLoveSpace();
        }, 100);
        
    } catch (error) {
        console.error('解除关系时出错:', error);
        alert('解除关系时出现错误，请重试');
    }
}

// ==================== DIY装饰相关函数 ====================

// DIY装饰功能相关变量
let isDIYMode = false;
let decorationItems = [];
let selectedDecoration = null;
let dragStartX = 0;
let dragStartY = 0;
let isDragging = false;

// 保存DIY布局到IndexedDB
async function saveDIYLayout() {
    try {
        console.log('💾 [saveDIYLayout] 开始保存到IndexedDB，装饰数量:', decorationItems.length);
        
        // 清空现有数据
        await db.diyDecorations.clear();
        
        // 保存新数据
        if (decorationItems.length > 0) {
            const decorationsWithTimestamp = decorationItems.map(item => ({
                ...item,
                createdAt: new Date().toISOString()
            }));
            
            await db.diyDecorations.bulkAdd(decorationsWithTimestamp);
            console.log('✅ [saveDIYLayout] IndexedDB保存成功，保存了', decorationsWithTimestamp.length, '个装饰');
        } else {
            console.log('✅ [saveDIYLayout] 清空IndexedDB中的装饰数据');
        }
        
        // 同时保存到localStorage作为备份
        localStorage.setItem('loveSpaceDIYLayout', JSON.stringify(decorationItems));
        console.log('✅ [saveDIYLayout] localStorage备份保存成功');
        
    } catch (error) {
        console.error('❌ [saveDIYLayout] IndexedDB保存失败，尝试localStorage:', error);
        // 如果IndexedDB失败，至少保存到localStorage
        try {
            localStorage.setItem('loveSpaceDIYLayout', JSON.stringify(decorationItems));
            console.log('✅ [saveDIYLayout] localStorage备用保存成功');
        } catch (localError) {
            console.error('❌ [saveDIYLayout] localStorage保存也失败:', localError);
        }
    }
}

// ==================== DIY装饰辅助函数 ====================

// 选中装饰元素
function selectDecoration(item) {
    // 取消之前的选中
    if (selectedDecoration) {
        selectedDecoration.classList.remove('selected');
    }
    
    // 选中当前元素
    selectedDecoration = item;
    item.classList.add('selected');
}

// 拖拽处理
function handleDrag(e) {
    if (!isDragging || !selectedDecoration) return;
    
    // 获取正确的坐标（鼠标或触摸）
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    const newX = clientX - dragStartX;
    const newY = clientY - dragStartY;
    
    selectedDecoration.style.left = Math.max(0, newX) + 'px';
    selectedDecoration.style.top = Math.max(0, newY) + 'px';
    
    // 更新数据
    const decorationData = decorationItems.find(d => d.id === selectedDecoration.id);
    if (decorationData) {
        decorationData.x = newX;
        decorationData.y = newY;
    }
}

// 结束拖拽
async function handleDragEnd() {
    isDragging = false;
    document.removeEventListener('mousemove', handleDrag);
    document.removeEventListener('mouseup', handleDragEnd);
    document.removeEventListener('touchmove', handleDrag);
    document.removeEventListener('touchend', handleDragEnd);
    
    // 自动保存布局
    await saveDIYLayout();
}

// 开始调整大小
function startResize(e, item, decorationData, direction) {
    isResizing = true;
    resizeDirection = direction;
    resizeItem = item;
    resizeData = decorationData;
    
    // 获取正确的坐标（鼠标或触摸）
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    resizeStartX = clientX;
    resizeStartY = clientY;
    resizeStartWidth = parseInt(item.style.width);
    resizeStartHeight = parseInt(item.style.height);
    
    document.addEventListener('mousemove', handleResize);
    document.addEventListener('mouseup', handleResizeEnd);
    document.addEventListener('touchmove', handleResize, { passive: false });
    document.addEventListener('touchend', handleResizeEnd);
}

// 处理调整大小
function handleResize(e) {
    if (!isResizing || !resizeItem) return;
    
    // 获取正确的坐标（鼠标或触摸）
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    const deltaX = clientX - resizeStartX;
    const deltaY = clientY - resizeStartY;
    
    let newWidth = resizeStartWidth;
    let newHeight = resizeStartHeight;
    let newLeft = parseInt(resizeItem.style.left);
    let newTop = parseInt(resizeItem.style.top);
    
    // 根据拖拽方向调整大小和位置
    switch (resizeDirection) {
        case 'nw': // 左上角
            newWidth = Math.max(20, resizeStartWidth - deltaX);
            newHeight = Math.max(20, resizeStartHeight - deltaY);
            newLeft = parseInt(resizeItem.style.left) + (resizeStartWidth - newWidth);
            newTop = parseInt(resizeItem.style.top) + (resizeStartHeight - newHeight);
            break;
        case 'ne': // 右上角
            newWidth = Math.max(20, resizeStartWidth + deltaX);
            newHeight = Math.max(20, resizeStartHeight - deltaY);
            newTop = parseInt(resizeItem.style.top) + (resizeStartHeight - newHeight);
            break;
        case 'sw': // 左下角
            newWidth = Math.max(20, resizeStartWidth - deltaX);
            newHeight = Math.max(20, resizeStartHeight + deltaY);
            newLeft = parseInt(resizeItem.style.left) + (resizeStartWidth - newWidth);
            break;
        case 'se': // 右下角
            newWidth = Math.max(20, resizeStartWidth + deltaX);
            newHeight = Math.max(20, resizeStartHeight + deltaY);
            break;
    }
    
    // 应用新的大小和位置
    resizeItem.style.width = newWidth + 'px';
    resizeItem.style.height = newHeight + 'px';
    resizeItem.style.left = newLeft + 'px';
    resizeItem.style.top = newTop + 'px';
    
    // 更新数据
    if (resizeData) {
        resizeData.width = newWidth;
        resizeData.height = newHeight;
        resizeData.x = newLeft;
        resizeData.y = newTop;
    }
}

// 结束调整大小
function handleResizeEnd() {
    isResizing = false;
    resizeItem = null;
    resizeData = null;
    document.removeEventListener('mousemove', handleResize);
    document.removeEventListener('mouseup', handleResizeEnd);
    document.removeEventListener('touchmove', handleResize);
    document.removeEventListener('touchend', handleResizeEnd);
    
    // 自动保存布局
    saveDIYLayout();
}

// 开始旋转
function startRotate(e, item, decorationData) {
    isRotating = true;
    rotateItem = item;
    rotateData = decorationData;
    
    const rect = item.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    // 获取正确的坐标（鼠标或触摸）
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    rotateStartAngle = Math.atan2(clientY - centerY, clientX - centerX) * 180 / Math.PI;
    rotateCurrentRotation = decorationData.rotation || 0;
    
    document.addEventListener('mousemove', handleRotate);
    document.addEventListener('mouseup', handleRotateEnd);
    document.addEventListener('touchmove', handleRotate, { passive: false });
    document.addEventListener('touchend', handleRotateEnd);
}

// 处理旋转
function handleRotate(e) {
    if (!isRotating || !rotateItem) return;
    
    const rect = rotateItem.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    // 获取正确的坐标（鼠标或触摸）
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    const currentAngle = Math.atan2(clientY - centerY, clientX - centerX) * 180 / Math.PI;
    const deltaAngle = currentAngle - rotateStartAngle;
    const newRotation = rotateCurrentRotation + deltaAngle;
    
    // 应用旋转
    const transform = rotateItem.style.transform;
    const scaleMatch = transform.match(/scaleX\([^)]+\)\s*scaleY\([^)]+\)/);
    const scaleTransform = scaleMatch ? scaleMatch[0] : 'scaleX(1) scaleY(1)';
    
    rotateItem.style.transform = `rotate(${newRotation}deg) ${scaleTransform}`;
    
    // 更新数据
    if (rotateData) {
        rotateData.rotation = newRotation;
    }
}

// 结束旋转
function handleRotateEnd() {
    isRotating = false;
    rotateItem = null;
    rotateData = null;
    document.removeEventListener('mousemove', handleRotate);
    document.removeEventListener('mouseup', handleRotateEnd);
    document.removeEventListener('touchmove', handleRotate);
    document.removeEventListener('touchend', handleRotateEnd);
    
    // 自动保存布局
    saveDIYLayout();
}

// 移动层级 - 基于图片之间的相对层级
function moveLayer(item, decorationData, direction) {
    // 获取所有装饰图片的层级信息
    const allItems = decorationItems.map(d => ({
        id: d.id,
        element: document.getElementById(d.id),
        zIndex: parseInt(d.zIndex) || 0
    })).filter(item => item.element);
    
    // 按z-index排序
    allItems.sort((a, b) => a.zIndex - b.zIndex);
    
    // 找到当前元素在排序后数组中的位置
    const currentIndex = allItems.findIndex(d => d.id === decorationData.id);
    
    if (currentIndex === -1) return;
    
    let targetIndex;
    if (direction === 'up') {
        // 上移一层：与上一个元素交换位置
        targetIndex = Math.min(currentIndex + 1, allItems.length - 1);
    } else {
        // 下移一层：与下一个元素交换位置
        targetIndex = Math.max(currentIndex - 1, 0);
    }
    
    if (targetIndex === currentIndex) return; // 已经在最顶层或最底层
    
    // 交换z-index值
    const currentItem = allItems[currentIndex];
    const targetItem = allItems[targetIndex];
    
    const tempZ = currentItem.zIndex;
    currentItem.zIndex = targetItem.zIndex;
    targetItem.zIndex = tempZ;
    
    // 应用新的z-index
    currentItem.element.style.zIndex = currentItem.zIndex;
    targetItem.element.style.zIndex = targetItem.zIndex;
    
    // 更新数据
    const currentData = decorationItems.find(d => d.id === currentItem.id);
    const targetData = decorationItems.find(d => d.id === targetItem.id);
    
    if (currentData) currentData.zIndex = currentItem.zIndex;
    if (targetData) targetData.zIndex = targetItem.zIndex;
    
    console.log(`${direction === 'up' ? '上移' : '下移'}层级: ${decorationData.id} (z-index: ${currentItem.zIndex})`);
    
    // 自动保存布局
    saveDIYLayout();
}

// 翻转装饰
function flipDecoration(item, decorationData, direction) {
    if (direction === 'horizontal') {
        decorationData.flipH = !decorationData.flipH;
    } else {
        decorationData.flipV = !decorationData.flipV;
    }
    
    item.style.transform = `rotate(${decorationData.rotation}deg) scaleX(${decorationData.flipH ? -1 : 1}) scaleY(${decorationData.flipV ? -1 : 1})`;
    
    // 自动保存布局
    saveDIYLayout();
}

// 旋转装饰
function rotateDecoration(item, decorationData) {
    decorationData.rotation = (decorationData.rotation + 90) % 360;
    item.style.transform = `rotate(${decorationData.rotation}deg) scaleX(${decorationData.flipH ? -1 : 1}) scaleY(${decorationData.flipV ? -1 : 1})`;
    
    // 自动保存布局
    saveDIYLayout();
}

// 删除装饰
function deleteDecoration(item, decorationData) {
    if (confirm('确定要删除这个装饰吗？')) {
        item.remove();
        const index = decorationItems.findIndex(d => d.id === decorationData.id);
        if (index > -1) {
            decorationItems.splice(index, 1);
        }
        if (selectedDecoration === item) {
            selectedDecoration = null;
        }
        
        // 自动保存布局
        saveDIYLayout();
    }
}

// 调整大小
function resizeDecoration(item, decorationData) {
    const newWidth = prompt('请输入新的宽度（像素）:', decorationData.width);
    const newHeight = prompt('请输入新的高度（像素）:', decorationData.height);
    
    if (newWidth && newHeight) {
        const width = parseInt(newWidth);
        const height = parseInt(newHeight);
        
        if (width > 0 && height > 0 && width <= 500 && height <= 500) {
            item.style.width = width + 'px';
            item.style.height = height + 'px';
            decorationData.width = width;
            decorationData.height = height;
        } else {
            alert('请输入有效的尺寸（1-500像素）');
        }
    }
}

// 绑定装饰元素事件
function bindDecorationEvents(item, decorationData) {
    // 点击选中
    item.addEventListener('click', (e) => {
        if (!isDIYMode) return;
        e.stopPropagation();
        selectDecoration(item);
    });
    
    // 拖拽功能（只对主体区域有效，不包括控制点）- 支持鼠标和触摸
    const startDrag = (e) => {
        if (!isDIYMode) return;
        
        // 如果点击的是控制点，不执行拖拽
        if (e.target.classList.contains('resize-handle') || 
            e.target.classList.contains('rotate-handle') ||
            e.target.closest('.decoration-controls')) {
            return;
        }
        
        e.preventDefault();
        e.stopPropagation();
        
        selectDecoration(item);
        isDragging = true;
        
        // 获取正确的坐标（鼠标或触摸）
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        dragStartX = clientX - item.offsetLeft;
        dragStartY = clientY - item.offsetTop;
        
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchmove', handleDrag, { passive: false });
        document.addEventListener('touchend', handleDragEnd);
    };
    
    item.addEventListener('mousedown', startDrag);
    item.addEventListener('touchstart', startDrag, { passive: false });
    
    // 调整大小功能 - 支持鼠标和触摸
    const resizeHandles = item.querySelectorAll('.resize-handle');
    resizeHandles.forEach(handle => {
        const handleResizeStart = (e) => {
            if (!isDIYMode) return;
            e.preventDefault();
            e.stopPropagation();
            
            selectDecoration(item);
            startResize(e, item, decorationData, handle.dataset.direction);
        };
        
        handle.addEventListener('mousedown', handleResizeStart);
        handle.addEventListener('touchstart', handleResizeStart, { passive: false });
    });
    
    // 旋转功能 - 支持鼠标和触摸
    const rotateHandle = item.querySelector('.rotate-handle');
    const handleRotateStart = (e) => {
        if (!isDIYMode) return;
        e.preventDefault();
        e.stopPropagation();
        
        selectDecoration(item);
        startRotate(e, item, decorationData);
    };
    
    rotateHandle.addEventListener('mousedown', handleRotateStart);
    rotateHandle.addEventListener('touchstart', handleRotateStart, { passive: false });
    
    // 控制按钮事件
    const controls = item.querySelector('.decoration-controls');
    
    // 层级控制
    controls.querySelector('.layer-up-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        moveLayer(item, decorationData, 'up');
    });
    
    controls.querySelector('.layer-down-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        moveLayer(item, decorationData, 'down');
    });
    
    // 翻转控制
    controls.querySelector('.flip-h-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        flipDecoration(item, decorationData, 'horizontal');
    });
    
    controls.querySelector('.flip-v-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        flipDecoration(item, decorationData, 'vertical');
    });
    
    // 旋转控制
    controls.querySelector('.rotate-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        rotateDecoration(item, decorationData);
    });
    
    // 删除控制
    controls.querySelector('.delete-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        deleteDecoration(item, decorationData);
    });
    
    // 双击调整大小
    item.addEventListener('dblclick', (e) => {
        if (!isDIYMode) return;
        e.stopPropagation();
        resizeDecoration(item, decorationData);
    });
}

// 添加装饰元素
async function addDecorationItem(url, width, height, x = 100, y = 100, rotation = 0, flipH = false, flipV = false, zIndex = null, autoSave = true) {
    console.log('🎨 [addDecorationItem] 开始添加装饰:', { url, width, height, x, y, autoSave });
    console.log('🎨 [addDecorationItem] 当前decorationItems数量:', decorationItems.length);
    
    const decorationLayer = document.getElementById('diy-decoration-layer');
    const item = document.createElement('div');
    item.className = 'decoration-item';
    
    // 生成唯一ID
    const itemId = 'decoration-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    item.id = itemId;
    
    // 设置样式
    item.style.left = x + 'px';
    item.style.top = y + 'px';
    item.style.width = width + 'px';
    item.style.height = height + 'px';
    item.style.transform = `rotate(${rotation}deg) scaleX(${flipH ? -1 : 1}) scaleY(${flipV ? -1 : 1})`;
    
    // 设置z-index - 如果没有指定，则设置为当前最高层级+1
    if (zIndex !== null) {
        item.style.zIndex = zIndex;
    } else {
        // 找到当前最高的z-index
        const maxZ = Math.max(0, ...decorationItems.map(d => parseInt(d.zIndex) || 0));
        item.style.zIndex = maxZ + 1;
    }
    
    // 创建图片
    const img = document.createElement('img');
    img.src = url;
    img.alt = '装饰图片';
    img.draggable = false;
    
    // 创建控制按钮
    const controls = document.createElement('div');
    controls.className = 'decoration-controls';
    controls.innerHTML = `
        <button class="control-btn layer-up-btn" title="上移一层">↑</button>
        <button class="control-btn layer-down-btn" title="下移一层">↓</button>
        <button class="control-btn flip-h-btn" title="水平翻转">⟷</button>
        <button class="control-btn flip-v-btn" title="垂直翻转">⟷</button>
        <button class="control-btn rotate-btn" title="旋转90°">↻</button>
        <button class="control-btn delete-btn" title="删除">×</button>
    `;
    
    // 创建调整大小控制点
    const resizeHandles = document.createElement('div');
    resizeHandles.innerHTML = `
        <div class="resize-handle nw" data-direction="nw"></div>
        <div class="resize-handle ne" data-direction="ne"></div>
        <div class="resize-handle sw" data-direction="sw"></div>
        <div class="resize-handle se" data-direction="se"></div>
    `;
    
    // 创建旋转控制点
    const rotateHandle = document.createElement('div');
    rotateHandle.className = 'rotate-handle';
    rotateHandle.title = '拖拽旋转';
    
    item.appendChild(img);
    item.appendChild(controls);
    item.appendChild(resizeHandles);
    item.appendChild(rotateHandle);
    decorationLayer.appendChild(item);
    
    // 保存到数组
    const decorationData = {
        id: itemId,
        url: url,
        x: x,
        y: y,
        width: width,
        height: height,
        rotation: rotation,
        flipH: flipH,
        flipV: flipV,
        zIndex: item.style.zIndex || 'auto'
    };
    decorationItems.push(decorationData);
    
    console.log('🎨 [addDecorationItem] 装饰数据已添加，新的数量:', decorationItems.length);
    console.log('🎨 [addDecorationItem] 添加的装饰数据:', decorationData);
    
    // 绑定事件
    bindDecorationEvents(item, decorationData);
    
    // 只在需要时自动保存布局到localStorage
    if (autoSave) {
        console.log('🎨 [addDecorationItem] 开始自动保存...');
        await saveDIYLayout();
        
        // 验证保存结果
        setTimeout(() => {
            const saved = localStorage.getItem('loveSpaceDIYLayout');
            if (saved) {
                try {
                    const savedData = JSON.parse(saved);
                    console.log('✅ [addDecorationItem] 保存验证成功，localStorage中装饰数量:', savedData.length);
                    console.log('✅ [addDecorationItem] localStorage数据:', savedData);
                } catch (e) {
                    console.error('❌ [addDecorationItem] localStorage数据解析失败:', e);
                }
            } else {
                console.error('❌ [addDecorationItem] localStorage中没有数据！');
            }
        }, 100);
    }
    
    return item;
}

// 从IndexedDB加载DIY布局
async function loadDIYLayout() {
    try {
        console.log('🔄 [loadDIYLayout] 开始从IndexedDB加载装饰...');
        
        // 检查DOM元素
        const decorationLayer = document.getElementById('diy-decoration-layer');
        console.log('🔄 [loadDIYLayout] 装饰层元素:', decorationLayer ? '存在' : '不存在');
        
        if (!decorationLayer) {
            console.error('❌ [loadDIYLayout] 装饰层元素不存在，无法加载装饰');
            return;
        }
        
        // 首先尝试从IndexedDB加载
        let layoutData = [];
        try {
            layoutData = await db.diyDecorations.orderBy('createdAt').toArray();
            console.log('🔄 [loadDIYLayout] 从IndexedDB加载到', layoutData.length, '个装饰');
            
            if (layoutData.length > 0) {
                console.log('🔄 [loadDIYLayout] IndexedDB数据预览:', layoutData.map(d => ({
                    id: d.id,
                    url: d.url.substring(0, 50) + '...',
                    x: d.x,
                    y: d.y,
                    width: d.width,
                    height: d.height
                })));
            }
        } catch (dbError) {
            console.warn('⚠️ [loadDIYLayout] IndexedDB加载失败，尝试localStorage:', dbError);
            
            // 如果IndexedDB失败，尝试从localStorage加载
            const savedLayout = localStorage.getItem('loveSpaceDIYLayout');
            if (savedLayout) {
                try {
                    layoutData = JSON.parse(savedLayout);
                    console.log('🔄 [loadDIYLayout] 从localStorage备份加载到', layoutData.length, '个装饰');
                } catch (parseError) {
                    console.error('❌ [loadDIYLayout] localStorage数据解析失败:', parseError);
                    layoutData = [];
                }
            }
        }
        
        // 只有在成功获取到数据后才清空现有显示
        if (layoutData.length > 0) {
            console.log('🔄 [loadDIYLayout] 开始恢复装饰元素...');
            
            // 清空现有数据
            decorationItems = [];
            decorationLayer.innerHTML = '';
            
            // 重新创建装饰元素（加载时不自动保存）
            for (let i = 0; i < layoutData.length; i++) {
                const data = layoutData[i];
                console.log(`🔄 [loadDIYLayout] 恢复装饰 ${i + 1}/${layoutData.length}:`, data.url);
                
                try {
                    await addDecorationItem(
                        data.url,
                        data.width,
                        data.height,
                        data.x,
                        data.y,
                        data.rotation || 0,
                        data.flipH || false,
                        data.flipV || false,
                        data.zIndex,
                        false  // 加载时不自动保存
                    );
                } catch (itemError) {
                    console.error(`❌ [loadDIYLayout] 恢复装饰 ${i + 1} 失败:`, itemError);
                    // 继续加载其他装饰，不中断整个流程
                }
            }
            
            console.log('✅ [loadDIYLayout] 装饰恢复完成，当前装饰数量:', decorationItems.length);
        } else {
            console.log('ℹ️ [loadDIYLayout] 没有找到保存的装饰数据，保持现有装饰不变');
        }
        
    } catch (error) {
        console.error('❌ [loadDIYLayout] 加载装饰失败:', error);
        console.log('⚠️ [loadDIYLayout] 保持现有装饰数据，不清空');
    }
}

// 点击空白区域取消选中
document.addEventListener('click', (e) => {
    if (isDIYMode && selectedDecoration && !e.target.closest('.decoration-item')) {
        selectedDecoration.classList.remove('selected');
        selectedDecoration = null;
    }
});

// 显示恋爱空间
function showLoveSpace() {
    document.getElementById('memories-main-selection').style.display = 'none';
    document.getElementById('love-space-view').style.display = 'flex';
    document.getElementById('private-space-view').style.display = 'none';
    
    // 记录用户当前在恋爱空间
    localStorage.setItem('lastActiveSpace', 'love-space');
    
    // 隐藏所有子相册相关的弹窗和设置
    document.getElementById('album-settings-menu').style.display = 'none';
    document.getElementById('delete-album-confirm').style.display = 'none';
    document.getElementById('contact-binding-dialog').style.display = 'none';
    document.getElementById('love-settings-modal').style.display = 'none';
    
    // 确保在恋爱空间时隐藏QQ主页导航栏
    document.body.classList.remove('on-chat-list-screen');
    
    // 更新绑定按钮状态
    updateBindCharButton();
    
    // ★★★ 初始化恋爱空间功能 ★★★
    initLoveSpace();
    
    // ★★★ 初始化打卡功能 ★★★
    initLoveSpaceCheckin();
    
    // ★★★ 加载DIY装饰布局 ★★★
    setTimeout(() => {
        console.log('🎨 [showLoveSpace] 加载DIY装饰布局...');
        loadDIYLayout().catch(error => {
            console.error('❌ [showLoveSpace] 加载DIY装饰失败:', error);
        });
    }, 100);
    
    // 初始化壁纸 - 延迟执行确保DOM渲染完成
    setTimeout(() => {
        console.log('showLoveSpace: 开始初始化壁纸...');
        
        // 直接应用保存的壁纸
        const homeWallpaper = localStorage.getItem(HOME_WALLPAPER_KEY);
        const navWallpaper = localStorage.getItem(CHAT_WALLPAPER_KEY);
        
        console.log('showLoveSpace壁纸数据:', { 
            homeWallpaper: homeWallpaper ? homeWallpaper.substring(0, 50) + '...' : null, 
            navWallpaper: navWallpaper ? navWallpaper.substring(0, 50) + '...' : null 
        });
        
        if (homeWallpaper) {
            console.log('showLoveSpace：应用主页壁纸');
            addOrUpdateWallpaperStyle('home', homeWallpaper);
        }
        
        if (navWallpaper) {
            console.log('showLoveSpace：应用导航栏壁纸');
            addOrUpdateWallpaperStyle('nav', navWallpaper);
        }
        
        console.log('showLoveSpace壁纸初始化完成');
    }, 200);
    
    // 默认显示主页
    switchLovePage('home');
}

// 应用保存的私人空间壁纸设置
function applyStoredWallpapers() {
    console.log('开始应用保存的壁纸设置...');
    
    const headerBg = localStorage.getItem('private-header-bg');
    const navBg = localStorage.getItem('private-nav-bg');
    const contentBg = localStorage.getItem('private-content-bg');
    
    console.log('保存的壁纸设置:', { headerBg, navBg, contentBg });
    
    // 使用更可靠的方式等待元素加载
    const applyWithRetry = (selector, bgUrl, name) => {
        let attempts = 0;
        const maxAttempts = 10;
        
        const tryApply = () => {
            const element = document.querySelector(selector);
            if (element) {
                element.style.backgroundImage = `url(${bgUrl})`;
                element.style.backgroundSize = 'cover';
                element.style.backgroundPosition = 'center';
                console.log(`${name}背景已应用:`, bgUrl);
                return true;
            } else {
                attempts++;
                if (attempts < maxAttempts) {
                    console.log(`${name}元素未找到，重试中... (${attempts}/${maxAttempts})`);
                    setTimeout(tryApply, 100);
                } else {
                    console.error(`未找到 ${selector} 元素，已达到最大重试次数`);
                }
                return false;
            }
        };
        
        tryApply();
    };
    
    if (headerBg) {
        applyWithRetry('.private-space-header-box', headerBg, '头部');
    }
    
    if (navBg) {
        applyWithRetry('.private-space-nav-box', navBg, '导航栏');
    }
    
    if (contentBg) {
        applyWithRetry('.private-space-content', contentBg, '内容区域');
    }
    
    console.log('壁纸设置应用完成');
}

// 应用私人空间壁纸设置
window.applyPrivateSpaceWallpapers = function() {
    console.log('开始应用私人空间壁纸设置...');
    
    if (!currentPrivateSpaceContactId) {
        console.log('没有当前私人空间联系人ID，跳过壁纸应用');
        return;
    }
    
    // 从当前角色的数据中获取壁纸设置
    const dataKey = `privateSpace_${currentPrivateSpaceContactId}`;
    const savedData = localStorage.getItem(dataKey);
    let wallpaperSettings = {};
    
    if (savedData) {
        const data = JSON.parse(savedData);
        wallpaperSettings = data.wallpaperSettings || {};
    }
    
    const headerBg = wallpaperSettings.header;
    const navBg = wallpaperSettings.nav;
    const contentBg = wallpaperSettings.content;
    
    console.log('私人空间壁纸设置:', { headerBg, navBg, contentBg });
    
    // 使用更可靠的方式等待元素加载
    const applyWithRetry = (selector, bgUrl, name) => {
        let attempts = 0;
        const maxAttempts = 10;
        
        const tryApply = () => {
            const element = document.querySelector(selector);
            if (element) {
                if (bgUrl) {
                    element.style.backgroundImage = `url(${bgUrl})`;
                    element.style.backgroundSize = 'cover';
                    element.style.backgroundPosition = 'center';
                    console.log(`私人空间${name}背景已应用:`, bgUrl);
                } else {
                    element.style.backgroundImage = '';
                    console.log(`私人空间${name}背景已清除`);
                }
                return true;
            } else {
                attempts++;
                if (attempts < maxAttempts) {
                    console.log(`私人空间${name}元素未找到，重试中... (${attempts}/${maxAttempts})`);
                    setTimeout(tryApply, 100);
                } else {
                    console.error(`未找到私人空间 ${selector} 元素，已达到最大重试次数`);
                }
                return false;
            }
        };
        
        tryApply();
    };
    
    // 应用或清除背景
    applyWithRetry('.private-space-header-box', headerBg, '头部');
    applyWithRetry('.private-space-nav-box', navBg, '导航栏');
    applyWithRetry('.private-space-content', contentBg, '内容区域');
    
    console.log('私人空间壁纸设置应用完成');
};

// 显示私人空间
function showPrivateSpace() {
    document.getElementById('memories-main-selection').style.display = 'none';
    document.getElementById('love-space-view').style.display = 'none';
    document.getElementById('private-space-view').style.display = 'flex';
    
    // 记录用户当前在私人空间
    localStorage.setItem('lastActiveSpace', 'private-space');
    
    // 确保在私人空间时隐藏QQ主页导航栏
    document.body.classList.remove('on-chat-list-screen');
    
    // 初始化私人空间
    initPrivateSpace();
    
    // 加载当前联系人的数据
    window.loadPrivateSpaceData();
    
    // 确保私人相册也重新渲染
    setTimeout(() => {
        if (typeof renderPrivateAlbum === 'function') {
            renderPrivateAlbum();
        }
    }, 100);
    
    console.log('私人空间已显示，当前联系人:', currentPrivateSpaceContactId);
    
    // 立即应用保存的壁纸设置（使用角色特定的函数）
    window.applyPrivateSpaceWallpapers();
    
    // 应用保存的壁纸设置（延迟确保）
    setTimeout(() => {
        window.applyPrivateSpaceWallpapers();
        console.log('私人空间壁纸设置已应用');
    }, 100);
    
    // 再次确保壁纸应用（延迟更长时间）
    setTimeout(() => {
        window.applyPrivateSpaceWallpapers();
        console.log('私人空间壁纸设置再次应用');
    }, 500);
    
    // 最后一次确保应用（处理慢加载情况）
    setTimeout(() => {
        window.applyPrivateSpaceWallpapers();
        console.log('私人空间壁纸设置最终应用');
    }, 1000);
}

/**
 * 渲染私人空间的约定列表
 */
async function renderPrivateAgreements() {
    const container = document.getElementById('private-agreements-list');
    if (!container) return;
    
    // 获取当前联系人的约定类型记录
    const allAgreements = await db.memories.where('type').equals('countdown').toArray();
    const agreements = allAgreements.filter(agreement => 
        agreement.chatId === currentPrivateSpaceContactId
    );
    
    if (agreements.length === 0) {
        container.innerHTML = `
            <div class="empty-state" style="text-align: center; padding: 40px 20px; color: #666;">
                <p style="margin: 0; font-size: 14px;">还没有约定，点击右上角的+号来创建第一个约定吧</p>
            </div>
        `;
        return;
    }
    
    // 按目标日期排序，未到期的在前面
    agreements.sort((a, b) => {
        const now = Date.now();
        const aExpired = a.targetDate <= now;
        const bExpired = b.targetDate <= now;
        
        if (aExpired && !bExpired) return 1;
        if (!aExpired && bExpired) return -1;
        return a.targetDate - b.targetDate;
    });
    
    let html = '';
    agreements.forEach(agreement => {
        const targetDate = new Date(agreement.targetDate);
        const now = new Date();
        const timeDiff = targetDate - now;
        
        let timerText = '';
        let isExpired = false;
        
        if (timeDiff <= 0) {
            timerText = '约定达成！';
            isExpired = true;
        } else {
            const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
            
            if (days > 0) {
                timerText = `${days}天 ${hours}小时`;
            } else if (hours > 0) {
                timerText = `${hours}小时 ${minutes}分钟`;
            } else {
                timerText = `${minutes}分钟`;
            }
        }
        
        const cardClass = isExpired ? 'private-agreement-card expired' : 'private-agreement-card';
        
        html += `
            <div class="${cardClass}" data-id="${agreement.id}">
                <div class="title">${agreement.description}</div>
                <div class="timer">${timerText}</div>
                <div class="target-date">${targetDate.toLocaleString()}</div>
                <div class="agreement-actions" style="margin-top: 15px;">
                    <button class="delete-agreement-btn" onclick="deleteAgreement(${agreement.id})" 
                            style="background: rgba(244, 67, 54, 0.1); border: 1px solid rgba(244, 67, 54, 0.3); 
                                   color: #d32f2f; padding: 6px 16px; border-radius: 20px; cursor: pointer; font-size: 12px;
                                   transition: all 0.2s ease;">
                        删除
                    </button>
                </div>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

/**
 * 删除约定
 */
window.deleteAgreement = async function(agreementId) {
    const confirmed = await showCustomConfirm('删除约定', '确定要删除这个约定吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.memories.delete(agreementId);
        // 保存到当前联系人的私人空间数据
        window.saveCurrentPrivateSpaceData();
        renderPrivateAgreements();
    }
}

// 当前私人空间的联系人ID
let currentPrivateSpaceContactId = null;

// 将变量设置为全局可访问
window.currentPrivateSpaceContactId = currentPrivateSpaceContactId;

// 初始化私人空间
function initPrivateSpace() {
    // 如果没有设置当前联系人，尝试从localStorage恢复，否则选择第一个可用联系人
    if (!currentPrivateSpaceContactId) {
        const savedContactId = localStorage.getItem('lastPrivateSpaceContactId');
        if (savedContactId && savedContactId !== 'default' && state.chats[savedContactId]) {
            currentPrivateSpaceContactId = savedContactId;
        } else {
            // 选择第一个可用的非群组联系人
            const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);
            if (contacts.length > 0) {
                currentPrivateSpaceContactId = contacts[0].id;
            } else {
                // 如果没有联系人，显示提示并返回
                showCustomAlert('提示', '暂无可用的联系人，请先创建一些AI联系人。\n\n💡 提示：在聊天列表中点击"+"号可以创建新的AI联系人。');
                return;
            }
        }
        window.currentPrivateSpaceContactId = currentPrivateSpaceContactId;
    }
    
    // 设置默认显示约定页面
    switchPrivateTab('agreement');
    
    // 加载当前联系人的约定列表
    renderPrivateAgreements();
    
    // 更新头像显示
    window.updatePrivateSpaceAvatar();
}

// 更新私人空间头像显示
window.updatePrivateSpaceAvatar = function() {
        const avatarImg = document.getElementById('private-space-avatar-img');
    const contactNameSpan = document.getElementById('current-contact-name');
    const allIndicators = document.querySelectorAll('.current-contact-name-indicator');
    
    if (!avatarImg) return;
    
    let displayName = '';
    
    // 显示对应联系人的头像（不再有默认页面）
    const contact = state.chats[currentPrivateSpaceContactId];
    if (contact && contact.settings && contact.settings.aiAvatar) {
        avatarImg.src = contact.settings.aiAvatar;
    } else {
        avatarImg.src = 'https://q1.qlogo.cn/g?b=qq&nk=123456789&s=100';
    }
    
    displayName = contact ? contact.name : '未知联系人';
    
    // 更新所有指示器
    if (contactNameSpan) {
        contactNameSpan.textContent = displayName;
    }
    
    allIndicators.forEach(indicator => {
        indicator.textContent = displayName;
    });
}

// 显示好友选择弹窗
window.showFriendsSelector = function() {
    // 获取所有非群组联系人
    const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    if (contacts.length === 0) {
        showCustomAlert('提示', '暂无可选择的好友，请先创建一些联系人。\n\n💡 提示：在聊天列表中点击"+"号可以创建新的AI联系人。');
        return;
    }
    
    // 创建弹窗HTML
    const modalHtml = `
        <div id="friends-selector-modal" class="modal visible">
            <div class="modal-content">
                <div class="modal-header">
                    <span>选择好友</span>
                    <span class="close-btn" onclick="closeFriendsSelector()">×</span>
                </div>
                <div style="padding: 10px 15px; font-size: 13px; color: #666; border-bottom: 1px solid #f0f0f0;">
                    每个好友都有独立的私人空间，包括约定、物品、相册和设置
                    <br><small style="color: #999;">提示：点击头像可以切换不同好友的私人空间</small>
                    <br><small style="color: #007bff;">📜 好友较多时可以滑动查看更多</small>
                </div>
                <div class="modal-body">
                    <div class="friends-list">
                        ${contacts.map(contact => `
                            <div class="friend-item ${currentPrivateSpaceContactId === contact.id ? 'active' : ''}" 
                                 onclick="selectFriend('${contact.id}')">
                                <img src="${contact.settings?.aiAvatar || 'https://q1.qlogo.cn/g?b=qq&nk=123456789&s=100'}" 
                                     class="friend-avatar" alt="${contact.name}">
                                <span class="friend-name">${contact.name}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // 移除已存在的弹窗
    const existingModal = document.getElementById('friends-selector-modal');
    if (existingModal) {
        existingModal.remove();
        }
    
    // 添加新弹窗
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

// 关闭好友选择弹窗
window.closeFriendsSelector = function() {
    const modal = document.getElementById('friends-selector-modal');
    if (modal) {
        modal.remove();
    }
}

// 选择好友
window.selectFriend = function(contactId) {
    // 保存当前联系人的数据
    window.saveCurrentPrivateSpaceData();
    
    // 切换到新联系人
    currentPrivateSpaceContactId = contactId;
    window.currentPrivateSpaceContactId = contactId;
    
    // 保存选择到localStorage
    localStorage.setItem('lastPrivateSpaceContactId', contactId);
    
    // 更新头像显示
    window.updatePrivateSpaceAvatar();
    
    // 重新加载数据
    window.loadPrivateSpaceData();
    
    // 应用新联系人的壁纸设置
    setTimeout(() => {
        window.applyPrivateSpaceWallpapers();
        // 检查函数是否存在再调用
        if (typeof updateWallpaperPreviews === 'function') {
            updateWallpaperPreviews(); // 更新壁纸预览
        }
        console.log('已应用新联系人的壁纸设置');
    }, 100);
    
    // 关闭弹窗
    window.closeFriendsSelector();
    
    console.log('切换到联系人:', contactId);
}

// 保存当前私人空间数据
window.saveCurrentPrivateSpaceData = function() {
    if (!currentPrivateSpaceContactId) return;
    
    const dataKey = `privateSpace_${currentPrivateSpaceContactId}`;
    
    // 收集当前的数据
    const currentData = {
        // 约定数据
        agreements: JSON.parse(localStorage.getItem('privateSpaceItems') || '[]'),
        
        // 物品数据 - 优先从itemsManager获取，否则从localStorage获取
        items: (() => {
            if (window.itemsManager && window.itemsManager.items) {
                return window.itemsManager.items;
            }
            // 如果itemsManager不存在，从localStorage获取
            const storedItems = localStorage.getItem('private-items');
            return storedItems ? JSON.parse(storedItems) : [];
        })(),
        
        // 壁纸设置 - 从当前角色的数据中获取，而不是全局localStorage
        wallpaperSettings: (() => {
            const existingData = localStorage.getItem(dataKey);
            if (existingData) {
                const parsed = JSON.parse(existingData);
                return parsed.wallpaperSettings || {};
            }
            return {};
        })(),
        
        // 相册数据 (如果有的话)
        albums: JSON.parse(localStorage.getItem('albums') || '[]').filter(album => 
            album.boundContacts && album.boundContacts.some(contact => 
                contact.id === currentPrivateSpaceContactId
            )
        ),
        
        // 私人相册数据 - 使用当前内存中的数据而不是localStorage
        privatePhotos: window.privatePhotos || []
    };
    
    // 调试信息
    console.log('🔍 保存私人空间数据:', {
        contactId: currentPrivateSpaceContactId,
        dataKey: dataKey,
        privatePhotosCount: currentData.privatePhotos.length,
        privatePhotos: currentData.privatePhotos
    });
    
    // 保存到localStorage
    localStorage.setItem(dataKey, JSON.stringify(currentData));
    console.log('保存私人空间数据:', currentPrivateSpaceContactId, currentData);
}

// 加载私人空间数据
window.loadPrivateSpaceData = function() {
    if (!currentPrivateSpaceContactId) return;
    
    const dataKey = `privateSpace_${currentPrivateSpaceContactId}`;
    const savedData = localStorage.getItem(dataKey);
    
    console.log('🔍 loadPrivateSpaceData 被调用:', {
        contactId: currentPrivateSpaceContactId,
        dataKey: dataKey,
        hasSavedData: !!savedData,
        savedDataLength: savedData ? savedData.length : 0
    });
    
    if (savedData) {
        const data = JSON.parse(savedData);
        
        // 恢复约定数据
        if (data.agreements) {
            localStorage.setItem('privateSpaceItems', JSON.stringify(data.agreements));
        } else {
            localStorage.setItem('privateSpaceItems', '[]');
        }
        
        // 恢复物品数据
        if (data.items) {
            // 直接保存到localStorage，无论物品管理器是否已初始化
            localStorage.setItem('private-items', JSON.stringify(data.items));
            
            // 如果物品管理器已经存在，同时更新它
            if (window.itemsManager) {
                window.itemsManager.items = data.items;
                window.itemsManager.renderTable();
            }
            
            console.log('🔍 恢复物品数据:', {
                contactId: currentPrivateSpaceContactId,
                itemsCount: data.items.length,
                items: data.items,
                hasItemsManager: !!window.itemsManager
            });
        } else {
            // 清空物品数据
            localStorage.setItem('private-items', '[]');
            if (window.itemsManager) {
                window.itemsManager.items = [];
                window.itemsManager.renderTable();
            }
        }
        
        // 恢复壁纸设置 - 不再写入全局localStorage，直接应用
        if (data.wallpaperSettings) {
            // 重新应用壁纸设置
            window.applyPrivateSpaceWallpapers();
        }
        
        // 恢复私人相册数据
        if (data.privatePhotos) {
            window.privatePhotos = data.privatePhotos;
            localStorage.setItem('privatePhotos', JSON.stringify(data.privatePhotos));
            console.log('🔍 恢复私人相册数据:', {
                contactId: currentPrivateSpaceContactId,
                photosCount: data.privatePhotos.length,
                photos: data.privatePhotos
            });
        } else {
            window.privatePhotos = [];
            localStorage.setItem('privatePhotos', '[]');
            console.log('🔍 没有私人相册数据，使用空数组');
        }
        
        // 重新渲染私人相册
        if (typeof renderPrivateAlbum === 'function') {
            renderPrivateAlbum();
        }
        
        console.log('加载私人空间数据:', currentPrivateSpaceContactId, data);
    } else {
        console.log('🔍 没有找到保存的数据，使用默认值:', {
            contactId: currentPrivateSpaceContactId,
            dataKey: dataKey,
            allLocalStorageKeys: Object.keys(localStorage)
        });
        
        // 没有保存的数据，使用默认值
        localStorage.setItem('privateSpaceItems', '[]');
        if (window.itemsManager) {
            window.itemsManager.items = [];
            window.itemsManager.saveItems(); // 更新localStorage
            window.itemsManager.renderTable();
        }
        
        // 清除壁纸设置
        // 清除当前角色的壁纸设置并重新应用
        window.applyPrivateSpaceWallpapers();
        
        // 清除私人相册数据
        window.privatePhotos = [];
        localStorage.setItem('privatePhotos', '[]');
        
        // 重新渲染私人相册
        if (typeof renderPrivateAlbum === 'function') {
            renderPrivateAlbum();
        }
        
        console.log('使用默认私人空间数据:', currentPrivateSpaceContactId);
    }
    
    // 重新渲染约定列表
    renderPrivateAgreements();
    
    // 重新渲染私人相册
    if (typeof renderPrivateAlbum === 'function') {
        renderPrivateAlbum();
    }
}

// 获取当前联系人的相册
function getCurrentContactAlbums() {
    if (!currentPrivateSpaceContactId) {
        return [];
    }
    
    const allAlbums = JSON.parse(localStorage.getItem('albums') || '[]');
    return allAlbums.filter(album => 
        album.boundContacts && album.boundContacts.some(contact => 
            contact.id === currentPrivateSpaceContactId
        )
    );
}

// 获取当前联系人的物品数据
window.getCurrentContactItems = function() {
    if (!currentPrivateSpaceContactId) {
        return [];
    }
    
    // 优先从itemsManager获取
    if (window.itemsManager && window.itemsManager.items) {
        return window.itemsManager.items;
    }
    
    // 从私人空间数据中获取
    const dataKey = `privateSpace_${currentPrivateSpaceContactId}`;
    const savedData = localStorage.getItem(dataKey);
    if (savedData) {
        const data = JSON.parse(savedData);
        return data.items || [];
    }
    
    // 最后从通用localStorage获取
    const storedItems = localStorage.getItem('private-items');
    return storedItems ? JSON.parse(storedItems) : [];
}

// 物品表格管理功能
class ItemsManager {
    constructor() {
        this.items = this.loadItems();
        this.columnWidths = this.loadColumnWidths();
        this.deleteMode = false;
        this.init();
    }

    init() {
        // 绑定事件
        const addBtn = document.getElementById('add-item-btn');
        const deleteBtn = document.getElementById('delete-mode-btn');
        
        if (addBtn) {
            addBtn.addEventListener('click', () => {
                this.addNewRow();
            });
        }

        if (deleteBtn) {
            deleteBtn.addEventListener('click', () => {
                this.toggleDeleteMode();
            });
        }

        // 初始化表格
        this.renderTable();
    }

    loadItems() {
        const stored = localStorage.getItem('private-items');
        return stored ? JSON.parse(stored) : [];
    }

    loadColumnWidths() {
        const stored = localStorage.getItem('private-column-widths');
        return stored ? JSON.parse(stored) : {};
    }

    saveItems() {
        localStorage.setItem('private-items', JSON.stringify(this.items));
        // 同时保存到当前联系人的私人空间数据中
        if (window.currentPrivateSpaceContactId) {
            window.saveCurrentPrivateSpaceData();
        }
    }

    saveColumnWidths() {
        localStorage.setItem('private-column-widths', JSON.stringify(this.columnWidths));
    }

    addNewRow() {
        const newItem = {
            id: Date.now(),
            name: '',
            description: '',
            effect: '',
            meaning: '',
            source: '',
            owner: ''
        };
        this.items.push(newItem);
        this.renderTable();
        this.saveItems();
    }

    deleteRow(index) {
        this.items.splice(index, 1);
        this.renderTable();
        this.saveItems();
    }

    toggleDeleteMode() {
        this.deleteMode = !this.deleteMode;
        const btn = document.getElementById('delete-mode-btn');
        const operationColumns = document.querySelectorAll('.operation-column');
        
        if (this.deleteMode) {
            btn.classList.add('active');
            btn.textContent = '完成';
            operationColumns.forEach(col => col.style.display = 'table-cell');
        } else {
            btn.classList.remove('active');
            btn.textContent = '删除';
            operationColumns.forEach(col => col.style.display = 'none');
        }
    }

    updateItem(index, field, value) {
        if (this.items[index]) {
            this.items[index][field] = value;
            this.saveItems();
        }
    }

    renderTable() {
        const tbody = document.getElementById('items-table-body');
        
        // 保存当前列的宽度
        const existingWidths = {};
        const existingRows = tbody.querySelectorAll('tr');
        if (existingRows.length > 0) {
            const firstRow = existingRows[0];
            const cells = firstRow.querySelectorAll('td:not(.serial-number):not(.operation-column)');
            cells.forEach((cell, index) => {
                if (cell.style.width) {
                    existingWidths[index] = cell.style.width;
                }
            });
        }
        
        tbody.innerHTML = '';

        this.items.forEach((item, index) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="serial-number">${index + 1}</td>
                <td><textarea data-field="name" data-index="${index}" rows="1">${item.name}</textarea></td>
                <td><textarea data-field="description" data-index="${index}" rows="1">${item.description}</textarea></td>
                <td><textarea data-field="effect" data-index="${index}" rows="1">${item.effect}</textarea></td>
                <td><textarea data-field="meaning" data-index="${index}" rows="1">${item.meaning}</textarea></td>
                <td><textarea data-field="source" data-index="${index}" rows="1">${item.source}</textarea></td>
                <td><textarea data-field="owner" data-index="${index}" rows="1">${item.owner}</textarea></td>
                <td class="operation-column" style="display: ${this.deleteMode ? 'table-cell' : 'none'};">
                    <button class="delete-row-btn" data-index="${index}">删除</button>
                </td>
            `;
            tbody.appendChild(row);
            
            // 恢复列宽度
            const cells = row.querySelectorAll('td:not(.serial-number):not(.operation-column)');
            cells.forEach((cell, cellIndex) => {
                if (existingWidths[cellIndex]) {
                    // 使用当前会话中的宽度
                    cell.style.width = existingWidths[cellIndex];
                    cell.style.minWidth = existingWidths[cellIndex];
                } else if (this.columnWidths[cellIndex]) {
                    // 使用保存的宽度
                    cell.style.width = this.columnWidths[cellIndex];
                    cell.style.minWidth = this.columnWidths[cellIndex];
                }
                // 如果既没有当前宽度也没有保存的宽度，就不设置固定宽度，保持初始状态
            });
        });

        // 高度和宽度自适应函数
        const autoResize = (textarea) => {
            // 重置高度为最小值，让浏览器重新计算scrollHeight
            textarea.style.height = '36px'; // 最小高度
            
            // 如果内容需要更多空间，使用scrollHeight
            if (textarea.scrollHeight > 36) {
                textarea.style.height = textarea.scrollHeight + 'px';
            }
            
            // 动态调整单元格宽度 - 只在宽度需要增加时才调整
            const td = textarea.parentElement;
            if (td && !td.classList.contains('serial-number') && !td.classList.contains('operation-column')) {
                // 获取列索引，用于同步整列的宽度
                const columnIndex = Array.from(td.parentElement.children).indexOf(td);
                
                // 创建一个临时元素来测量文本宽度（复用）
                if (!window.textMeasureSpan) {
                    window.textMeasureSpan = document.createElement('span');
                    window.textMeasureSpan.style.visibility = 'hidden';
                    window.textMeasureSpan.style.position = 'absolute';
                    window.textMeasureSpan.style.fontSize = '14px';
                    window.textMeasureSpan.style.fontFamily = 'Microsoft YaHei, Arial, sans-serif';
                    window.textMeasureSpan.style.lineHeight = '20px';
                    window.textMeasureSpan.style.whiteSpace = 'nowrap';
                    window.textMeasureSpan.style.wordBreak = 'normal';
                    document.body.appendChild(window.textMeasureSpan);
                }
                
                const tempSpan = window.textMeasureSpan;
                
                // 测量文本宽度的辅助函数
                const measureTextWidth = (text) => {
                    const lines = (text || '占位文字').split('\n');
                    let maxLineWidth = 0;
                    lines.forEach(line => {
                        tempSpan.textContent = line || '占位文字';
                        maxLineWidth = Math.max(maxLineWidth, tempSpan.offsetWidth);
                    });
                    return maxLineWidth + 16; // 加上padding
                };
                
                const textWidth = measureTextWidth(textarea.value);
                
                // 计算需要的宽度，最小120px，根据内容长度动态增加
                const minWidth = 120;
                const maxAllowedWidth = 400; // 设置一个合理的最大宽度
                const newWidth = Math.max(minWidth, Math.min(maxAllowedWidth, textWidth));
                
                // 获取当前单元格的宽度
                const currentCellWidth = parseInt(td.style.width) || minWidth;
                
                // 只有当新宽度大于当前宽度时，才重新计算整列
                if (newWidth > currentCellWidth) {
                    // 获取当前列的所有单元格，找出最大需要的宽度
                    const table = td.closest('table');
                    const allRowsInColumn = table.querySelectorAll(`tr td:nth-child(${columnIndex + 1}):not(.serial-number):not(.operation-column)`);
                    let columnMaxWidth = newWidth;
                    
                    // 检查这一列的其他单元格是否需要更大的宽度
                    allRowsInColumn.forEach(cell => {
                        const cellTextarea = cell.querySelector('textarea');
                        if (cellTextarea) {
                            const cellWidth = Math.max(minWidth, Math.min(maxAllowedWidth, measureTextWidth(cellTextarea.value)));
                            columnMaxWidth = Math.max(columnMaxWidth, cellWidth);
                        }
                    });
                    
                    // 只有当计算出的宽度确实更大时，才应用到整列
                    if (columnMaxWidth > currentCellWidth) {
                        allRowsInColumn.forEach(cell => {
                            cell.style.width = columnMaxWidth + 'px';
                            cell.style.minWidth = columnMaxWidth + 'px';
                        });
                        
                        // 保存列宽度
                        const itemsManager = window.itemsManager;
                        if (itemsManager) {
                            // columnIndex已经是从0开始的，序号列是第0列，所以数据列从1开始
                            // 需要减1来得到数据列的索引（0-5对应name, description, effect, meaning, source, owner）
                            const dataColumnIndex = columnIndex - 1;
                            itemsManager.columnWidths[dataColumnIndex] = columnMaxWidth + 'px';
                            itemsManager.saveColumnWidths();
                        }
                    }
                }
            }
        };

        // 绑定textarea事件
        tbody.querySelectorAll('textarea').forEach(textarea => {
            // 初始化高度（但不重新计算宽度）
            textarea.style.height = '36px'; // 最小高度
            if (textarea.scrollHeight > 36) {
                textarea.style.height = textarea.scrollHeight + 'px';
            }

            // 输入时自动调整高度
            textarea.addEventListener('input', (e) => {
                autoResize(e.target);
            });

            // 粘贴时自动调整高度
            textarea.addEventListener('paste', (e) => {
                setTimeout(() => autoResize(e.target), 0);
            });

            // 键盘事件（删除、回车等）
            textarea.addEventListener('keyup', (e) => {
                autoResize(e.target);
            });

            // 失去焦点时保存数据
            textarea.addEventListener('blur', (e) => {
                const index = parseInt(e.target.dataset.index);
                const field = e.target.dataset.field;
                const value = e.target.value;
                this.updateItem(index, field, value);
                autoResize(e.target);
            });

            // 允许Enter键换行（不再阻止）
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    // 允许换行，不做任何处理
                    setTimeout(() => autoResize(e.target), 0);
                }
            });
        });

        // 让整个单元格都可以点击来聚焦textarea
        tbody.querySelectorAll('td:not(.serial-number):not(.operation-column)').forEach(td => {
            td.addEventListener('click', (e) => {
                // 如果点击的不是textarea本身，就聚焦到textarea
                if (e.target !== td.querySelector('textarea')) {
                    const textarea = td.querySelector('textarea');
                    if (textarea) {
                        textarea.focus();
                        // 将光标移到文本末尾
                        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                    }
                }
            });
        });

        // 绑定删除按钮事件
        tbody.querySelectorAll('.delete-row-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const index = parseInt(e.target.dataset.index);
                if (confirm('确定要删除这个物品吗？')) {
                    this.deleteRow(index);
                }
            });
        });
    }
}

// 切换私人空间标签页
function switchPrivateTab(tabName) {
    // 移除所有标签的active状态
    document.querySelectorAll('.private-nav-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // 隐藏所有内容页面
    document.querySelectorAll('.private-content-page').forEach(page => {
        page.classList.remove('active');
    });
    
    // 激活选中的标签和页面
    const selectedTab = document.querySelector(`[data-tab="${tabName}"]`);
    const selectedPage = document.getElementById(`${tabName}-page`);
    
    if (selectedTab) selectedTab.classList.add('active');
    if (selectedPage) selectedPage.classList.add('active');
    
    // 如果切换到约定页面，刷新约定列表
    if (tabName === 'agreement') {
        renderPrivateAgreements();
    }
    
    // 如果切换到物品页面，初始化物品管理器
    if (tabName === 'items') {
        // 延迟初始化，确保DOM完全显示
        setTimeout(() => {
            const addBtn = document.getElementById('add-item-btn');
            
            if (addBtn && !window.itemsManager) {
                window.itemsManager = new ItemsManager();
                // 初始化后，确保加载当前角色的数据
                if (window.currentPrivateSpaceContactId) {
                    window.loadPrivateSpaceData();
                }
            }
        }, 100);
    }
    
    // 如果切换到相册页面，初始化相册
    if (tabName === 'album') {
        setTimeout(() => {
            renderPrivateAlbum();
        }, 100);
    }
    
    // 更新当前联系人指示器
    window.updatePrivateSpaceAvatar();
}



// 更新恋爱空间状态（原绑定按钮已删除）
function updateBindCharButton() {
    // 更新AI头像和状态显示
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    const aiAvatar = document.getElementById('ai-avatar');
    const aiStatus = document.getElementById('ai-status');
    
    if (boundCharId && state.chats[boundCharId]) {
        // 已绑定角色，更新头像和显示状态
        const boundChar = state.chats[boundCharId];
        if (aiAvatar && boundChar.avatar) {
            aiAvatar.src = boundChar.avatar;
        }
        if (aiStatus) {
            aiStatus.style.display = 'block';
            // 计算恋爱天数（可以基于绑定时间或其他逻辑）
            const days = calculateLoveDays(boundCharId);
            aiStatus.innerHTML = `想你<span id="ai-days">${days}</span>天`;
        }
    } else {
        // 未绑定角色，显示默认状态
        if (aiStatus) {
            aiStatus.style.display = 'none';
        }
        // 保持默认AI头像
    }
}

// 计算恋爱天数
function calculateLoveDays(charId) {
    const bindDate = localStorage.getItem(`loveSpaceBindDate_${charId}`);
    if (!bindDate) {
        // 如果没有绑定日期，设置为今天
        const today = new Date().toDateString();
        localStorage.setItem(`loveSpaceBindDate_${charId}`, today);
        return 0;
    }
    
    const bindTime = new Date(bindDate);
    const today = new Date();
    const diffTime = Math.abs(today - bindTime);
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    return diffDays;
}

// 处理角色绑定
async function handleCharacterBinding() {
    const availableChars = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    if (availableChars.length === 0) {
        await showCustomAlert('提示', '您还没有创建任何AI角色，请先在聊天页面创建AI角色后再进行绑定。');
        return;
    }
    
    // 创建选择列表
    let optionsHtml = availableChars.map(chat => {
        // 使用聊天设置中的AI头像（和恋爱空间邀请卡片保持一致）
        const aiAvatar = chat.settings.aiAvatar || 'img/default_avatar.png';
        return `
        <div class="char-option" data-char-id="${chat.id}">
            <img src="${aiAvatar}" alt="${chat.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 12px;">
            <span>${chat.name}</span>
        </div>
        `;
    }).join('');
    
    const currentBoundId = localStorage.getItem('loveSpaceBoundChar');
    if (currentBoundId && state.chats[currentBoundId]) {
        optionsHtml += `
            <div class="char-option" data-char-id="unbind" style="color: #ff3b30; border-top: 1px solid #eee; margin-top: 10px; padding-top: 10px;">
                <span style="margin-left: 52px;">解除绑定</span>
            </div>
        `;
    }
    
    // 使用现有的modal系统
    const selectedCharId = await new Promise((resolve) => {
        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalFooter = document.querySelector('.custom-modal-footer');
        
        modalTitle.textContent = '选择AI角色';
        modalBody.innerHTML = optionsHtml;
        modalFooter.style.display = 'none'; // 隐藏默认按钮
        
        modalBody.querySelectorAll('.char-option').forEach(option => {
            option.style.cursor = 'pointer';
            option.style.padding = '12px';
            option.style.display = 'flex';
            option.style.alignItems = 'center';
            option.style.borderRadius = '8px';
            option.style.transition = 'background-color 0.2s';
            
            option.addEventListener('mouseenter', () => {
                option.style.backgroundColor = '#f0f0f0';
            });
            option.addEventListener('mouseleave', () => {
                option.style.backgroundColor = '';
            });
            
            option.addEventListener('click', () => {
                resolve(option.dataset.charId);
                modalOverlay.classList.remove('visible');
                modalFooter.style.display = 'flex'; // 恢复默认按钮显示
            });
        });
        
        // 点击背景关闭
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                resolve(null);
                modalOverlay.classList.remove('visible');
                modalFooter.style.display = 'flex';
            }
        });
        
        modalOverlay.classList.add('visible');
    });
    
    if (selectedCharId) {
        if (selectedCharId === 'unbind') {
            // ★★★ 解除绑定时也要彻底清除所有打卡数据 ★★★
            console.log('解除绑定：正在彻底清除所有打卡相关数据...');
            
            const previousBoundCharId = localStorage.getItem('loveSpaceBoundChar');
            localStorage.removeItem('loveSpaceBoundChar');
            
            // 清除所有打卡相关数据
            localStorage.removeItem('loveSpaceCheckinData');
            localStorage.removeItem('checkinHistory');
            localStorage.removeItem('myCheckinDays');
            localStorage.removeItem('partnerCheckinDays');
            
            // 清除所有AI活动记录
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('aiActivity_')) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => {
                console.log(`清除活动数据: ${key}`);
                localStorage.removeItem(key);
            });
            
            // 清除之前绑定角色的聊天记录中的打卡消息
            if (previousBoundCharId && state.chats[previousBoundCharId]) {
                const originalLength = state.chats[previousBoundCharId].history.length;
                state.chats[previousBoundCharId].history = state.chats[previousBoundCharId].history.filter(msg => 
                    msg.type !== 'checkin-card'
                );
                const newLength = state.chats[previousBoundCharId].history.length;
                if (originalLength !== newLength) {
                    console.log(`清除了角色 ${previousBoundCharId} 的${originalLength - newLength}条打卡消息`);
                    await db.chats.put(state.chats[previousBoundCharId]);
                }
            }
            
            await showCustomAlert('成功', '已解除角色绑定\n所有打卡记录已清空');
        } else {
            // ★★★ 核心功能4：绑定新角色时清除所有旧的打卡记录，确保重新绑定是全新开始 ★★★
            const previousBoundCharId = localStorage.getItem('loveSpaceBoundChar');
            
            // ★★★ 彻底清除所有打卡相关数据（确保重新绑定是全新开始）★★★
            console.log('正在彻底清除所有打卡相关数据...');
            
            // 清除主要打卡数据
            localStorage.removeItem('loveSpaceCheckinData');
            localStorage.removeItem('checkinHistory');
            localStorage.removeItem('myCheckinDays');
            localStorage.removeItem('partnerCheckinDays');
            
            // ★★★ 清除所有AI活动记录（包括今天的）★★★
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('aiActivity_')) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => {
                console.log(`清除活动数据: ${key}`);
                localStorage.removeItem(key);
            });
            
            // ★★★ 强制重置打卡数据到初始状态 ★★★
            const resetData = {
                userLastCheckin: null,
                userConsecutiveDays: 0,
                userTotalCheckins: 0,
                aiLastCheckin: null,
                aiConsecutiveDays: 0,
                aiTotalCheckins: 0,
                userCheckinHistory: {},
                aiCheckinHistory: {}
            };
            localStorage.setItem('loveSpaceCheckinData', JSON.stringify(resetData));
            console.log('已重置打卡数据到初始状态');
            
            // 如果之前绑定过其他角色，清除其聊天记录中的打卡消息
            if (previousBoundCharId && previousBoundCharId !== selectedCharId && state.chats[previousBoundCharId]) {
                state.chats[previousBoundCharId].history = state.chats[previousBoundCharId].history.filter(msg => 
                    msg.type !== 'checkin-card'
                );
                db.chats.put(state.chats[previousBoundCharId]);
            }
            
            // 清除即将绑定角色的聊天记录中的旧打卡消息
            if (state.chats[selectedCharId] && state.chats[selectedCharId].history) {
                const originalLength = state.chats[selectedCharId].history.length;
                state.chats[selectedCharId].history = state.chats[selectedCharId].history.filter(msg => 
                    msg.type !== 'checkin-card'
                );
                const newLength = state.chats[selectedCharId].history.length;
                if (originalLength !== newLength) {
                    console.log(`清除了角色 ${selectedCharId} 的${originalLength - newLength}条旧打卡消息`);
                    db.chats.put(state.chats[selectedCharId]);
                }
            }
            
            localStorage.setItem('loveSpaceBoundChar', selectedCharId);
            const selectedChar = state.chats[selectedCharId];
            await showCustomAlert('成功', `已绑定角色：${selectedChar.name}\n\n✨ 全新的恋爱空间开始了！`);
            console.log('★★★ 角色绑定成功，所有打卡记录已重置为全新状态 ★★★');
        }
        updateBindCharButton();
    }
}

// ▼▼▼ 恋爱空间打卡和头像功能 ▼▼▼

// 打卡数据存储key（已在前面定义）
const USER_AVATAR_KEY = 'loveSpaceUserAvatar';
const AI_AVATAR_KEY = 'loveSpaceAIAvatar';
// 壁纸数据存储key
const HOME_WALLPAPER_KEY = 'loveSpaceHomeWallpaper';
const CHAT_WALLPAPER_KEY = 'loveSpaceChatWallpaper';



// 保存打卡数据
function saveCheckinData(data) {
    localStorage.setItem(CHECKIN_DATA_KEY, JSON.stringify(data));
}

// 检查是否是新的一天
function isNewDay(lastCheckin) {
    if (!lastCheckin) return true;
    const last = new Date(lastCheckin);
    const now = new Date();
    return last.toDateString() !== now.toDateString();
}

// 检查是否已经打卡
function hasCheckedInToday(lastCheckin) {
    if (!lastCheckin) return false;
    const last = new Date(lastCheckin);
    const now = new Date();
    return last.toDateString() === now.toDateString();
}

// 更新打卡按钮状态
function updateCheckinButton() {
    const data = getCheckinData();
    const ball = document.getElementById('checkin-ball');
    const ballText = ball.querySelector('.ball-text');
    
    if (hasCheckedInToday(data.userLastCheckin)) {
        ball.classList.add('checked');
        ballText.textContent = '已打卡';
        ball.onclick = null;
    } else {
        ball.classList.remove('checked');
        ballText.textContent = '打卡';
        ball.onclick = userCheckin;
    }
}

// 更新头像下的状态显示
function updateAvatarStatus() {
    const data = getCheckinData();
    const userStatus = document.getElementById('user-status');
    const aiStatus = document.getElementById('ai-status');
    const userDays = document.getElementById('user-days');
    const aiDays = document.getElementById('ai-days');
    
    // 显示用户状态
    if (hasCheckedInToday(data.userLastCheckin)) {
        userStatus.style.display = 'block';
        userDays.textContent = data.userTotalCheckins; // 改为显示总打卡天数
    } else {
        userStatus.style.display = 'none';
    }
    
    // 显示AI状态
    if (hasCheckedInToday(data.aiLastCheckin)) {
        aiStatus.style.display = 'block';
        aiDays.textContent = data.aiTotalCheckins; // 改为显示总打卡天数
    } else {
        aiStatus.style.display = 'none';
    }
}

// 更新打卡统计
function updateCheckinStats() {
    const data = getCheckinData();
    document.getElementById('consecutive-days').textContent = data.userConsecutiveDays;
    document.getElementById('total-checkins').textContent = data.userTotalCheckins;
}

// 用户打卡
function userCheckin() {
    // 检查是否已绑定恋爱空间
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (!boundCharId || !state.chats[boundCharId]) {
        showCustomAlert('提示', '请先绑定恋爱空间后才能打卡哦！');
        return;
    }
    
    const data = getCheckinData();
    
    if (hasCheckedInToday(data.userLastCheckin)) {
        showCustomAlert('提示', '今天已经打卡过了哦！');
        return;
    }
    
    const now = new Date();
    
    // 检查是否连续打卡
    if (data.userLastCheckin) {
        const lastCheckin = new Date(data.userLastCheckin);
        const yesterday = new Date(now);
        yesterday.setDate(yesterday.getDate() - 1);
        
        if (lastCheckin.toDateString() === yesterday.toDateString()) {
            // 连续打卡
            data.userConsecutiveDays += 1;
        } else {
            // 断签了，重新开始
            data.userConsecutiveDays = 1;
        }
    } else {
        // 第一次打卡
        data.userConsecutiveDays = 1;
    }
    
    data.userLastCheckin = now.toISOString();
    data.userTotalCheckins += 1;
    
    // 保存到打卡历史记录
    const dateStr = getLocalDateString(now);
    if (!data.userCheckinHistory) {
        data.userCheckinHistory = {};
    }
    data.userCheckinHistory[dateStr] = true;
    
    saveCheckinData(data);
    updateCheckinButton();
    updateAvatarStatus();
    updateCheckinStats();
    
    // 更新日历显示
    console.log('用户打卡后更新日历显示...');
    if (typeof updateCalendarDisplay === 'function') {
        updateCalendarDisplay();
        console.log('日历显示更新完成!');
    } else {
        console.log('updateCalendarDisplay函数不存在!');
    }
    
    // 打卡成功动画
    const ball = document.getElementById('checkin-ball');
    ball.style.animation = 'none';
    setTimeout(() => {
        ball.style.animation = 'float 3s ease-in-out infinite';
    }, 100);
    
    showCustomAlert('打卡成功', `连续打卡 ${data.userConsecutiveDays} 天！`);
    
    // ★★★ 核心功能1：发送打卡成功的卡片消息到聊天页面 ★★★
    sendCheckinSuccessMessage(boundCharId, 'user', data.userConsecutiveDays);
    console.log('用户打卡成功，已发送打卡卡片消息到聊天记录');
}

// AI自动打卡


// 在API调用时触发打卡的函数
// 清理过期的AI活动数据
function cleanupOldActivityData() {
    try {
        const today = new Date().toDateString();
        const keysToRemove = [];
        
        // 遍历localStorage查找所有AI活动数据
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('aiActivity_')) {
                const dateStr = key.replace('aiActivity_', '');
                // 如果不是今天的数据，就标记为删除
                if (dateStr !== today) {
                    keysToRemove.push(key);
                }
            }
        }
        
        // 删除过期的AI活动数据
        keysToRemove.forEach(key => {
            console.log(`清除过期活动数据: ${key}`);
            localStorage.removeItem(key);
        });
        
        if (keysToRemove.length > 0) {
            console.log(`已清理 ${keysToRemove.length} 个过期的AI活动数据`);
        }
    } catch (error) {
        console.error('清理AI活动数据时出错:', error);
    }
}

// ★★★ 简化的打卡提醒检测函数：只要没打卡就一直提醒 ★★★
function checkIfShouldRemindAICheckin() {
    // ★★★ 严格检查：只有绑定的恋爱空间角色才能触发提醒 ★★★
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (!boundCharId || !state.chats[boundCharId]) {
        console.log('🔍 恋爱空间打卡检测：未绑定恋爱空间，跳过');
        return { shouldRemind: false, reason: 'not_bound' };
    }
    
    // ★★★ 确保当前活动的角色就是绑定的角色 ★★★
    if (state.activeChatId !== boundCharId) {
        console.log(`🔍 恋爱空间打卡检测：当前聊天角色 ${state.activeChatId} 不是绑定角色 ${boundCharId}，跳过`);
        return { shouldRemind: false, reason: 'not_bound_char' };
    }
    
    const data = getCheckinData();
    
    // ★★★ 检查今天是否已经打卡过 ★★★
    const alreadyCheckedInMain = hasCheckedInToday(data.aiLastCheckin);
    
    const charName = state.chats[boundCharId]?.name || '角色';
    console.log(`🔍 恋爱空间打卡检测:`);
    console.log(`   📊 今日打卡状态: ${alreadyCheckedInMain ? '✅已打卡' : '❌未打卡'}`);
    console.log(`   👤 绑定角色: ${charName} (${boundCharId})`);
    
    if (alreadyCheckedInMain) {
        console.log(`   ⏭️ 结论: 今天已打卡，跳过提醒`);
        return { shouldRemind: false, reason: 'already_checked_in' };
    } else {
        console.log(`   ✅ 结论: 今天未打卡，需要提醒角色 ${charName} 发送打卡消息`);
        return { 
            shouldRemind: true, 
            totalCheckins: data.aiTotalCheckins,
            consecutiveDays: data.aiConsecutiveDays,
            boundCharName: charName
        };
    }
}

// ★★★ 真正执行AI打卡的函数：简化版，直接执行打卡 ★★★
function executeAICheckin() {
    // ★★★ 严格检查：只有绑定的恋爱空间角色才能打卡 ★★★
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (!boundCharId || !state.chats[boundCharId]) {
        console.log('❌ 执行打卡失败：未绑定恋爱空间');
        return { success: false, reason: 'not_bound' };
    }
    
    // ★★★ 确保当前活动的角色就是绑定的角色 ★★★
    if (state.activeChatId !== boundCharId) {
        console.log(`❌ 执行打卡失败：当前聊天角色 ${state.activeChatId} 不是绑定角色 ${boundCharId}`);
        return { success: false, reason: 'not_bound_char' };
    }
    
    const data = getCheckinData();
    
    // 获取今日活动计数数据
    const today = new Date().toDateString();
    const activityKey = `aiActivity_${today}`;
    let activityData = JSON.parse(localStorage.getItem(activityKey) || '{"count": 0, "hasCheckedIn": false}');
    
    // ★★★ 检查今天是否已经打卡过 ★★★
    const alreadyCheckedInMain = hasCheckedInToday(data.aiLastCheckin);
    const alreadyCheckedInActivity = activityData.hasCheckedIn;
    
    if (alreadyCheckedInMain || alreadyCheckedInActivity) {
        console.log(`❌ 今天已打卡过，无法重复打卡。主数据:${alreadyCheckedInMain ? '已打卡' : '未打卡'}, 活动数据:${alreadyCheckedInActivity ? '已打卡' : '未打卡'}`);
        return { success: false, reason: 'already_checked_in' };
    }
    
    // ★★★ 简化：直接执行打卡，不再检查活动次数 ★★★
    console.log('🎯 开始执行AI打卡...');
    
    // 执行打卡
    const now = new Date();
    
    // 检查是否连续打卡
    if (data.aiLastCheckin) {
        const lastCheckin = new Date(data.aiLastCheckin);
        const yesterday = new Date(now);
        yesterday.setDate(yesterday.getDate() - 1);
        
        if (lastCheckin.toDateString() === yesterday.toDateString()) {
            data.aiConsecutiveDays += 1;
        } else {
            data.aiConsecutiveDays = 1;
        }
    } else {
        data.aiConsecutiveDays = 1;
    }
    
    data.aiLastCheckin = now.toISOString();
    data.aiTotalCheckins += 1;
    
    // 保存到打卡历史记录
    const dateStr = getLocalDateString(now);
    if (!data.aiCheckinHistory) {
        data.aiCheckinHistory = {};
    }
    data.aiCheckinHistory[dateStr] = true;
    
    saveCheckinData(data);
    
    // ★★★ 更新活动数据：标记已打卡 ★★★
    activityData.hasCheckedIn = true;
    activityData.checkinTime = now.toISOString();
    localStorage.setItem(activityKey, JSON.stringify(activityData));
    
    // 更新UI显示
    updateAvatarStatus();
    
    // 更新日历显示
    if (typeof updateCalendarDisplay === 'function') {
        updateCalendarDisplay();
    }
    
    console.log(`🎉 AI打卡成功！连续打卡 ${data.aiConsecutiveDays} 天 🎉`);
    console.log(`📊 打卡状态: ✅已完成`);
    
    return { 
        success: true, 
        consecutiveDays: data.aiConsecutiveDays,
        totalCheckins: data.aiTotalCheckins
    };
}

// ★★★ 解除恋爱空间关系函数 ★★★
function executeLoveSpaceUnbind() {
    console.log('🚨 开始执行解除恋爱空间关系...');
    
    // ★★★ 严格检查：只有绑定的恋爱空间角色才能解除 ★★★
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (!boundCharId || !state.chats[boundCharId]) {
        console.log('❌ 解除失败：未绑定恋爱空间');
        return { success: false, message: '当前没有绑定恋爱空间关系' };
    }
    
    // ★★★ 确保当前活动的角色就是绑定的角色 ★★★
    if (state.activeChatId !== boundCharId) {
        console.log(`❌ 解除失败：当前聊天角色 ${state.activeChatId} 不是绑定角色 ${boundCharId}`);
        return { success: false, message: '只有绑定的恋爱空间角色才能解除关系' };
    }
    
    // 获取角色名用于记录
    const previousBoundChar = state.chats[boundCharId]?.name || '未知角色';
    const unbindTime = new Date().toISOString();
    
    // ★★★ 执行解除绑定：清除所有恋爱空间相关数据 ★★★
    console.log('🗑️ 正在清除恋爱空间相关数据...');
    
    // 清除绑定关系
    localStorage.removeItem('loveSpaceBoundChar');
    
    // 清除所有打卡相关数据
    localStorage.removeItem('loveSpaceCheckinData');
    localStorage.removeItem('checkinHistory');
    localStorage.removeItem('myCheckinDays');
    localStorage.removeItem('partnerCheckinDays');
    
    // 清除所有AI活动记录
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('aiActivity_')) {
            keysToRemove.push(key);
        }
    }
    keysToRemove.forEach(key => localStorage.removeItem(key));
    
    // 更新恋爱空间UI显示
    if (typeof updateLoveSpaceDisplay === 'function') {
        updateLoveSpaceDisplay();
    }
    
    // 更新日历显示
    if (typeof updateCalendarDisplay === 'function') {
        updateCalendarDisplay();
    }
    
    console.log(`💔 恋爱空间关系解除成功！与 ${previousBoundChar} 的关系已彻底清除`);
    
    return { 
        success: true, 
        previousBoundChar: previousBoundChar,
        unbindTime: unbindTime
    };
}

// ★★★ 核心功能2&3：AI活动次数打卡逻辑 - 基于每日活动次数，只有绑定角色才能打卡 ★★★
// ★★★ 旧的活动轮数函数已删除，现在使用简化的打卡提醒机制 ★★★

// 更换用户头像
function changeUserAvatar() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const avatarImg = document.getElementById('user-avatar');
                avatarImg.src = e.target.result;
                localStorage.setItem(USER_AVATAR_KEY, e.target.result);
                showCustomAlert('成功', '用户头像更换成功！');
            };
            reader.readAsDataURL(file);
        }
    };
    
    input.click();
}

// ★★★ 核心功能1：发送打卡成功的卡片消息到聊天记录 ★★★
function sendCheckinSuccessMessage(chatId, senderType, consecutiveDays) {
    if (!state.chats[chatId]) {
        console.error('发送打卡消息失败：聊天不存在', chatId);
        return;
    }
    
    // 强制确保消息格式为打卡卡片
    const senderName = senderType === 'user' ? '我' : (state.chats[chatId] ? state.chats[chatId].name : 'AI');
    const message = {
        id: Date.now() + Math.random(),
        content: `今日${senderName}已成功打卡~ 连续打卡 ${consecutiveDays} 天！💕`,
        timestamp: Date.now(),
        role: senderType === 'user' ? 'user' : 'assistant',
        type: 'checkin-card',  // 强制设置为打卡卡片类型
        senderName: senderName
    };
    
    console.log(`准备发送${senderType}打卡卡片消息:`, message.content);
    
    // 添加消息到聊天历史记录
    if (!state.chats[chatId].history) {
        state.chats[chatId].history = [];
    }
    state.chats[chatId].history.push(message);
    
    // 如果当前正在查看这个聊天，则更新显示
    if (state.activeChatId === chatId) {
        appendMessage(message, state.chats[chatId]);
    }
    
    // 保存状态到数据库
    db.chats.put(state.chats[chatId]).then(() => {
        console.log(`★★★ ${senderType}打卡卡片消息已成功发送并保存到聊天 ${chatId} ★★★`);
    }).catch(error => {
        console.error('保存打卡消息到数据库失败:', error);
    });
}

// 获取用户头像（用于每天想你弹窗）
function getUserAvatar() {
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (boundCharId && state.chats[boundCharId]) {
        return state.chats[boundCharId].settings.myAvatar || 'img/default_avatar.png';
    }
    return 'img/default_avatar.png';
}

// 获取AI头像（用于每天想你弹窗）
function getAIAvatar() {
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (boundCharId && state.chats[boundCharId]) {
        return state.chats[boundCharId].settings.aiAvatar || 'img/default_avatar.png';
    }
    return 'img/default_avatar.png';
}

// 显示打卡详情视图（用户或AI的打卡情况）
function showCheckinView(viewType) {
    const container = document.getElementById('checkin-view-container');
    const checkinData = getCheckinData();
    
    // 显示完整日历界面
    container.innerHTML = `
        <div class="checkin-detail-view">
            <div class="calendar-container">
                <div class="calendar-header">
                    <button class="calendar-nav-btn" onclick="previousMonth()">‹</button>
                    <div class="calendar-month-year" id="calendarMonthYear">2025年9月</div>
                    <button class="calendar-nav-btn" onclick="nextMonth()">›</button>
                </div>
                
                <div class="calendar-weekdays">
                    <div class="calendar-weekday">日</div>
                    <div class="calendar-weekday">一</div>
                    <div class="calendar-weekday">二</div>
                    <div class="calendar-weekday">三</div>
                    <div class="calendar-weekday">四</div>
                    <div class="calendar-weekday">五</div>
                    <div class="calendar-weekday">六</div>
                </div>
                
                <div class="calendar-days" id="calendarDays">
                    <!-- 这里会动态生成日历天数 -->
                </div>
                
                <div class="calendar-legend">
                    <div class="legend-item">
                        <div class="legend-color legend-today"></div>
                        <span>今天</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-user"></div>
                        <span>我打卡</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-ai"></div>
                        <span>伴侣打卡</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color legend-both"></div>
                        <span>都打卡</span>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // 初始化日历显示 - 如果当前月份早于2025年9月，则显示2025年9月
    const now = new Date();
    const startMonth = new Date(2025, 8, 1); // 2025年9月
    
    if (now < startMonth) {
        currentCalendarDate = new Date(2025, 8, 1);
    } else {
        currentCalendarDate = new Date(now.getFullYear(), now.getMonth(), 1);
    }
    
    updateCalendarDisplay();
}

// 旧的生成打卡日历函数（保留兼容性）
function generateCheckinCalendar(lastCheckin, consecutiveDays) {
    // 这个函数现在被新的日历系统替代，但保留以防其他地方还在使用
    return '';
}

// 恋爱空间邀请相关函数已移动到state变量定义之后



// ★★★ 初始化恋爱空间打卡功能 ★★★
function initLoveSpaceCheckin() {
    console.log('初始化恋爱空间打卡功能...');
    
    // 检查是否已绑定角色
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (!boundCharId || !state.chats[boundCharId]) {
        console.log('未绑定恋爱空间角色，跳过打卡初始化');
        return;
    }
    
    console.log(`已绑定恋爱空间角色: ${state.chats[boundCharId].name}`);
    
    // 更新打卡按钮状态
    updateCheckinButton();
    
    // 更新头像状态显示
    updateAvatarStatus();
    
    // 更新打卡统计
    updateCheckinStats();
    
    // 清理过期的AI活动数据
    cleanupOldActivityData();
    
    console.log('恋爱空间打卡功能初始化完成');
}

// ★★★ 调试：获取当前打卡状态的工具函数 ★★★
function getCheckinStatus() {
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    const data = getCheckinData();
    const today = new Date().toDateString();
    const activityKey = `aiActivity_${today}`;
    const activityData = JSON.parse(localStorage.getItem(activityKey) || '{"count": 0, "hasCheckedIn": false}');
    
    const status = {
        绑定角色: boundCharId ? (state.chats[boundCharId] ? state.chats[boundCharId].name : '角色不存在') : '未绑定',
        用户今日已打卡: hasCheckedInToday(data.userLastCheckin),
        AI今日已打卡: hasCheckedInToday(data.aiLastCheckin),
        用户连续天数: data.userConsecutiveDays,
        AI连续天数: data.aiConsecutiveDays,
        AI活动打卡状态: activityData.hasCheckedIn
    };
    
    console.table(status);
    return status;
}

// 加载保存的头像
function loadSavedAvatars() {
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    
    // 更新用户头像
        const userAvatarEl = document.getElementById('user-avatar');
        if (userAvatarEl) {
        if (boundCharId && state.chats && state.chats[boundCharId] && state.chats[boundCharId].settings && state.chats[boundCharId].settings.myAvatar) {
            // 有绑定且有聊天设置中的用户头像时使用
            userAvatarEl.src = state.chats[boundCharId].settings.myAvatar;
            userAvatarEl.style.display = 'block';
            console.log('使用聊天设置中的用户头像');
        } else if (boundCharId) {
            // 有绑定但没有聊天设置头像时，使用存储的自定义头像
            const userAvatar = localStorage.getItem(USER_AVATAR_KEY);
            if (userAvatar) {
            userAvatarEl.src = userAvatar;
                userAvatarEl.style.display = 'block';
                console.log('使用存储的用户头像');
        } else {
                userAvatarEl.style.display = 'none';
            }
        } else {
            // 没有绑定时隐藏用户头像
            userAvatarEl.style.display = 'none';
            console.log('没有绑定，隐藏用户头像');
        }
    }
    
    // 更新AI头像
        const aiAvatarEl = document.getElementById('ai-avatar');
        if (aiAvatarEl) {
        if (boundCharId && state.chats && state.chats[boundCharId]) {
            // 有绑定时显示AI头像
            if (state.chats[boundCharId].settings && state.chats[boundCharId].settings.aiAvatar) {
                aiAvatarEl.src = state.chats[boundCharId].settings.aiAvatar;
                aiAvatarEl.style.display = 'block';
                console.log('使用聊天设置中的AI头像');
            } else if (state.chats[boundCharId].avatar) {
                aiAvatarEl.src = state.chats[boundCharId].avatar;
                aiAvatarEl.style.display = 'block';
                console.log('使用绑定角色头像');
        } else {
                aiAvatarEl.style.display = 'none';
        }
    } else {
            // 没有绑定时隐藏AI头像
            aiAvatarEl.style.display = 'none';
            console.log('没有绑定，隐藏AI头像');
        }
    }
}

// ====== 壁纸相关函数 ======

// 应用壁纸
function applyWallpaper(type, dataUrl) {
    console.log(`应用壁纸: ${type}`, dataUrl ? dataUrl.substring(0, 50) + '...' : 'null');
    
    if (type === 'home') {
        const loveSpaceView = document.getElementById('love-space-view');
        if (loveSpaceView) {
            if (dataUrl) {
                // 方法1：直接设置内联样式
                loveSpaceView.style.setProperty('background-image', `url(${dataUrl})`, 'important');
                loveSpaceView.style.setProperty('background-size', 'cover', 'important');
                loveSpaceView.style.setProperty('background-position', 'center', 'important');
                loveSpaceView.style.setProperty('background-repeat', 'no-repeat', 'important');
                loveSpaceView.style.setProperty('background-attachment', 'fixed', 'important');
                
                // 方法2：通过CSS样式表设置（更可靠）
                addOrUpdateWallpaperStyle('home', dataUrl);
                
                // 保存到localStorage
                localStorage.setItem(HOME_WALLPAPER_KEY, dataUrl);
                console.log('主页壁纸已应用并保存', {
                    element: loveSpaceView,
                    isVisible: loveSpaceView.style.display !== 'none',
                    backgroundImage: loveSpaceView.style.backgroundImage,
                    computedStyle: window.getComputedStyle(loveSpaceView).backgroundImage
                });
            } else {
                // 清除所有背景属性
                loveSpaceView.style.removeProperty('background-image');
                loveSpaceView.style.removeProperty('background-size');
                loveSpaceView.style.removeProperty('background-position');
                loveSpaceView.style.removeProperty('background-repeat');
                loveSpaceView.style.removeProperty('background-attachment');
                
                // 清除CSS样式表中的样式
                removeWallpaperStyle('home');
                
                // 清除localStorage
                localStorage.removeItem(HOME_WALLPAPER_KEY);
                console.log('主页壁纸已清除');
            }
        } else {
            console.log('未找到love-space-view元素');
        }
    } else if (type === 'nav') {
        const bottomNav = document.querySelector('#love-space-view .love-bottom-nav');
        if (bottomNav) {
            if (dataUrl) {
                // 方法1：直接设置内联样式
                bottomNav.style.setProperty('background-image', `url(${dataUrl})`, 'important');
                bottomNav.style.setProperty('background-size', 'cover', 'important');
                bottomNav.style.setProperty('background-position', 'center', 'important');
                bottomNav.style.setProperty('background-repeat', 'no-repeat', 'important');
                bottomNav.style.setProperty('background-attachment', 'fixed', 'important');
                
                // 方法2：通过CSS样式表设置（更可靠）
                addOrUpdateWallpaperStyle('nav', dataUrl);
                
                // 保存到localStorage (使用CHAT_WALLPAPER_KEY作为导航栏壁纸的存储键)
                localStorage.setItem(CHAT_WALLPAPER_KEY, dataUrl);
                console.log('导航栏壁纸已应用并保存', {
                    element: bottomNav,
                    isVisible: bottomNav.offsetParent !== null,
                    backgroundImage: bottomNav.style.backgroundImage
                });
            } else {
                // 清除所有背景属性
                bottomNav.style.removeProperty('background-image');
                bottomNav.style.removeProperty('background-size');
                bottomNav.style.removeProperty('background-position');
                bottomNav.style.removeProperty('background-repeat');
                bottomNav.style.removeProperty('background-attachment');
                
                // 清除CSS样式表中的样式
                removeWallpaperStyle('nav');
                
                // 清除localStorage
                localStorage.removeItem(CHAT_WALLPAPER_KEY);
                console.log('导航栏壁纸已清除');
            }
        } else {
            console.log('未找到love-bottom-nav元素');
        }
    }
}

// 通过CSS样式表添加或更新壁纸样式
function addOrUpdateWallpaperStyle(type, dataUrl) {
    const styleId = `wallpaper-style-${type}`;
    let styleEl = document.getElementById(styleId);
    
    if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = styleId;
        document.head.appendChild(styleEl);
    }
    
    let cssRule;
    if (type === 'home') {
        cssRule = `
            #love-space-view {
                background-image: url(${dataUrl}) !important;
                background-size: cover !important;
                background-position: center !important;
                background-repeat: no-repeat !important;
                background-attachment: fixed !important;
            }
        `;
    } else if (type === 'nav') {
        cssRule = `
            #love-space-view .love-bottom-nav {
                background-image: url(${dataUrl}) !important;
                background-size: cover !important;
                background-position: center !important;
                background-repeat: no-repeat !important;
                background-attachment: fixed !important;
            }
        `;
    }
    
    styleEl.textContent = cssRule;
    console.log(`CSS样式已添加/更新: ${type}`, cssRule);
}

// 移除壁纸样式
function removeWallpaperStyle(type) {
    const styleId = `wallpaper-style-${type}`;
    const styleEl = document.getElementById(styleId);
    if (styleEl) {
        styleEl.remove();
        console.log(`CSS样式已移除: ${type}`);
    }
}

// 初始化恋爱空间壁纸
function initLoveSpaceWallpapers() {
    console.log('=== 开始初始化壁纸 ===');
    console.log('HOME_WALLPAPER_KEY:', HOME_WALLPAPER_KEY);
    console.log('CHAT_WALLPAPER_KEY:', CHAT_WALLPAPER_KEY);
    
    const homeWallpaper = localStorage.getItem(HOME_WALLPAPER_KEY);
    const navWallpaper = localStorage.getItem(CHAT_WALLPAPER_KEY);
    
    console.log('从localStorage获取的壁纸数据:', { 
        homeWallpaper: homeWallpaper ? homeWallpaper.substring(0, 50) + '...' : null, 
        navWallpaper: navWallpaper ? navWallpaper.substring(0, 50) + '...' : null 
    });
    
    // 直接通过CSS样式表应用壁纸，不需要检查元素显示状态
    if (homeWallpaper) {
        console.log('准备应用主页壁纸...');
        addOrUpdateWallpaperStyle('home', homeWallpaper);
    } else {
        console.log('没有找到主页壁纸数据');
        removeWallpaperStyle('home');
    }
    
    if (navWallpaper) {
        console.log('准备应用导航栏壁纸...');
        addOrUpdateWallpaperStyle('nav', navWallpaper);
    } else {
        console.log('没有找到导航栏壁纸数据');
        removeWallpaperStyle('nav');
    }
    
    console.log('=== 壁纸初始化完成 ===');
}



// 初始化恋爱空间
function initLoveSpace() {
    loadSavedAvatars();
    updateCheckinButton();
    updateAvatarStatus();
    updateCheckinStats();
    
    // 检查并更新绑定角色的头像
    updateBoundCharacterAvatar();
}

// 更新绑定角色头像的函数
function updateBoundCharacterAvatar() {
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (!boundCharId) return;
    
    const boundChat = state.chats[boundCharId];
    if (!boundChat) {
        // 如果绑定的角色不存在了，清除绑定
        localStorage.removeItem('loveSpaceBoundChar');
        localStorage.removeItem('loveSpaceBindTime');
        // 更新头像显示（隐藏所有头像）
        loadSavedAvatars();
        return;
    }
    
    // 更新AI头像 - 优先使用聊天设置中的头像
    const aiAvatarImg = document.getElementById('ai-avatar');
    if (aiAvatarImg) {
        if (boundChat.settings && boundChat.settings.aiAvatar) {
            aiAvatarImg.src = boundChat.settings.aiAvatar;
        } else if (boundChat.avatar) {
        aiAvatarImg.src = boundChat.avatar;
    }
    }
    
    // 不再在这里设置头像状态，让updateAvatarStatus函数来处理
    // 这样打卡状态就不会被覆盖了
}

// 旧的相册功能已删除，使用新的相册管理系统

// ▲▲▲ 恋爱空间打卡和头像功能结束 ▲▲▲

// ▲▲▲ 回忆页面功能函数结束 ▲▲▲

// ▼▼▼ 请用这个【终极反代兼容版】替换旧的 triggerAiFriendApplication 函数 ▼▼▼
async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("流程启动", `正在为角色“${chat.name}”准备好友申请...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("配置错误", "API设置不完整，无法继续。");
        return;
    }

    const contextSummary = chat.history
        .slice(-5)
        .map(msg => {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        })
        .join('\n');

    // ▼▼▼ 在这里添加下面的代码 ▼▼▼
    let worldBookContent = '';
    const effectiveWorldBookIds = getEffectiveWorldBookIds(chat);
    if (effectiveWorldBookIds.length > 0) {
        const linkedContents = effectiveWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (请参考)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲

    const systemPrompt = `
# 你的任务
你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的“被拉黑前的对话摘要”，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
# 你的角色设定
${chat.settings.aiPersona}
${worldBookContent} // <--【核心】在这里注入世界书内容
# 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
${contextSummary}
# 指令格式
你的回复【必须】是一个JSON对象，格式如下：
\`\`\`json
{
  "decision": "apply",
  "reason": "在这里写下你想对用户说的、真诚的、有针对性的申请理由。"
}
\`\`\`
`;

        const messagesForApi = [
            {role: 'user', content: systemPrompt}
        ];

        try {
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesForApi,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 0.9,
                })
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
            }

            const data = await response.json();

            // --- 【核心修正：在这里净化AI的回复】 ---
            let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            // 1. 移除头尾可能存在的 "```json" 和 "```"
            rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
            // 2. 移除所有换行符和多余的空格，确保是一个干净的JSON字符串
            const cleanedContent = rawContent.trim();

            // 3. 使用净化后的内容进行解析
            const responseObj = JSON.parse(cleanedContent);
            // --- 【修正结束】 ---

        if (responseObj.decision === 'apply' && responseObj.reason) {
            chat.relationship.status = 'pending_user_approval';
            chat.relationship.applicationReason = responseObj.reason;
            
            state.chats[chatId] = chat; 
            renderChatList();
            await showCustomAlert("申请成功！", `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`);

        } else {
            await showCustomAlert("AI决策", `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`);
            chat.relationship.status = 'blocked_by_user';
            chat.relationship.blockedTimestamp = Date.now(); 
        }
    } catch (error) {
        await showCustomAlert("执行出错", `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now(); 
    } finally {
        await db.chats.put(chat);
        renderChatInterface(chatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】红包功能核心函数 ▼▼▼

/**
 * 【总入口】根据聊天类型，决定打开转账弹窗还是红包弹窗
 */
function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
        openRedPacketModal();
    } else {
        // 单聊保持原样，打开转账弹窗
        document.getElementById('transfer-modal').classList.add('visible');
    }
}

/**
 * 检查钱包余额并扣费
 * @param {number} amount - 需要扣除的金额
 * @param {string} description - 交易描述
 * @param {string} source - 交易来源
 * @returns {boolean} - 是否扣费成功
 */
async function checkAndDeductWalletBalance(amount, description, source) {
    try {
        // 获取当前钱包余额
        const db = await ensureWalletDB();
        if (!db) {
            console.error('无法连接到钱包数据库');
            showInsufficientBalanceModal();
            return false;
        }
        
        const walletRecord = await db.wallet.orderBy('id').first();
        if (!walletRecord) {
            console.error('钱包记录不存在');
            showInsufficientBalanceModal();
            return false;
        }
        
        const currentBalance = walletRecord.balance || 0;
        
        // 检查余额是否足够
        if (currentBalance < amount) {
            // 显示余额不足弹窗
            showInsufficientBalanceModal();
            return false;
        }
        
        // 扣除余额并记录交易
        const newBalance = currentBalance - amount;
        await updateWalletBalance(-amount, description, source);
        
        console.log(`钱包扣费成功：${amount}元，剩余余额：${newBalance}元`);
        return true;
    } catch (error) {
        console.error('钱包扣费失败:', error);
        alert('钱包操作失败，请重试');
        return false;
    }
}

// 确保函数在全局作用域中可访问
window.checkAndDeductWalletBalance = checkAndDeductWalletBalance;

/**
 * 显示余额不足弹窗
 */
function showInsufficientBalanceModal() {
    const existingModal = document.getElementById('insufficient-balance-modal');
    if (existingModal) {
        existingModal.remove();
    }
    
    const modalHtml = `
        <div id="insufficient-balance-modal" class="modal visible">
            <div class="modal-content" style="width: 300px; text-align: center;">
                <div class="modal-header">
                    <span>余额不足</span>
                </div>
                <div class="modal-body" style="padding: 20px;">
                    <p style="margin-bottom: 20px;">钱包余额不足，无法完成此操作</p>
                    <p style="color: #666; font-size: 14px;">建议：</p>
                    <p style="color: #666; font-size: 14px;">1. 通过游戏充值增加余额</p>
                    <p style="color: #666; font-size: 14px;">2. 向朋友乞讨一些零花钱</p>
                </div>
                <div class="modal-footer">
                    <button class="cancel" onclick="document.getElementById('insufficient-balance-modal').remove()">知道了</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}


/**
 * 打开并初始化发红包模态框
 */
function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];
    
    // 清理输入框
    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = '¥ 0.00';
    document.getElementById('rp-direct-total').textContent = '¥ 0.00';

    // 填充专属红包的接收人列表
    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';
chat.members.forEach(member => {
    const option = document.createElement('option');
    // 【核心】使用 originalName 作为提交给AI的值，因为它独一无二
    option.value = member.originalName; 
    // 【核心】使用 groupNickname 作为显示给用户看的值
    option.textContent = member.groupNickname; 
    receiverSelect.appendChild(option);
});
    
    // 默认显示拼手气红包页签
    document.getElementById('rp-tab-group').click();
    
    modal.classList.add('visible');
}

/**
 * 发送群红包（拼手气）
 */
async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的总金额！"); return;
    }
    if (isNaN(count) || count <= 0) {
        alert("请输入有效的红包个数！"); return;
    }
    if (amount / count < 0.01) {
        alert("单个红包金额不能少于0.01元！"); return;
    }

    // 【修改】不再在发送红包时立即扣费，改为AI收红包时才扣费
    // 但仍需检查余额是否足够
    try {
        const db = await ensureWalletDB();
        if (!db) {
            console.error('无法连接到钱包数据库');
            showInsufficientBalanceModal();
            return;
        }
        
        const walletRecord = await db.wallet.orderBy('id').first();
        if (!walletRecord) {
            console.error('钱包记录不存在');
            showInsufficientBalanceModal();
            return;
        }
        
        const currentBalance = walletRecord.balance || 0;
        
        // 检查余额是否足够，但不扣费
        if (currentBalance < amount) {
            showInsufficientBalanceModal();
            return;
        }
    } catch (error) {
        console.error('钱包检查失败:', error);
        alert('钱包操作失败，请重试');
        return;
    }

    const myNickname = chat.settings.myNickname || '我';
    
    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
        timestamp: Date.now(),
        totalAmount: amount,
        count: count,
        greeting: greeting || '恭喜发财，大吉大利！',
        claimedBy: {}, // { name: amount }
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);
    
    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 发送专属红包
 */
async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的金额！"); return;
    }
    if (!receiverName) {
        alert("请选择一个接收人！"); return;
    }
    
    // 【修改】不再在发送红包时立即扣费，改为AI收红包时才扣费
    // 但仍需检查余额是否足够
    try {
        const db = await ensureWalletDB();
        if (!db) {
            console.error('无法连接到钱包数据库');
            showInsufficientBalanceModal();
            return;
        }
        
        const walletRecord = await db.wallet.orderBy('id').first();
        if (!walletRecord) {
            console.error('钱包记录不存在');
            showInsufficientBalanceModal();
            return;
        }
        
        const currentBalance = walletRecord.balance || 0;
        
        // 检查余额是否足够，但不扣费
        if (currentBalance < amount) {
            showInsufficientBalanceModal();
            return;
        }
    } catch (error) {
        console.error('钱包检查失败:', error);
        alert('钱包操作失败，请重试');
        return;
    }
    
    const myNickname = chat.settings.myNickname || '我';

    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'direct',
        timestamp: Date.now(),
        totalAmount: amount,
        count: 1,
        greeting: greeting || '给你准备了一个红包',
        receiverName: receiverName, // 核心字段
        claimedBy: {},
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 【总入口】当用户点击红包卡片时触发 (V4 - 流程重构版)
 * @param {number} timestamp - 被点击的红包消息的时间戳
 */
async function handlePacketClick(timestamp) {
    const currentChatId = state.activeChatId;
    const chat = state.chats[currentChatId];
    if (!chat) return;

    // 不要从数据库重新加载数据，直接使用内存中的数据
    const packet = chat.history.find(m => m.timestamp === timestamp);
    if (!packet) return;

    const myNickname = chat.settings.myNickname || '我';
    const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

    // 如果是专属红包且不是给我的，或已领完，或已领过，都只显示详情
    if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
        showRedPacketDetails(packet);
    } else {
        // 核心流程：先尝试打开红包
        const claimedAmount = await handleOpenRedPacket(packet);
        
        // 如果成功打开（claimedAmount不为null）
        if (claimedAmount !== null) {
            // **关键：在数据更新后，再重新渲染UI**
            renderChatInterface(currentChatId);
            
            // 显示成功提示
            await showCustomAlert("恭喜！", `你领取了 ${packet.senderName} 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`);
        }

        // 无论成功与否，最后都显示详情页
        // 此时需要从state中获取最新的packet对象，因为它可能在handleOpenRedPacket中被更新了
        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        showRedPacketDetails(updatedPacket);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【核心】处理用户打开红包的逻辑 (V5 - 专注于数据更新)
 */
async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    const myNickname = chat.settings.myNickname || '我';
    
    // 1. 检查红包是否还能领
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
        packet.isFullyClaimed = true;
        await db.chats.put(chat);
        await showCustomAlert("手慢了", "红包已被领完！");
        return null; // 返回null表示领取失败
    }
    
    // 2. 计算领取金额
    let claimedAmount = 0;
    const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    if (packet.packetType === 'lucky') {
        if (remainingCount === 1) { claimedAmount = remainingAmount; }
        else {
            const min = 0.01;
            const max = remainingAmount - (remainingCount - 1) * min;
            claimedAmount = Math.random() * (max - min) + min;
        }
    } else { claimedAmount = packet.totalAmount; }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));

    // 3. 更新红包数据
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myNickname] = claimedAmount;
    
    const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
    if (isNowFullyClaimed) {
        packet.isFullyClaimed = true;
    }

    // 4. 构建系统消息和AI指令
    let hiddenMessageContent = isNowFullyClaimed
        ? `[系统提示：用户 (${myNickname}) 领取了最后一个红包，现在 ${packet.senderName} 的红包已被领完。请对此事件发表评论。]`
        : `[系统提示：用户 (${myNickname}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完，你现在可以使用 'open_red_packet' 指令来尝试领取。]`;

    const visibleMessage = { role: 'system', type: 'pat_message', content: `你领取了 ${packet.senderName} 的红包`, timestamp: Date.now() };
    const hiddenMessage = { role: 'system', content: hiddenMessageContent, timestamp: Date.now() + 1, isHidden: true };
    chat.history.push(visibleMessage, hiddenMessage);

    // 5. 更新钱包余额
    const senderName = packet.senderName === myNickname ? '自己' : packet.senderName;
    
    // 【修改】如果是用户自己发送的红包，需要扣除而不是增加钱包余额
    if (packet.role === 'user' && packet.senderName === myNickname) {
        // 用户收自己的红包，从钱包扣除金额
        await updateWalletBalance(-claimedAmount, `你领取了自己的红包`, 'red_packet_self_claimed');
    } else {
        // 用户收别人的红包，增加钱包余额
        await updateWalletBalance(claimedAmount, `领取${senderName}的红包`, 'red_packet');
    }
    
    // 6. 保存到数据库
    await db.chats.put(chat);
    
    // 7. 返回领取的金额，用于后续弹窗
    return claimedAmount;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】显示红包领取详情的模态框 (V4 - 已修复参数错误)
 */
async function showRedPacketDetails(packet) {
    // 1. 直接检查传入的packet对象是否存在，无需再查找
    if (!packet) {
        console.error("showRedPacketDetails收到了无效的packet对象");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');
    const myNickname = chat.settings.myNickname || '我';
    
    // 2. 后续所有逻辑保持不变，直接使用传入的packet对象
    document.getElementById('rp-details-sender').textContent = packet.senderName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜发财，大吉大利！';
    
    const myAmountEl = document.getElementById('rp-details-my-amount');
    if (packet.claimedBy && packet.claimedBy[myNickname]) {
        myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
        myAmountEl.style.display = 'block';
    } else {
        myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}个红包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
        const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
        if(timeLeft > 0) summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});
    
    let luckyKing = { name: '', amount: -1 };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
    }

    claimedEntries.sort((a,b) => b[1] - a[1]);

    claimedEntries.forEach(([name, amount]) => {
        const item = document.createElement('div');
        item.className = 'rp-details-item';
        let luckyTag = '';
        if (luckyKing.name && name === luckyKing.name) {
            luckyTag = '<span class="lucky-king-tag">手气王</span>';
        }
        item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} 元</span>
            ${luckyTag}
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// 绑定关闭详情按钮的事件
document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
});

// 供全局调用的函数，以便红包卡片上的 onclick 能找到它
window.handlePacketClick = handlePacketClick;

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】投票功能核心函数 ▼▼▼

/**
 * 打开创建投票的模态框并初始化
 */
function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';
    
    // 默认创建两个空的选项框
    addPollOptionInput();
    addPollOptionInput();
    
    modal.classList.add('visible');
}

/**
 * 在模态框中动态添加一个选项输入框
 */
function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="选项内容...">
        <button class="remove-option-btn">-</button>
    `;
    
    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
        // 确保至少保留两个选项
        if (container.children.length > 2) {
            wrapper.remove();
        } else {
            alert('投票至少需要2个选项。');
        }
    });
    
    container.appendChild(wrapper);
}

/**
 * 用户确认发起投票
 */
async function sendPoll() {
    if (!state.activeChatId) return;
    
    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
        alert('请输入投票问题！');
        return;
    }
    
    const options = Array.from(document.querySelectorAll('.poll-option-input'))
        .map(input => input.value.trim())
        .filter(text => text); // 过滤掉空的选项

    if (options.length < 2) {
        alert('请至少输入2个有效的投票选项！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const newPollMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'poll',
        timestamp: Date.now(),
        question: question,
        options: options,
        votes: {}, // 初始投票为空
        isClosed: false,
    };
    
    chat.history.push(newPollMessage);
    await db.chats.put(chat);
    
    appendMessage(newPollMessage, chat);
    renderChatList();
    
    document.getElementById('create-poll-modal').classList.remove('visible');
}

// ▼▼▼ 用这个【已修复重复点击问题】的版本替换 handleUserVote 函数 ▼▼▼
/**
 * 处理用户投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 * @param {string} choice - 用户选择的选项文本
 */
async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    // 1. 【核心修正】如果投票不存在或已关闭，直接返回
    if (!poll || poll.isClosed) {
        // 如果是已关闭的投票，则直接显示结果
        if (poll && poll.isClosed) {
            showPollResults(timestamp);
        }
        return;
    }

    // 2. 检查用户是否点击了已经投过的同一个选项
    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
    
    // 3. 【核心修正】如果不是重复点击，才执行投票逻辑
    if (!isReclickingSameOption) {
        // 移除旧投票（如果用户改选）
        for (const option in poll.votes) {
            const voterIndex = poll.votes[option].indexOf(myNickname);
            if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
            }
        }
        // 添加新投票
        if (!poll.votes[choice]) {
            poll.votes[choice] = [];
        }
        poll.votes[choice].push(myNickname);
    }
    
    // 4. 【核心逻辑】现在只处理用户投票事件，不再检查是否结束
    let hiddenMessageContent = null; 
    
    // 只有在用户真正投票或改票时，才生成提示
    if (!isReclickingSameOption) {
         hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
    }

    // 5. 如果有需要通知AI的事件，则创建并添加隐藏消息
    if (hiddenMessageContent) {
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);
    }
    
    // 6. 保存数据并更新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId); 
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 用户结束投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 */
async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("结束投票", "确定要结束这个投票吗？结束后将无法再进行投票。");
    if (confirmed) {
        poll.isClosed = true;

        const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
        const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;
        
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);

        // 【核心修改】只保存数据和更新UI，不调用 triggerAiResponse()
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示投票结果详情
 * @param {number} timestamp - 投票消息的时间戳
 */
function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
    
    if (Object.keys(poll.votes).length === 0) {
        resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
    } else {
        poll.options.forEach(option => {
            const voters = poll.votes[option] || [];
            resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join('、 ') : '无人投票'}
                    </p>
                </div>
            `;
        });
    }

    showCustomAlert("投票结果", resultsHtml);
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】AI头像库管理功能函数 ▼▼▼

/**
 * 打开AI头像库管理模态框
 */
function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `“${chat.name}”的头像库`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
}

/**
 * 渲染AI头像库的内容
 */
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 复用表情面板的样式
        item.style.backgroundImage = `url(${avatar.url})`;
        item.title = avatar.name;

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block'; // 总是显示删除按钮
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除“${avatar.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 向当前AI的头像库中添加新头像
 */
async function addAvatarToLibrary() {
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
        alert("请输入有效的图片URL！");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    if (!chat.settings.aiAvatarLibrary) {
        chat.settings.aiAvatarLibrary = [];
    }

    chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
    await db.chats.put(chat);
    renderAiAvatarLibrary();
}

/**
 * 关闭AI头像库管理模态框
 */
function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
/* ▼▼▼ 步骤 3.2：将这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼ */

// ▼▼▼ 用下面这【一整块】代码，替换你旧的 applyWidgetData 函数 ▼▼▼
function applyWidgetData() {
    if (!state.globalSettings.widgetData) return;
    for (const elementId in state.globalSettings.widgetData) {
        const element = document.getElementById(elementId);
        const savedValue = state.globalSettings.widgetData[elementId];
        if (element) {
            if (element.tagName === 'IMG') {
                element.src = savedValue;
            } 
            // --- ▼▼▼ 这是我们新增的修复逻辑 ▼▼▼ ---
            // 如果是地点这个特殊元素，就用 innerHTML 来正确显示图标
            else if (elementId === 'profile-location') {
                element.innerHTML = savedValue;
            } 
            // 如果是聊天文字元素，直接设置文本内容
            else if (elementId === 'chat-text-1' || elementId === 'chat-text-2') {
                element.textContent = savedValue;
            }
            // --- ▲▲▲ 修复逻辑结束 ▲▲▲ ---
            else {
                // 其他普通文本元素，保持原来的逻辑不变
                element.textContent = savedValue; 
            }
        }
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新辅助函数】打开文件选择器，并返回本地图片的Base64编码
 * @returns {Promise<string|null>} - 返回图片的Base64 Data URL，如果用户取消则返回null
 */
function uploadImageLocally() {
    return new Promise(resolve => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*'; // 只接受图片文件

        input.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    resolve(readerEvent.target.result); // 返回Base64字符串
                };
                reader.readAsDataURL(file);
            } else {
                resolve(null); // 用户关闭了文件选择框
            }
        };

        input.click();
    });
}

// ▼▼▼ 步骤 2.2：用这个已修复的版本，替换旧的 handleEditText 函数 ▼▼▼
async function handleEditText(element) {
    const elementId = element.id;
    const placeholder = element.dataset.placeholder || "请输入新的内容：";
    const textSpan = element.querySelector('span');
    const isComplexElement = !!textSpan;
    const targetElement = isComplexElement ? textSpan : element;
    const currentValue = targetElement.textContent;
    
    const newValue = await showCustomPrompt("修改文字", "请输入新的内容：", currentValue === placeholder ? "" : currentValue);

    if (newValue !== null) {
        const trimmedValue = newValue.trim();
        targetElement.textContent = trimmedValue ? trimmedValue : placeholder;
        state.globalSettings.widgetData[elementId] = isComplexElement ? element.innerHTML : targetElement.textContent;
        await db.globalSettings.put(state.globalSettings);
    }
}
// ▲▲▲ JavaScript 替换结束 ▲▲▲

/**
 * 【全新】触发指定群聊的后台AI互动
 * @param {string} chatId - 要触发互动的群聊ID
 */
async function triggerGroupAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.isGroup) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.warn(`群聊 "${chat.name}" 后台活动失败：API未配置。`);
        return;
    }

    try {
        const lastMessage = chat.history.slice(-1)[0];
        const timeSinceLastMessage = lastMessage ? (Date.now() - lastMessage.timestamp) / 1000 / 60 : Infinity; // in minutes
        
        const membersList = chat.members.map(m => `- ${m.groupNickname} (人设: ${m.persona})`).join('\n');
          const myNickname = chat.settings.myNickname || '我';
  
        let worldBookContent = '';
    const effectiveWorldBookIds = getEffectiveWorldBookIds(chat);
    if (effectiveWorldBookIds.length > 0) {
        const linkedContents = effectiveWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }
    let musicContext = '';
    // 注意：后台群聊活动通常不与特定的“一起听歌”会话绑定，因此这里我们提供一个空的音乐上下文。
    // 如果未来需要更复杂的功能，可以在此扩展。

    const countdownContext = await getCountdownContext(); 
    
    let sharedContext = '';
    // 后台群聊活动中不存在用户分享聊天记录的上下文，因此这里为空。

// ▼▼▼ 从这里开始完整替换 ▼▼▼
    const systemPrompt = `
# 任务
你是一个群聊后台模拟器。当前群聊 "${chat.name}" 已经沉寂了 ${Math.round(timeSinceLastMessage)} 分钟，用户(昵称: "${chat.settings.myNickname || '我'}")不在线。
你的任务是根据下方每个角色的人设，在他们之间【自发地】生成一段简短、自然的对话。

# 核心规则
1.  **【【【身份铁律】】】**: 用户【绝对不在场】。你【绝对不能】生成任何提及用户或与用户对话的内容。整段对话必须是AI角色之间的互动。你的唯一任务是扮演且仅能扮演下方“群成员列表”中明确列出的角色。
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
3.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。
5.  **自然性**: 对话应该简短（2-5条消息即可），符合逻辑和角色性格。可以是闲聊、讨论某个话题，或者对之前聊天内容的延续。不要每次都生成所有人的发言。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **发送带emoji表情的文本**: \`{"type": "text", "name": "角色名", "message": "好开心呀😊今天天气真好🌞"}\` (根据角色性格和人设可以选择使用或不使用emoji表情)
-   **发送表情包**: \`{"type": "sticker", "url": "...", "meaning": "..."}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细中文描述"}\`
${state.globalSettings.enableRealImag ? `-   **发送RealImag真实图片**: \`{"type": "realimag", "name": "角色名", "prompt": "英文描述词..."}\` (生成真实可见的图片)` : ''}
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **发送NovelAI真实图片**: \`{"type": "naiimag", "name": "角色名", "prompt": "英文描述词..."}\` (生成真实可见的图片)` : ''}
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\` (向【群友】发起)
-   **拍一拍群友**: \`{"type": "pat_user", "name": "你的角色名", "targetName": "【被拍的群友名】", "suffix": "(可选)你想加的后缀"}\`
-   **发红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", ...}\`
-   **发起投票**: \`{"type": "poll", "name": "你的角色名", ...}\`

# 如何处理后台互动中的【拍一拍】:
-   后台活动中的 "pat_user" 指令【只能用于拍群内的其他AI角色】。
-   你【必须】在指令中加入一个 \`"targetName"\` 字段，值为被你拍的那个角色的名字。
-   例如: \`{"type": "pat_user", "name": "角色A", "targetName": "角色B"}\`
-   系统会自动生成 "角色A 拍了拍 角色B" 的提示。

${worldBookContent}
${musicContext}
${countdownContext} // <--- 把备忘录加在这里
${sharedContext} 
# 群成员列表及人设
${membersList}
# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}
# 对话历史参考 (最近5条)
${chat.history.slice(-5).map(m => `${m.senderName || '用户'}: ${m.content}`).join('\n')}

现在，请严格遵守以上所有规则，开始你的模拟。`;
        
        const messagesPayload = [{ role: 'user', content: systemPrompt }];

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: 0.9,
                })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        const messagesArray = JSON.parse(aiResponseContent);

        if (Array.isArray(messagesArray) && messagesArray.length > 0) {
            let messageTimestamp = Date.now();
            let firstMessageContent = '';
            
            messagesArray.forEach((msgData, index) => {
                if (msgData.name && msgData.message) {
                    const aiMessage = {
                        role: 'assistant',
                        senderName: msgData.name,
                        content: String(msgData.message),
                        timestamp: messageTimestamp++
                    };
                    chat.history.push(aiMessage);
                    if (index === 0) {
                        firstMessageContent = `${msgData.name}: ${msgData.message}`;
                    }
                }
            });

            // 更新此群聊的最后活动时间戳
            chat.settings.backgroundActivity.lastActivityTimestamp = Date.now();
            
            // 给用户发通知
            chat.unreadCount = (chat.unreadCount || 0) + messagesArray.length;
            showNotification(chatId, firstMessageContent);
            
            // 保存并刷新UI
            await db.chats.put(chat);
            renderChatList();
            
            console.log(`群聊 "${chat.name}" 后台互动成功，生成了 ${messagesArray.length} 条新消息。`);
        }

    } catch (error) {
        console.error(`群聊 "${chat.name}" 的后台活动失败:`, error);
    }
}

// ▼▼▼ 请用这【一整块新代码】替换旧的 handleEditImage 函数 ▼▼▼
async function handleEditImage(element) {
    const elementId = element.id;

    // 【核心修改】移除了按钮文字中的图标
    const choice = await showChoiceModal("修改图片", [
        { text: '从本地上传', value: 'local' },
        { text: '使用网络URL', value: 'url' }
    ]);

    let newValue = null;

    if (choice === 'local') {
        newValue = await uploadImageLocally();
    } else if (choice === 'url') {
        newValue = await showCustomPrompt("修改图片", "请输入新的图片URL：", element.src, "url");
    }

    if (newValue && newValue.trim()) {
        const trimmedValue = newValue.trim();
        element.src = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
    } else if (choice === 'url' && newValue !== null) {
        alert("请输入一个有效的图片URL！");
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】群聊专属后台活动时钟 ▼▼▼

let groupSimulationIntervalId = null; // 用于存储群聊主时钟的ID

/**
 * 启动群聊的后台“主时钟”。这个时钟会一直运行，定期检查所有群聊。
 */
function startGroupSimulation() {
    if (groupSimulationIntervalId) return; // 如果已经启动，则不重复启动
    
    // 我们设置一个相对较短的间隔（比如30秒）来作为“主时钟”的频率
    // 它不是具体某个群聊的活动间隔，而是检查所有群聊的频率
    groupSimulationIntervalId = setInterval(runGroupSimulationTick, 30000); // 30秒检查一次
    console.log("群聊后台活动主时钟已启动，每30秒检查一次所有群聊。");
}

/**
 * 停止群聊的后台“主时钟”。
 */
function stopGroupSimulation() {
    if (groupSimulationIntervalId) {
        clearInterval(groupSimulationIntervalId);
        groupSimulationIntervalId = null;
        console.log("群聊后台活动主时钟已停止。");
    }
}

/**
 * 群聊“主时钟”的每一次心跳执行的函数
 */
function runGroupSimulationTick() {
    const allGroupChats = Object.values(state.chats).filter(chat => chat.isGroup);

    allGroupChats.forEach(chat => {
        const bgSettings = chat.settings.backgroundActivity;
        // 检查1：该群聊自己的开关是否开启
        if (bgSettings && bgSettings.enabled) {
            const now = Date.now();
            // 检查2：使用该群聊自己设置的间隔期
            const intervalMs = (bgSettings.interval || 120) * 1000;
            const lastActivity = bgSettings.lastActivityTimestamp || 0;

            // 检查3：是否到达了该群聊的行动时间
            if (now - lastActivity > intervalMs) {
                console.log(`群聊 "${chat.name}" 到达行动时间 (间隔: ${bgSettings.interval}秒)，准备触发后台互动...`);
                // 触发群聊专属的后台行动函数
                triggerGroupAiAction(chat.id);
            }
        }
    });
}

// ▲▲▲ 新增代码结束 ▲▲▲
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼
/**
 * 【全新】清空所有已关注角色的微博帖子
 */
async function clearFollowingFeed() {
    // 1. 弹出确认框，防止误操作
    const confirmed = await showCustomConfirm(
        '确认清空',
        '此操作将永久删除所有【非你本人发布】的微博，且无法恢复。确定要继续吗？',
        { confirmButtonClass: 'btn-danger' } // 红色按钮以示警告
    );

    if (!confirmed) {
        return; // 如果用户取消，则不执行任何操作
    }

    try {
        // 2. 从数据库中找出所有作者不是'user'的帖子
        const postsToDelete = await db.weiboPosts.where('authorId').notEqual('user').toArray();
        const idsToDelete = postsToDelete.map(p => p.id);

        if (idsToDelete.length === 0) {
            alert("目前没有可以清空的动态。");
            return;
        }

        // 3. 批量删除这些帖子
        await db.weiboPosts.bulkDelete(idsToDelete);

        // 4. 重新渲染“关注的人”的Feed，让界面变空
        await renderWeiboFeeds('weibo-following-view');

        alert(`已成功清空 ${idsToDelete.length} 条动态！`);

    } catch (error) {
        console.error("清空关注动态时出错:", error);
        alert(`操作失败: ${error.message}`);
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这两个【新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 【全新】将保存的图标URL应用到主屏幕的App图标上
 */
function applyAppIcons() {
    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
        const imgElement = document.getElementById(`icon-img-${iconId}`);
        if (imgElement) {
            imgElement.src = state.globalSettings.appIcons[iconId];
        }
    }
}

/**
 * 更新X App图标的显示状态
 */
function updateFloatingXLogo() {
    const xAppIcon = document.getElementById('x-app-icon');
    const xImg = document.getElementById('x-logo-img');
    const xDefaultIcon = document.getElementById('x-default-icon');
    
    if (!xAppIcon || !xImg || !xDefaultIcon) return;
    
    if (state.globalSettings?.appIcons?.['floating-x-logo']) {
        // 有自定义图标
        xImg.src = state.globalSettings.appIcons['floating-x-logo'];
        xImg.style.display = 'block';
        xDefaultIcon.style.display = 'none';
        xAppIcon.classList.add('has-custom-icon');
    } else {
        // 使用默认图标
        xImg.style.display = 'none';
        xDefaultIcon.style.display = 'block';
        xAppIcon.classList.remove('has-custom-icon');
    }
}

/**
 * 【全新】在外观设置页面渲染出所有App图标的设置项
 */
function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = {
        'world-book': '世界书',
        'qq': 'QQ',
        'api-settings': 'API设置',
        'wallpaper': '壁纸',
        'font': '字体',
        'check-phone': '查手机',
        'weibo': '微博',
        'floating-x-logo': '悬浮X图标'
    };


    for (const iconId in state.globalSettings.appIcons) {
        const iconUrl = state.globalSettings.appIcons[iconId];
        const labelText = appLabels[iconId] || '未知App';

        const item = document.createElement('div');
        item.className = 'icon-setting-item';
        // 【重要】我们用 data-icon-id 来标记这个设置项对应哪个图标
        item.dataset.iconId = iconId; 

        item.innerHTML = `
            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
            <button class="change-icon-btn">更换</button>
        `;
        grid.appendChild(item);
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用这块【最终确认版】的代码，替换旧的 openBrowser 和 closeBrowser 函数 ▼▼▼

/**
 * 当用户点击链接卡片时，打开伪浏览器
 * @param {number} timestamp - 被点击消息的时间戳
 */
function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    // 安全检查，确保 chat 和 history 都存在
    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
        console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
        return; // 如果找不到消息，就直接退出
    }

    // 填充浏览器内容
    document.getElementById('browser-title').textContent = message.source_name || '文章详情';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
        <h1 class="article-title">${message.title || '无标题'}</h1>
        <div class="article-meta">
            <span>来源: ${message.source_name || '未知'}</span>
        </div>
        <div class="article-body">
            <p>${(message.content || '内容为空。').replace(/\n/g, '</p><p>')}</p>
        </div>
    `;

    // 显示浏览器屏幕
    showScreen('browser-screen');
}

/**
 * 关闭伪浏览器，返回聊天界面
 * (这个函数现在由 init() 中的事件监听器调用)
 */
function closeBrowser() {
    showScreen('chat-interface-screen'); 
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】用户分享链接功能的核心函数 ▼▼▼

/**
 * 打开让用户填写链接信息的模态框
 */
function openShareLinkModal() {
    if (!state.activeChatId) return;

    // 清空上次输入的内容
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';

    // 显示模态框
    document.getElementById('share-link-modal').classList.add('visible');
}

/**
 * 用户确认分享，创建并发送链接卡片消息
 */
async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
        alert("标题是必填项哦！");
        return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];
    
    // 创建消息对象
    const linkMessage = {
        role: 'user', // 角色是 'user'
        type: 'share_link',
        timestamp: Date.now(),
        title: title,
        description: description,
        source_name: sourceName,
        content: content,
        // 用户分享的链接，我们不提供图片，让它总是显示占位图
        thumbnail_url: null 
    };

    // 将消息添加到历史记录
    chat.history.push(linkMessage);
    await db.chats.put(chat);

    // 渲染新消息并更新列表
    appendMessage(linkMessage, chat);
    renderChatList();

    // 关闭模态框
    document.getElementById('share-link-modal').classList.remove('visible');
}

/**
 * 【全新升级版】根据AI视角和动态设置，构建给AI看的评论区上下文
 * @param {object} post - 正在处理的动态对象
 * @param {object} viewerChat - 正在“看”动态的AI角色
 * @param {string} userNickname - 用户的昵称
 * @returns {{contextString: string, visibilityFlag: string}} - 返回包含上下文文本和可见性标志的对象
 */
function buildCommentsContextForAI(post, viewerChat, userNickname) {
    if (!post.comments || post.comments.length === 0) {
        // ★★★ 关键在这里：确保 "[评论区可见]" 是一个带引号的字符串 ★★★
        return { contextString: "", visibilityFlag: "[评论区可见]" };
    }

    const viewerName = viewerChat.name;
    let commentsForAI;
    let visibilityFlag;

    if (post.areCommentsVisible !== false) {
        commentsForAI = post.comments;
        // ★★★ 关键在这里：确保 "[评论区可见]" 是一个带引号的字符串 ★★★
        visibilityFlag = "[评论区可见]"; 
    } else {
        commentsForAI = post.comments.filter(comment => {
            return comment.commenterName === viewerName
                || comment.commenterName === userNickname
                || comment.replyTo === viewerName;
        });
        // ★★★ 关键在这里：确保 "[评论区部分可见]" 是一个带引号的字符串 ★★★
        visibilityFlag = "[评论区部分可见]";
    }

    if (commentsForAI.length === 0) {
        return { contextString: "", visibilityFlag: visibilityFlag };
    }

    let context = `  └ 评论区:\n`;
    commentsForAI.slice(-5).forEach(c => {
        if (c.replyTo) {
            context += `    - ${c.commenterName} 回复 ${c.replyTo}: ${c.text}\n`;
        } else {
            context += `    - ${c.commenterName}: ${c.text}\n`;
        }
    });
    
    return { contextString: context, visibilityFlag: visibilityFlag };
}



/**
 * 根据AI的视角，过滤出它能看到的动态
 * @param {Array} allPosts - 所有待检查的动态帖子
 * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
 * @returns {Array} - 过滤后该AI可见的动态帖子
 */
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; // 安全检查

    const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

    return allPosts.filter(post => {
        // 规则1：如果是用户发的动态
        if (post.authorId === 'user') {
            // 如果用户设置了“部分可见”
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用户没设置，说明是公开的，所有AI都可见
            return true;
        }

        // 规则2：如果是其他AI发的动态
        const authorGroupId = post.authorGroupId; // 发帖AI所在的分组ID
        
        // 如果发帖的AI没有分组，那它的动态就是公开的
        if (!authorGroupId) {
            return true;
        }

        // 如果发帖的AI有分组，那么只有在同一个分组的AI才能看到
        return authorGroupId === viewerGroupId;
    });
}

/**
 * 应用指定的主题（'light' 或 'dark'）
 * @param {string} theme - 要应用的主题名称
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果开关存在，就同步它的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    localStorage.setItem('ephone-theme', theme);
}

/**
 * 切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}

// ▼▼▼ 请将这【一整块新函数】粘贴到你的JS功能函数定义区 ▼▼▼

function startReplyToMessage() {
    if (!activeMessageTimestamp) return;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    // 1. 【核心修正】同时获取“完整内容”和“预览片段”
    const fullContent = String(message.content || '');
    let previewSnippet = '';

    if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
        previewSnippet = '[表情]';
    } else if (message.type === 'ai_image' || message.type === 'user_photo') {
        previewSnippet = '[图片]';
    } else if (message.type === 'voice_message') {
        previewSnippet = '[语音]';
    } else {
        // 预览片段依然截断，但只用于UI显示
        previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
    }
    
    // 2. 【核心修正】将“完整内容”存入上下文，以备发送时使用
    currentReplyContext = {
        timestamp: message.timestamp,
        senderName: message.senderName || (message.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
        content: fullContent, // <--- 这里存的是完整的原文！
    };

    // 3. 【核心修正】仅在更新“回复预览栏”时，才使用“预览片段”
    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.querySelector('.sender').textContent = `回复 ${currentReplyContext.senderName}:`;
    previewBar.querySelector('.text').textContent = previewSnippet; // <--- 这里用的是缩略版！
    previewBar.style.display = 'block';

    // 4. 后续操作保持不变
    hideMessageActions();
    document.getElementById('chat-input').focus();
}

/**
 * 【全新】取消引用模式
 */
function cancelReplyMode() {
    currentReplyContext = null;
    document.getElementById('reply-preview-bar').style.display = 'none';
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】用户处理转账的核心功能函数 ▼▼▼

let activeTransferTimestamp = null; // 用于暂存被点击的转账消息的时间戳

/**
 * 显示处理转账的操作菜单
 * @param {number} timestamp - 被点击的转账消息的时间戳
 */
function showTransferActionModal(timestamp) {
    activeTransferTimestamp = timestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (message) {
        // 将AI的名字填入弹窗
        document.getElementById('transfer-sender-name').textContent = message.senderName;
    }
    document.getElementById('transfer-actions-modal').classList.add('visible');
}

/**
 * 隐藏处理转账的操作菜单
 */
function hideTransferActionModal() {
    document.getElementById('transfer-actions-modal').classList.remove('visible');
    activeTransferTimestamp = null;
}

/**
 * 处理用户接受或拒绝转账的逻辑
 * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
 */
async function handleUserTransferResponse(choice) {
    if (!activeTransferTimestamp) return;

    const timestamp = activeTransferTimestamp;
    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始转账消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;

    let systemContent;

    // 2. 如果用户选择“拒绝”
    if (choice === 'declined') {
        // 立刻在前端生成一个“退款”卡片，让用户看到
        const refundMessage = {
            role: 'user',
            type: 'transfer',
            isRefund: true, // 这是一个关键标记，用于UI显示这是退款
            amount: originalMessage.amount,
            note: '已拒收对方转账',
            timestamp: Date.now()
        };
        chat.history.push(refundMessage);
        
        // 准备一条对AI可见的隐藏消息，告诉它发生了什么
        systemContent = `[系统提示：你拒绝并退还了“${originalMessage.senderName}”的转账。]`;
    } else { // 如果用户选择“接受”
        // 只需准备隐藏消息通知AI即可
        systemContent = `[系统提示：你接受了“${originalMessage.senderName}”的转账。]`;
    }

    // 3. 创建这条对用户隐藏、但对AI可见的系统消息
    const hiddenMessage = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
        isHidden: true // 这个标记会让它不在聊天界面显示
    };
    chat.history.push(hiddenMessage);

    // 4. 保存所有更改到数据库，并刷新界面
    await db.chats.put(chat);
    hideTransferActionModal(); 
    renderChatInterface(state.activeChatId);
    renderChatList();
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】通话记录功能核心函数 ▼▼▼

async function renderCallHistoryScreen() {
    showScreen('call-history-screen'); // <--【核心修正】把它移动到最前面！

    const listEl = document.getElementById('call-history-list');
    const titleEl = document.getElementById('call-history-title');
    listEl.innerHTML = '';
    titleEl.textContent = '所有通话记录';
    
    const records = await db.callRecords.orderBy('timestamp').reverse().toArray();
    
    if (records.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
        return; // 现在的 return 就没问题了，因为它只跳过了后续的渲染逻辑
    }
    
    records.forEach(record => {
        const card = createCallRecordCard(record);

    addLongPressListener(card, async () => {
        // 1. 弹出输入框，并将旧名称作为默认值，方便修改
        const newName = await showCustomPrompt(
            "自定义通话名称", 
            "请输入新的名称（留空则恢复默认）",
            record.customName || '' // 如果已有自定义名称，就显示它
        );

        // 2. 如果用户点击了“取消”，则什么都不做
        if (newName === null) return;
        
        // 3. 更新数据库中的这条记录
        await db.callRecords.update(record.id, { customName: newName.trim() });
        
        // 4. 刷新整个列表，让更改立刻显示出来
        await renderCallHistoryScreen();
        
        // 5. 给用户一个成功的提示
        await showCustomAlert('成功', '通话名称已更新！');
    });
        listEl.appendChild(card);
    });    
}

// ▼▼▼ 用这个【升级版】函数，完整替换你旧的 createCallRecordCard 函数 ▼▼▼
/**
 * 【升级版】根据单条记录数据，创建一张能显示聊天对象的通话卡片
 * @param {object} record - 一条通话记录对象
 * @returns {HTMLElement} - 创建好的卡片div
 */
function createCallRecordCard(record) {
    const card = document.createElement('div');
    card.className = 'call-record-card';
    card.dataset.recordId = record.id; 

    // 获取通话对象的名字
    const chatInfo = state.chats[record.chatId];
    const chatName = chatInfo ? chatInfo.name : '未知会话';

    const callDate = new Date(record.timestamp);
    const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
    const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;

    const avatarsHtml = record.participants.map(p => 
        `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
    ).join('');
    
    card.innerHTML = `
        <div class="card-header">
            <span class="date">${dateString}</span>
            <span class="duration">${durationText}</span>
        </div>
        <div class="card-body">
            <!-- 【核心修改】在这里新增一个标题行 -->
            ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
            
            <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                <div class="participants-avatars">${avatarsHtml}</div>
                <span class="participants-names">与 ${chatName}</span>
            </div>
        </div>
    `;
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示指定通话记录的完整文字稿
 * @param {number} recordId - 通话记录的ID
 */
async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('transcript-modal-body');

    titleEl.textContent = `通话于 ${new Date(record.timestamp).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
    bodyEl.innerHTML = '';
    
    if (!record.transcript || record.transcript.length === 0) {
        bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
    } else {
        record.transcript.forEach(entry => {
            const bubble = document.createElement('div');
            // 根据角色添加不同的class，应用不同的样式
            bubble.className = `transcript-entry ${entry.role}`; 
            bubble.textContent = entry.content;
            bodyEl.appendChild(bubble);
        });
    }

    const deleteBtn = document.getElementById('delete-transcript-btn');
    
    // 【重要】使用克隆节点技巧，防止事件重复绑定
    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    
    // 为新的、干净的按钮绑定事件
    newDeleteBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm(
            "确认删除",
            "确定要永久删除这条通话记录吗？此操作不可恢复。",
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            // 1. 关闭当前的详情弹窗
            modal.classList.remove('visible');
            
            // 2. 从数据库删除
            await db.callRecords.delete(recordId);
            
            // 3. 刷新通话记录列表
            await renderCallHistoryScreen();
            
            // 4. (可选) 给出成功提示
            alert('通话记录已删除。');
        }
    });
    modal.classList.add('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请用这个【全新函数】替换掉你旧的 handleStatusResetClick 函数 ▼▼▼

/**
 * 【全新】处理用户点击状态栏，弹出编辑框让用户修改AI的当前状态
 */
async function handleEditStatusClick() {
    // 1. 安全检查，确保在单聊界面
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
        return; 
    }
    const chat = state.chats[state.activeChatId];

    // 2. 弹出输入框，让用户输入新的状态，并将当前状态作为默认值
    const newStatusText = await showCustomPrompt(
        '编辑对方状态',
        '请输入对方现在的新状态：',
        chat.status.text // 将当前状态作为输入框的默认内容
    );

    // 3. 如果用户输入了内容并点击了“确定”
    if (newStatusText !== null) {
        // 4. 更新内存和数据库中的状态数据
        chat.status.text = newStatusText.trim() || '在线'; // 如果用户清空了，就默认为“在线”
        chat.status.isBusy = false; // 每次手动编辑都默认其不处于“忙碌”状态
        chat.status.lastUpdate = Date.now();
        await db.chats.put(chat);

        // 5. 立刻刷新UI，让用户看到修改后的状态
        renderChatInterface(state.activeChatId);
        renderChatList();
        
        // 6. 给出一个无伤大雅的成功提示
        await showCustomAlert('状态已更新', `“${chat.name}”的当前状态已更新为：${chat.status.text}`);
    }
}

// 放在你的JS功能函数定义区
async function openShareTargetPicker() {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';

    // 获取所有聊天作为分享目标
    const chats = Object.values(state.chats);

    chats.forEach(chat => {
        // 复用联系人选择器的样式
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; 
        item.innerHTML = `
            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

function closeMusicPlayerWithAnimation(callback) {
    const overlay = document.getElementById('music-player-overlay');
    if (!overlay.classList.contains('visible')) {
        if (callback) callback();
        return;
    }
    overlay.classList.remove('visible');
    setTimeout(() => {
        document.getElementById('music-playlist-panel').classList.remove('visible');
        if (callback) callback();
    }, 400); 
}

function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = lrcContent.split('\n');
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

    for (const line of lines) {
        const text = line.replace(timeRegex, '').trim();
        if (!text) continue;
        timeRegex.lastIndex = 0;
        let match;
        while ((match = timeRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            lyrics.push({ time, text });
        }
    }
    return lyrics.sort((a, b) => a.time - b.time);
}

function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
        return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
}

function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
        if (currentTime >= musicState.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();
}

function updateLyricsUI() {
    const lyricsList = document.getElementById('music-lyrics-list');
    const container = document.getElementById('music-lyrics-container');
    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));
    if (musicState.currentLyricIndex === -1) {
        lyricsList.style.transform = `translateY(0px)`;
        return;
    }
    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
        activeLine.classList.add('active');
        const containerHeight = container.offsetHeight;
        const offset = (containerHeight / 3) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
        lyricsList.style.transform = `translateY(${offset}px)`;
    }

    // ▼▼▼ 在这里添加下面这块【新代码】 ▼▼▼
    // 【核心新增】同步歌词到悬浮栏
    const floatingLyricText = document.getElementById('floating-lyric-text');
    if (activeLine) {
        floatingLyricText.textContent = activeLine.textContent;
    } else if (musicState.parsedLyrics.length > 0) {
        floatingLyricText.textContent = '♪ ♪ ♪'; // 歌曲前奏
    } else {
        floatingLyricText.textContent = '♪ 暂无歌词 ♪';
    }
    // ▲▲▲ 新代码添加结束 ▲▲▲

}

function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
}

function updateMusicProgressBar() {
    const currentTimeEl = document.getElementById('music-current-time');
    const totalTimeEl = document.getElementById('music-total-time');
    const progressFillEl = document.getElementById('music-progress-fill');
    if (!audioPlayer.duration) {
        currentTimeEl.textContent = "0:00";
        totalTimeEl.textContent = "0:00";
        progressFillEl.style.width = '0%';
        return;
    }
    const progressPercent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
    progressFillEl.style.width = `${progressPercent}%`;
    currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
    totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
    updateActiveLyric(audioPlayer.currentTime);
}

/**
 * 【全新】处理用户点击“撤回”按钮的入口函数
 */
async function handleRecallClick() {
    if (!activeMessageTimestamp) return;

    const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
    const messageTime = activeMessageTimestamp;
    const now = Date.now();

    // 检查是否超过了撤回时限
    if (now - messageTime > RECALL_TIME_LIMIT_MS) {
        hideMessageActions();
        await showCustomAlert('操作失败', '该消息发送已超过2分钟，无法撤回。');
        return;
    }
    
    // 如果在时限内，执行真正的撤回逻辑
    await recallMessage(messageTime, true);
    hideMessageActions();
}

/**
 * 【全新】消息撤回的核心逻辑
 * @param {number} timestamp - 要撤回的消息的时间戳
 * @param {boolean} isUserRecall - 是否是用户主动撤回
 */
async function recallMessage(timestamp, isUserRecall) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const messageToRecall = chat.history[messageIndex];

    // 1. 修改消息对象，将其变为“已撤回”状态
    const recalledData = {
        originalType: messageToRecall.type || 'text',
        originalContent: messageToRecall.content,
        // 保存其他可能存在的原始数据
        originalMeaning: messageToRecall.meaning,
        originalQuote: messageToRecall.quote 
    };
    
    messageToRecall.type = 'recalled_message';
    messageToRecall.content = isUserRecall ? '你撤回了一条消息' : '对方撤回了一条消息';
    messageToRecall.recalledData = recalledData;
    // 清理掉不再需要的旧属性
    delete messageToRecall.meaning;
    delete messageToRecall.quote;

    // 2. 如果是用户撤回，需要给AI发送一条它看不懂内容的隐藏提示
    if (isUserRecall) {
        const hiddenMessageForAI = {
            role: 'system',
            content: `[系统提示：用户撤回了一条消息。你不知道内容是什么，只需知道这个事件即可。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessageForAI);
    }

    // 3. 保存到数据库并刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    if(isUserRecall) renderChatList(); // 用户撤回时，最后一条消息变了，需要刷新列表
}

// ▼▼▼ 【全新】将这些函数粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 打开分类管理模态框
 */
async function openCategoryManager(isGlobal = false) {
    try {
        // 存储当前管理的类型，供其他函数使用
        window.currentCategoryType = isGlobal;
        await renderCategoryListInManager(isGlobal);
        const typeText = isGlobal ? '全局' : '局部';
        
        // 安全地设置标题
        const titleElement = document.querySelector('#world-book-category-manager-modal .modal-header span');
        if (titleElement) {
            titleElement.textContent = `管理${typeText}世界书分类`;
        } else {
            console.error('找不到分类管理模态框的标题元素');
        }
        
        // 显示模态框
        const modal = document.getElementById('world-book-category-manager-modal');
        if (modal) {
            modal.classList.add('visible');
        } else {
            console.error('找不到分类管理模态框');
        }
    } catch (error) {
        console.error('打开分类管理器时出错:', error);
        alert('打开分类管理器失败，请刷新页面重试');
    }
}

/**
 * 在模态框中渲染已存在的分类列表
 */
async function renderCategoryListInManager(isGlobal = false) {
    try {
        const listEl = document.getElementById('existing-categories-list');
        if (!listEl) {
            console.error('找不到分类列表容器元素');
            return;
        }
        
        const allCategories = await db.worldBookCategories.toArray();
        const categories = allCategories
            .filter(cat => cat.isGlobal === isGlobal)
            .sort((a, b) => a.name.localeCompare(b.name));
        
        listEl.innerHTML = '';
        if (categories.length === 0) {
            const typeText = isGlobal ? '全局' : '局部';
            listEl.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">还没有任何${typeText}分类</p>`;
        }
        
        categories.forEach(cat => {
            // 复用好友分组的样式
            const item = document.createElement('div');
            item.className = 'existing-group-item'; 
            item.innerHTML = `
                <span class="group-name">${cat.name}</span>
                <span class="delete-group-btn" data-id="${cat.id}">×</span>
            `;
            listEl.appendChild(item);
        });
    } catch (error) {
        console.error('渲染分类列表时出错:', error);
    }
}

/**
 * 添加一个新的世界书分类
 */
async function addNewCategory(isGlobal = false) {
    const input = document.getElementById('new-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分类名不能为空！');
        return;
    }
    // 检查同类型下是否已存在同名分类
    const existing = await db.worldBookCategories.where('name').equals(name).and(cat => cat.isGlobal === isGlobal).first();
    if (existing) {
        const typeText = isGlobal ? '全局' : '局部';
        alert(`${typeText}分类 "${name}" 已经存在了！`);
        return;
    }
    await db.worldBookCategories.add({ name, isGlobal });
    input.value = '';
    await renderCategoryListInManager(isGlobal);
    // 刷新对应的世界书页面
    await renderWorldBookPage(isGlobal ? 'global' : 'local');
}

/**
 * 删除一个世界书分类
 * @param {number} categoryId - 要删除的分类的ID
 */
async function deleteCategory(categoryId) {
    const confirmed = await showCustomConfirm(
        '确认删除', 
        '删除分类后，该分类下的所有世界书将变为“未分类”。确定要删除吗？', 
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.worldBookCategories.delete(categoryId);
        // 将属于该分类的世界书的 categoryId 设为 null
        const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
        for (const book of booksToUpdate) {
            book.categoryId = null;
            await db.worldBooks.put(book);
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if(bookInState) bookInState.categoryId = null;
        }
        // 不在这里刷新，由调用者负责刷新
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】角色专属NPC库管理功能函数 ▼▼▼

let editingNpcId = null; // 用于追踪正在编辑的NPC

/**
 * 打开NPC库管理界面
 */
function openNpcManager() {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('npc-management-title').textContent = `“${chat.name}”的NPC库`;
    renderNpcList();
    showScreen('npc-management-screen');
}

/**
 * 渲染NPC列表
 */
function renderNpcList() {
    const listEl = document.getElementById('npc-management-list');
    const chat = state.chats[state.activeChatId];
    const npcLibrary = chat.npcLibrary || [];
    listEl.innerHTML = '';

    if (npcLibrary.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">这里空空如也，点击右上角“+”添加第一个NPC吧！</p>';
        return;
    }

    npcLibrary.forEach(npc => {
        // 复用聊天列表的样式，非常方便
        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.style.cursor = 'pointer';
        item.innerHTML = `
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <div class="info">
                <span class="name">${npc.name}</span>
                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
            </div>
        `;
        // 点击编辑
        item.addEventListener('click', () => openNpcEditor(npc.id));
        // 长按删除
        addLongPressListener(item, () => deleteNpc(npc.id, npc.name));
        listEl.appendChild(item);
    });
}

// ▼▼▼ 用这个【全新的、已修复两个Bug的函数】，完整替换旧的 openNpcEditor 函数 ▼▼▼
async function openNpcEditor(npcId = null) {
    editingNpcId = npcId;
    // 【核心修复1】使用正确的 state.activeChatId 来获取当前聊天对象
    const chat = state.chats[state.activeChatId];
    if (!chat) return; // 安全检查

    let npc = { name: '', persona: '', avatar: defaultGroupMemberAvatar };
    
    if (npcId) {
        // 【核心修复2】从正确的 chat.npcLibrary 中查找数据
        npc = (chat.npcLibrary || []).find(n => n.id === npcId) || npc;
        document.getElementById('persona-editor-title').textContent = `编辑NPC: ${npc.name}`;
    } else {
        document.getElementById('persona-editor-title').textContent = '添加新NPC';
    }
    
    // 填充编辑器内容
    document.getElementById('npc-editor-name-input').value = npc.name;
    document.getElementById('preset-avatar-preview').src = npc.avatar;
    document.getElementById('preset-persona-input').value = npc.persona;
    
    // 【核心逻辑】根据NPC模式，显隐特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'block';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'none';

    // 绑定正确的保存函数
    document.getElementById('save-persona-preset-btn').onclick = saveNpc;

    // 最后才显示弹窗
    document.getElementById('persona-editor-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲






// ▼▼▼ 从这里开始替换 ▼▼▼
/**
 * 【V2 - 完整版】保存NPC（新建或更新）
 */
async function saveNpc() {
    const chat = state.chats[state.activeChatId];

    
    // 从编辑器中获取所有数据
    const name = document.getElementById('npc-editor-name-input').value.trim();
    const persona = document.getElementById('preset-persona-input').value.trim();
    const avatar = document.getElementById('preset-avatar-preview').src;

    if (!name) {
        alert("NPC名字不能为空！");
        return;
    }

    if (editingNpcId) {
        // 更新现有的NPC
        const npc = chat.npcLibrary.find(n => n.id === editingNpcId);
        if (npc) {
            npc.name = name;
            npc.persona = persona;
            npc.avatar = avatar;
        }
    } else {
        // 添加一个全新的NPC
        const newNpc = {
            id: 'npc_' + Date.now(),
            name: name,
            persona: persona,
            avatar: avatar
        };
        chat.npcLibrary.push(newNpc);
    }

    await db.chats.put(chat);
    renderNpcList();
    closePersonaEditor(); // 复用关闭编辑器的函数
}
// ▲▲▲ 替换到这里结束 ▲▲▲


/**
 * 删除一个NPC
 * @param {string} npcId - 要删除的NPC的ID
 * @param {string} npcName - 要删除的NPC的名字，用于确认提示
 */
async function deleteNpc(npcId, npcName) {
    const confirmed = await showCustomConfirm(
        '删除NPC',
        `确定要从“${state.chats[state.activeChatId].name}”的NPC库中删除 “${npcName}” 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        chat.npcLibrary = chat.npcLibrary.filter(n => n.id !== npcId);
        await db.chats.put(chat);
        renderNpcList();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// --- ▼▼▼ 【全新】自定义头像框管理功能 ▼▼▼ ---

function openFrameManager() {
    renderFrameManager();
    document.getElementById('custom-frame-manager-modal').classList.add('visible');
}

async function renderFrameManager() {
    const grid = document.getElementById('custom-frame-grid');
    grid.innerHTML = '';
    const customFrames = await db.customAvatarFrames.toArray();
    if (customFrames.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">你还没有上传过头像框哦~</p>';
        return;
    }
    customFrames.forEach(frame => {
        const item = document.createElement('div');
        // 复用表情面板的样式，很方便
        item.className = 'sticker-item'; 
        item.style.backgroundImage = `url(${frame.url})`;
        item.title = frame.name;
        
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像框', `确定要删除“${frame.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.customAvatarFrames.delete(frame.id);
                renderFrameManager(); // 刷新管理列表
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 【V2多选版】处理用户上传自定义头像框的逻辑
 */
function handleUploadCustomFrame() {
    document.getElementById('custom-frame-upload-input').addEventListener('change', async (event) => {
        const files = event.target.files;
        if (!files.length) return;

        const newFrames = [];
        
        // 使用 for...of 循环来逐个处理选中的文件
        for (const file of files) {
            // 【核心修改】自动生成名字，而不是让用户输入
            // 我们用 "文件名 (前8位) + 时间戳" 来确保名字几乎不会重复
            const fileName = file.name.replace(/\.[^/.]+$/, "").substring(0, 8);
            const autoName = `${fileName}_${Date.now()}`;

            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            
            newFrames.push({
                id: 'frame_' + (Date.now() + newFrames.length), // 确保ID唯一
                name: autoName,
                url: base64Url
            });
        }
        
        // 循环结束后，批量添加到数据库
        if (newFrames.length > 0) {
            await db.customAvatarFrames.bulkAdd(newFrames);
            renderFrameManager(); // 刷新管理列表
            await showCustomAlert("上传成功", `已成功添加 ${newFrames.length} 个新头像框！`);
        }

        // 清空文件选择器的值
        event.target.value = null;
    }, { once: true });

    document.getElementById('custom-frame-upload-input').click();
}

// ▲▲▲ 新增功能函数结束 ▲▲▲

// ▼▼▼ 用这【一整块】全新的代码，替换掉你旧的 openFrameSelectorModal 函数 ▼▼▼

async function openFrameSelectorModal(type, targetId = null) {
    const grid = document.getElementById('avatar-frame-grid');
    grid.innerHTML = '';
    
    currentFrameSelection.type = type;
    currentFrameSelection.target = targetId;
    
    const chat = state.chats[state.activeChatId];
    let currentFrameUrl = '';
    let previewAvatarUrl = '';

    // 确定当前使用的是哪个头像框和哪个头像
    if (type === 'ai') {
        currentFrameUrl = chat.settings.aiAvatarFrame || '';
        previewAvatarUrl = chat.settings.aiAvatar || defaultAvatar;
    } else if (type === 'my') {
        currentFrameUrl = chat.settings.myAvatarFrame || '';
        previewAvatarUrl = chat.settings.myAvatar || defaultAvatar;
    } else if (type === 'member' && targetId) {
        const member = chat.members.find(m => m.id === targetId);
        if (member) {
            currentFrameUrl = member.avatarFrame || '';
            previewAvatarUrl = member.avatar || defaultGroupMemberAvatar;
        }
    }
    
    // 【核心改造】
    // 1. 从数据库读取你自己的自定义头像框
    const customFrames = await db.customAvatarFrames.toArray();

    // 2. 将内置的头像框数组和你的自定义头像框数组合并成一个大列表
    //    我们使用 Set 来自动去重，防止内置的和自定义的URL重复
    const frameUrlSet = new Set();
    const allFrames = [...avatarFrames, ...customFrames].filter(frame => {
        if (!frame.url || !frameUrlSet.has(frame.url)) {
            frameUrlSet.add(frame.url);
            return true;
        }
        return false;
    });

    // 3. 遍历这个合并后的大列表来创建所有选项
    allFrames.forEach(frame => {
        const item = createFrameItem(frame, previewAvatarUrl);
        // 如果当前头像框的URL和列表中的某一项匹配，就默认选中它
        if (currentFrameUrl === frame.url) {
            item.classList.add('selected');
            // 确保初始选择被记录
            currentFrameSelection.url = frame.url;
        }
        grid.appendChild(item);
    });

    // 最后，显示模态框
    document.getElementById('avatar-frame-modal').classList.add('visible');
}

// ▲▲▲ 替换结束 ▲▲▲

// 辅助函数：创建一个头像框选项
function createFrameItem(frame, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.title = frame.name;
    item.innerHTML = `
        <img src="${previewAvatarSrc}" class="preview-avatar">
        ${frame.url ? `<img src="${frame.url}" class="preview-frame" style="pointer-events: none;">` : ''}
    `;
    item.addEventListener('click', () => {
        document.querySelectorAll('#avatar-frame-grid .frame-item').forEach(el => el.classList.remove('selected'));
        item.classList.add('selected');
        currentFrameSelection.url = frame.url;
    });
    return item;
}

// 保存选择
async function saveSelectedFrames() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const { type, url, target } = currentFrameSelection;

    if (type === 'ai') {
        chat.settings.aiAvatarFrame = url;
    } else if (type === 'my') {
        chat.settings.myAvatarFrame = url;
    } else if (type === 'member' && target) {
        const member = chat.members.find(m => m.id === target);
        if (member) member.avatarFrame = url;
    }
    
    await db.chats.put(chat);
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    
    // 刷新UI
    renderChatInterface(state.activeChatId);
    // 如果聊天设置弹窗还开着，就刷新一下里面的头像预览
    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
        document.getElementById('chat-settings-btn').click(); 
    }
}

/**
 * 检查两个时间戳是否在不同的自然日
 * @param {number} timestamp1 - 新消息的时间戳
 * @param {number | null} timestamp2 - 上一条消息的时间戳
 * @returns {boolean} - 如果是新的一天，返回 true
 */
function isNewDay(timestamp1, timestamp2) {
    // 如果没有上一条消息的时间戳，说明这是第一条消息，肯定要显示日期
    if (!timestamp2) return true;

    const date1 = new Date(timestamp1);
    const date2 = new Date(timestamp2);

    // 比较年、月、日是否完全相同
    return date1.getFullYear() !== date2.getFullYear() ||
           date1.getMonth()    !== date2.getMonth()    ||
           date1.getDate()     !== date2.getDate();
}

/**
 * 将时间戳格式化为 "X月X日 HH:mm" 的形式
 * @param {number} timestamp - 时间戳
 * @returns {string} - 格式化后的日期字符串
 */
function formatDateStamp(timestamp) {
    const date = new Date(timestamp);
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${month}月${day}日 ${hours}:${minutes}`;
}

/**
 * 【全新】根据时间戳，格式化聊天列表右侧的日期/时间显示
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式化后的字符串 (例如 "14:30", "昨天", "08/03")
 */
function formatChatListTimestamp(timestamp) {
    if (!timestamp) return ''; // 如果没有时间戳，返回空字符串

    const now = new Date();
    const msgDate = new Date(timestamp);

    // 判断是否为今天
    const isToday = now.getFullYear() === msgDate.getFullYear() &&
                    now.getMonth() === msgDate.getMonth() &&
                    now.getDate() === msgDate.getDate();

    if (isToday) {
        // 如果是今天，只显示时间
        return msgDate.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    }

    // 判断是否为昨天
    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    const isYesterday = yesterday.getFullYear() === msgDate.getFullYear() &&
                        yesterday.getMonth() === msgDate.getMonth() &&
                        yesterday.getDate() === msgDate.getDate();

    if (isYesterday) {
        return '昨天';
    }

    // 判断是否为今年
    if (now.getFullYear() === msgDate.getFullYear()) {
        // 如果是今年，显示 "月/日"
        const month = String(msgDate.getMonth() + 1).padStart(2, '0');
        const day = String(msgDate.getDate()).padStart(2, '0');
        return `${month}/${day}`;
    }

    // 如果是更早的年份，显示 "年/月/日"
    const year = msgDate.getFullYear();
    const month = String(msgDate.getMonth() + 1).padStart(2, '0');
    const day = String(msgDate.getDate()).padStart(2, '0');
    return `${year}/${month}/${day}`;
}

/**
 * 【全新】创建一个功能完整的日期戳“伪消息”元素
 * @param {number} timestamp - 该日期戳代表的时间
 * @returns {HTMLElement} - 创建好的 DOM 元素
 */
function createDateStampElement(timestamp) {
    // 1. 创建最外层的包裹 div，和真实消息一样
    const wrapper = document.createElement('div');
    wrapper.className = 'message-wrapper date-stamp-wrapper';
    // 【核心】把时间戳存起来，这是多选和删除的关键
    wrapper.dataset.timestamp = timestamp; 

    // 2. 创建气泡 div
    const bubble = document.createElement('div');
    // 【核心】同时加上 .message-bubble 类，让多选逻辑能找到它
    bubble.className = 'message-bubble date-stamp-bubble';
    bubble.dataset.timestamp = timestamp;
    bubble.textContent = formatDateStamp(timestamp);
    
    wrapper.appendChild(bubble);

    // 3. 【核心】为它绑定和真实消息完全一样的事件监听器
    addLongPressListener(wrapper, () => {
        // 日期戳不支持复杂操作，长按直接进入多选
        enterSelectionMode(timestamp);
    });
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(timestamp);
        }
    });

    return wrapper;
}
// ▼▼▼ 在你的JS功能函数定义区，粘贴下面这一整块新代码 ▼▼▼

// --- 美化功能的核心变量 ---
let activeThemeId = null; // 用于追踪当前正在编辑的主题ID

/**
 * 将CSS代码应用到页面上
 * @param {string} cssCode - 要应用的CSS代码字符串
 */
function applyThemeCss(cssCode) {
    const styleTag = document.getElementById('custom-theme-style');
    if (styleTag) {
        styleTag.innerHTML = cssCode || '';
    }
}

/**
 * 从数据库加载所有主题到下拉选择框
 */
async function loadThemesToDropdown() {
    const selector = document.getElementById('theme-selector');
    selector.innerHTML = '<option value="">-- 选择方案或新建 --</option>'; // 默认选项
    
    const themes = await db.themes.toArray();
    themes.forEach(theme => {
        const option = document.createElement('option');
        option.value = theme.id;
        option.textContent = theme.name;
        selector.appendChild(option);
    });
}

/**
 * 处理用户从下拉框选择一个主题的逻辑
 */
async function handleThemeSelection() {
    const selector = document.getElementById('theme-selector');
    const editor = document.getElementById('theme-css-editor');
    activeThemeId = selector.value ? parseInt(selector.value) : null;
    
    if (activeThemeId) {
        const theme = await db.themes.get(activeThemeId);
        editor.value = theme.css;
    } else {
        // 如果选择“--”，就加载模板
        editor.value = THEME_CSS_TEMPLATE;
    }
    // 立即应用选中的或模板代码，让用户看到效果
    applyThemeCss(editor.value);
}

/**
 * 保存当前编辑区的内容到当前选中的主题
 */
async function saveCurrentTheme() {
    if (!activeThemeId) {
        alert("请先选择一个方案，或使用“另存为”来创建新方案。");
        return;
    }
    const cssCode = document.getElementById('theme-css-editor').value;
    await db.themes.update(activeThemeId, { css: cssCode });
    alert("当前方案已保存！");
}

/**
 * 将当前编辑区的内容另存为一个新主题
 */
async function saveAsNewTheme() {
    const themeName = await showCustomPrompt("保存新方案", "请输入新方案的名称");
    if (!themeName || !themeName.trim()) {
        if(themeName !== null) alert("方案名称不能为空！");
        return;
    }
    const cssCode = document.getElementById('theme-css-editor').value;
    const newTheme = { name: themeName.trim(), css: cssCode };
    const newId = await db.themes.add(newTheme);
    
    // 刷新下拉框并自动选中新保存的方案
    await loadThemesToDropdown();
    document.getElementById('theme-selector').value = newId;
    activeThemeId = newId;
    
    alert(`方案 "${themeName}" 已成功保存！`);
}

/**
 * 重命名当前选中的主题
 */
async function renameSelectedTheme() {
    if (!activeThemeId) {
        alert("请先选择一个要重命名的方案。");
        return;
    }
    const currentTheme = await db.themes.get(activeThemeId);
    const newName = await showCustomPrompt("重命名方案", "请输入新的名称", currentTheme.name);
    if (newName && newName.trim()) {
        await db.themes.update(activeThemeId, { name: newName.trim() });
        await loadThemesToDropdown();
        document.getElementById('theme-selector').value = activeThemeId;
        alert("重命名成功！");
    }
}

/**
 * 删除当前选中的主题
 */
async function deleteSelectedTheme() {
    if (!activeThemeId) {
        alert("请先选择一个要删除的方案。");
        return;
    }
    const confirmed = await showCustomConfirm(
        "确认删除", 
        `确定要删除方案 "${document.getElementById('theme-selector').selectedOptions[0].textContent}" 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.themes.delete(activeThemeId);
        activeThemeId = null;
        await loadThemesToDropdown();
        // 恢复到模板状态
        document.getElementById('theme-css-editor').value = THEME_CSS_TEMPLATE;
        applyThemeCss(THEME_CSS_TEMPLATE);
        alert("方案已删除。");
    }
}

/**
 * 导出当前选中的主题为一个JSON文件
 */
async function exportTheme() {
    if (!activeThemeId) {
        alert("请先选择一个要导出的方案。");
        return;
    }
    const theme = await db.themes.get(activeThemeId);
    const exportData = {
        themeName: theme.name,
        themeCss: theme.css
    };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${theme.name}-Theme.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 导入一个主题JSON文件
 */
function importTheme(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            if (data.themeName && typeof data.themeCss !== 'undefined') {
                // 为了避免重名，导入时可以在名字后面加个 "(导入)"
                const newTheme = {
                    name: `${data.themeName} (导入)`,
                    css: data.themeCss
                };
                const newId = await db.themes.add(newTheme);
                await loadThemesToDropdown();
                document.getElementById('theme-selector').value = newId;
                handleThemeSelection(); // 导入后自动选中并应用
                alert(`方案 "${newTheme.name}" 导入成功！`);
            } else {
                alert("导入失败：文件格式不正确。");
            }
        } catch (error) {
            alert(`导入失败：文件解析错误。 ${error.message}`);
        }
    };
    reader.readAsText(file);
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】API预设功能核心函数 ▼▼▼

/**
 * 渲染并填充API预设的下拉选择框
 */
function renderApiPresetSelector() {
    const selectEl = document.getElementById('api-preset-select');
    if (!selectEl) return;

    selectEl.innerHTML = '<option value="">-- 自定义配置 --</option>';

    if (state.apiPresets) {
        state.apiPresets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            selectEl.appendChild(option);
        });
    }

    // 检查当前配置是否匹配任何一个预设
    const { proxyUrl, apiKey } = state.apiConfig;
    const matchingPreset = state.apiPresets ? state.apiPresets.find(p => p.proxyUrl === proxyUrl && p.apiKey === apiKey) : null;

    if (matchingPreset) {
        selectEl.value = matchingPreset.id;
    } else {
        selectEl.value = ""; // 如果不匹配任何预设，则选中“自定义配置”
    }
}

/**
 * 当用户在下拉框中选择一个预设时触发
 */
function handleApiPresetSelectChange() {
    const selectEl = document.getElementById('api-preset-select');
    const proxyUrlInput = document.getElementById('proxy-url');
    const apiKeyInput = document.getElementById('api-key');
    const selectedId = parseInt(selectEl.value);

    if (selectedId && state.apiPresets) {
        const selectedPreset = state.apiPresets.find(p => p.id === selectedId);
        if (selectedPreset) {
            proxyUrlInput.value = selectedPreset.proxyUrl;
            apiKeyInput.value = selectedPreset.apiKey;
        }
    }
}

/**
 * 打开预设管理的操作菜单
 */
async function openApiPresetManager() {
    const selectEl = document.getElementById('api-preset-select');
    const selectedId = parseInt(selectEl.value);
    const selectedPreset = state.apiPresets ? state.apiPresets.find(p => p.id === selectedId) : null;

    const modal = document.getElementById('preset-actions-modal');
    const footer = modal.querySelector('.custom-modal-footer');

    footer.innerHTML = `
        <button id="preset-action-save-new">保存当前配置为新预设</button>
        <button id="preset-action-update-current" ${!selectedPreset ? 'disabled' : ''}>更新当前配置</button>
        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? 'disabled' : ''}>删除当前配置</button>
        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
    `;

    document.getElementById('preset-action-save-new').addEventListener('click', saveCurrentApiConfigAsPreset);
    if (selectedPreset) {
        document.getElementById('preset-action-update-current').addEventListener('click', () => updateSelectedApiPreset(selectedId));
        document.getElementById('preset-action-delete-current').addEventListener('click', () => deleteSelectedApiPreset(selectedId));
    }
    document.getElementById('preset-action-cancel').addEventListener('click', () => modal.classList.remove('visible'));

    modal.classList.add('visible');
}

/**
 * 将当前输入框的内容保存为一个新的预设
 */
async function saveCurrentApiConfigAsPreset() {
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();

    if (!proxyUrl || !apiKey) {
        alert('代理地址和密钥都不能为空！');
        return;
    }

    const name = await showCustomPrompt('保存API预设', '请为这个配置起个名字：');
    if (name && name.trim()) {
        const newPreset = { name: name.trim(), proxyUrl, apiKey };
        const newId = await db.apiPresets.add(newPreset);
        
        if (!state.apiPresets) state.apiPresets = [];
        state.apiPresets.push({ id: newId, ...newPreset });

        renderApiPresetSelector(); 
        document.getElementById('api-preset-select').value = newId; 
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `API预设 "${name.trim()}" 已保存！`);
    }
}

/**
 * 更新当前选中的预设
 */
async function updateSelectedApiPreset(presetId) {
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();

    if (!proxyUrl || !apiKey) {
        alert('代理地址和密钥都不能为空！');
        return;
    }

    const preset = state.apiPresets.find(p => p.id === presetId);
    if (preset) {
        preset.proxyUrl = proxyUrl;
        preset.apiKey = apiKey;
        await db.apiPresets.put(preset);
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `预设 "${preset.name}" 已更新！`);
    }
}

/**
 * 删除当前选中的预设
 */
async function deleteSelectedApiPreset(presetId) {
    const preset = state.apiPresets.find(p => p.id === presetId);
    if (preset) {
        const confirmed = await showCustomConfirm('确认删除', `确定要删除API预设 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.apiPresets.delete(presetId);
            state.apiPresets = state.apiPresets.filter(p => p.id !== presetId);

            renderApiPresetSelector();
            document.getElementById('preset-actions-modal').classList.remove('visible');
            await showCustomAlert('成功', '预设已删除。');
        }
    }
}

// ▼▼▼ 【全新】气泡样式预设功能的核心函数 ▼▼▼

/**
 * 渲染并填充气泡样式预设的下拉选择框
 */
function renderBubblePresetSelector() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const customCssInput = document.getElementById('custom-css-input');

    selectEl.innerHTML = '<option value="">-- 无预设 --</option>';

    if (state.bubbleStylePresets) {
        state.bubbleStylePresets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            selectEl.appendChild(option);
        });
    }

    // 检查当前聊天的CSS是否匹配任何一个预设
    const currentCss = customCssInput.value.trim();
    const matchingPreset = state.bubbleStylePresets ? state.bubbleStylePresets.find(p => p.css.trim() === currentCss) : null;

    if (matchingPreset) {
        selectEl.value = matchingPreset.id;
    } else {
        selectEl.value = ""; // 如果不匹配任何预设，则选中“无预设”
    }
}

/**
 * 当用户在下拉框中选择一个预设时触发
 */
function handlePresetSelectChange() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const customCssInput = document.getElementById('custom-css-input');
    const selectedId = parseInt(selectEl.value);

    if (selectedId && state.bubbleStylePresets) {
        const selectedPreset = state.bubbleStylePresets.find(p => p.id === selectedId);
        if (selectedPreset) {
            customCssInput.value = selectedPreset.css;
        }
    }
    updateSettingsPreview(); // 无论如何都更新预览
}

/**
 * 打开预设管理的操作菜单
 */
async function openBubblePresetManager() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const selectedId = parseInt(selectEl.value);
    const selectedPreset = state.bubbleStylePresets ? state.bubbleStylePresets.find(p => p.id === selectedId) : null;

    const modal = document.getElementById('preset-actions-modal'); // 复用现有模态框
    const footer = modal.querySelector('.custom-modal-footer');

    footer.innerHTML = `
        <button id="preset-action-save-new">保存</button>
        <button id="preset-action-update-current" ${!selectedPreset ? 'disabled' : ''}>更新</button>
        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? 'disabled' : ''}>删除</button>
        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
    `;

    // 重新绑定事件
    document.getElementById('preset-action-save-new').addEventListener('click', saveCurrentCssAsPreset);
    if (selectedPreset) {
        document.getElementById('preset-action-update-current').addEventListener('click', () => updateSelectedPreset(selectedId));
        document.getElementById('preset-action-delete-current').addEventListener('click', () => deleteSelectedPreset(selectedId));
    }
    document.getElementById('preset-action-cancel').addEventListener('click', () => modal.classList.remove('visible'));

    modal.classList.add('visible');
}

/**
 * 将当前CSS文本框的内容保存为一个新的预设
 */
async function saveCurrentCssAsPreset() {
    const customCssInput = document.getElementById('custom-css-input');
    const css = customCssInput.value.trim();
    if (!css) {
        alert('CSS内容不能为空！');
        return;
    }

    const name = await showCustomPrompt('保存预设', '请为这个气泡样式命名：');
    if (name && name.trim()) {
        try {
            const newPreset = { name: name.trim(), css: css };
            const newId = await db.bubbleStylePresets.add(newPreset);
            
            if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
            state.bubbleStylePresets.push({ id: newId, ...newPreset });

            // 双重备份：同时保存到localStorage
            const backupData = JSON.stringify(state.bubbleStylePresets);
            localStorage.setItem('bubbleStylePresets_backup', backupData);
            console.log('气泡样式预设已备份到localStorage');

            renderBubblePresetSelector(); 
            document.getElementById('bubble-style-preset-select').value = newId; 
            document.getElementById('preset-actions-modal').classList.remove('visible');
            await showCustomAlert('成功', `预设 "${name.trim()}" 已保存！`);
        } catch (error) {
            console.error('保存气泡预设失败:', error);
            alert('保存失败，请重试');
        }
    }
}

/**
 * 更新当前选中的预设
 */
async function updateSelectedPreset(presetId) {
    const customCssInput = document.getElementById('custom-css-input');
    const css = customCssInput.value.trim();

    const preset = state.bubbleStylePresets.find(p => p.id === presetId);
    if (preset) {
        preset.css = css;
        await db.bubbleStylePresets.put(preset);
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `预设 "${preset.name}" 已更新！`);
    }
}

/**
 * 删除当前选中的预设
 */
async function deleteSelectedPreset(presetId) {
    const preset = state.bubbleStylePresets.find(p => p.id === presetId);
    if (preset) {
        const confirmed = await showCustomConfirm('确认删除', `确定要删除预设 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.bubbleStylePresets.delete(presetId);
            state.bubbleStylePresets = state.bubbleStylePresets.filter(p => p.id !== presetId);

            renderBubblePresetSelector(); 
            document.getElementById('custom-css-input').value = '';
            updateSettingsPreview();

            document.getElementById('preset-actions-modal').classList.remove('visible');
            await showCustomAlert('成功', '预设已删除。');
        }
    }
}

// ▼▼▼ 【全新】来电铃声控制函数 ▼▼▼

/**
 * 播放来电铃声
 */
function playRingtone() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    // 优先使用用户在设置中保存的URL，如果没设置，就用我们预设的URL
    const ringtoneUrl = state.globalSettings.ringtoneUrl || 'https://files.catbox.moe/3w7gla.mp3';
    
    if (ringtonePlayer && ringtoneUrl) {
        ringtonePlayer.src = ringtoneUrl;
        // play() 返回一个 Promise，我们最好用 try...catch 包裹以防止浏览器报错
        const playPromise = ringtonePlayer.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => {
                console.error("铃声播放失败:", error);
                // 可以在这里给用户一个静音提示，如果需要的话
            });
        }
    }
}

/**
 * 停止并重置来电铃声
 */
function stopRingtone() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    if (ringtonePlayer) {
        ringtonePlayer.pause();
        ringtonePlayer.currentTime = 0; // 将播放进度重置到开头
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】音频上下文解锁函数（修复铃声无法自动播放的问题） ▼▼▼
function unlockAudioContext() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    // 检查播放器是否处于暂停状态，并且我们之前没有成功播放过
    if (ringtonePlayer && ringtonePlayer.paused) {
        // 尝试播放，然后立刻暂停。
        // 这个操作对用户是无感知的，但能告诉浏览器用户已与音频交互。
        ringtonePlayer.play().catch(() => {}); // play() 会返回一个 Promise，我们忽略任何可能发生的错误
        ringtonePlayer.pause();
        console.log("Ringtone audio context unlocked.");
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】“查手机”内容单条删除功能 ▼▼▼
/**
 * 处理角色手机内数据删除的通用函数
 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要删除的数据在数组中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 处理像 bank.transactions 这样的嵌套数据
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条记录吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根据删除的类型，重新渲染对应的APP界面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
        }
        alert('记录已删除。');
    }
}
// ▲▲▲ 删除功能结束 ▲▲▲
/**
 * 【全新】处理角色手机内单条聊天消息的删除
 * @param {string} contactName - 正在查看的联系人名称
 * @param {number} index - 要删除的消息在历史记录中的索引
 */
async function handleCharacterChatMessageDeletion(contactName, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    let historyArray;
    // 判断是和“我”的聊天还是和NPC的聊天
    if (contactName === (chat.characterPhoneData.chats['我']?.remarkName || '我')) {
        historyArray = chat.history;
    } else {
        historyArray = chat.characterPhoneData.chats[contactName]?.history;
    }

    if (!historyArray || !historyArray[index]) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条消息吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        historyArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 重新渲染当前聊天界面
        renderCharacterChatHistory(contactName);
        alert('消息已删除。');
    }
}

// ▼▼▼ 【全新】锁屏功能核心函数 ▼▼▼

/**
 * 应用锁屏壁纸到 #lock-screen 元素
 */
function applyLockscreenWallpaper() {
    const lockScreen = document.getElementById('lock-screen');
    const wallpaper = state.globalSettings.lockscreenWallpaper;
    if (wallpaper && wallpaper.startsWith('data:image')) {
        lockScreen.style.backgroundImage = `url(${wallpaper})`;
    } else if (wallpaper) {
        lockScreen.style.backgroundImage = wallpaper;
    }
}

/**
 * 显示锁屏界面
 */
function lockPhone() {
    console.log("正在锁定手机...");
    isLocked = true;
    document.getElementById('lock-screen').classList.add('active');
    document.querySelectorAll('.screen:not(#lock-screen)').forEach(s => s.classList.remove('active'));
}

/**
 * 解锁手机，显示主屏幕
 */
function unlockPhone() {
    console.log("手机已解锁！");
    isLocked = false;
        // 【核心修改】在这里彻底隐藏锁屏和毛玻璃背景
    document.getElementById('lock-screen').classList.remove('active');
    const blurBg = document.getElementById('lock-screen-background-blur');
    blurBg.style.display = 'none';
    blurBg.style.opacity = '0';

    // 确保主屏幕是唯一激活的顶层屏幕
    showScreen('home-screen'); 

    // 重置锁屏的样式，为下次锁定做准备
    setTimeout(() => {
        const lockScreen = document.getElementById('lock-screen');
        const unlockHint = document.getElementById('unlock-hint');
        lockScreen.style.transition = 'none'; 
        unlockHint.style.transition = 'none';
        lockScreen.style.transform = 'translateY(0)';
        lockScreen.offsetHeight; 
        lockScreen.style.transition = 'transform 0.3s ease-out';
        unlockHint.style.transition = 'opacity 0.3s ease-out';
    }, 500); 
}

/**
 * 显示密码输入弹窗
 */
function showPasswordModal() {
    const modal = document.getElementById('password-modal-overlay');
    const input = document.getElementById('password-input-field');
    input.value = ''; // 清空上次输入
    modal.classList.add('visible');
    setTimeout(() => input.focus(), 100); // 延迟聚焦，确保动画流畅
}

/**
 * 隐藏密码输入弹窗
 */
function hidePasswordModal() {

document.getElementById('password-modal-overlay').style.backgroundImage = 'none';

    const modal = document.getElementById('password-modal-overlay');
    modal.classList.remove('visible');
    // 移除可能存在的错误动画类
    modal.querySelector('.password-modal-content').classList.remove('error');
    // 【核心修改】当取消输入密码时...
    // 1. 隐藏毛玻璃背景
    const blurBg = document.getElementById('lock-screen-background-blur');
    blurBg.style.opacity = '0';
    setTimeout(() => { blurBg.style.display = 'none'; }, 300); // 动画结束后再隐藏

    // 2. 让锁屏界面滑回来
    const lockScreen = document.getElementById('lock-screen');
    const unlockHint = document.getElementById('unlock-hint');
    lockScreen.style.transform = 'translateY(0)';
    unlockHint.style.opacity = '1';
}

/**
 * 检查用户输入的密码是否正确
 */
function checkPassword() {
    const input = document.getElementById('password-input-field');
    const enteredPassword = input.value;
    const correctPassword = state.globalSettings.password;

    if (enteredPassword === correctPassword) {
        // --- 密码正确 ---

        // 1. 【核心魔术】提前把主屏幕在最底层激活并准备好！
        //    因为它 z-index 最低，所以你暂时还看不到它。
        showScreen('home-screen');

        // 2. 隐藏密码输入框 (它会自己播放淡出动画)
        document.getElementById('password-modal-overlay').classList.remove('visible');
        
        // 3. 让毛玻璃背景也开始淡出
        document.getElementById('lock-screen-background-blur').style.opacity = '0';
        
        // 4. 等待淡出动画播放完毕 (300毫秒)，再执行最终的清理工作
        setTimeout(unlockPhone, 300);

    } else {
        // --- 密码错误 (逻辑保持不变) ---
        const content = document.querySelector('.password-modal-content');
        content.classList.add('error');
        input.value = '';
        setTimeout(() => content.classList.remove('error'), 400);
    }
}

/**
 * 更新锁屏界面的时钟
 */
function updateLockClock() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' });
    document.getElementById('lock-main-time').textContent = timeString;
    document.getElementById('lock-main-date').textContent = dateString;
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 在你的JS功能函数定义区，粘贴下面这一整块新代码 ▼▼▼

/**
 * 【全新】打开批量添加表情包的模态框
 */
async function openBulkAddStickersModal() {
    const placeholder = `在这里粘贴表情包，每行一个，格式如下：\n\n猫猫喝水：https://..../cat.gif\n狗狗摇头：https://..../dog.png\n\n(支持用中文冒号“：”、英文冒号“:”或空格分隔)`;

    const textInput = await showCustomPrompt(
        "批量添加表情(URL)",
        "一行一个，名称和链接用冒号或空格隔开",
        "", // 初始值为空
        'textarea' // 使用多行文本域
    );

    if (!textInput || !textInput.trim()) {
        return; // 用户取消或没有输入
    }

    // --- 开始解析 ---
    const lines = textInput.trim().split('\n');
    const newStickers = [];
    let successCount = 0;
    let errorLines = [];

    lines.forEach((line, index) => {
        line = line.trim();
        if (!line) return; // 跳过空行

        // 容错解析：尝试用各种分隔符分割
        let parts;
        if (line.includes('：')) { // 中文冒号
            parts = line.split('：').map(p => p.trim());
        } else if (line.includes(':')) { // 英文冒号
            parts = line.split(':').map(p => p.trim());
        } else {
            // 如果没有冒号，就尝试用最后一个空格分割
            const lastSpaceIndex = line.lastIndexOf(' ');
            if (lastSpaceIndex > -1) {
                parts = [line.substring(0, lastSpaceIndex).trim(), line.substring(lastSpaceIndex + 1).trim()];
            } else {
                // 如果连空格都没有，就无法解析
                errorLines.push(index + 1);
                return;
            }
        }

        // 确保我们得到了名称和URL两部分
        if (parts.length >= 2) {
            const name = parts.slice(0, -1).join(':').trim(); // 处理名称中也包含冒号的情况
            const url = parts[parts.length - 1].trim();

            // 简单验证URL是否有效
            if (name && (url.startsWith('http') || url.startsWith('data:image'))) {
                newStickers.push({
                    id: 'sticker_' + (Date.now() + index),
                    url: url,
                    name: name
                });
                successCount++;
            } else {
                errorLines.push(index + 1);
            }
        } else {
            errorLines.push(index + 1);
        }
    });

    // --- 解析结束，准备保存 ---
    if (newStickers.length > 0) {
        await db.userStickers.bulkAdd(newStickers);
        state.userStickers.push(...newStickers);
        renderStickerPanel(); // 刷新表情面板
    }

    // --- 生成并显示报告 ---
    let reportMessage = `批量导入完成！\n\n成功导入：${successCount} 个表情。`;
    if (errorLines.length > 0) {
        reportMessage += `\n失败行号：${errorLines.join(', ')}。\n\n请检查这些行的格式是否正确。`;
    }
    await showCustomAlert("导入报告", reportMessage);
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 【全新】粘贴这两个新函数到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】根据距离文本，计算CSS宽度百分比
 * @param {string} distanceText - 距离描述，例如 "500m", "10km", "很近"
 * @returns {number} - 10到90之间的百分比
 */
function calculatePinDistancePercentage(distanceText) {
    if (!distanceText) return 50; // 默认值

    const text = distanceText.toLowerCase();
    // 提取数字部分
    const matches = text.match(/(\d+(\.\d+)?)/);
    const num = matches ? parseFloat(matches[1]) : 0;

    // 根据单位或关键词判断
    if (text.includes('km') || text.includes('公里')) {
        if (num > 1000) return 90;
        if (num > 100) return 80;
        if (num > 10) return 70;
        if (num > 1) return 60;
        return 50;
    } else if (text.includes('m') || text.includes('米')) {
        if (num > 500) return 40;
        if (num > 100) return 30;
        return 20;
    } else if (text.includes('远') || text.includes('不同城市')) {
        return 90;
    } else if (text.includes('附近') || text.includes('隔壁')) {
        return 20;
    } else if (text.includes('近')) {
        return 30;
    }
    
    return 15; // 如果无法识别，给一个最小的距离
}


// ▼▼▼ 用这整块【全新代码】，替换旧的 sendUserLocation 函数 ▼▼▼

/**
 * 【全新】在定位模态框中添加一个途经点输入框
 */
function addTrajectoryPointInput(name = '') {
    const container = document.getElementById('trajectory-points-container');
    const div = document.createElement('div');
    div.style.display = 'flex';
    div.style.gap = '8px';
    div.innerHTML = `
        <input type="text" class="trajectory-point-input" placeholder="途经点${container.children.length + 1}" value="${name}" style="flex-grow: 1;">
        <button class="remove-option-btn">-</button>
    `;
    div.querySelector('.remove-option-btn').addEventListener('click', () => div.remove());
    container.appendChild(div);
}

/**
 * 【重构版】处理用户发送定位的逻辑
 */
async function sendUserLocation() {
    if (!state.activeChatId) return;

    const userLocation = document.getElementById('user-location-input').value.trim();
    const aiLocation = document.getElementById('ai-location-input').value.trim();
    const distance = document.getElementById('distance-input').value.trim();

    if (!distance || (!userLocation && !aiLocation)) {
        alert("“我的位置”和“Ta的位置”至少要填写一个，且“相距”为必填项！");
        return;
    }

    // 从所有输入框收集途经点
    const trajectoryPoints = Array.from(document.querySelectorAll('.trajectory-point-input'))
        .map(input => ({ name: input.value.trim() }))
        .filter(point => point.name); // 过滤掉空的途经点

    const chat = state.chats[state.activeChatId];
    
    const locationMessage = {
        role: 'user',
        type: 'location',
        timestamp: Date.now(),
        userLocation: userLocation,
        aiLocation: aiLocation,
        distance: distance,
        trajectoryPoints: trajectoryPoints // 使用新的数组结构
    };

    chat.history.push(locationMessage);
    await db.chats.put(chat);
    appendMessage(locationMessage, chat);
    renderChatList();

    document.getElementById('send-location-modal').classList.remove('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】“一键重roll”功能核心代码 ▼▼▼

/**
 * 智能查找AI上一轮回复的所有消息
 * @param {Array} history - 完整的聊天历史记录
 * @returns {Array} - 一个包含了上一轮AI所有消息对象的数组
 */
function findLastAiTurnMessages(history) {
    const turnMessages = [];
    let lastMessageIndex = history.length - 1;

    // 从最后一条消息开始，向前查找
    for (let i = lastMessageIndex; i >= 0; i--) {
        const message = history[i];
        
        // 如果是AI的消息，就把它加入我们的“待删除列表”
        if (message.role === 'assistant') {
            turnMessages.unshift(message); // 使用 unshift 保持原始顺序
        } 
        // 一旦遇到非AI的消息（用户的或系统的），说明AI的这一轮回复已经结束了，立刻停止查找
        else {
            break;
        }
    }
    return turnMessages;
}

/**
 * “重roll”按钮被点击时的主处理函数
 */
async function handleRerollClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];

    // 1. 调用我们的智能查找函数，找出需要删除的消息
    const messagesToReroll = findLastAiTurnMessages(chat.history);

    // 2. 如果没找到（比如最后一条是用户发的），就提示并退出
    if (messagesToReroll.length === 0) {
        alert("请在AI回复后使用此功能。");
        return;
    }

    // 3. 从聊天记录中过滤掉这些旧消息
    const timestampsToReroll = new Set(messagesToReroll.map(m => m.timestamp));
    chat.history = chat.history.filter(msg => !timestampsToReroll.has(msg.timestamp));
    
    // 4. 保存更新后的聊天记录到数据库
    await db.chats.put(chat);

    // 5. 刷新聊天界面，让旧消息瞬间消失
    renderChatInterface(state.activeChatId);

    // 6. 触发一次新的AI响应，就像用户点击了“等待回复”一样
    triggerAiResponse();
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 【全新简化版】粘贴这个完整的拖动功能函数 ▼▼▼
function initDraggableLyricsBar() {
    const bar = document.getElementById('floating-lyrics-bar');
    const phoneScreen = document.getElementById('phone-screen');
    
    let isDragging = false;
    let offsetX, offsetY;

    const onDragStart = (e) => {
        // 【问题2修复】检查点击的是否是按钮，如果是，则不开始拖动
        if (e.target.closest('#lyrics-settings-btn') || e.target.closest('.close-btn')) {
            return;
        }

        isDragging = true;
        bar.classList.add('dragging');
        
        const rect = bar.getBoundingClientRect();
        const coords = getEventCoords(e);

        offsetX = coords.x - rect.left;
        offsetY = coords.y - rect.top;

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);
    };

    const onDragMove = (e) => {
        if (!isDragging) return;
        
        e.preventDefault();

        const phoneRect = phoneScreen.getBoundingClientRect();
        const coords = getEventCoords(e);

        let newLeft = coords.x - offsetX - phoneRect.left;
        let newTop = coords.y - offsetY - phoneRect.top;

        const maxLeft = phoneScreen.clientWidth - bar.offsetWidth;
        const maxTop = phoneScreen.clientHeight - bar.offsetHeight;

        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        newTop = Math.max(0, Math.min(newTop, maxTop));
        
        // 【问题1修复】在拖动时，同时设置left, top并清除transform
        bar.style.left = `${newLeft}px`;
        bar.style.top = `${newTop}px`;
        bar.style.transform = 'none';
    };

    const onDragEnd = () => {
        if (!isDragging) return;
        isDragging = false;
        bar.classList.remove('dragging');

        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('touchend', onDragEnd);
    };

    bar.addEventListener('mousedown', onDragStart);
    bar.addEventListener('touchstart', onDragStart, { passive: true });
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】粘贴这个完整的函数 ▼▼▼
function applyLyricsSettings() {
    const bar = document.getElementById('floating-lyrics-bar');
    const toggleBtn = document.getElementById('toggle-lyrics-bar-btn');
    
    // 应用样式
    bar.style.fontSize = `${lyricsBarSettings.fontSize}px`;
    bar.style.color = lyricsBarSettings.fontColor;
    bar.style.backgroundColor = `rgba(0, 0, 0, ${lyricsBarSettings.bgOpacity / 100})`;

    // 更新设置模态框里的控件值
    document.getElementById('lyrics-font-size-slider').value = lyricsBarSettings.fontSize;
    document.getElementById('lyrics-font-size-value').textContent = `${lyricsBarSettings.fontSize}px`;
    document.getElementById('lyrics-bg-opacity-slider').value = lyricsBarSettings.bgOpacity;
    document.getElementById('lyrics-bg-opacity-value').textContent = `${lyricsBarSettings.bgOpacity}%`;
    document.getElementById('lyrics-font-color-picker').value = lyricsBarSettings.fontColor;
    
    // 【问题4需要】更新播放器里的开关按钮状态
    if (toggleBtn) {
        toggleBtn.textContent = lyricsBarSettings.showOnClose ? '悬浮' : '隐藏';
        toggleBtn.style.opacity = lyricsBarSettings.showOnClose ? '1' : '0.5';
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用下面这块【已修复】的代码，替换旧的 getCountdownContext 函数 ▼▼▼
/**
 * 【全新】获取并格式化【与当前聊天相关】的约定，生成给AI看的上下文
 * @param {string} chatId - 当前正在聊天的角色ID
 * @returns {Promise<string>} 格式化后的约定信息字符串
 */
async function getCountdownContext(chatId) {
    // 1. 从数据库中找出所有“约定”类型，并且目标日期还没到的记录
    const activeCountdowns = await db.memories
        .where('type').equals('countdown')
        .filter(item => 
            item.targetDate > Date.now() &&
            // ★★★★★ 这就是我们这次修复的核心！ ★★★★★
            // 它现在只会查找两种约定：
            // 1. chatId 和当前聊天角色ID匹配的 (AI自己创建的)
            // 2. chatId 为空的 (你，也就是用户创建的全局约定)
            (item.chatId === chatId || item.chatId === null)
        )
        .toArray();

    // 如果没有与当前角色相关的约定，就告诉AI“目前没有”
    if (activeCountdowns.length === 0) {
        return "\n- **近期约定**: 目前没有特别的约定。";
    }

    // 2. 后续的整理报告逻辑保持不变
    let context = "\n# 近期约定与倒计时 (重要参考信息)\n";
    const now = Date.now();

    activeCountdowns.forEach(item => {
        const diff = item.targetDate - now;
        const diffDays = Math.floor(diff / (1000 * 60 * 60 * 24));
        const diffHours = Math.floor(diff / (1000 * 60 * 60));

        let timeText;
        if (diffDays > 1) {
            timeText = `还有 ${diffDays} 天`;
        } else if (diffHours > 0) {
            timeText = `还有 ${diffHours} 小时`;
        } else {
            timeText = "就是现在！";
        }
        
        context += `- **${item.description}**: ${timeText} (目标: ${new Date(item.targetDate).toLocaleString()})\n`;
    });

    return context;
}
// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 【全新】“查角色手机”功能的所有核心函数 ▼▼▼

/**
 * 入口：打开角色选择界面
 */
async function openCharacterSelectionScreen() {
    await renderCharacterSelectionScreen();
    showScreen('character-selection-screen');
}

/**
 * 渲染角色选择列表
 */
async function renderCharacterSelectionScreen() {
    const listEl = document.getElementById('character-selection-list');
    listEl.innerHTML = '';
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">还没有可以查看的角色</p>';
        return;
    }

    characters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'character-select-item';
        item.dataset.chatId = char.id;
        item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
            <span class="name">${char.name}</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 【V2重构版】打开指定角色的手机界面
 */
function openCharacterPhone(chatId) {
    activeCharacterPhoneId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return;

    document.getElementById('character-phone-owner-name').textContent = `${chat.name}的手机`;
    renderCharacterAppGrid(); // 渲染APP图标

    // 核心修改：我们现在显示的是“手机外壳”这个总容器
    showScreen('character-phone-container'); 
    // 同时，确保默认显示的是它的主屏幕
    showCharacterPhonePage('character-phone-screen');
}

/**
 * 【V4美化版】渲染角色手机主界面的APP图标
 */
function renderCharacterAppGrid() {
    const gridEl = document.getElementById('character-app-grid');
    gridEl.innerHTML = '';

    const apps = [
        { 
            id: 'chat', name: '微信', screen: 'character-chat-list-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#4CAF50"><path d="M12 2C6.48 2 2 6.48 2 12c0 2.94 1.28 5.58 3.34 7.42c-.22 1.4-.89 3.1-1.25 3.82c-.36.72.48 1.39 1.05.94c.82-.67 2.43-1.88 3.3-2.58C9.44 21.78 10.68 22 12 22c5.52 0 10-4.48 10-10S17.52 2 12 2zm3.5 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5zm-7 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>`
        },
        { 
            id: 'cart', name: '购物车', screen: 'character-shopping-cart-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#F44336"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2s-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2s2-.9 2-2s-.9-2-2-2zm-15-14h3.27l.94 2H20c.69 0 1.25.56 1.25 1.25c0 .09-.02.18-.04.27l-3.58 6.49c-.25.44-.73.74-1.26.74H8.52l-.94-2H4.27V4H2V2h3.27z"/></svg>`
        },
        { 
            id: 'memos', name: '备忘录', screen: 'character-memos-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#FFC107"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>`
        },
        {
            id: 'browser', name: '浏览器', screen: 'character-browser-screen',
            // 【核心修改】替换为新的指南针SVG
            svg: `<svg viewBox="0 0 24 24" fill="#2196F3"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1.5-12.5l3 7.5 7.5-3-7.5-3z"/></svg>`
        },
        {
            id: 'album', name: '相册', screen: 'character-album-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#8BC34A"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"/></svg>`
        },
        {
            id: 'bank', name: '钱包', screen: 'character-bank-screen',
            // 【核心修改】替换为新的钱包SVG
            svg: `<svg viewBox="0 0 24 24" fill="#E91E63"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>`
        },
        {
            id: 'trajectory', name: '足迹', screen: 'character-trajectory-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#795548"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5s-1.12 2.5-2.5 2.5z"/></svg>`
        },
        {
            id: 'app_usage', name: '使用记录', screen: 'character-app-usage-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#607D8B"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8s8 3.58 8 8s-3.58 8-8 8zm.5-13H11v6l5.25 3.15l.75-1.23l-4.5-2.67z"/></svg>`
        },
        {
            id: 'diary', name: '日记', screen: 'character-diary-screen',
            svg: `<svg viewBox="0 0 24 24" fill="#009688"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83l3.75 3.75 1.83-1.83z"/></svg>`
        },
    ];

    apps.forEach(app => {
        const iconEl = document.createElement('div');
        iconEl.className = 'app-icon';
        iconEl.innerHTML = `
            <div class="icon-bg" style="display: flex; justify-content: center; align-items: center; padding: 12px;">
                ${app.svg}
            </div>
            <span class="label">${app.name}</span>
        `;
        iconEl.addEventListener('click', () => {
            switch(app.id) {
                case 'chat': renderCharacterChatList(); break;
                case 'cart': renderCharacterShoppingCart(); break;
                case 'memos': renderCharacterMemos(); break;
                case 'browser': renderCharacterBrowser(); break;
                case 'album': renderCharacterPhotoAlbum(); break;
                case 'bank': renderCharacterBank(); break;
                case 'trajectory': renderCharacterTrajectory(); break;
                case 'app_usage': renderCharacterAppUsage(); break;
            }
            showCharacterPhonePage(app.screen); 
        });
        gridEl.appendChild(iconEl);
    });
}

// ▼▼▼ 用下面这【一整块】增强版代码，替换掉你旧的 generateCharacterPhoneData 函数 ▼▼▼
/**
 * 【AI核心】生成角色手机数据 (已增加错误处理)
 */
async function generateCharacterPhoneData() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const userNickname = state.qzoneSettings.nickname || '我';
        const persona = chat.settings.aiPersona;
        const recentHistory = chat.history.slice(-10).map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        
        let worldBookContext = '';
        const effectiveWorldBookIds = getEffectiveWorldBookIds(chat);
        if (effectiveWorldBookIds.length > 0) {
            worldBookContext = '--- 世界观设定 (必须严格遵守) ---\n' +
                effectiveWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        const npcLibrary = chat.npcLibrary || [];
        let npcContext = '';
        if (npcLibrary.length > 0) {
            npcContext = '# 你的专属NPC好友列表 (你必须在下方"chats"中为他们生成对话)\n' +
                '这些人是你的好朋友，你和他们非常熟悉。请根据他们的人设，生成符合你们关系的、自然的聊天记录。\n' +
                npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
        } else {
            npcContext = '# 你的专属NPC好友列表\n(你没有专属NPC，请虚构一些普通朋友)';
        }
// ▼▼▼ 在 prompt = `...` 的上方，粘贴这段代码 ▼▼▼

// 【新增】为AI准备已有的NPC聊天记录上下文
let npcChatHistoryContext = '';
const existingNpcChats = Object.entries(chat.characterPhoneData.chats || {}).filter(([name, chatData]) => chatData.history && chatData.history.length > 0);

if (existingNpcChats.length > 0) {
    npcChatHistoryContext += '\n\n# 已有的聊天记录摘要 (请在此基础上继续对话)\n';
    existingNpcChats.forEach(([contactName, chatData]) => {
        // 只取每个联系人最新的5条消息作为上下文，避免prompt过长
        const recentMessages = chatData.history.slice(-5).map(msg => `  - ${msg.sender}: ${msg.content}`).join('\n');
        npcChatHistoryContext += `\n## 你和“${contactName}”的最近对话:\n${recentMessages}\n`;
    });
}

// ▲▲▲ 新增代码粘贴结束 ▲▲▲

 const prompt = `
# 任务
你现在是角色 "${chat.name}"。请根据你的人设、世界观、NPC好友列表以及和${userNickname}的最近聊天记录，模拟生成你手机中的各项数据。你需要一次性生成所有数据，并严格按照下面的JSON格式返回。

# 【【【绝对禁止事项：这是必须遵守的安全红线】】】
1.  在生成JSON数据，特别是chats字段时，**绝对不允许**创建另一个用户（${userNickname}）的虚拟形象或让他/她出现在你与其他NPC的对话中。
2.  chats字段中，与NPC或朋友的聊天记录，其sender或content**绝对不能**包含${userNickname}的名字或代称。
3.  所有你生成的聊天对话，都必须严格限制在【你(${chat.name})】和【另一位NPC/朋友】这**两个人之间**。**严禁**出现任何形式的第三者，尤其是${userNickname}。

# 你的信息
- 你的名字: ${chat.name}
- 你的人设: ${persona}
${worldBookContext}

# 和${userNickname}的最近聊天记录摘要
${recentHistory}

${npcContext}
${npcChatHistoryContext}
# JSON输出格式 (必须严格遵守，不要添加任何额外说明)
{
  "chats": [
    {
      // 这是你和真实用户 ${userNickname} 的聊天窗口占位，不需要生成具体消息
      "contactName": "【这里填写你给${userNickname}的备注名】"
    },
    {
      // 这是你和NPC/朋友的聊天窗口，必须生成消息
      "contactName": "【这里必须填写上面NPC列表中的一个名字，或一个虚构朋友名】",
      "messages": [
        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容1..."},
        {"sender": "${chat.name}", "content": "你的回复1..."},
        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容2..."},
        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容3..."},
        {"sender": "${chat.name}", "content": "你的回复2..."}
      ]
    }
  ],
  "shoppingCart": [
    {"name": "商品名", "price": 价格, "store": "店铺名"}
  ],
  "memos": [
    {"title": "备忘录标题", "content": "备忘录详细内容..."}
  ],
  "browserHistory": [
    {"query": "搜索或浏览的标题", "result": "【这里是AI生成的、关于这个搜索标题的模拟文章或网页内容】"}
  ],
  "photoAlbum": [
    {"hiddenContent": "对照片画面的详细文字描述"}
  ],
  "bank": {
    "balance": 银行卡余额(数字),
    "transactions": [
      {"type": "收入或支出", "amount": 金额, "description": "交易描述"}
    ]
  },
  "trajectory": [
    {"time": "时间段", "location": "地点", "activity": "干了什么事"}
  ],
  "appUsage": [
    {"appName": "应用名", "duration": "使用时长"}
  ]
}

# 【【【重要指令：关于聊天记录生成】】】
- 你正在续写这段对话。你提供的聊天记录是上下文，你【绝对不能】重复或改写其中的任何内容。你的生成必须从【全新的、下一条】消息开始。
- 你必须严格遵守本提示词最上方的【绝对禁止事项】。
- 如果“你的专属NPC好友列表”不为空，你【必须】为列表中的【每一个NPC】都生成一段与你（${chat.name}）的对话。
- 如果列表为空，你可以虚构2-3个普通朋友并生成对话。
- 你必须为每个联系人生成一段【至少包含5条消息】的对话。
- 对话内容应该自然流畅，可以包含连续发言、表情包和表情符号等，以体现真实感。
- 不要只生成一问一答的机械式对话。
`;

        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, [{role: 'user', content: prompt}], isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: prompt}],
                    temperature: 0.8,
                    response_format: { type: "json_object" }
                })
            });

        // --- ★★★ 错误处理核心代码 ★★★ ---
        if (!response.ok) {
            let errorMsg = `API请求失败，状态码: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg += `\n错误信息: ${errorData.error.message}`;
            } catch (e) {
                errorMsg += `\n无法解析错误响应体。`;
            }
            throw new Error(errorMsg);
        }
        // --- ★★★ 错误处理结束 ★★★ ---
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        // --- ★★★ 增加对AI返回内容的解析检查 ★★★ ---
        let newData;
        try {
            newData = JSON.parse(aiResponseContent);
        } catch (e) {
            throw new Error(`AI返回的不是有效的JSON格式，无法解析。\n原始返回内容:\n${aiResponseContent}`);
        }
        // --- ★★★ 解析检查结束 ★★★ ---

        let phoneData = chat.characterPhoneData;
        phoneData.lastGenerated = Date.now();
        
 // ▼▼▼ 用这整块新代码替换 ▼▼▼
if (newData.chats) {
    newData.chats.forEach(newChat => {
        // 首先，处理和“我”的聊天备注名，这部分逻辑不变
        if (!newChat.messages) {
            const myNickname = userNickname || '我'; // 确保有默认值
            if (!phoneData.chats[myNickname]) {
                phoneData.chats[myNickname] = { avatar: '', history: [] };
            }
            phoneData.chats[myNickname].remarkName = newChat.contactName;
        } 
        // 接下来，处理和NPC的聊天记录
        else {
            const contactName = newChat.contactName;
            
            // 【关键改动】检查这个联系人是否已经存在于手机数据中
            if (phoneData.chats[contactName] && phoneData.chats[contactName].history) {
                // 如果存在，就把新生成的消息追加到已有的历史记录后面
                console.log(`合并聊天记录: 为 "${contactName}" 追加 ${newChat.messages.length} 条新消息。`);
                phoneData.chats[contactName].history.push(...newChat.messages);
            } else {
                // 如果不存在，就创建一个新的联系人记录
                console.log(`创建新聊天: "${contactName}"`);
                phoneData.chats[contactName] = { 
                    avatar: newChat.avatar, 
                    history: newChat.messages 
                };
            }
        }
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 修复到这里结束 ▲▲▲


        if(!phoneData.shoppingCart) phoneData.shoppingCart = [];
        phoneData.shoppingCart.push(...(newData.shoppingCart || []));
        if(!phoneData.memos) phoneData.memos = [];
        phoneData.memos.push(...(newData.memos || []));
        if(!phoneData.browserHistory) phoneData.browserHistory = [];
        phoneData.browserHistory.push(...(newData.browserHistory || []));
        if(!phoneData.photoAlbum) phoneData.photoAlbum = [];
        phoneData.photoAlbum.push(...(newData.photoAlbum || []));
        if(!phoneData.trajectory) phoneData.trajectory = [];
        phoneData.trajectory.push(...(newData.trajectory || []));
        if(!phoneData.appUsage) phoneData.appUsage = [];
        phoneData.appUsage.push(...(newData.appUsage || []));
        if (!phoneData.diary) phoneData.diary = [];
        phoneData.diary.push(...(newData.diary || []));

        if (newData.bank) {
            if(!phoneData.bank) phoneData.bank = { balance: 0, transactions: [] };
            phoneData.bank.balance = newData.bank.balance || phoneData.bank.balance;
            phoneData.bank.transactions.push(...(newData.bank.transactions || []));
        }

        await db.chats.put(chat);
        alert('数据已刷新！');

    } catch (error) {
        console.error("生成角色手机数据失败:", error);
        // 使用我们强大的弹窗来显示详细错误
        await showCustomAlert('生成失败', `发生了一个错误，请检查你的网络、API密钥或模型设置。\n\n详细信息:\n${error.message}`);
    } finally {
        // 无论成功还是失败，最后都必须隐藏加载动画
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 清空角色手机数据
 */
async function clearCharacterPhoneData() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    const confirmed = await showCustomConfirm('确认清空', `确定要清空“${chat.name}”的所有手机数据吗？此操作不可恢复。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 重置为初始状态
        chat.characterPhoneData = {
            lastGenerated: null, chats: {}, shoppingCart: [], memos: [],
            browserHistory: [], photoAlbum: [], bank: { balance: 0, transactions: [] },
            trajectory: [],         appUsage: [],
        diary: [] // <--- 在这里新增
        };
        await db.chats.put(chat);
        // 重新渲染APP网格，因为点击APP会读取新数据
        renderCharacterAppGrid();
        alert('数据已清空。');
    }
}

// ▼▼▼ 请用这整块代码，完整替换掉你旧的 renderCharacterChatList 函数 ▼▼▼
/**
 * 【V12 - 诊断版 A】渲染角色手机的聊天列表 (诊断备注名问题)
 */
function renderCharacterChatList() {
    const listEl = document.getElementById('character-chat-list');
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) return;

    const characterChatData = characterChat.characterPhoneData;
    const realChatHistory = characterChat.history;
    listEl.innerHTML = '';

    // ★★★★★ 诊断日志 A 和 B ★★★★★
    console.log("【诊断日志 A】: 开始渲染聊天列表，完整的 characterPhoneData.chats 对象是:", characterChatData.chats);

    const userContactInData = characterChatData.chats
        ? Object.values(characterChatData.chats).find(c => !c.history || c.history.length === 0)
        : null;
    
    console.log("【诊断日志 B】: 根据 '!c.history' 条件找到的用户联系人对象是:", userContactInData);
    
    const remarkNameForMe = userContactInData ? userContactInData.remarkName : '我';
    console.log("【诊断日志 C】: 最终为真实用户决定的备注名是:", remarkNameForMe);
    // ★★★★★ 诊断结束 ★★★★★

    // --- 后续渲染逻辑保持不变 ---
    const lastMsg = realChatHistory.filter(m => !m.isHidden).slice(-1)[0] || { content: '...' };
    const myChatItem = document.createElement('div');
    myChatItem.className = 'chat-list-item';
    myChatItem.dataset.contactName = remarkNameForMe;
    myChatItem.dataset.isUserChat = 'true';
    const myAvatar = characterChat.settings.myAvatar || defaultMyGroupAvatar;
    myChatItem.innerHTML = `
        <img src="${myAvatar}" class="avatar" style="border-radius: 6px;">
        <div class="info">
            <span class="name">${remarkNameForMe}</span>
            <div class="last-msg">${stripHtmlAndCode(String(lastMsg.content)).substring(0, 30)}</div>
        </div>
    `;
    listEl.appendChild(myChatItem);

    if (characterChatData.chats) {
        for (const contactName in characterChatData.chats) {
            if (contactName === remarkNameForMe) continue;
            const contact = characterChatData.chats[contactName];
            if (!contact.history || contact.history.length === 0) continue;
            // ... (后续NPC渲染代码不变) ...
            const lastNpcMsg = contact.history.slice(-1)[0] || { content: '...' };
            const npcChatItem = document.createElement('div');
            npcChatItem.className = 'chat-list-item';
            npcChatItem.dataset.contactName = contactName;

            let npcAvatarHtml;
            const npcFromLibrary = (characterChat.npcLibrary || []).find(npc => npc.name === contactName);
            if (npcFromLibrary && npcFromLibrary.avatar) {
                npcAvatarHtml = `<img src="${npcFromLibrary.avatar}" class="avatar" style="border-radius: 6px;">`;
            } else {
                const avatarColors = ['#FFC107', '#4CAF50', '#2196F3', '#F44336', '#9C27B0', '#00BCD4'];
                const npcNameInitial = contactName.slice(-1);
                const colorIndex = contactName.length % avatarColors.length;
                const bgColor = avatarColors[colorIndex];
                npcAvatarHtml = `<div class="avatar" style="border-radius: 6px; background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
            }
            npcChatItem.innerHTML = `${npcAvatarHtml}<div class="info"><span class="name">${contactName}</span><div class="last-msg">${stripHtmlAndCode(String(lastNpcMsg.content)).substring(0, 30)}</div></div>`;
            addLongPressListener(npcChatItem, () => { deleteCharacterPhoneContact(contactName); });
            listEl.appendChild(npcChatItem);
        }
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这整块代码，完整替换掉你旧的 renderCharacterChatHistory 函数 ▼▼▼
/**
 * 【V13 - 性能优化版】渲染角色手机的具体聊天记录 (分页加载)
 */
function renderCharacterChatHistory(contactName, isUserChat = false, loadOffset = 0) {
    const MESSAGES_PER_PAGE = 50; // 每次加载50条

    const messagesEl = document.getElementById('character-chat-history-messages');
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) {
        console.error("【错误】: 找不到 characterChat 对象！");
        return;
    }

    // --- 准备工作：设置标题和头像 (仅在首次加载时执行) ---
    if (loadOffset === 0) {
        messagesEl.innerHTML = ''; // 首次加载才清空
        let finalContactName = contactName;
        if (isUserChat) {
            const myChatData = characterChat.characterPhoneData.chats['我'];
            // 尝试从手机数据里找AI给用户的备注名
            const userContactInData = characterChat.characterPhoneData.chats
                ? Object.values(characterChat.characterPhoneData.chats).find(c => !c.history || c.history.length === 0)
                : null;
            finalContactName = userContactInData ? userContactInData.remarkName : '我';
        }
        document.getElementById('character-chat-with-name').textContent = finalContactName;
    }

    // --- 数据源选择 ---
    let fullHistory = [];
    if (isUserChat) {
        fullHistory = characterChat.history.filter(m => !m.isHidden);
    } else {
        const npcChat = characterChat.characterPhoneData.chats[contactName];
        if (npcChat && npcChat.history) {
            fullHistory = npcChat.history;
        }
    }

    // --- 核心分页逻辑 ---
    const totalMessages = fullHistory.length;
    const startIndex = Math.max(0, totalMessages - MESSAGES_PER_PAGE - loadOffset);
    const endIndex = totalMessages - loadOffset;
    const historyToShow = fullHistory.slice(startIndex, endIndex);

    // --- 移除旧的“加载更多”按钮 ---
    const existingLoader = document.getElementById('load-more-messages-btn');
    if (existingLoader) {
        existingLoader.remove();
    }

    // --- 渲染消息 ---
    const fragment = document.createDocumentFragment(); // 使用文档片段提升性能
    const characterName = characterChat.name;

    // (渲染逻辑与之前版本基本相同，只是添加到了 fragment 中)
    historyToShow.forEach((msg, index) => {
        if (msg.isHidden || msg.isSystemDecision) return;
        const container = document.createElement('div');
        let sender;
        if (isUserChat) { sender = msg.role === 'user' ? '我' : characterName; } 
        else { sender = msg.sender; }

        const isSentByCharacter = sender === characterName;
        container.className = `character-chat-bubble-container ${isSentByCharacter ? 'sent' : 'received'}`;
        
        let avatarHtml = '';
        if(isSentByCharacter) {
             avatarHtml = `<img src="${characterChat.settings.aiAvatar || defaultAvatar}" class="character-chat-avatar">`;
        } else {
             if(isUserChat){
                avatarHtml = `<img src="${characterChat.settings.myAvatar || defaultMyGroupAvatar}" class="character-chat-avatar">`;
             } else {
                 const npcData = (characterChat.npcLibrary || []).find(npc => npc.name === contactName);
                 if (npcData && npcData.avatar) {
                    avatarHtml = `<img src="${npcData.avatar}" class="character-chat-avatar">`;
                 } else {
                    const avatarColors = ['#FFC107', '#4CAF50', '#2196F3', '#F44336', '#9C27B0', '#00BCD4'];
                    const npcNameInitial = contactName.slice(-1);
                    const colorIndex = contactName.length % avatarColors.length;
                    const bgColor = avatarColors[colorIndex];
                    avatarHtml = `<div class="character-chat-avatar" style="background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
                 }
             }
        }

        let contentHtml = '';
        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
            contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-height: 100px;">`;
        } else {
            contentHtml = msg.content;
        }
        const bubbleHtml = `<div class="character-chat-bubble">${contentHtml}</div>`;
        const originalIndex = startIndex + index; // 计算在完整历史记录中的真实索引
        container.innerHTML = `${avatarHtml}${bubbleHtml}<button class="item-delete-btn message-delete-btn" data-contact-name="${contactName}" data-index="${originalIndex}" data-is-user-chat="${isUserChat}">×</button>`;
        fragment.appendChild(container);
    });
    
    // --- 决定是否显示“加载更多”按钮 ---
    if (startIndex > 0) {
        const loadMoreBtn = document.createElement('div');
        loadMoreBtn.id = 'load-more-messages-btn';
        loadMoreBtn.textContent = '加载更早的消息';
        loadMoreBtn.style.textAlign = 'center';
        loadMoreBtn.style.padding = '10px';
        loadMoreBtn.style.color = '#888';
        loadMoreBtn.style.cursor = 'pointer';
        loadMoreBtn.style.fontSize = '12px';
        loadMoreBtn.onclick = () => {
            // 记录当前滚动条位置，以便加载后恢复
            const currentScrollHeight = messagesEl.scrollHeight;
            renderCharacterChatHistory(contactName, isUserChat, loadOffset + MESSAGES_PER_PAGE);
            // 加载后，将滚动条定位到之前的位置，避免跳动
            messagesEl.scrollTop = messagesEl.scrollHeight - currentScrollHeight;
        };
        messagesEl.prepend(loadMoreBtn); // 将按钮添加到顶部
    }
    
    messagesEl.prepend(fragment); // 将新消息一次性插入到DOM中

    // --- 滚动条定位 ---
    if (loadOffset === 0) {
        // 首次加载，滚动到底部
        messagesEl.scrollTop = messagesEl.scrollHeight;
    }
}
// ▲▲▲ 替换结束 ▲▲▲



function renderCharacterShoppingCart() {
    const listEl = document.getElementById('character-shopping-cart-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.shoppingCart;
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">购物车是空的</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-cart-item';
        itemEl.innerHTML = `
            <div class="cart-item-icon">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>
            </div>
            <div class="cart-item-info">
                <div class="title">${item.name}</div>
                <div class="store">${item.store}</div>
            </div>
            <div class="cart-item-price">¥ ${item.price.toFixed(2)}</div>
            <button class="item-delete-btn" data-type="shoppingCart" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}
function renderCharacterMemos() {
    const listEl = document.getElementById('character-memos-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.memos;
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">备忘录是空的</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-data-item';
        itemEl.innerHTML = `
            <div class="title">${item.title}</div>
            <div class="content">${item.content}</div>
            <button class="item-delete-btn" data-type="memos" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}


// ▲▲▲ 新功能函数结束 ▲▲▲

/**
 * 【全新】在角色手机内部切换页面
 * @param {string} pageId - 要显示的角色手机页面的ID
 */
function showCharacterPhonePage(pageId) {
    // 1. 找到角色手机内部屏幕的所有页面
    const pages = document.querySelectorAll('.character-phone-page');
    // 2. 隐藏所有页面
    pages.forEach(p => p.classList.remove('active'));
    // 3. 显示目标页面
    const pageToShow = document.getElementById(pageId);
    if (pageToShow) {
        pageToShow.classList.add('active');
    }
}

// ▼▼▼ 【全新】角色手机新增APP渲染函数 ▼▼▼

function renderCharacterBrowser() {
    const listEl = document.getElementById('character-browser-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.browserHistory;
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">浏览器历史为空</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-browser-item';
        itemEl.innerHTML = `
            <span class="browser-item-icon">🌐</span>
            <div class="title">${item.query}</div>
            <button class="item-delete-btn" data-type="browserHistory" data-index="${index}">×</button>
        `;
        itemEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('item-delete-btn')) return;
            document.getElementById('character-browser-detail-title').textContent = item.query;
            document.getElementById('character-browser-detail-content').innerHTML = (item.result || "AI未生成详细内容。").replace(/\n/g, '<br>');
            showCharacterPhonePage('character-browser-detail-screen');
        });
        listEl.appendChild(itemEl);
    });
}


function renderCharacterPhotoAlbum() {
    const gridEl = document.getElementById('character-album-grid');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.photoAlbum;
    gridEl.innerHTML = '';
    if (!items || items.length === 0) {
        gridEl.innerHTML = '<p style="grid-column: 1 / -1; text-align:center; color: #8a8a8a; margin-top: 50px;">相册里没有照片</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-album-item';
        itemEl.style.position = 'relative'; 
        itemEl.innerHTML = `
            <img src="https://i.postimg.cc/KYr2qRCK/1.jpg" alt="文字图">
            <button class="item-delete-btn" data-type="photoAlbum" data-index="${index}" style="top: 10px; right: 10px; z-index: 1;">×</button>
        `;
        itemEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('item-delete-btn')) return;
            showCustomAlert("图片内容", item.hiddenContent);
        });
        gridEl.appendChild(itemEl);
    });
}



/**
 * 【V2美化版】渲染角色手机 - 银行
 */
function renderCharacterBank() {
    const detailsEl = document.getElementById('character-bank-details');
    const bankData = state.chats[activeCharacterPhoneId].characterPhoneData.bank;
    detailsEl.innerHTML = '';
    
    const balanceCard = document.createElement('div');
    balanceCard.className = 'character-bank-balance-card';
    balanceCard.innerHTML = `
        <div class="label">账户余额</div>
        <div class="amount">¥ ${(bankData.balance || 0).toFixed(2)}</div>
    `;
    detailsEl.appendChild(balanceCard);
    
    if (!bankData.transactions || bankData.transactions.length === 0) {
        detailsEl.innerHTML += '<p style="text-align:center; color: #8a8a8a; margin-top: 30px;">暂无交易明细</p>';
        return;
    }
    [...bankData.transactions].reverse().forEach((item, index) => {
        const originalIndex = bankData.transactions.length - 1 - index;
        const isIncome = item.type === '收入';
        const itemEl = document.createElement('div');
        itemEl.className = 'character-bank-transaction';
        const iconBg = isIncome ? '#4CAF50' : '#E91E63';
        const iconSvg = isIncome 
            ? `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M7 10h10v4H7z" opacity=".3"/><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"/></svg>`
            : `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-1 14H5c-.55 0-1-.45-1-1v-5h16v5c0 .55-.45 1-1 1zm1-10H4V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v2z"/></svg>`;

        itemEl.innerHTML = `
            <div class="transaction-details">
                <div class="transaction-icon" style="background-color: ${iconBg};">${iconSvg}</div>
                <div>
                    <div class="title">${item.description}</div>
                    <div class="meta" style="border:none; padding:0; margin-top:4px;"><span>${item.type}</span></div>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <span class="transaction-amount ${isIncome ? 'income' : 'expense'}">
                    ${isIncome ? '+' : '-'} ${item.amount.toFixed(2)}
                </span>
                <button class="item-delete-btn" data-type="bank.transactions" data-index="${originalIndex}">×</button>
            </div>
        `;
        detailsEl.appendChild(itemEl);
    });
}

/**
 * 【V2美化版】渲染角色手机 - 行动轨迹
 */
function renderCharacterTrajectory() {
    const listEl = document.getElementById('character-trajectory-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.trajectory;
    listEl.innerHTML = '';
    listEl.classList.add('character-trajectory-list');

    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暂无足迹</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-trajectory-item';
        itemEl.innerHTML = `
            <div class="trajectory-item-content">
                <div class="title">${item.activity}</div>
                <div class="meta">
                    <span>📍 ${item.location}</span>
                    <span style="margin-left: 10px;">🕒 ${item.time}</span>
                </div>
            </div>
            <button class="item-delete-btn" data-type="trajectory" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}

/**
 * 【V2美化版】渲染角色手机 - APP使用记录
 */
function renderCharacterAppUsage() {
    const listEl = document.getElementById('character-app-usage-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.appUsage;
    listEl.innerHTML = '';
     if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暂无使用记录</p>';
        return;
    }
    const durationsInMinutes = items.map(item => parseDurationToMinutes(item.duration));
    const maxDuration = Math.max(...durationsInMinutes);
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-app-usage-item';
        const durationInMinutes = durationsInMinutes[index];
        const barWidth = maxDuration > 0 ? (durationInMinutes / maxDuration) * 100 : 0;
        itemEl.innerHTML = `
            <div class="app-usage-header">
                <span class="name">${item.appName}</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="duration">${item.duration}</span>
                    <button class="item-delete-btn" data-type="appUsage" data-index="${index}">×</button>
                </div>
            </div>
            <div class="app-usage-bar-container">
                <div class="app-usage-bar" style="width: ${barWidth}%;"></div>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}


/**
 * 【日记 V4-最终修复版】渲染角色的日记列表
 */
function renderCharacterDiary() {
    const listEl = document.getElementById('character-diary-list');
    const items = state.chats[activeCharacterPhoneId].characterPhoneData.diary;
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">日记本还是空的，点击右上角写下第一篇日记吧。</p>';
        return;
    }
    
    [...items].reverse().forEach((item, index) => {
        const originalIndex = items.length - 1 - index;
        const itemEl = document.createElement('div');
        itemEl.className = 'character-data-item';
        const contentHtml = renderMarkdown(item.content);
        itemEl.innerHTML = `
            <div class="content">${contentHtml}</div>
            <div class="meta">
                <span>${new Date(item.timestamp).toLocaleString('zh-CN', { 
                    year: 'numeric', 
                    month: '2-digit', 
                    day: '2-digit', 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false
                })}</span>
            </div>
            <button class="item-delete-btn" data-type="diary" data-index="${originalIndex}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}


// ▼▼▼ 用下面这【一整块】增强版代码，替换掉你旧的 generateNewDiaryEntry 函数 ▼▼▼
/**
 * 【日记】独立刷新，生成新的日记条目 (已增加错误处理)
 */
async function generateNewDiaryEntry() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const persona = chat.settings.aiPersona;
        const recentHistory = chat.history.slice(-20).map(msg => {
            const sender = msg.role === 'user' ? '我' : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        
        let worldBookContext = '';
        const effectiveWorldBookIds = getEffectiveWorldBookIds(chat);
        if (effectiveWorldBookIds.length > 0) {
            worldBookContext = '--- 世界观设定 (这是你必须严格遵守的背景) ---\n' +
                effectiveWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        
        const diaryPrompt = `
# 任务
你现在是角色 "${chat.name}"。请你回顾一下最近和我的聊天，以及你的人设，然后用你的口吻写一篇日记。
这篇日记是你内心的独白，可以记录你的感受、思考、计划或者秘密。
内容要丰富、有深度，长度在100到300字之间。

# 【【【重要：格式指令】】】
你【必须】使用以下Markdown语法来丰富日记的格式，使其更具表现力：
-   **标题**: 使用 \`#\` 或 \`##\` 来创建大标题和副标题。 (例如: \`# 今天的心情\`)
-   **粗体**: 使用 \`**文字**\` 来强调重点。 (例如: \`今天真的**非常**开心。\`)
-   **斜体**: 使用 \`*文字*\` 来表达情绪或内心想法。 (例如: \`*他到底是怎么想的呢...*\`)
-   **删除线**: 使用 \`~~文字~~\` 来表示划掉或否定的想法。 (例如: \`我决定明天去<s>逛街</s>学习。\`)
-   **遮挡/剧透**: 使用 \`||文字||\` 来隐藏秘密或悄悄话。 (例如: \`我偷偷准备了一个惊喜，||是一个手织的围巾||。\`)

你的输出【必须且只能】是日记的正文内容，不要包含任何其他说明或JSON格式。

# 你的信息
- 你的名字: ${chat.name}
- 你的人设: ${persona}
${worldBookContext}

# 最近聊天记录参考
${recentHistory}
`;

        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, diaryPrompt, [{role: 'user', content: diaryPrompt}], isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: diaryPrompt}],
                    temperature: 0.9,
                })
            });
        
        // --- ★★★ 错误处理核心代码 ★★★ ---
        if (!response.ok) {
            let errorMsg = `API请求失败，状态码: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg += `\n错误信息: ${errorData.error.message}`;
            } catch (e) {
                errorMsg += `\n无法解析错误响应体。`;
            }
            throw new Error(errorMsg);
        }
        // --- ★★★ 错误处理结束 ★★★ ---
        
        const data = await response.json();
        const diaryContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

        // 确保使用当前准确时间
        const currentTimestamp = Date.now();
        console.log('生成日记时间:', new Date(currentTimestamp).toLocaleString('zh-CN'));
        
        const newEntry = {
            timestamp: currentTimestamp,
            content: diaryContent
        };
        
        chat.characterPhoneData.diary.push(newEntry);
        await db.chats.put(chat);
        
        renderCharacterDiary();
        alert('新日记已生成！');

    } catch (error) {
        console.error("生成日记失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误，请检查你的网络、API密钥或模型设置。\n\n详细信息:\n${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▲▲▲ 新增函数结束 ▲▲▲

// ▼▼▼ 【全新】万能Markdown渲染函数 (带安全过滤和遮挡效果) ▼▼▼

/**
 * 将Markdown文本安全地渲染为HTML
 * @param {string} markdownText - 原始的Markdown文本
 * @returns {string} - 处理和净化后的安全HTML字符串
 */
function renderMarkdown(markdownText) {
    if (!markdownText) return '';

    // 1. 【预处理】支持自定义的“遮挡/剧透”语法 ||spoiler||
    // 我们在 marked.js 处理之前，手动把 ||text|| 替换成带特定class的HTML标签
    let processedText = markdownText.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');

    // 2. 【核心】使用 marked.js 将Markdown转换为HTML
    // gfm: true 开启GitHub风格的Markdown，支持删除线等
    // breaks: true 让回车符也能变成<br>，更符合聊天习惯
    let rawHtml = marked.parse(processedText, { gfm: true, breaks: true });

    // 3. 【安全】使用 DOMPurify 清洗HTML，防止XSS攻击
    let sanitizedHtml = DOMPurify.sanitize(rawHtml);

    return sanitizedHtml;
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 【辅助函数】将时长字符串（如“2.5小时”）转换为分钟数
 */
function parseDurationToMinutes(durationString) {
    if (!durationString) return 0;
    const num = parseFloat(durationString) || 0;
    if (durationString.includes('小时') || durationString.includes('h')) {
        return num * 60;
    }
    // 默认单位是分钟
    return num;
}
// ▼▼▼ 把这两个【新函数】粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】切换视频通话的大小窗口画面
 */
function switchVideoViews() {
    const mainView = document.getElementById('video-main-view');
    const pipView = document.getElementById('video-pip-view');
    
    // 交换两张图片的 src
    const mainImg = mainView.querySelector('img');
    const pipImg = pipView.querySelector('img');
    const tempSrc = mainImg.src;
    mainImg.src = pipImg.src;
    pipImg.src = tempSrc;
}

// ▼▼▼ 用这个【全新的、逻辑正确的函数】，完整替换掉你旧的 handleVideoCallReroll 函数 ▼▼▼
/**
 * 【全新】处理视频通话中的“重roll”请求
 */
async function handleVideoCallReroll() {
    if (!videoCallState.isActive) return;

    // 1. 找到用户最后一次说的话的索引
    const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex(h => h.role === 'user');
    
    // 2. 从通话历史中，删除掉那之后的所有AI回复
    //    如果用户一句话没说（lastUserSpeechIndex 是 -1），就删除所有AI的回复
    if (lastUserSpeechIndex > -1) {
        videoCallState.callHistory.splice(lastUserSpeechIndex + 1);
    } else {
        // 如果用户还没说过话，就清空所有历史，让AI重说第一句话
        videoCallState.callHistory = [];
    }
    
    // 3. 【核心】重新渲染通话界面，让旧的AI气泡从屏幕上消失
    //    我们需要根据当前是哪种模式，来清空对应的聊天容器
    const chat = state.chats[videoCallState.activeChatId];
    const isVisualMode = chat.settings.visualVideoCallEnabled;
    // 根据通话类型和模式决定使用哪个消息容器
    let callFeed;
    if (videoCallState.callType === 'voice') {
        callFeed = document.getElementById('voice-call-main');
    } else if (isVisualMode) {
        callFeed = document.getElementById('video-call-messages-visual');
    } else {
        callFeed = document.getElementById('video-call-main');
    }
    
    callFeed.innerHTML = ''; // 清空容器
    
    // 重新渲染删除后的历史记录
    videoCallState.callHistory.forEach(msg => {
        let bubble;
        if (isVisualMode) {
            bubble = document.createElement('div');
            bubble.className = `visual-call-bubble ${msg.role === 'user' ? 'user' : 'ai'}`;
        } else {
            bubble = document.createElement('div');
            bubble.className = `call-message-bubble ${msg.role === 'user' ? 'user-speech' : 'ai-speech'}`;
        }
        bubble.textContent = msg.content;
        callFeed.appendChild(bubble);
    });
    
    // 4. 重新触发AI响应，它会根据删减后的历史记录生成新内容
    await triggerAiInCallAction();
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 应用指定的主题（'light' 或 'dark'）
 * @param {string} theme - 要应用的主题名称
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    // 核心操作：添加或移除 .dark-mode 类
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果开关存在，就同步它的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    // 将用户的选择保存到本地存储，以便下次打开时记住
    localStorage.setItem('ephone-theme', theme);

    // 【重要】因为聊天背景色依赖模式，切换后需要重新渲染
    if (state.activeChatId) {
        renderChatInterface(state.activeChatId);
    }
}

/**
 * 当用户点击开关时，切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}
// ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼
/**
 * 【全新】删除角色手机中的一个联系人及其所有聊天记录
 * @param {string} contactName - 要删除的联系人的名字
 */
async function deleteCharacterPhoneContact(contactName) {
    if (!activeCharacterPhoneId) return;

    // 弹出确认框，防止误删
    const confirmed = await showCustomConfirm(
        '删除联系人',
        `确定要从TA的手机中删除联系人“${contactName}”以及所有相关聊天记录吗？此操作不可恢复。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeCharacterPhoneId];
        if (chat && chat.characterPhoneData && chat.characterPhoneData.chats) {
            // 从数据中删除这个联系人
            delete chat.characterPhoneData.chats[contactName];
            
            // 将更新后的数据保存回数据库
            await db.chats.put(chat);
            
            // 重新渲染聊天列表，让删除效果立刻显示
            renderCharacterChatList();
            
            alert(`联系人“${contactName}”已删除。`);
        }
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
/* ▼▼▼ 【全新】心声功能核心函数 ▼▼▼ */

/**
 * 打开心声面板
 */
function openInnerVoiceModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.latestInnerVoice) {
        // 如果还没有心声数据，可以给个提示
        alert("还没有捕捉到Ta的心声哦，试着再聊一句吧！");
        return;
    }
    
    const modal = document.getElementById('inner-voice-modal');
    const data = chat.latestInnerVoice;
    
    // 填充数据
    document.getElementById('inner-voice-avatar').src = chat.settings.aiAvatar || defaultAvatar;
    document.getElementById('inner-voice-char-name').textContent = chat.name;
    document.getElementById('inner-voice-adopter').textContent = `领养人: ${state.qzoneSettings.nickname || '你'}`;
    
    document.getElementById('inner-voice-clothing').textContent = data.clothing || '...';
    document.getElementById('inner-voice-behavior').textContent = data.behavior || '...';
    document.getElementById('inner-voice-thoughts').textContent = data.thoughts || '...';
    document.getElementById('inner-voice-naughty-thoughts').textContent = data.naughtyThoughts || '...';

    // 显示面板
    modal.classList.add('visible');
    // 确保历史面板是隐藏的
    document.getElementById('inner-voice-history-panel').style.display = 'none';
    document.getElementById('inner-voice-main-panel').style.display = 'flex';
    isInnerVoiceHistoryOpen = false;
}

/**
 * 打开或关闭历史记录面板
 */
function toggleInnerVoiceHistory() {
    const mainPanel = document.getElementById('inner-voice-main-panel');
    const historyPanel = document.getElementById('inner-voice-history-panel');
    
    if (isInnerVoiceHistoryOpen) {
        // 如果是打开的，就关闭它，显示主面板
        mainPanel.style.display = 'flex';
        historyPanel.style.display = 'none';
    } else {
        // 如果是关闭的，就打开它，隐藏主面板
        renderInnerVoiceHistory(); // 渲染历史记录
        mainPanel.style.display = 'none';
        historyPanel.style.display = 'flex';
    }
    isInnerVoiceHistoryOpen = !isInnerVoiceHistoryOpen; // 切换状态
}

/**
 * 渲染心声的历史记录列表
 */
function renderInnerVoiceHistory() {
    const listEl = document.getElementById('inner-voice-history-list');
    listEl.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const history = chat.innerVoiceHistory || [];

    if (history.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">还没有历史记录</p>';
        return;
    }

    // 从新到旧显示
    [...history].reverse().forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'inner-voice-history-item';
        
        const date = new Date(item.timestamp);
        const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        
        // 【核心修改】在HTML中加入了删除按钮
        itemEl.innerHTML = `
            <button class="history-item-delete-btn" data-timestamp="${item.timestamp}">×</button>
            <div class="history-item-timestamp">${dateString}</div>
            <div class="history-item-content">
                <p><strong>服装:</strong> ${item.clothing || '...'}</p>
                <p><strong>行为:</strong> ${item.behavior || '...'}</p>
                <p><strong>心声:</strong> ${item.thoughts || '...'}</p>
                <p><strong>坏心思:</strong> ${item.naughtyThoughts || '...'}</p>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}
/**
 * 【全新】删除单条心声记录
 * @param {number} timestamp - 要删除的心声的时间戳
 */
async function deleteSingleInnerVoice(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.innerVoiceHistory) return;

    // 弹出确认框
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这条心声记录吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 从数组中过滤掉匹配的项
        chat.innerVoiceHistory = chat.innerVoiceHistory.filter(item => item.timestamp !== timestamp);
        // 保存回数据库
        await db.chats.put(chat);
        // 重新渲染列表
        renderInnerVoiceHistory();
    }
}

/**
 * 【全新】清空所有心声记录
 */
async function clearAllInnerVoiceHistory() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.innerVoiceHistory || chat.innerVoiceHistory.length === 0) return;

    const confirmed = await showCustomConfirm('确认清空', '确定要清空所有心声历史记录吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        chat.innerVoiceHistory = [];
        await db.chats.put(chat);
        renderInnerVoiceHistory();
    }
}// ▼▼▼ 请将下面这一整块全新的代码，粘贴到 init() 函数的上方 ▼▼▼

/**
 * 【总入口】当用户点击“召唤NPC评论”按钮时触发
 * @param {number} postId - 动态的ID
 * @param {string} authorId - 动态作者的ID ('user' 或 'chat_...')
 */
async function handleNpcSummonClick(postId, authorId) {
    const post = await db.qzonePosts.get(postId);
    if (!post) {
        alert("找不到该动态！");
        return;
    }

    if (authorId === 'user') {
        // 如果是用户发的动态，弹出选择菜单
        await handleUserPostCommentTrigger(post);
    } else {
        // 如果是角色发的动态，直接触发他自己的NPC
        await handleCharPostCommentTrigger(post, authorId);
    }
}

/**
 * 处理【角色】动态的NPC召唤
 * @param {object} post - 动态对象
 * @param {string} authorId - 动态作者的角色ID
 */
async function handleCharPostCommentTrigger(post, authorId) {
    const authorChar = state.chats[authorId];
    if (!authorChar || !authorChar.npcLibrary || authorChar.npcLibrary.length === 0) {
        alert(`角色“${authorChar.name}”还没有自己的NPC朋友哦！`);
        return;
    }

    // 只使用这个角色自己的NPC库
    await generateNpcCommentsForPost(post, authorChar.npcLibrary);
}

/**
 * 处理【用户】动态的NPC召唤（弹出选择框）
 */
async function handleUserPostCommentTrigger(post) {
    const modal = document.getElementById('custom-modal-overlay');
    const modalTitle = document.getElementById('custom-modal-title');
    const modalBody = document.getElementById('custom-modal-body');
    const modalConfirmBtn = document.getElementById('custom-modal-confirm');
    const modalCancelBtn = document.getElementById('custom-modal-cancel');
    
    modalTitle.textContent = '选择要召唤的NPC';
    
    // 筛选出所有拥有NPC库的角色
    const charsWithNpcs = Object.values(state.chats).filter(
        chat => !chat.isGroup && chat.npcLibrary && chat.npcLibrary.length > 0
    );

    if (charsWithNpcs.length === 0) {
        alert("当前没有任何角色拥有NPC库。");
        return;
    }

    // 构建选择列表的HTML
    let optionsHtml = '<div style="text-align: left;">';
    optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="all" checked> 召唤所有人</label>`;
    charsWithNpcs.forEach(char => {
        optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="${char.id}"> 只召唤 ${char.name} 的朋友</label>`;
    });
    optionsHtml += '</div>';
    
    modalBody.innerHTML = optionsHtml;
    modalConfirmBtn.textContent = '确认召唤';
    modalCancelBtn.style.display = 'block';

    modal.classList.add('visible');

    modalConfirmBtn.onclick = async () => {
        const selectedValue = document.querySelector('input[name="npc_summon_choice"]:checked').value;
        let npcsToSummon = [];

        if (selectedValue === 'all') {
            // 集合所有角色的所有NPC
            charsWithNpcs.forEach(char => {
                npcsToSummon.push(...char.npcLibrary);
            });
        } else {
            // 只获取被选中的那个角色的NPC
            const selectedChar = state.chats[selectedValue];
            if (selectedChar) {
                npcsToSummon = selectedChar.npcLibrary;
            }
        }
        
        modal.classList.remove('visible');
        if (npcsToSummon.length > 0) {
            await generateNpcCommentsForPost(post, npcsToSummon);
        }
    };
    
    modalCancelBtn.onclick = () => modal.classList.remove('visible');
}

/**
 * 【AI核心 - V2.1 弹窗修正版】生成NPC评论或回复，并更新到动态
 * @param {object} post - 动态对象
 * @param {Array<object>} npcsToComment - 将要发表评论的NPC对象数组
 */
async function generateNpcCommentsForPost(post, npcsToComment) {
    // ▼▼▼ 【日志#1】函数开始，并显示传入的数据 ▼▼▼
    console.log("【NPC评论-诊断】: 1. 函数 generateNpcCommentsForPost 已触发", { post, npcsToComment });

    await showCustomAlert("请稍候...", "正在召唤NPC们前来围观评论...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    const postContent = (post.content || post.publicText || post.hiddenContent || "(图片动态)").substring(0, 150);
    const existingComments = (post.comments || []).slice(-3).map(c => `${c.commenterName}: ${c.text}`).join('\n');

    const shuffledNpcs = [...npcsToComment].sort(() => 0.5 - Math.random());
    const selectedNpcs = shuffledNpcs.slice(0, 5);
    const npcList = selectedNpcs.map(npc => `- ${npc.name} (人设: ${npc.persona})`).join('\n');
    
    const authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '未知作者');

    const systemPrompt = `
# 任务
你是一个多角色扮演AI。现在有一条动态需要你扮演指定的NPC角色进行评论或回复。

# 动态信息
- 作者: ${authorName}
- 内容摘要: ${postContent}...
- 最近的评论 (你可以回复他们):
${existingComments || "(暂无评论)"}

# 你需要扮演的NPC列表 (及他们的人设)
${npcList}

# 核心规则
1.  你【可以】从上面的NPC列表中，选择1到3个最合适的角色进行评论或回复。如果你不想回复，也可以不回复。
2.  评论/回复内容【必须】严格符合该NPC的人设和口吻，并与动态内容或已有评论相关。
3.  你的回复【必须且只能】是一个严格的JSON数组，每个对象代表一条评论或回复。
4.  格式: \`[{"commenterName": "NPC名字", "commentText": "评论内容", "replyTo": "(可选)被回复者名字"}]\`

现在，请开始生成评论或回复。
`;
    // ▼▼▼ 【日志#2】显示最终构建好、即将发送给AI的Prompt ▼▼▼
    console.log("【NPC评论-诊断】: 2. 已构建完成，准备发送给AI的 System Prompt:", systemPrompt);

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi;
        if (isGemini) {
            messagesForApi = [{ role: 'user', content: systemPrompt }];
        } else {
            messagesForApi = [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: "请根据你在system prompt中读到的信息生成评论。" }
            ];
        }
        
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        // ▼▼▼ 【日志#3】在发送请求前，显示最终的请求体，这是最关键的信息！▼▼▼
        console.log("【NPC评论-诊断】: 3. 即将发送API请求... 请求地址:", isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`);
        console.log("【NPC评论-诊断】: 3.1 请求体 (Body) 内容:", isGemini ? geminiConfig.data.body : JSON.stringify({ model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } }));

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 0.9,
                    response_format: { type: "json_object" }
                })
            });

        // ▼▼▼ 【日志#4】显示API的响应状态，判断网络请求是否成功 ▼▼▼
        console.log("【NPC评论-诊断】: 4. 收到API响应", { ok: response.ok, status: response.status });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API请求失败: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        // ▼▼▼ 【日志#5】显示AI返回的原始文本内容，看它有没有乱来 ▼▼▼
        console.log("【NPC评论-诊断】: 5. 从API获取到的原始回复内容:", aiResponseContent);
        
        let newComments;
        if (aiResponseContent.includes('"chatResponse"')) {
            newComments = JSON.parse(aiResponseContent).chatResponse;
        } else {
            newComments = JSON.parse(aiResponseContent);
        }

        // ▼▼▼ 【日志#6】显示成功解析后的JSON对象，看格式对不对 ▼▼▼
        console.log("【NPC评论-诊断】: 6. 成功解析后的评论对象数组:", newComments);

        if (Array.isArray(newComments) && newComments.length > 0) {
            const postToUpdate = await db.qzonePosts.get(post.id); 
            if (!postToUpdate) throw new Error("在数据库中找不到要更新的帖子！");
            if (!postToUpdate.comments) postToUpdate.comments = [];

            newComments.forEach(comment => {
                if(comment.commenterName && comment.commentText) {
                    const newCommentObject = {
                        commenterName: comment.commenterName,
                        text: comment.commentText,
                        timestamp: Date.now()
                    };
                    if (comment.replyTo) newCommentObject.replyTo = comment.replyTo;
                    postToUpdate.comments.push(newCommentObject);
                }
            });

            await db.qzonePosts.put(postToUpdate);
            hideCustomModal();
            await renderQzonePosts(); 
            alert("NPC们评论成功！");
        } else {
             hideCustomModal();
             alert("NPC们似乎没什么想说的。");
        }

    } catch (error) {
        // ▼▼▼ 【日志#7】如果中途出错，打印详细的错误信息 ▼▼▼
        console.error("【NPC评论-错误】: 召唤NPC评论失败:", error);
        await showCustomAlert('召唤失败', `发生了一个错误：\n${error.message}`);
    }
}

// ▼▼▼ 把这一整块全新的微博功能函数，粘贴到 init() 函数的上方 ▼▼▼

let currentHotTopic = ''; // 用于存储当前正在查看的热搜话题

// ▼▼▼ 用这【一整块新代码】完整替换掉旧的 generateHotSearch 函数 ▼▼▼
/**
 * 【总入口 V3 - 严防OOC版】生成微博热搜列表，并联动生成广场内容
 */
async function generateHotSearch() {
    await showCustomAlert("请稍候...", "正在结合角色人设生成微博热搜和广场动态...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    const publicFigures = Object.values(state.chats)
        .filter(chat => !chat.isGroup)
        .map(chat => ({ name: chat.name, persona: chat.settings.aiPersona.substring(0, 150) + '...' }));

    const publicFiguresContext = publicFigures.length > 0
        ? `
# 核心参考人物 (你必须围绕他们生成热搜)
${JSON.stringify(publicFigures, null, 2)}
`
        : "当前没有特定的公众人物，请自由生成热点事件。";

    const systemPrompt = `
# 任务
你是一个专业的“微博热搜榜单生成器”。你的任务是根据下方提供的“核心参考人物”信息，为他们量身打造一个包含10个热搜话题的榜单。

# 核心规则
1.  **强相关性**: 生成的话题【必须】与“核心参考人物”的身份、职业、人设高度相关。例如，如果是电竞选手，热搜就应该是关于比赛；如果是演员，就应该是关于新剧。
2.  **【【【严禁杜撰】】】**: 绝对禁止为列表中的人物【凭空捏造】他们人设中没有的职业、身份或背景。你只能根据提供的人设进行合理发挥。
3.  **真实感与多样性**: 为了让榜单更真实，你可以混合2-3个与核心人物无关的、社会化的虚拟热点事件。
4.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，数组中包含10个对象。每个对象【必须】包含以下三个字段:
    -   \`"topic"\`: (字符串) 热搜的话题，必须用"#"符号包裹。
    -   \`"heat"\`: (字符串) 热度值，例如 "345.6万"。
    -   \`"tag"\`: (字符串) 一个标签，必须从 "热"、"新"、"荐" 中选择一个。

${publicFiguresContext}
`;

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
        });

        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空内容，可能被安全策略拦截。请检查Prompt或更换模型。");
        }
        
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent);
        const hotSearchData = responseData.hot_searches || responseData;

        await generatePlazaFeed(hotSearchData); 
        renderHotSearchList(hotSearchData); 

        await showCustomAlert("操作成功", "热搜榜和广场均已生成完毕！");

    } catch (error) {
        console.error("生成热搜失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【UI渲染】根据AI返回的数据渲染热搜列表
 */
function renderHotSearchList(hotSearchData) {
    const listEl = document.getElementById('weibo-hot-search-list');
    listEl.innerHTML = ''; 

    if (!hotSearchData || !Array.isArray(hotSearchData)) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">AI返回的数据格式不正确，无法渲染。</p>';
        return;
    }

    hotSearchData.forEach((item, index) => {
        const rank = index + 1;
        const tagClass = { '热': 'hot', '新': 'new', '荐': 'rec' }[item.tag] || 'rec';

        const itemEl = document.createElement('div');
        itemEl.className = 'hot-search-item';
        itemEl.dataset.rank = rank;
        itemEl.innerHTML = `
            <span class="hot-search-rank">${rank}</span>
            <div class="hot-search-content">
                <span class="hot-search-topic">${item.topic}</span>
                <span class="hot-search-tag ${tagClass}">${item.tag}</span>
            </div>
            <span class="hot-search-heat" style="color: var(--text-secondary); font-size: 13px;">${item.heat}</span>
        `;
        itemEl.addEventListener('click', () => showHotTopicFeedScreen(item.topic));
        listEl.appendChild(itemEl);
    });
}

/**
 * 【总入口】显示并生成指定热搜话题的微博Feed
 */
async function showHotTopicFeedScreen(topic) {
    currentHotTopic = topic; 
    document.getElementById('weibo-hottopic-title').textContent = topic;
    switchToWeiboView('weibo-hottopic-feed-view'); 
    await generateHotSearchFeed(topic); 
}

/**
 * 【AI核心】调用API为指定话题生成微博Feed
 */
async function generateHotSearchFeed(topic) {
    const feedEl = document.getElementById('weibo-hottopic-feed-list');
    feedEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">正在生成内容，请稍候...</p>';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }
    
    // 【核心】收集所有可用的角色和NPC，让AI知道可以用他们发言
    const allChars = Object.values(state.chats).filter(c => !c.isGroup).map(c => ({ name: c.name, persona: c.settings.aiPersona.substring(0,100) }));
    const allNpcs = Object.values(state.chats).flatMap(c => c.npcLibrary || []).map(npc => ({ name: npc.name, persona: npc.persona.substring(0,100) }));
    const allPeople = [...allChars, ...allNpcs];

    const systemPrompt = `
# 任务
你是一个“微博内容生成器”。你的任务是围绕一个给定的热搜话题，生成一批相关的微博帖子。

# 当前热搜话题
**${topic}**

# 核心规则
1.  **数量**: 生成 5 到 10 条微博。
2.  **相关性**: 所有微博内容【必须】与话题 **"${topic}"** 强相关，并且【必须】在内容中包含 **${topic}** 这个话题标签。
3.  **高热度**: 生成的微博必须看起来像是热搜里的内容，所以它们的 "likes" (点赞数) 和 "comments" (评论数) 【必须】非常高。点赞数应在 10000 到 500000 之间，评论数应在 800 到 20000 之间。
4.  **评论生成**: 为每条微博生成 8 到 10 条真实感的路人评论。评论内容应与微博内容相关，风格多样。
5.  **作者多样性**: 微博的作者可以是下方“可用人物列表”中的角色，也可以是你虚构的路人、大V或官方媒体。如果让列表中的角色发言，内容必须符合他的人设。
6.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，数组中包含多条微博对象。每个对象【必须】包含以下字段:
    -   \`"author"\`: (字符串) 作者昵称。
    -   \`"content"\`: (字符串) 微博正文，必须包含话题标签 ${topic}。
    -   \`"likes"\`: (数字) 10000到500000之间的随机高赞数。
    -   \`"comments"\`: (数字) 800到20000之间的随机高评论数。
    -   \`"comments_list"\`: (数组) 包含8-10个评论对象的数组，每个对象格式为 \`{"author": "评论者昵称", "text": "评论内容"}\`。

# 可用人物列表 (你可以让他们发言)
${JSON.stringify(allPeople, null, 2)}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空内容，可能被安全策略拦截。");
        }
        
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent);
        const feedData = responseData.posts || responseData;

        renderWeiboFeed(feedEl, feedData, true);

    } catch (error) {
        console.error("生成热搜Feed失败:", error);
        feedEl.innerHTML = `<p style="text-align:center; color: #ff3b30; padding: 20px;">生成失败: ${error.message}</p>`;
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用这【一整块新代码】完整替换掉旧的 generatePlazaFeed 函数 ▼▼▼
/**
 * 【总入口 V3 - 严防OOC版】生成微博广场Feed
 * @param {Array} hotTopics - (可选) 从热搜生成函数传过来的话题数组
 */
async function generatePlazaFeed(hotTopics = null) {
    if (!hotTopics) {
        await showCustomAlert("请稍候...", "正在生成广场动态...");
    }
    const feedEl = document.getElementById('weibo-plaza-feed-list');
    feedEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">正在加载内容，请稍候...</p>';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }
    
    // 【核心修改1】这里我们不再只获取名字，而是把人设也一起拿过来！
    const publicFigures = Object.values(state.chats)
        .filter(chat => !chat.isGroup)
        .map(chat => ({ 
            name: chat.name, 
            persona: chat.settings.aiPersona.substring(0, 150) + '...' // 只截取前150个字符，防止prompt过长
        }));

    const publicFiguresContext = publicFigures.length > 0 
        ? `
# 核心参考人物 (你生成的内容可以围绕他们展开)
${JSON.stringify(publicFigures, null, 2)}
` 
        : "";
    
    const topicsContext = (hotTopics && Array.isArray(hotTopics) && hotTopics.length > 0)
        ? `请围绕以下热门话题生成内容：${hotTopics.map(t => t.topic).join('、 ')}`
        : "请随机生成一些生活化的日常内容。";

    const systemPrompt = `
# 任务
你是一个“微博广场内容生成器”。你的任务是模拟一个真实的社交媒体广场，生成10条由不同路人发布的微博帖子。

# 核心规则
1.  **身份**: 发帖者都是普通人，昵称要生活化。
2.  **内容**: 帖子内容应是生活化的日常。${topicsContext}
3.  **热度**: 赞和评论数可高可低，模拟真实世界的随机性。
4.  **【【【严禁杜撰】】】**: 如果你生成的内容提到了上方“核心参考人物”列表中的任何角色，你【绝对禁止】为他们【凭空捏造】人设中没有的职业、身份或背景。你只能根据提供的人设进行合理发挥。
5.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，包含10个微博对象。每个对象的格式与“热搜Feed”的格式完全相同（包含 author, content, likes, comments, comments_list 字段）。
    - \`"comments_list"\`: (数组) 包含2-5条评论对象的数组，每个对象格式为 \`{"author": "评论者昵称", "text": "评论内容"}\`。
${publicFiguresContext}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空内容，可能被安全策略拦截。");
        }
        
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent);
        const feedData = responseData.posts || responseData; 

        renderWeiboFeed(feedEl, feedData, false);

        if (!hotTopics) {
            await showCustomAlert("操作成功", "广场生成完毕！");
        }

    } catch (error) {
        console.error("生成广场Feed失败:", error);
        feedEl.innerHTML = `<p style="text-align:center; color: #ff3b30; padding: 20px;">生成失败: ${error.message}</p>`;
    }
}
// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 用这整块【V3修复版】代码，完整替换旧的 renderWeiboFeed 函数 ▼▼▼
/**
 * 【UI渲染 V3 - 修复评论和头像】通用函数，用于渲染微博Feed列表
 */
function renderWeiboFeed(containerEl, feedData, isHotSearch) {
    containerEl.innerHTML = '';
    
    if (!feedData || !Array.isArray(feedData)) {
        containerEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">AI返回的数据格式不正确，无法渲染。</p>';
        return;
    }

    feedData.forEach(post => {
        const postEl = document.createElement('div');
        postEl.className = 'weibo-post-item';

        // 【核心修复1：头像查找逻辑】
        let finalAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg'; // 默认路人头像
        const potentialChar = Object.values(state.chats).find(c => c.name === post.author);
        if (potentialChar) {
            finalAvatar = potentialChar.settings.aiAvatar; // 如果作者是你的char，就用他的头像！
        }

        // 【核心修复2：评论渲染逻辑】
        let commentsHtml = '';
        if (post.comments_list && post.comments_list.length > 0) {
            commentsHtml += '<div class="weibo-comments-container">';
            post.comments_list.forEach(comment => {
                // 确保我们能正确访问评论者昵称和内容
                const commenterName = comment.author || '匿名用户'; // 优先用 author，没有就用匿名
                const commentText = comment.text || ''; // 确保 text 存在
                commentsHtml += `
                    <div class="weibo-comment-item">
                        <span class="weibo-commenter-name">${commenterName}:</span>
                        <span class="weibo-comment-text">${commentText}</span>
                    </div>`;
            });
            commentsHtml += '</div>';
        }
        
        postEl.innerHTML = `
            <div class="weibo-post-header">
                <img src="${finalAvatar}" class="weibo-post-avatar">
                <div class="weibo-post-info">
                    <span class="weibo-post-nickname">${post.author}</span>
                    <span class="weibo-post-timestamp">${isHotSearch ? '热搜内容' : '刚刚'}</span>
                </div>
            </div>
            <div class="weibo-post-content">${(post.content || '').replace(/\n/g, '<br>')}</div>
            <div class="weibo-post-footer">
                <div class="weibo-post-actions">
                    <span class="weibo-action-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
                        <span>${post.likes || 0}</span>
                    </span>
                    <span class="weibo-action-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                        <span>${post.comments || 0}</span>
                    </span>
                </div>
                ${commentsHtml}
            </div>
        `;
        containerEl.appendChild(postEl);
    });
}
// ▲▲▲ 替换结束 ▲▲▲




        // ===================================================================
        // 4. 初始化函数 init()
        // ===================================================================
        /* ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼ */
/**
 * 【全新】如果数据库中没有，则自动创建一个内置的夜间模式主题
 */
async function addDefaultDarkModeThemeIfNeeded() {
    const themeName = "内置夜间模式"; // 这是我们要内置的主题名字
    try {
        // 检查数据库里是否已经有了这个名字的主题
        const existingTheme = await db.themes.where('name').equals(themeName).first();
        
        // 如果没有找到 (existingTheme 是 undefined)，就创建它
        if (!existingTheme) {
            console.log("内置夜间模式不存在，正在创建...");

            // 这就是完整的夜间模式CSS代码
            const darkModeCss = `
/* 1. 全局重新定义颜色变量 */
:root {
  --secondary-bg: #1c1c1e;
  --border-color: #38383a;
  --text-primary: #ffffff;
  --text-secondary: #8e8e93;
  --status-bar-text-color: #ffffff;
  --accent-color: #0A84FF; /* iOS风格的蓝色 */
}

/* 2. 为所有屏幕和主要容器设置基础深色背景 */
#phone-screen, .screen, #chat-list, #world-book-list, .list-container, .form-container, #chat-messages,
#wallpaper-screen, #font-settings-screen, #api-settings-screen, #character-selection-screen,
#world-book-screen, #world-book-editor-screen, #character-phone-inner-screen, #character-phone-page {
    background-color: #000000 !important;
}

/* 3. 主屏幕专属样式 */
#home-screen { background: #111827 !important; }
#desktop-dock { background-color: rgba(55, 65, 81, 0.5); }
.desktop-app-icon .label, .widget-subtext { color: #e5e7eb; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
#profile-widget .profile-info { background: linear-gradient(to bottom, rgba(28, 28, 30, 0.85) 20%, rgba(28, 28, 30, 0)); color: #f9fafb; }
#profile-username, #profile-bio, #profile-location span { color: #f9fafb; }
#profile-sub-username, #profile-location { color: #9ca3af; }
#profile-location { background-color: rgba(255,255,255,0.1); }
.widget-bubble { background-color: rgba(55, 65, 81, 0.9); color: #e5e7eb; }
.widget-bubble::after { border-top-color: rgba(55, 65, 81, 0.9); }

/* 4. 适配所有页面的头部Header */
.header, .qzone-header, .character-phone-header {
    background-color: rgba(28, 28, 30, 0.85) !important;
    border-bottom-color: var(--border-color) !important;
    color: var(--text-primary) !important; 
}

/* 5. 适配所有通用组件 */
#chat-input-area, #chat-list-bottom-nav { background-color: rgba(28, 28, 30, 0.85); border-top-color: var(--border-color); }
#chat-input { background-color: var(--secondary-bg); color: var(--text-primary); }
.modal-content, #custom-modal { background-color: #2c2c2e; }
.modal-header, .modal-footer, .custom-modal-footer, .custom-modal-footer button:first-child { border-color: var(--border-color); }
.form-group input, .form-group select, .form-group textarea { background-color: var(--secondary-bg); color: var(--text-primary); border-color: var(--border-color); }
.list-item, .chat-list-item-swipe-container:not(:last-child), .chat-group-container, .world-book-group-container { border-bottom-color: var(--border-color) !important; }
.chat-group-container:first-of-type { border-top-color: var(--border-color) !important; }
.list-item:hover, .chat-list-item:hover { background-color: #2c2c2e; }

/* 6. 特殊页面深度适配 */
.chat-group-header, .world-book-group-header { background-color: #1c1c1e; }
.chat-list-item-content.pinned { background-color: #3a3a3c; }
#font-preview, #wallpaper-preview, .font-preset-slot { background-color: #1c1c1e !important; border-color: #38383a !important; }

/* 7. 角色手机内部适配 & 全局文字颜色修复 */
#character-phone-container { background-color: #000000; }
.character-phone-frame { background-color: #111; }
#character-chat-history-messages { background-color: #0e0e0e !important; }
.character-chat-bubble.received { background-color: #2c2c2e !important; }
.character-data-item, .character-bank-transaction, .character-cart-item, .character-browser-item {
    background-color: #1c1c1e;
    border-color: #38383a;
}

/* ▼▼▼ 核心修复：把所有这些元素的文字颜色都改为低饱和度的浅灰色 ▼▼▼ */
.character-data-item .title,
.character-data-item .content,
.character-data-item .meta,
.cart-item-price,
.cart-item-info .title,
.character-browser-item .title,
.transaction-details .title,
.transaction-amount,
.character-select-item .name,  /* 修复角色选择列表的名字颜色 */
#character-diary-list .character-data-item .content,
#character-diary-list .character-data-item .content h1,
#character-diary-list .character-data-item .content h2 {
    color: #E0E0E0 !important; /* 使用一个柔和的、不刺眼的白色 */
}

.character-data-item .meta span,
#character-diary-list .character-data-item .meta {
    color: #9E9E9E !important; /* 次要信息使用更暗的灰色 */
}

#character-diary-list .character-data-item {
    background-color: #26211a; /* 夜间模式下的信纸背景色 */
    border-color: #524a3d;
    border-left-color: #9e8a70;
}

`;

            // 把这个新主题添加到数据库的 'themes' 表里
            await db.themes.add({ name: themeName, css: darkModeCss });
            console.log("内置夜间模式已成功创建！");
        } else {
            console.log("内置夜间模式已存在，跳过创建。");
        }
    } catch (error) {
        console.error("检查或创建内置夜间模式时出错:", error);
    }
}
// ▼▼▼ 【全新】聊天记录搜索功能核心函数 ▼▼▼

/**
 * 打开并准备聊天记录搜索界面
 */
function openChatSearchScreen() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 清空旧的搜索条件和结果
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('sender-search-select').innerHTML = '';
    document.getElementById('date-search-input').value = '';
    document.getElementById('chat-search-results-list').innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">输入条件开始搜索</p>';

    // 动态填充“人物”下拉菜单
    const senderSelect = document.getElementById('sender-search-select');
    senderSelect.innerHTML = '<option value="">所有人</option>'; // 默认选项

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    const myOption = document.createElement('option');
    myOption.value = myNickname;
    myOption.textContent = myNickname;
    senderSelect.appendChild(myOption);

    if (chat.isGroup) {
        chat.members.forEach(member => {
            const memberOption = document.createElement('option');
            memberOption.value = member.originalName; // 使用本名进行精确匹配
            memberOption.textContent = member.groupNickname; // 显示群昵称给用户看
            senderSelect.appendChild(memberOption);
        });
    } else {
        const aiOption = document.createElement('option');
        aiOption.value = chat.name;
        aiOption.textContent = chat.name;
        senderSelect.appendChild(aiOption);
    }
    
    // 关闭聊天设置弹窗，并显示搜索界面
    document.getElementById('chat-settings-modal').classList.remove('visible');
    showScreen('chat-search-screen');
}

/**
 * 执行搜索操作
 */
/**
 * 【功能完整版】执行搜索操作
 */
function performChatSearch() {
    const chat = state.chats[state.activeChatId];
    if (!chat) {
        // 如果找不到聊天对象，给用户一个明确的提示
        alert('无法执行搜索，因为没有找到当前聊天。');
        return;
    }

    // 1. 获取所有搜索条件
    const keyword = document.getElementById('keyword-search-input').value.trim();
    const senderValue = document.getElementById('sender-search-select').value;
    const dateValue = document.getElementById('date-search-input').value;

    // 将关键词保存到全局变量，以便在渲染结果时用于高亮
    currentSearchKeyword = keyword;

    if (!keyword && !senderValue && !dateValue) {
        alert('请至少输入一个搜索条件！');
        return;
    }

    // 2. 筛选聊天记录
    console.log(`开始搜索: 关键词='${keyword}', 发言人='${senderValue}', 日期='${dateValue}'`);
    
    const results = chat.history.filter(msg => {
        // 过滤掉系统消息和对用户隐藏的消息
        if (msg.isHidden || msg.role === 'system' || msg.type === 'recalled_message') {
            return false;
        }

        // a. 筛选日期
        if (dateValue) {
            const msgDate = new Date(msg.timestamp).toISOString().split('T')[0];
            if (msgDate !== dateValue) {
                return false;
            }
        }

        // b. 筛选发言人
        if (senderValue) {
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            let msgSenderName = '';
            
            if (msg.role === 'user') {
                msgSenderName = myNickname;
            } else { // AI或群成员的消息
                // 这里我们使用 originalName 来精确匹配，因为群昵称可能会变
                msgSenderName = chat.isGroup ? msg.senderName : chat.name;
            }
            if (msgSenderName !== senderValue) {
                return false;
            }
        }

        // c. 筛选关键词
        if (keyword) {
            let contentText = '';
            // 将所有可能包含文本的内容都转换成字符串进行搜索
            if (typeof msg.content === 'string') {
                contentText = msg.content;
            } else if (typeof msg.content === 'object' && msg.content !== null) {
                // 对于复杂对象，我们可以简单地将它们转为JSON字符串来搜索
                contentText = JSON.stringify(msg.content);
            }
            
            if (!contentText.toLowerCase().includes(keyword.toLowerCase())) {
                return false;
            }
        }

        return true; // 所有条件都满足
    });
    
    console.log(`搜索到 ${results.length} 条结果`);

    // 3. 渲染结果
    renderSearchResults(results);
}


/**
 * 渲染搜索结果列表
 * @param {Array} results - 筛选出的消息数组
 */
function renderSearchResults(results) {
    const listEl = document.getElementById('chat-search-results-list')
;
    listEl.innerHTML = '';
listEl.scrollTop = 0; // 每次渲染前，都将滚动条重置到顶部

    if (results.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">未找到相关记录</p>';
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    // 为了性能，只渲染最新的100条结果
    results.slice(-100).reverse().forEach(msg => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.timestamp = msg.timestamp; // 关键！用于跳转

        let senderName, senderAvatar;
        if (msg.role === 'user') {
            senderName = myNickname;
            senderAvatar = chat.settings.myAvatar;
        } else {
            if (chat.isGroup) {
                senderName = msg.senderName;
                const member = chat.members.find(m => m.originalName === senderName);
                senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
            } else {
                senderName = chat.name;
                senderAvatar = chat.settings.aiAvatar;
            }
        }

        let contentText = '';
        if (msg.type === 'sticker' || (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content))) {
            contentText = '[表情]';
        } else if (msg.type === 'ai_image' || msg.type === 'user_photo' || msg.type === 'realimag' || Array.isArray(msg.content)) {
            contentText = '[图片]';
        } else {
            contentText = String(msg.content);
        }

        item.innerHTML = `
            <img src="${senderAvatar || defaultAvatar}" class="avatar">
            <div class="search-result-info">
                <div class="search-result-meta">
                    <span class="name">${senderName}</span>
                    <span class="timestamp">${formatDateStamp(msg.timestamp)}</span>
                </div>
                <div class="search-result-content">
                    ${highlightText(contentText, currentSearchKeyword)}
                </div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 辅助函数：高亮文本中的关键词
 * @param {string} text - 原始文本
 * @param {string} keyword - 要高亮的关键词
 * @returns {string} - 处理后的HTML字符串
 */
function highlightText(text, keyword) {
    if (!keyword || !text) {
        return text;
    }
    const regex = new RegExp(keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
    return text.replace(regex, `<span class="highlight">$&</span>`);
}

/**
 * 点击搜索结果，跳转到对应的消息位置
 * @param {number} timestamp - 目标消息的时间戳
 */
async function jumpToMessage(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    
    // 1. 切换回聊天界面
    showScreen('chat-interface-screen');
    // 短暂延迟，确保界面已切换
    await new Promise(resolve => setTimeout(resolve, 50));

    // 2. 为了确保能找到消息，我们临时渲染所有历史记录
    const messagesContainer = document.getElementById('chat-messages');
    messagesContainer.innerHTML = ''; // 清空
    chat.history.forEach(msg => {
        // 这里我们用一个简化版的渲染，不处理日期戳，只为了能找到元素
        if (!msg.isHidden) {
             appendMessage(msg, chat, true);
        }
    });

    // 3. 找到目标消息元素并滚动到视图
    const targetMessage = messagesContainer.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);
    if (targetMessage) {
        targetMessage.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // 4. 添加闪烁高亮效果
        targetMessage.classList.add('flash');
        setTimeout(() => {
            targetMessage.classList.remove('flash');
        }, 1500);
    }

    // 5. 等待跳转和动画效果结束后，恢复正常的按需加载模式
    setTimeout(() => {
        renderChatInterface(state.activeChatId);
    }, 1600);
}

// ▲▲▲ 新增函数粘贴结束 ▲▲▲
// ▼▼▼ 把下面这【两段】全新的函数，粘贴到 init() 函数的【正上方】 ▼▼▼

/**
 * 【全新】显示微博主页并渲染数据
 */
async function showWeiboScreen() {
    // 1. 计算关注数
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    let totalNpcCount = 0;
    allSingleChats.forEach(chat => {
        if (chat.npcLibrary && chat.npcLibrary.length > 0) {
            totalNpcCount += chat.npcLibrary.length;
        }
    });
    const followingCount = allSingleChats.length + totalNpcCount;

    // 2. 更新页面上的元素
    // 从你的“动态(QZone)”设置里获取头像和昵称，保持统一
    document.getElementById('weibo-avatar-img').src = state.qzoneSettings.avatar || defaultAvatar;
    document.getElementById('weibo-nickname').textContent = state.qzoneSettings.nickname || '你的昵称';
    document.getElementById('weibo-following-count').textContent = followingCount;

    // 3. 显示微博页面
    showScreen('weibo-screen');
}

// ▼▼▼ 用这个【带有诊断功能的最终修复版】，再次替换旧的 showFollowingList 函数 ▼▼▼
function showFollowingList() {
    // 诊断代码 2: 检查函数是否被成功调用
    console.log("【诊断日志 2】: showFollowingList 函数已成功触发！");

    const modal = document.getElementById('weibo-following-modal');

    // 诊断代码 3: 检查是否能找到弹窗的HTML元素
    console.log("【诊断日志 3】: 正在尝试获取弹窗元素 #weibo-following-modal:", modal);
    if (!modal) {
        alert("诊断错误：在HTML中找不到ID为 'weibo-following-modal' 的弹窗元素！请检查HTML代码。");
        return; // 如果找不到元素，就停止执行
    }

    const listContainer = document.getElementById('weibo-following-list-container');
    listContainer.innerHTML = ''; // 清空旧列表
    
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    if (allSingleChats.length === 0) {
        listContainer.innerHTML = '<p style="text-align:center; color:grey; padding: 20px;">还没有关注任何人哦</p>';
    } else {
        allSingleChats.forEach(chat => {
            const charItem = document.createElement('div');
            charItem.className = 'weibo-following-item';
            charItem.innerHTML = `
                <img src="${chat.settings.aiAvatar || defaultAvatar}" class="weibo-following-avatar">
                <span class="weibo-following-name">${chat.name}</span>
            `;
            listContainer.appendChild(charItem);
            
            if (chat.npcLibrary && chat.npcLibrary.length > 0) {
                chat.npcLibrary.forEach(npc => {
                    const npcItem = document.createElement('div');
                    npcItem.className = 'weibo-following-item';
                    npcItem.style.paddingLeft = '30px';
                    npcItem.innerHTML = `
                         <img src="${npc.avatar || defaultGroupMemberAvatar}" class="weibo-following-avatar">
                         <span class="weibo-following-name">${npc.name} (NPC)</span>
                    `;
                    listContainer.appendChild(npcItem);
                });
            }
        });
    }
    
    // 核心代码：显示模态框
    modal.classList.add('visible');
    console.log("【诊断日志 4】: 已成功为弹窗添加 .visible 类，弹窗现在应该显示了。");
}
// ▲▲▲ 替换结束 ▲▲▲



// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】微博页面功能函数 ▼▼▼

// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼

// ▼▼▼ 把这一整块全新的微博功能函数，粘贴到 init() 函数的上方 ▼▼▼

/**
 * 【微博专属】渲染微博个人主页的所有数据
 */
async function renderWeiboProfile() {
    const settings = state.qzoneSettings || {};
    // 【核心】所有数据都从 weibo... 字段读取！
    document.getElementById('weibo-avatar-img').src = settings.weiboAvatar;
    document.getElementById('weibo-nickname').textContent = settings.weiboNickname;
    document.getElementById('weibo-fans-count').textContent = settings.weiboFansCount;
    document.getElementById('weibo-background-img').src = settings.weiboBackground;
    
    // 动态计算关注数 (这部分不变)
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    let totalNpcCount = 0;
    allSingleChats.forEach(chat => {
        if (chat.npcLibrary && chat.npcLibrary.length > 0) {
            totalNpcCount += chat.npcLibrary.length;
        }
    });
    document.getElementById('weibo-following-count').textContent = allSingleChats.length + totalNpcCount;
    
    // 动态计算微博数
    const postsCount = await db.weiboPosts.where('authorId').equals('user').count();
    document.getElementById('weibo-posts-count').textContent = postsCount;
}

/**
 * 【微博专属】编辑微博头像
 */
async function editWeiboAvatar() {
    const newAvatarUrl = await getNewImageUrl("更换微博头像", state.qzoneSettings.weiboAvatar);
    if (newAvatarUrl) {
        state.qzoneSettings.weiboAvatar = newAvatarUrl; // 只修改微博头像
        await saveQzoneSettings();
        await renderWeiboProfile(); // 用专属函数刷新
    }
}

/**
 * 【微博专属】编辑微博背景图
 */
async function editWeiboBackground() {
    const newBgUrl = await getNewImageUrl("更换微博背景", state.qzoneSettings.weiboBackground);
    if (newBgUrl) {
        state.qzoneSettings.weiboBackground = newBgUrl; // 只修改微博背景
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 【微博专属】编辑微博昵称
 */
async function editWeiboNickname() {
    const newNickname = await showCustomPrompt("编辑微博昵称", "请输入新的昵称", state.qzoneSettings.weiboNickname);
    if (newNickname !== null) {
        state.qzoneSettings.weiboNickname = newNickname.trim() || '你的昵称'; // 只修改微博昵称
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 【微博专属】编辑微博粉丝数
 */
async function editWeiboFansCount() {
    const newFans = await showCustomPrompt("编辑粉丝数", "请输入新的粉丝数", state.qzoneSettings.weiboFansCount, "number");
    if (newFans !== null) {
        state.qzoneSettings.weiboFansCount = newFans.trim() || '0'; // 只修改微博粉丝数
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 通用的图片编辑函数 (本地上传或URL)
 * @param {string} title - 弹窗标题
 * @param {string} currentUrl - 当前的图片URL
 * @returns {Promise<string|null>} - 新的图片URL或null
 */
async function getNewImageUrl(title, currentUrl) {
    const choice = await showChoiceModal(title, [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);

    if (choice === 'local') {
        return await uploadImageLocally();
    } else if (choice === 'url') {
        const url = await showCustomPrompt(title, "请输入新的图片URL", currentUrl, "url");
        if (url && url.trim().startsWith('http')) {
            return url.trim();
        } else if (url !== null) {
            alert("请输入一个有效的URL！");
        }
    }
    return null;
}

/**
 * 编辑微博头像
 */
async function editWeiboAvatar() {
    const newAvatarUrl = await getNewImageUrl("更换头像", state.qzoneSettings.weiboAvatar);
    if (newAvatarUrl) {
        state.qzoneSettings.weiboAvatar = newAvatarUrl;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 编辑微博背景图
 */
async function editWeiboBackground() {
    const newBgUrl = await getNewImageUrl("更换背景图", state.qzoneSettings.weiboBackground);
    if (newBgUrl) {
        state.qzoneSettings.weiboBackground = newBgUrl;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 编辑微博昵称
 */
async function editWeiboNickname() {
    const newNickname = await showCustomPrompt("编辑昵称", "请输入新的微博昵称", state.qzoneSettings.weiboNickname);
    if (newNickname !== null) {
        state.qzoneSettings.weiboNickname = newNickname.trim() || '你的昵称';
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 编辑微博粉丝数
 */
async function editWeiboFansCount() {
    const newFans = await showCustomPrompt("编辑粉丝数", "请输入新的粉丝数", state.qzoneSettings.weiboFansCount, "number");
    if (newFans !== null) {
        state.qzoneSettings.weiboFansCount = newFans.trim() || '0';
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲


// ▼▼▼ 用这个【新版本】替换旧的 switchToWeiboView 函数 ▼▼▼
/**
 * 【全新】切换微博主界面中的不同页面视图
 * @param {string} viewId - 要切换到的视图的ID
 */
function switchToWeiboView(viewId) {
    // 1. 隐藏所有微博页面
    document.querySelectorAll('.weibo-view').forEach(view => {
        view.style.display = 'none'; // 使用 style.display 确保隐藏
    });
    
    // 2. 显示目标页面
    const targetView = document.getElementById(viewId);
    if (targetView) {
        targetView.style.display = 'flex'; // 使用 flex 显示
    }

    // 3. 更新底部导航栏的高亮状态
    document.querySelectorAll('.weibo-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    const targetNavItem = document.querySelector(`.weibo-nav-item[data-view="${viewId}"]`);
    if (targetNavItem) {
        targetNavItem.classList.add('active');
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在这里开始复制 ▼▼▼

/**
 * 【动态专属】打开动态发布/编辑模态框
 * @param {string} mode - 'shuoshuo' 或 'complex'
 */
async function openQZonePublisher(mode) {
    // 1. 重置弹窗状态
    resetCreatePostModal(); 
    const modal = document.getElementById('create-post-modal');
    
    // 2. 设置模式和标题
    modal.dataset.mode = mode; // 关键！标记为动态模式
    document.getElementById('create-post-modal-title').textContent = '发布动态';
    
    // 3. 加载分组列表
    await loadGroupsForVisibility();

    // 3. 根据是“说说”还是“图片动态”，显示/隐藏对应的控件
    if (mode === 'shuoshuo') {
        // 如果是发说说，就隐藏图片相关的所有东西
        modal.querySelector('.post-mode-switcher').style.display = 'none';
        modal.querySelector('#image-mode-content').style.display = 'none';
        modal.querySelector('#text-image-mode-content').style.display = 'none';
        modal.querySelector('#post-public-text').placeholder = '分享新鲜事...';
    } else {
        // 如果是发图片/文字图动态，就确保这些控件是显示的
        modal.querySelector('.post-mode-switcher').style.display = 'flex';
        // 重置display样式，确保元素可见
        modal.querySelector('#image-mode-content').style.display = '';
        modal.querySelector('#text-image-mode-content').style.display = '';
        modal.querySelector('#image-mode-content').classList.add('active'); // 默认显示图片上传
        modal.querySelector('#text-image-mode-content').classList.remove('active');
        modal.querySelector('#post-public-text').placeholder = '分享新鲜事...（非必填的公开文字）';
    }

    // 4. 确保“动态”专属的“评论区可见”开关是显示的
    document.getElementById('post-comments-toggle-group').style.display = 'block';
    
    // 5. 显示弹窗
    modal.classList.add('visible');
}

// ▲▲▲ 复制到这里结束 ▲▲▲
// ▼▼▼ 用下面这块【功能升级版】的代码，完整替换掉你旧的 generateWeiboComments 函数 ▼▼▼

// ▼▼▼ 用下面这块【最终修复版】的代码，完整替换掉你旧的 generateWeiboComments 函数 ▼▼▼

// ▼▼▼ 用下面这块【防爆修复版】的代码，完整替换掉你旧的 generateWeiboComments 函数 ▼▼▼

/**
 * 【防爆修复版】AI生成微博评论的核心函数 (修复了人设过长导致的503错误)
 * @param {number} postId - 需要生成评论的微博ID
 */
async function generateWeiboComments(postId) {
    const post = await db.weiboPosts.get(postId);
    if (!post) {
        alert("错误：找不到这条微博！");
        return;
    }

    await showCustomAlert("请稍候...", "正在召唤网友...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }
    
    let authorPersona = "一个普通用户。"; // 默认人设
    const authorName = post.authorId === 'user' ? (state.qzoneSettings.weiboNickname || '我') : post.authorNickname;
    
    // 如果发帖的是用户
    if (post.authorId === 'user') {
        // 确保至少有一个聊天存在
        if (Object.keys(state.chats).length > 0) {
            const anyChat = Object.values(state.chats)[0];
            if (anyChat && anyChat.settings.myPersona) {
                authorPersona = anyChat.settings.myPersona;
            }
        }
    } 
    // 如果发帖的是AI角色
    else {
        const authorChat = state.chats[post.authorId];
        if (authorChat && authorChat.settings.aiPersona) {
            authorPersona = authorChat.settings.aiPersona;
        }
    }

    // ▼▼▼ 核心修复：对人设字符串进行截断，防止请求体过大！ ▼▼▼
    const truncatedPersona = authorPersona.substring(0, 400);
    // ▲▲▲ 修复结束 ▲▲▲

    const postContent = (post.content || post.hiddenContent || "(图片动态)").substring(0, 200);
    const existingComments = (post.comments || []).slice(-5).map(c => `${c.authorNickname}: ${c.commentText}`).join('\n');

    // 在指令中使用截断后的人设
    const systemPrompt = `
# 任务
你是一个专业的“社交媒体模拟器”。你的任务是根据一个特定角色的“人设”，为他/她发布的一条微博生成一批真实的、符合情景的网友评论。

# 微博情景
- **作者**: ${authorName}
- **作者人设 (你必须严格参考)**: ${truncatedPersona}
- **内容摘要**: ${postContent}...
- **已有评论 (你可以回复他们，也可以发表新观点)**:
${existingComments || "(暂无评论)"}

# 你的任务
1.  仔细阅读并理解“作者人设”，想象一下这样的人在现实生活中会有什么样的粉丝、朋友或路人网友。
2.  根据人设和微博内容，生成5到10条风格各异、口吻真实的评论。评论者的身份可以是粉丝、朋友、路人、甚至是黑粉，但必须符合逻辑。
3.  你的回复【必须且只能】是一个严格的JSON数组，每个对象代表一条评论。

# 格式指令 (必须遵守)
-   发表新评论, 使用格式: \`{"author": "路人甲", "comment": "说得好！"}\`
-   回复已有评论, 使用格式: \`{"author": "热心网友", "comment": "我也这么觉得！", "replyTo": "路人甲"}\`
-   "replyTo" 的值必须是上面“已有评论”中出现过的昵称。

现在，请开始你的表演。
`;

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 0.9,
                    response_format: { type: "json_object" }
                })
            });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API请求失败: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        const newComments = JSON.parse(aiResponseContent);

        if (Array.isArray(newComments) && newComments.length > 0) {
            const postToUpdate = await db.weiboPosts.get(post.id);
            if (!postToUpdate) throw new Error("在数据库中找不到要更新的帖子！");
            
            if (!postToUpdate.comments) postToUpdate.comments = [];
            
            newComments.forEach(comment => {
                if(comment.author && comment.comment) {
                    const newCommentObject = {
                        commentId: 'comment_' + Date.now() + Math.random(),
                        authorNickname: comment.author,
                        commentText: comment.comment,
                        timestamp: Date.now()
                    };
                    if (comment.replyTo) {
                        newCommentObject.replyToNickname = comment.replyTo;
                    }
                    postToUpdate.comments.push(newCommentObject);
                }
            });

            postToUpdate.baseLikesCount = (postToUpdate.baseLikesCount || 0) + Math.floor(Math.random() * newComments.length * 3 + 5);

            await db.weiboPosts.put(postToUpdate);
            
            await renderMyWeiboFeed();
            await renderFollowingWeiboFeed();
            
            alert(`成功生成了 ${newComments.length} 条新评论！`);
        } else {
             alert("AI没有生成有效的评论。");
        }

    } catch (error) {
        console.error("生成微博评论失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}

// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 把这个新函数粘贴到 renderWeiboProfile 函数的上方 ▼▼▼
/**
 * 【全新】删除一条微博评论
 * @param {number} postId - 评论所在的微博ID
 * @param {string} commentId - 要删除的评论的ID
 */
async function deleteWeiboComment(postId, commentId) {
    const post = await db.weiboPosts.get(postId);
    if (!post || !post.comments) return;

    const commentIndex = post.comments.findIndex(c => c.commentId === commentId);
    if (commentIndex === -1) return;
    
    const commentText = post.comments[commentIndex].commentText;

    const confirmed = await showCustomConfirm(
        '删除评论', 
        `确定要删除这条评论吗？\n\n“${commentText.substring(0, 50)}...”`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        post.comments.splice(commentIndex, 1);
        await db.weiboPosts.put(post);
        await renderMyWeiboFeed();
        await renderFollowingWeiboFeed();
        alert("评论已删除。");
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲


/* ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼ */
        async function init() {
            // ▼▼▼ 在 init() 函数的【最开头】，粘贴下面这两行代码 ▼▼▼
            const savedTheme = localStorage.getItem('ephone-theme') || 'light'; // 默认为日间模式
            applyTheme(savedTheme);
            // ▲▲▲ 粘贴结束 ▲▲▲
            // ...你原来的其他 init() 代码...
        }

/* ▼▼▼ 【V2修正版】主屏幕美化预设核心功能函数 ▼▼▼ */

let activeHomePresetId = null; // 用于追踪当前选中的预设ID

/**
 * 启用或禁用预设管理按钮
 */
function toggleHomePresetButtons(isEnabled) {
    document.getElementById('apply-home-preset-btn').disabled = !isEnabled;
    document.getElementById('update-home-preset-btn').disabled = !isEnabled; // <-- 新增这一行
    document.getElementById('rename-home-preset-btn').disabled = !isEnabled;
    document.getElementById('delete-home-preset-btn').disabled = !isEnabled;
    document.getElementById('export-home-preset-btn').disabled = !isEnabled;
}


/**
 * 加载预设到下拉框（修复版 - 保持选中状态）
 */
async function loadHomeScreenPresetsToDropdown() {
    const selector = document.getElementById('home-preset-selector');
    const savedSelection = localStorage.getItem('lastSelectedHomePresetId'); // 保存上次选择
    
    selector.innerHTML = '<option value="">-- 请选择一个预设 --</option>';
    const presets = await db.homeScreenPresets.toArray();
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selector.appendChild(option);
    });
    
    // 恢复上次的选择状态
    if (savedSelection && document.querySelector(`option[value="${savedSelection}"]`)) {
        selector.value = savedSelection;
        activeHomePresetId = parseInt(savedSelection);
        toggleHomePresetButtons(true);
    } else {
        activeHomePresetId = null;
        toggleHomePresetButtons(false);
    }
}

/**
 * 【修复版】当用户从下拉框选择一个预设时
 */
function handleHomePresetSelection() {
    const selector = document.getElementById('home-preset-selector');
    activeHomePresetId = selector.value ? parseInt(selector.value) : null;
    
    // 保存选择状态到localStorage
    if (activeHomePresetId) {
        localStorage.setItem('lastSelectedHomePresetId', activeHomePresetId.toString());
    } else {
        localStorage.removeItem('lastSelectedHomePresetId');
    }
    
    // 只有当用户确实选择了一个预设时，才启用相关按钮
    toggleHomePresetButtons(!!activeHomePresetId);
}

/**
 * 【新】应用当前选中的预设
 */
async function applySelectedHomeScreenPreset() {
    if (!activeHomePresetId) {
        alert("请先从下拉框中选择一个要应用的预设。");
        return;
    }
    const preset = await db.homeScreenPresets.get(activeHomePresetId);
    if (preset && preset.data) {
        state.globalSettings.widgetData = preset.data;

        if (preset.data.wallpaper) {
            state.globalSettings.wallpaper = preset.data.wallpaper;
            applyGlobalWallpaper();
        }

        // 核心：现在这一段代码会自动处理好包括微博在内的所有图标！
        if (preset.data.appIcons) {
            state.globalSettings.appIcons = { ...preset.data.appIcons };
            applyAppIcons();
        }
        
        // 我们不再需要下面这段单独处理微博图标的代码了，可以删掉它！
        /*
        if (preset.data.weiboIcon) {
            document.getElementById('icon-img-weibo').src = preset.data.weiboIcon;
        }
        */
        
        await db.globalSettings.put(state.globalSettings);
        applyWidgetData(); 

        alert(`已成功应用预设: "${preset.name}"！`);
        showScreen('home-screen');
    }
}



/**
 * 保存当前的主屏幕设置为一个新的预设
 */
async function saveCurrentHomeScreenAsPreset() {
    const presetName = await showCustomPrompt("保存预设", "请为这个主屏幕美化方案起个名字：");
    if (!presetName || !presetName.trim()) {
        if (presetName !== null) alert("名字不能为空！");
        return;
    }

    // ▼▼▼ 核心修改在这里 ▼▼▼
    // 在保存之前，先确保 state.globalSettings.appIcons 包含了最新的微博图标
    // 这样所有图标数据就统一了！
    state.globalSettings.appIcons['weibo'] = document.getElementById('icon-img-weibo').src;
    // ▲▲▲ 修改结束 ▲▲▲

    const presetData = {
        'profile-banner-img': document.getElementById('profile-banner-img').src,
        'profile-avatar-img': document.getElementById('profile-avatar-img').src,
        'profile-username': document.getElementById('profile-username').textContent,
        'profile-sub-username': document.getElementById('profile-sub-username').textContent,
        'profile-bio': document.getElementById('profile-bio').textContent,
        'profile-location': document.getElementById('profile-location').innerHTML,
        'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
        'widget-image-1': document.getElementById('widget-image-1').src,
        'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
        'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
        'widget-image-2': document.getElementById('widget-image-2').src,
        'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
        'appIcons': { ...state.globalSettings.appIcons }, // 现在这里就包含了最新的微博图标
        'wallpaper': state.globalSettings.wallpaper
        // 我们不再需要下面这行单独的代码了
        // 'weiboIcon': document.getElementById('icon-img-weibo').src 
    };
    await db.homeScreenPresets.add({ name: presetName.trim(), data: presetData });
    
    // 双重备份：同时保存到localStorage
    try {
        const allPresets = await db.homeScreenPresets.toArray();
        const backupData = JSON.stringify(allPresets);
        localStorage.setItem('homeScreenPresets_backup', backupData);
        console.log('主屏幕预设已备份到localStorage');
    } catch (error) {
        console.error('备份主屏幕预设失败:', error);
    }
    
    await loadHomeScreenPresetsToDropdown();
    alert(`预设 "${presetName.trim()}" 已保存！`);
}

/**
 * 【全新】更新当前选中的预设
 */
async function updateSelectedHomeScreenPreset() {
    if (!activeHomePresetId) {
        alert("请先选择一个要更新的预设。");
        return;
    }

    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    if (!currentPreset) return;

    const confirmed = await showCustomConfirm(
        "确认更新",
        `确定要用当前的主屏幕布局覆盖预设 "${currentPreset.name}" 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // ▼▼▼ 核心修改在这里 ▼▼▼
        // 同样，在更新前，先确保 state 里的数据是最新的
        state.globalSettings.appIcons['weibo'] = document.getElementById('icon-img-weibo').src;
        // ▲▲▲ 修改结束 ▲▲▲

        const presetData = {
            'profile-banner-img': document.getElementById('profile-banner-img').src,
            'profile-avatar-img': document.getElementById('profile-avatar-img').src,
            'profile-username': document.getElementById('profile-username').textContent,
            'profile-sub-username': document.getElementById('profile-sub-username').textContent,
            'profile-bio': document.getElementById('profile-bio').textContent,
            'profile-location': document.getElementById('profile-location').innerHTML,
            'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
            'widget-image-1': document.getElementById('widget-image-1').src,
            'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
            'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
            'widget-image-2': document.getElementById('widget-image-2').src,
            'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
            'appIcons': { ...state.globalSettings.appIcons },
            'wallpaper': state.globalSettings.wallpaper
            // 单独的 weiboIcon 也不再需要了
        };

        await db.homeScreenPresets.update(activeHomePresetId, { data: presetData });
        
        await showCustomAlert('成功', `预设 "${currentPreset.name}" 已更新！`);
    }
}




/**
 * 重命名选中的预设
 */
async function renameSelectedHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    const newName = await showCustomPrompt("重命名", "请输入新的名称：", currentPreset.name);
    if (newName && newName.trim()) {
        await db.homeScreenPresets.update(activeHomePresetId, { name: newName.trim() });
        await loadHomeScreenPresetsToDropdown();
        document.getElementById('home-preset-selector').value = activeHomePresetId;
        alert("重命名成功！");
    }
}

/**
 * 删除选中的预设
 */
async function deleteSelectedHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${currentPreset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.homeScreenPresets.delete(activeHomePresetId);
        await loadHomeScreenPresetsToDropdown(); // 这会自动重置选择并禁用按钮
        alert("预设已删除。");
    }
}

/**
 * 【全新】导出选中的预设
 */
async function exportHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const preset = await db.homeScreenPresets.get(activeHomePresetId);
    const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${preset.name}-HomeScreen.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 【全新】导入预设文件
 */
function importHomeScreenPreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            // 简单验证一下文件内容是不是我们需要的格式
            if (data.name && data.data) {
                await db.homeScreenPresets.add({ name: `${data.name} (导入)`, data: data.data });
                await loadHomeScreenPresetsToDropdown();
                alert(`预设 "${data.name}" 导入成功！`);
            } else {
                alert("导入失败：文件格式不正确。");
            }
        } catch (error) {
            alert(`导入失败：文件解析错误。${error.message}`);
        }
    };
    reader.readAsText(file);
}
/* ▲▲▲ 新功能函数粘贴结束 ▲▲▲ */



        async function init() {

    // ▼▼▼ 在 init() 函数的【最开头】，粘贴下面这两行代码 ▼▼▼
    const savedTheme = localStorage.getItem('ephone-theme') || 'light'; // 默认为日间模式
    applyTheme(savedTheme);
    // ▲▲▲ 粘贴结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲


    // ▼▼▼ 修改这两行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
    // ▲▲▲ 修改结束 ▲▲▲

            window.showScreen = showScreen;
            window.renderChatListProxy = renderChatList;
            window.renderApiSettingsProxy = renderApiSettings;
            window.renderWallpaperScreenProxy = renderWallpaperScreen;
            window.renderWorldBookScreenProxy = renderWorldBookScreen;
            window.createMessageElement = createMessageElement;
            window.appendMessage = appendMessage;

            await loadAllDataFromDB();
            await loadAllFontPresetsOnStartup(); // <---- 在这里添加这一行新代码
            await addDefaultDarkModeThemeIfNeeded();
            applyWidgetData();
            
            // 修复：检查并恢复丢失的预设数据
            await checkAndRestorePresetData();
            
            // 修复：在页面加载时初始化气泡样式预设
            if (typeof renderBubblePresetSelector === 'function' && state.bubbleStylePresets) {
                renderBubblePresetSelector();
                console.log('气泡样式预设已初始化，当前预设数量:', state.bubbleStylePresets.length);
            }
            
            // 初始化贴纸面板（确保数据加载后贴纸能正确显示）
            if (typeof renderStickerPanel === 'function') {
                renderStickerPanel();
                console.log('贴纸面板已初始化，当前贴纸数量:', state.userStickers ? state.userStickers.length : 0);
            }

            // 初始化未读动态计数
            const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
            updateUnreadIndicator(storedCount);
            
            // ▲▲▲ 代码添加结束 ▲▲▲

            if (state.globalSettings && state.globalSettings.fontUrl) {
                applyCustomFont(state.globalSettings.fontUrl);
            }

    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    // 【核心修复】初始化时，自动加载并应用已保存的主题
    if (state.globalSettings.activeThemeId) {
        const activeTheme = await db.themes.get(state.globalSettings.activeThemeId);
        if (activeTheme) {
            console.log(`正在应用已保存的主题: "${activeTheme.name}"`);
            applyThemeCss(activeTheme.css);
        }
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

            updateClock();
            setInterval(updateClock, 1000 * 30);
            applyGlobalWallpaper();
            initBatteryManager(); 

applyAppIcons();

    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    initDraggableLyricsBar(); // 初始化悬浮歌词栏的拖动功能
    // ▲▲▲ 添加结束 ▲▲▲

            // ==========================================================
            // --- 各种事件监听器 ---
            // ==========================================================
            // ▼▼▼ 在 init() 函数的事件监听器区域末尾，添加下面这行代码 ▼▼▼
// ▼▼▼ 用这块新代码，替换旧的 weibo-screen 事件监听器 ▼▼▼
            // ▼▼▼ 【全新】长期记忆功能事件监听器 ▼▼▼
            // 聊天界面顶部新按钮 -> 打开全屏页面
            document.getElementById('open-memory-screen-btn').addEventListener('click', openLongTermMemoryScreen);
            
            // 长期记忆页面返回按钮 -> 返回聊天界面
            document.getElementById('memory-screen-back-btn').addEventListener('click', () => {
                showScreen('chat-interface-screen');
            });
            
            // 长期记忆页面顶部"+"按钮 -> 手动添加
            document.getElementById('add-manual-memory-btn-header').addEventListener('click', handleAddManualMemory);
            
            // 长期记忆页面顶部"总结"按钮 -> 手动总结
            document.getElementById('summarize-recent-btn-header').addEventListener('click', handleManualSummary);
            
            // 长期记忆页面顶部"精炼"按钮 -> 精炼现有记忆
            document.getElementById('refine-memory-btn-header').addEventListener('click', () => {
                if(state.activeChatId) {
                    summarizeExistingLongTermMemory(state.activeChatId);
                }
            });

            // 长期记忆列表的编辑和删除按钮事件委托
            document.getElementById('memory-list-container').addEventListener('click', (e) => {
                const editBtn = e.target.closest('.edit-memory-btn');
                if (editBtn) {
                    handleEditMemory(editBtn.dataset.authorId, parseInt(editBtn.dataset.memoryTimestamp));
                    return;
                }
                const deleteBtn = e.target.closest('.delete-memory-btn');
                if (deleteBtn) {
                    handleDeleteMemory(deleteBtn.dataset.authorId, parseInt(deleteBtn.dataset.memoryTimestamp));
                    return;
                }
            });
            // ▲▲▲ 长期记忆功能事件监听器结束 ▲▲▲

            // ▼▼▼ 【全新】"查角色手机"功能事件监听器 ▼▼▼

// 1. 绑定主屏幕上的"查手机"APP图标
//    【核心修复】我们现在用 JS 来绑定事件，而不是用 HTML 的 onclick
document.getElementById('check-phone-btn').addEventListener('click', openCharacterSelectionScreen);

// 2. 角色选择列表的点击事件 (事件委托)
document.getElementById('character-selection-list').addEventListener('click', (e) => {
    const item = e.target.closest('.character-select-item');
    if (item && item.dataset.chatId) {
        openCharacterPhone(item.dataset.chatId);
    }
});

// 3. 角色手机顶部的“刷新”和“清空”按钮
document.getElementById('generate-character-data-btn').addEventListener('click', generateCharacterPhoneData);
document.getElementById('clear-character-data-btn').addEventListener('click', clearCharacterPhoneData);

// ▲▲▲ 事件监听器添加结束 ▲▲▲
// ▼▼▼ 【V3最终美化版】主屏幕预设功能事件绑定 ▼▼▼
document.getElementById('home-preset-selector').addEventListener('change', handleHomePresetSelection);
document.getElementById('apply-home-preset-btn').addEventListener('click', applySelectedHomeScreenPreset);
// 【核心修改】这里按钮的ID变了
document.getElementById('save-home-preset-btn').addEventListener('click', saveCurrentHomeScreenAsPreset); 
document.getElementById('update-home-preset-btn').addEventListener('click', updateSelectedHomeScreenPreset); // <-- 新增这一行
document.getElementById('rename-home-preset-btn').addEventListener('click', renameSelectedHomeScreenPreset);
document.getElementById('delete-home-preset-btn').addEventListener('click', deleteSelectedHomeScreenPreset);
document.getElementById('export-home-preset-btn').addEventListener('click', exportHomeScreenPreset);
document.getElementById('import-home-preset-btn').addEventListener('click', () => document.getElementById('import-home-preset-input').click());
document.getElementById('import-home-preset-input').addEventListener('change', (e) => {
    importHomeScreenPreset(e.target.files[0]);
    e.target.value = null;
});

            document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);
// ▼▼▼ 【全新】聊天记录搜索功能事件绑定 ▼▼▼
document.getElementById('search-chat-btn').addEventListener('click', openChatSearchScreen);

document.getElementById('search-back-btn').addEventListener('click', () => {
    // 返回时，重新打开聊天设置弹窗
    showScreen('chat-interface-screen');
    document.getElementById('chat-settings-btn').click();
});

document.getElementById('perform-search-btn').addEventListener('click', performChatSearch);

// 使用事件委托来处理所有搜索结果的点击
document.getElementById('chat-search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.timestamp) {
        jumpToMessage(parseInt(item.dataset.timestamp));
    }
});
// ▲▲▲ 新事件绑定结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这行新代码 ▼▼▼

document.getElementById('create-weibo-post-btn').addEventListener('click', openWeiboPublisherClean);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域末尾，粘贴下面这行新代码 ▼▼▼
document.getElementById('delete-expired-songs-btn').addEventListener('click', deleteExpiredSearchedSongs);
// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这整块新代码 ▼▼▼

// ▼▼▼ 用这块新代码替换 ▼▼▼
// --- 微博热搜与广场功能事件绑定 ---

// 1. 绑定热搜页面的“生成”按钮
document.getElementById('generate-hot-search-btn').addEventListener('click', generateHotSearch);

// 2. 【核心修改】现在，广场页面的“生成”按钮也调用同一个函数！
document.getElementById('generate-plaza-feed-btn').addEventListener('click', generateHotSearch);
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这整块新代码 ▼▼▼

// --- 微博热搜与广场功能事件绑定 ---

// 1. 绑定热搜详情页的“返回”按钮
document.getElementById('back-from-hottopic-btn').addEventListener('click', () => {
    switchToWeiboView('weibo-hot-search-view');
});

// 2. 绑定热搜详情页的“换一批”按钮
document.getElementById('refresh-hottopic-feed-btn').addEventListener('click', () => {
    if (currentHotTopic) {
        generateHotSearchFeed(currentHotTopic);
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲


// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 【全新】心声历史记录删除功能事件绑定 ▼▼▼
document.getElementById('clear-all-history-btn').addEventListener('click', clearAllInnerVoiceHistory);

// 使用事件委托处理单条删除
document.getElementById('inner-voice-history-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('history-item-delete-btn')) {
        const timestamp = parseInt(e.target.dataset.timestamp);
        if (!isNaN(timestamp)) {
            deleteSingleInnerVoice(timestamp);
        }
    }
});
// ▲▲▲ 心声历史删除事件绑定结束 ▲▲▲

 // ▼▼▼ 这是我们新加的导入功能事件监听 ▼▼▼
        document.getElementById('import-character-card-btn').addEventListener('click', () => {
            // 点击我们的新按钮时，就去触发那个隐藏的文件选择框
            document.getElementById('character-card-input').click();
        });

        document.getElementById('character-card-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                // 当用户选择了文件后，调用我们的总处理函数
                handleCharacterImport(file);
            }
            // 清空选择，这样用户下次还能选择同一个文件
            event.target.value = null; 
        });
        // ▲▲▲ 新事件监听结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域，粘贴这行新代码 ▼▼▼
document.getElementById('phone-screen').addEventListener('click', unlockAudioContext, { once: true });
// ▲▲▲ 新代码粘贴结束 ▲▲▲
            document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
            document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
            
            // URL输入弹窗事件监听器
            document.getElementById('url-input-modal-cancel').addEventListener('click', hideUrlInputModal);
            document.getElementById('url-input-modal-confirm').addEventListener('click', confirmUrlInput);
            document.getElementById('url-input-modal-overlay').addEventListener('click', (e) => { 
                if (e.target === document.getElementById('url-input-modal-overlay')) hideUrlInputModal(); 
            });
            // 支持键盘操作
            document.getElementById('url-input-field').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    confirmUrlInput();
                } else if (e.key === 'Escape') {
                    hideUrlInputModal();
                }
            });
            document.getElementById('export-data-btn').addEventListener('click', exportBackup);
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
            document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));
            document.getElementById('back-to-list-btn').addEventListener('click', () => { 

    // ▼▼▼ 修改这两行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
    // ▲▲▲ 修改结束 ▲▲▲

exitSelectionMode(); state.activeChatId = null;
// 【心声功能】返回列表时，隐藏心形按钮
document.getElementById('char-heart-btn').style.display = 'none';
 showScreen('chat-list-screen'); });
            // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼
            // 为歌曲封面/歌词区域绑定点击切换事件
            document.getElementById('music-display-area').addEventListener('click', () => {
                const displayArea = document.getElementById('music-display-area');
                // 直接切换 .show-lyrics 这个类，CSS会自动处理显示/隐藏
                displayArea.classList.toggle('show-lyrics');
            });
            // ▲▲▲ 新代码粘贴结束 ▲▲▲

                        document.getElementById('add-chat-btn').addEventListener('click', async () => { 
                const name = await showCustomPrompt('创建新聊天', '请输入Ta的名字'); 
                if (name && name.trim()) { 
                    const newChatId = 'chat_' + Date.now(); 
                    
                    // ▼▼▼ 从这里开始替换 ▼▼▼
                    const newChat = { 
                        id: newChatId, 
                        name: name.trim(), 
                        isGroup: false,
                        isPinned: false,
                        // 新增：为角色对象添加 npcLibrary 数组，用于存放专属NPC
                        npcLibrary: [], 
                        relationship: {
                            status: 'friend',
                            blockedTimestamp: null,
                            applicationReason: ''
                        },
                        status: {
                            text: '在线',
                            lastUpdate: Date.now(),
                            isBusy: false 
                        },
                        settings: { 
                            aiPersona: '你是谁呀。', 
                            myPersona: '我是谁呀。', 
                            maxMemory: 10, 
                            aiAvatar: defaultAvatar, 
                            myAvatar: defaultAvatar, 
                            background: '', 
                            theme: 'default', 
                            fontSize: 13, 
                            customCss: '',
                            linkedWorldBookIds: [], 
                            aiAvatarLibrary: [],
                        }, 
                        history: [], 
                        musicData: { totalTime: 0 },
                        characterPhoneData: {
                            lastGenerated: null,
                            chats: {},
                            shoppingCart: [],
                            memos: [],
                            browserHistory: [],
                            photoAlbum: [],
                            bank: { balance: 0, transactions: [] },
                            trajectory: [],
                            appUsage: [],
                            diary: []
                        }
                    };
// ▲▲▲ 替换到这里结束 ▲▲▲


                    state.chats[newChatId] = newChat; 
                    await db.chats.put(newChat); 
                    renderChatList(); 
                } 
            });

            // ▼▼▼ 【修正】创建群聊按钮现在打开联系人选择器 ▼▼▼
document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
// ▲▲▲ 替换结束 ▲▲▲                      
            document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
            document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

            document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
            document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
            document.getElementById('music-return-btn').addEventListener('click', returnToChat);
            document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
            document.getElementById('music-next-btn').addEventListener('click', playNext);
            document.getElementById('music-prev-btn').addEventListener('click', playPrev);
            document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
            document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
            document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
            document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
            document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
            
            // ▼▼▼ 世界书分组折叠事件委托 ▼▼▼
            document.addEventListener('click', (e) => {
                if (e.target.closest('.world-book-group-header')) {
                    const header = e.target.closest('.world-book-group-header');
                    header.classList.toggle('collapsed');
                    const content = header.nextElementSibling;
                    if (content) {
                        content.classList.toggle('collapsed');
                    }
                }
            });
            // ▲▲▲ 世界书分组折叠事件委托结束 ▲▲▲
            document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
            // ▼▼▼ 【全新】BGM搜索功能事件绑定 ▼▼▼
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

document.getElementById('search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.songJson) {
        const songData = JSON.parse(item.dataset.songJson);
        handleSearchResultClick(songData);
    }
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲

            audioPlayer.addEventListener('ended', playNext);

            const chatInput = document.getElementById('chat-input');
            // ▼▼▼ 找到 id="send-btn" 的 click 事件监听器 ▼▼▼
document.getElementById('send-btn').addEventListener('click', async () => { 
    const content = chatInput.value.trim(); 
    if (!content || !state.activeChatId) return; 
    
    const chat = state.chats[state.activeChatId]; 
    
    // --- 【核心修改】在这里添加 ---
    const msg = { 
        role: 'user', 
        content, 
        timestamp: Date.now(),
        offlineMode: chat.settings.offlineMode || false // 记录发送时的模式状态
    };

    // 检查当前是否处于引用回复模式
    if (currentReplyContext) {
        msg.quote = currentReplyContext; // 将引用信息附加到消息对象上
    }
    // --- 【修改结束】 ---
    
    chat.history.push(msg); 
    await db.chats.put(chat); 
    appendMessage(msg, chat); 
    renderChatList(); 
    chatInput.value = ''; 
    chatInput.style.height = 'auto'; 
    chatInput.focus(); 
    
    // --- 【核心修改】发送后，取消引用模式 ---
    cancelReplyMode(); 
});
            document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
            chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });

            document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
            // ▼▼▼ 用这整块代码，替换旧的 save-wallpaper-btn 事件监听器 ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    let changesMade = false;

    // 保存壁纸
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
        changesMade = true;
    }

    // 保存锁屏壁纸 (新增)
    if (newLockscreenWallpaperBase64) {
        state.globalSettings.lockscreenWallpaper = newLockscreenWallpaperBase64;
        changesMade = true;
    }
    // 保存密码 (新增)
    const newPassword = document.getElementById('password-set-input').value;
    state.globalSettings.password = newPassword;

state.globalSettings.ringtoneUrl = document.getElementById('ringtone-url-input').value.trim();

    // ▼▼▼ 在这里添加新代码 ▼▼▼
    // 记录当前激活的主题ID
    const activeThemeSelector = document.getElementById('theme-selector');
    if (activeThemeSelector.value) {
        state.globalSettings.activeThemeId = parseInt(activeThemeSelector.value);
    } else {
        // 如果用户选择的是“-- 选择方案或新建 --”，就清空记录
        state.globalSettings.activeThemeId = null;
    }
    // ▲▲▲ 新代码添加结束 ▲▲▲
        // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
    // 【核心修复】在点击保存时，明确地读取开关的当前状态并保存
    const isLockEnabled = document.getElementById('enable-lock-screen-toggle').checked;
    state.globalSettings.enableLockScreen = isLockEnabled;
    localStorage.setItem('lockScreenEnabled', isLockEnabled); // 同时也保存到 localStorage
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

    await db.globalSettings.put(state.globalSettings);

    // 应用所有更改
    if (changesMade) {
        applyGlobalWallpaper();        applyLockscreenWallpaper(); // <-- 新增
        newWallpaperBase64 = null;        newLockscreenWallpaperBase64 = null; // <-- 新增
    }
    applyAppIcons(); // 重新应用所有图标

    alert('外观设置已保存并应用！');
    showScreen('home-screen');
});
// ▲▲▲ 替换结束 ▲▲▲
            document.getElementById('save-api-settings-btn').addEventListener('click', async () => { 

// ▼▼▼ 在这里粘贴新代码 ▼▼▼
const proxyUrlToCheck = document.getElementById('proxy-url').value.trim();
const isBlocked = BLOCKED_API_SITES.some(blockedDomain => proxyUrlToCheck.includes(blockedDomain));

if (isBlocked) {
    alert('错误：该 API 站点已被禁用，无法使用。');
    return; // 阻止保存
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim(); state.apiConfig.apiKey = document.getElementById('api-key').value.trim(); state.apiConfig.model = document.getElementById('model-select').value; await db.apiConfig.put(state.apiConfig); 

// 保存Minimax语音配置到localStorage
const minimaxGroupId = document.getElementById('minimax-group-id').value.trim();
const minimaxApiKey = document.getElementById('minimax-api-key').value.trim();
const minimaxVoiceModel = document.getElementById('minimax-voice-model').value.trim();
localStorage.setItem('minimaxGroupId', minimaxGroupId);
localStorage.setItem('minimaxApiKey', minimaxApiKey);
localStorage.setItem('minimaxVoiceModel', minimaxVoiceModel);

// 在 'save-api-settings-btn' 的 click 事件监听器内部
// await db.apiConfig.put(state.apiConfig); 这行之后

// ▼▼▼ 将之前那段保存后台活动设置的逻辑，替换为下面这个增强版 ▼▼▼

const backgroundSwitch = document.getElementById('background-activity-switch');
const intervalInput = document.getElementById('background-interval-input');
const newEnableState = backgroundSwitch.checked;
const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

// 只有在用户“从关到开”时，才弹出警告
if (newEnableState && !oldEnableState) {
    const userConfirmed = confirm(
        "【高费用警告】\n\n" +
        "您正在启用“后台角色活动”功能。\n\n" +
        "这会使您的AI角色们在您不和他们聊天时，也能“独立思考”并主动给您发消息或进行社交互动，极大地增强沉浸感。\n\n" +
        "但请注意：\n" +
        "这会【在后台自动、定期地调用API】，即使您不进行任何操作。根据您的角色数量和检测间隔，这可能会导致您的API费用显著增加。\n\n" +
        "您确定要开启吗？"
    );

    if (!userConfirmed) {
        backgroundSwitch.checked = false; // 用户取消，把开关拨回去
        return; // 阻止后续逻辑
    }
}

state.globalSettings.enableBackgroundActivity = newEnableState;
state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;

// 保存 RealImag 开关状态
state.globalSettings.enableRealImag = document.getElementById('realimag-switch').checked;

await db.globalSettings.put(state.globalSettings);

// 动态启动或停止模拟器
stopBackgroundSimulation();
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log(`后台活动模拟已启动，间隔: ${state.globalSettings.backgroundActivityInterval}秒`);
} else {
    console.log("后台活动模拟已停止。");
}
// ▲▲▲ 替换结束 ▲▲▲

// 保存智谱语音识别配置到localStorage
saveZhipuSpeechSettings();

// 保存NovelAI配置到localStorage
const novelaiEnabled = document.getElementById('novelai-switch').checked;
const novelaiModel = document.getElementById('novelai-model').value;
const novelaiApiKey = document.getElementById('novelai-api-key').value.trim();
localStorage.setItem('novelai-enabled', novelaiEnabled);
localStorage.setItem('novelai-model', novelaiModel);
localStorage.setItem('novelai-api-key', novelaiApiKey);

alert('API设置已保存!'); });

                    // gemini 密钥聚焦的时候显示明文
        const ApiKeyInput = document.getElementById('api-key')
        ApiKeyInput.addEventListener('focus', (e) => {
            e.target.setAttribute('type', 'text')
        })
        ApiKeyInput.addEventListener('blur', (e) => {
            e.target.setAttribute('type', 'password')
        })


        document.getElementById('fetch-models-btn').addEventListener('click', async () => {
            const url = document.getElementById('proxy-url').value.trim();
            const key = document.getElementById('api-key').value.trim();
            if (!url || !key) return alert('请先填写反代地址和密钥');
            try {

                let  isGemini = url === GEMINI_API_URL;
                const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`,isGemini ? undefined : {headers: {'Authorization': `Bearer ${key}`}});
                if (!response.ok) throw new Error('无法获取模型列表');
                const data = await response.json();
                let models = isGemini ? data.models : data.data;
                if(isGemini){
                    models = models.map((model)=>{
                        const parts = model.name.split('/');
                        return {
                            id:parts.length > 1 ? parts[1] : model.name
                        }
                    })
                }
                const modelSelect = document.getElementById('model-select');
                modelSelect.innerHTML = '';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    if (model.id === state.apiConfig.model) option.selected = true;
                    modelSelect.appendChild(option);
                });
                alert('模型列表已更新');
            } catch (error) {
                alert(`拉取模型失败: ${error.message}`);
            }
        });

        // ▼▼▼ 智谱API Key显示/隐藏功能 ▼▼▼
        document.getElementById('zhipu-api-key-toggle').addEventListener('click', () => {
            const input = document.getElementById('zhipu-speech-api-key');
            if (input.type === 'password') {
                input.type = 'text';
                } else {
                input.type = 'password';
            }
        });

        // ▼▼▼ 智谱AI模型配置 - 已改为手动输入，无需拉取 ▼▼▼
        // 注意：智谱AI的 /v4/chat/completions 是对话端点（POST），不是模型列表端点（GET）
        // 因此改为用户直接输入模型名称（如：GLM-4-Voice）

        // ▼▼▼ Minimax语音模型拉取功能 ▼▼▼
        document.getElementById('fetch-voice-models-btn').addEventListener('click', async () => {
            const groupId = document.getElementById('minimax-group-id').value.trim();
            const apiKey = document.getElementById('minimax-api-key').value.trim();
            
            if (!groupId || !apiKey) {
                alert('请先填写 Minimax Group ID 和 API Key');
                return;
            }
            
            const button = document.getElementById('fetch-voice-models-btn');
            const originalText = button.textContent;
            button.textContent = '加载中...';
            button.disabled = true;
            
            try {
                // 由于官方API端点可能有变化，先提供预设的官方语音模型
                // 基于Minimax API实际支持的语音模型（移除不支持的模型）
                const officialModels = [
                    { voice_id: 'speech-01', voice_name: 'Speech-01 ⭐', description: '标准语音模型，稳定可靠，推荐使用' },
                    { voice_id: 'speech-02', voice_name: 'Speech-02', description: '改进版语音模型，质量更佳' }
                ];
                
                console.log('加载Minimax官方语音模型列表:', officialModels);
                
                // 更新语音模型下拉框
                const voiceModelSelect = document.getElementById('minimax-voice-model');
                voiceModelSelect.innerHTML = '<option value="">选择语音模型</option>';
                
                officialModels.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.voice_id;
                    option.textContent = `${voice.voice_name} - ${voice.description}`;
                    voiceModelSelect.appendChild(option);
                });
                
                // 恢复之前选择的模型
                const savedModel = localStorage.getItem('minimaxVoiceModel');
                if (savedModel) {
                    voiceModelSelect.value = savedModel;
                }
                
                alert(`✨ 成功加载 ${officialModels.length} 个官方语音模型！

🎯 推荐选择：
• Speech-02 HD - 最新高清模型，支持零样本语音克隆
• Speech-02 - 平衡版本，功能强大
• Speech-01 HD - 稳定的高清版本

💡 这些是Minimax官方的语音模型，可直接使用！`);
                
            } catch (error) {
                console.error('加载语音模型失败:', error);
                alert(`加载语音模型失败: ${error.message}`);
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        });
        // ▲▲▲ Minimax语音模型拉取功能结束 ▲▲▲
        
        // ▼▼▼ 语音缓存管理功能 ▼▼▼
        
        // 更新缓存状态显示
        function updateCacheStatus() {
            if (!window.VoiceStorageAPI) {
                document.getElementById('cache-status').innerHTML = '缓存系统未加载';
                return;
            }
            
            const totalSize = window.VoiceStorageAPI.getCurrentCacheSize();
            const maxSize = window.VoiceStorageAPI.MAX_CACHE_SIZE;
            const cacheCount = Object.keys(localStorage).filter(key => key.startsWith('voice_')).length;
            
            document.getElementById('cache-status').innerHTML = `
                <div>缓存项目: <strong>${cacheCount}</strong> 个</div>
                <div>使用空间: <strong>${(totalSize / 1024 / 1024).toFixed(2)}MB</strong> / ${(maxSize / 1024 / 1024).toFixed(0)}MB</div>
                <div>使用率: <strong>${((totalSize / maxSize) * 100).toFixed(1)}%</strong></div>
            `;
        }
        
        // 刷新缓存状态
        document.getElementById('refresh-cache-status').addEventListener('click', () => {
            updateCacheStatus();
        });
        
        // 清理过期缓存
        document.getElementById('clean-expired-cache').addEventListener('click', async () => {
            if (!window.VoiceStorageAPI) {
                alert('缓存系统未加载');
                return;
            }
            
            try {
                const cleaned = window.VoiceStorageAPI.cleanExpiredCache();
                updateCacheStatus();
                alert(`成功清理 ${cleaned} 个过期缓存项`);
            } catch (error) {
                alert(`清理失败: ${error.message}`);
            }
        });
        
        // 清理旧缓存（释放25%空间）
        document.getElementById('clean-old-cache').addEventListener('click', async () => {
            if (!window.VoiceStorageAPI) {
                alert('缓存系统未加载');
                return;
            }
            
            const confirmed = confirm('确定要清理旧的语音缓存吗？这将删除最早缓存的语音文件以释放存储空间。');
            if (!confirmed) return;
            
            try {
                const targetSize = window.VoiceStorageAPI.getCurrentCacheSize() * 0.25; // 清理25%
                const freedSize = window.VoiceStorageAPI.cleanOldestCache(targetSize);
                updateCacheStatus();
                alert(`成功释放 ${(freedSize / 1024 / 1024).toFixed(2)}MB 存储空间`);
            } catch (error) {
                alert(`清理失败: ${error.message}`);
            }
        });
        
        // 清空所有缓存
        document.getElementById('clear-all-cache').addEventListener('click', async () => {
            const confirmed = confirm('⚠️ 确定要清空所有语音缓存吗？\\n\\n这将删除所有已缓存的语音文件（被收藏的除外），之后播放语音需要重新下载。\\n\\n此操作不可撤销！');
            if (!confirmed) return;
            
            const doubleConfirmed = confirm('请再次确认：真的要删除所有语音缓存吗？\\n\\n（注意：被收藏的语音消息缓存将被保留）');
            if (!doubleConfirmed) return;
            
            try {
                if (window.VoiceStorageAPI) {
                    const result = await window.VoiceStorageAPI.clearAllVoiceCache();
                    updateCacheStatus();
                    
                    let message = `成功清空语音缓存，共删除 ${result.count} 个缓存项`;
                    if (result.kept > 0) {
                        message += `\\n\\n已保留 ${result.kept} 个被收藏的语音缓存`;
                    }
                    alert(message);
                } else {
                    alert('语音缓存系统未初始化');
                }
            } catch (error) {
                alert(`清空失败: ${error.message}`);
            }
        });
        
        // 页面加载时更新缓存状态
        setTimeout(() => {
            updateCacheStatus();
        }, 1000);
        
        // ▲▲▲ 语音缓存管理功能结束 ▲▲▲
            // 旧的添加世界书按钮已移除，新的按钮事件在下面定义
            document.getElementById('save-world-book-btn').addEventListener('click', async () => { if (!editingWorldBookId) return; const book = state.worldBooks.find(wb => wb.id === editingWorldBookId); if (book) { const newName = document.getElementById('world-book-name-input').value.trim(); if (!newName) { alert('书名不能为空！'); return; } book.name = newName; book.content = document.getElementById('world-book-content-input').value; 

        // ▼▼▼ 【核心修改】在这里保存分类ID ▼▼▼
        const categoryId = document.getElementById('world-book-category-select').value;
        // 如果选择了“未分类”，存入 null；否则存入数字ID
        book.categoryId = categoryId ? parseInt(categoryId) : null; 
        // ▲▲▲ 修改结束 ▲▲▲

        await db.worldBooks.put(book);
        document.getElementById('world-book-editor-title').textContent = newName;
        editingWorldBookId = null;
        await renderWorldBookScreen();
        showScreen('world-book-screen');
    }
});
            document.getElementById('chat-messages').addEventListener('click', (e) => { const aiImage = e.target.closest('.ai-generated-image'); if (aiImage) { const description = aiImage.dataset.description; if (description) showCustomAlert('照片描述', description); return; }  });
            
            const chatSettingsModal = document.getElementById('chat-settings-modal');
            const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');

function updateWorldBookSelectionDisplay() { const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked'); const displayText = document.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- 点击选择 --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `已选择 ${checkedBoxes.length} 项`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } }        
            
            worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
            document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
            window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });

            // ▼▼▼ 群聊记忆选择界面事件监听器 ▼▼▼
            const groupMemorySelectBox = document.getElementById('group-memory-select-box');
            const groupMemoryCheckboxesContainer = document.getElementById('group-memory-checkboxes-container');
            
            groupMemorySelectBox.addEventListener('click', (e) => {
                e.stopPropagation();
                groupMemoryCheckboxesContainer.classList.toggle('visible');
                groupMemorySelectBox.classList.toggle('expanded');
            });
            
            document.getElementById('group-memory-checkboxes-container').addEventListener('change', updateGroupMemorySelectionDisplay);
            
            window.addEventListener('click', (e) => {
                if (!document.getElementById('group-memory-settings-group').contains(e.target)) {
                    groupMemoryCheckboxesContainer.classList.remove('visible');
                    groupMemorySelectBox.classList.remove('expanded');
                }
            });
            // ▲▲▲ 群聊记忆选择界面事件监听器结束 ▲▲▲

// ▼▼▼ 群聊记忆功能相关函数 ▼▼▼
function loadGroupMemorySettings(chat) {
    const container = document.getElementById('group-memory-checkboxes-container');
    container.innerHTML = '';
    
    // 获取所有群聊
    const groupChats = Object.values(state.chats).filter(c => c.isGroup);
    const selectedGroupIds = new Set(chat.settings.selectedGroupChats || []);
    
    if (groupChats.length === 0) {
        container.innerHTML = '<p style="text-align:center; color:#999; padding:10px;">暂无群聊可选择</p>';
        return;
    }
    
    groupChats.forEach(groupChat => {
        const label = document.createElement('label');
        label.innerHTML = `
            <input type="checkbox" value="${groupChat.id}" ${selectedGroupIds.has(groupChat.id) ? 'checked' : ''}>
            ${groupChat.name}
        `;
        container.appendChild(label);
    });
    
    // 更新显示文本
    updateGroupMemorySelectionDisplay();
}

function updateGroupMemorySelectionDisplay() {
    const checkedBoxes = document.querySelectorAll('#group-memory-checkboxes-container input:checked');
    const displayText = document.getElementById('group-memory-selected-text');
    
    if (checkedBoxes.length === 0) {
        displayText.textContent = '-- 点击选择 --';
    } else if (checkedBoxes.length > 2) {
        displayText.textContent = `已选择 ${checkedBoxes.length} 个群聊`;
    } else {
        displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', ');
    }
}

// ▲▲▲ 群聊记忆功能相关函数结束 ▲▲▲

// ▼▼▼ 【新增】显示屏幕底部状态提示函数 ▼▼▼
function showStatusToast(message) {
    // 移除已存在的提示
    const existingToast = document.querySelector('.status-toast');
    if (existingToast) {
        existingToast.remove();
    }
    
    // 创建新的提示
    const toast = document.createElement('div');
    toast.className = 'status-toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    // 显示动画
    setTimeout(() => {
        toast.classList.add('show');
    }, 10);
    
    // 3秒后自动消失
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, 300);
    }, 3000);
}

// ▼▼▼ 【修改】线下模式头部按钮事件监听器 ▼▼▼
document.getElementById('offline-mode-header-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // 记录当前滚动位置
    const chatMessages = document.getElementById('chat-messages');
    const scrollTop = chatMessages.scrollTop;
    const scrollHeight = chatMessages.scrollHeight;
    const clientHeight = chatMessages.clientHeight;
    const isAtBottom = scrollTop + clientHeight >= scrollHeight - 10;
    
    // 切换线下模式状态
    chat.settings.offlineMode = !chat.settings.offlineMode;
    
    // 更新按钮状态
    const button = document.getElementById('offline-mode-header-btn');
    
    if (chat.settings.offlineMode) {
        button.classList.add('active');
        // 显示状态提示
        showStatusToast(chat.isGroup ? '已切换到线下模式' : '已切换到线下模式');
    } else {
        button.classList.remove('active');
        // 显示状态提示
        showStatusToast(chat.isGroup ? '已切换回线上模式' : '已切换回线上模式');
    }
    
    // 恢复滚动位置
    setTimeout(() => {
        if (isAtBottom) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        } else {
            chatMessages.scrollTop = scrollTop;
        }
    }, 10);
    
    // 保存聊天数据
    await db.chats.put(chat);
});

// ▼▼▼ 请用这段【完整、全新的代码】替换旧的 chat-settings-btn 点击事件 ▼▼▼
document.getElementById('chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const isGroup = chat.isGroup;
    
    // 显示/隐藏线下模式专属设置菜单
    const offlineSettingsGroup = document.getElementById('offline-mode-settings-group');
    if (chat.settings.offlineMode) {
        offlineSettingsGroup.style.display = 'block';
    } else {
        offlineSettingsGroup.style.display = 'none';
    }

    // --- 统一显示/隐藏控件 ---
    // ▼▼▼ 在 chat-settings-btn 的 click 事件中，粘贴这段代码 ▼▼▼
const videoCallSettingsGroup = document.getElementById('video-call-settings-group');
const visualCallSwitch = document.getElementById('visual-video-call-switch');
const imageUploadsDiv = document.getElementById('video-call-image-uploads');

if (isGroup) {
    videoCallSettingsGroup.style.display = 'none'; // 群聊不支持，隐藏整个设置区
} else {
    videoCallSettingsGroup.style.display = 'block'; // 单聊显示
    
    // 加载当前设置
    visualCallSwitch.checked = chat.settings.visualVideoCallEnabled || false;
    imageUploadsDiv.style.display = visualCallSwitch.checked ? 'block' : 'none';
    document.getElementById('char-video-image-preview').src = chat.settings.charVideoImage || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
    document.getElementById('user-video-image-preview').src = chat.settings.userVideoImage || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';

    // 为开关添加实时交互
    visualCallSwitch.onchange = () => {
        imageUploadsDiv.style.display = visualCallSwitch.checked ? 'block' : 'none';
    };
}
// ▲▲▲ 粘贴结束 ▲▲▲
// --- ▼▼▼ 请将这段全新的代码粘贴到 init() 函数的末尾 ---

// 启用锁屏开关的事件
document.getElementById('enable-lock-screen-toggle').addEventListener('change', (e) => {
    localStorage.setItem('lockScreenEnabled', e.target.checked);
    alert(e.target.checked ? '锁屏已启用，下次刷新生效' : '锁屏已禁用，下次刷新生效');
});

// 显示状态栏开关的事件
document.getElementById('show-status-bar-toggle').addEventListener('change', (e) => {
    const isEnabled = e.target.checked;
    localStorage.setItem('showStatusBar', isEnabled);
    document.getElementById('status-bar').style.display = isEnabled ? 'flex' : 'none';
});

// --- ▲▲▲ 粘贴结束 ▲▲▲ ---

// ▼▼▼ 【全新】为气泡导入/导出按钮绑定事件 ▼▼▼
document.getElementById('export-bubble-preset-btn').addEventListener('click', exportSelectedBubblePreset);

document.getElementById('import-bubble-preset-btn').addEventListener('click', () => {
    // 点击“导入”按钮时，触发隐藏的文件选择框
    document.getElementById('import-bubble-preset-input').click();
});

document.getElementById('import-bubble-preset-input').addEventListener('change', (e) => {
    // 当用户选择了文件后，调用导入函数处理
    importBubblePreset(e.target.files[0]);
    e.target.value = null; // 每次用完后清空，方便下次选择同一个文件
});
// ▲▲▲ 新事件绑定结束 ▲▲▲

// --- 全新视频通话功能事件绑定 (V2 修正版) ---

// 绑定新界面的挂断按钮
document.getElementById('hang-up-btn-visual').addEventListener('click', endVideoCall);

// 【新增】绑定新界面的发言按钮
document.getElementById('user-speak-btn-visual').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;
    const userInput = await showCustomPrompt('你说', '请输入你想说的话...');
    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});

// 绑定切换镜头按钮 (也是小窗本身)
document.getElementById('switch-camera-btn').addEventListener('click', switchVideoViews);
document.getElementById('video-pip-view').addEventListener('click', switchVideoViews);

// 【修正】绑定两个界面的重roll按钮
document.getElementById('reroll-call-btn').addEventListener('click', handleVideoCallReroll);
document.getElementById('reroll-call-btn-text').addEventListener('click', handleVideoCallReroll);

// 【修复】语音通话按钮事件绑定已移动到DOMContentLoaded内

// ▲▲▲ 替换结束 ▲▲▲



    document.getElementById('chat-name-group').style.display = 'block';
    document.getElementById('my-persona-group').style.display = 'block';
    document.getElementById('my-avatar-group').style.display = 'block';
    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
    
    // 显示/隐藏Minimax语音ID设置（仅私聊显示）
    document.getElementById('minimax-voice-id-group').style.display = isGroup ? 'none' : 'block';
        // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    document.getElementById('npc-library-group').style.display = isGroup ? 'none' : 'block';
    // ▲▲▲ 粘贴结束 ▲▲▲
    
    // ▼▼▼ NAI出图设置的显示/隐藏和加载 ▼▼▼
    const naiCharacterSettingsGroup = document.getElementById('nai-character-settings-group');
    // 检查系统是否启用了NovelAI
    const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
    if (!isGroup && novelaiEnabled) {
        naiCharacterSettingsGroup.style.display = 'block';
        
        // 加载角色NAI设置
        const naiSettings = chat.settings.naiSettings || {
            promptSource: 'system',
            characterPositivePrompt: '',
            characterNegativePrompt: ''
        };
        
        console.log('📖 [加载设置] 角色NAI设置:', naiSettings);
        console.log('   promptSource:', naiSettings.promptSource);
        console.log('   characterPositivePrompt:', naiSettings.characterPositivePrompt);
        console.log('   characterNegativePrompt:', naiSettings.characterNegativePrompt);
        
        // 设置提示词来源选项
        const promptSourceRadios = document.querySelectorAll('input[name="nai-prompt-source"]');
        promptSourceRadios.forEach(radio => {
            radio.checked = (radio.value === naiSettings.promptSource);
            console.log(`   设置单选按钮 ${radio.value}: ${radio.checked}`);
        });
    } else {
        naiCharacterSettingsGroup.style.display = 'none';
    }
    // ▲▲▲ NAI出图设置加载结束 ▲▲▲

    // ▼▼▼ 群聊NAI出图设置的显示/隐藏和加载 ▼▼▼
    const groupNaiSettingsGroup = document.getElementById('group-nai-settings-group');
    if (isGroup && novelaiEnabled) {
        groupNaiSettingsGroup.style.display = 'block';
        
        // 加载群聊角色NAI设置
        const groupNaiSettings = chat.settings.naiSettings || {
            promptSource: 'system',
            characterPositivePrompt: '',
            characterNegativePrompt: ''
        };
        
        console.log('📖 [加载设置] 群聊角色NAI设置:', groupNaiSettings);
        console.log('   promptSource:', groupNaiSettings.promptSource);
        console.log('   characterPositivePrompt:', groupNaiSettings.characterPositivePrompt);
        console.log('   characterNegativePrompt:', groupNaiSettings.characterNegativePrompt);
        
        // 设置提示词来源选项
        const groupPromptSourceRadios = document.querySelectorAll('input[name="group-nai-prompt-source"]');
        groupPromptSourceRadios.forEach(radio => {
            radio.checked = (radio.value === groupNaiSettings.promptSource);
            console.log(`   设置单选按钮 ${radio.value}: ${radio.checked}`);
        });
    } else {
        groupNaiSettingsGroup.style.display = 'none';
    }
    // ▲▲▲ 群聊NAI出图设置加载结束 ▲▲▲

    // 【核心修改1】根据是否为群聊，显示或隐藏"好友分组"区域
    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
    
    // 【新增】群聊记忆设置只对单聊显示
    document.getElementById('group-memory-settings-group').style.display = isGroup ? 'none' : 'block';
    
    // 【新增】群聊私聊记忆设置只对群聊显示
    document.getElementById('group-private-memory-settings-group').style.display = isGroup ? 'block' : 'none';
    
    // --- 加载表单数据 ---
    document.getElementById('chat-name-input').value = chat.name;
    document.getElementById('my-persona').value = chat.settings.myPersona;
    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
    document.getElementById('max-memory').value = chat.settings.maxMemory;
    // ▼▼▼ 在 max-memory 赋值的下一行，粘贴这一整块代码 ▼▼▼
const timeToggle = document.getElementById('time-perception-toggle');
const customTimeContainer = document.getElementById('custom-time-container');
const customTimeInput = document.getElementById('custom-time-input');

// 如果是旧聊天，给一个默认值 true（开启）
const isTimeEnabled = chat.settings.timePerceptionEnabled ?? true; 
timeToggle.checked = isTimeEnabled;
customTimeInput.value = chat.settings.customTime || '';

// 根据开关状态，决定是否显示自定义时间输入框
customTimeContainer.style.display = isTimeEnabled ? 'none' : 'block';
// ▲▲▲ 粘贴结束 ▲▲▲

    // ▼▼▼ 加载群聊记忆设置 ▼▼▼
    if (!isGroup) {
        const groupMemorySwitch = document.getElementById('group-memory-switch');
        const groupMemoryContainer = document.getElementById('group-memory-selection-container');
        const groupMemoryRounds = document.getElementById('group-memory-rounds');
        
        // 加载群聊记忆开关状态
        const isGroupMemoryEnabled = chat.settings.groupMemoryEnabled || false;
        groupMemorySwitch.checked = isGroupMemoryEnabled;
        groupMemoryContainer.style.display = isGroupMemoryEnabled ? 'block' : 'none';
        
        // 加载读取轮数设置
        groupMemoryRounds.value = chat.settings.groupMemoryRounds || 5;
        
        // 加载群聊选择并渲染群聊列表
        loadGroupMemorySettings(chat);
        
        // 绑定开关事件
        groupMemorySwitch.onchange = () => {
            groupMemoryContainer.style.display = groupMemorySwitch.checked ? 'block' : 'none';
        };
    }
    // ▲▲▲ 群聊记忆设置加载结束 ▲▲▲
    
    // ▼▼▼ 加载群聊私聊记忆设置 ▼▼▼
    if (isGroup) {
        const groupPrivateMemorySwitch = document.getElementById('group-private-memory-switch');
        const groupPrivateMemoryContainer = document.getElementById('group-private-memory-selection-container');
        const groupPrivateMemoryRounds = document.getElementById('group-private-memory-rounds');
        
        // 加载群聊私聊记忆开关状态
        const isGroupPrivateMemoryEnabled = chat.settings.groupPrivateMemoryEnabled || false;
        groupPrivateMemorySwitch.checked = isGroupPrivateMemoryEnabled;
        groupPrivateMemoryContainer.style.display = isGroupPrivateMemoryEnabled ? 'block' : 'none';
        
        // 加载读取轮数设置
        const privateMemoryRounds = chat.settings.groupPrivateMemoryRounds || 8;
        groupPrivateMemoryRounds.value = privateMemoryRounds;
        
        // 绑定开关事件
        groupPrivateMemorySwitch.onchange = () => {
            groupPrivateMemoryContainer.style.display = groupPrivateMemorySwitch.checked ? 'block' : 'none';
        };
    }
    // ▲▲▲ 群聊私聊记忆设置加载结束 ▲▲▲

    const bgPreview = document.getElementById('bg-preview');
    const removeBgBtn = document.getElementById('remove-bg-btn');
    if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
    } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
    }

    if (isGroup) {
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        renderGroupMemberSettings(chat.members);
        // 加载群聊后台活动设置
const groupActivityGroup = document.getElementById('group-background-activity-group');
const groupActivitySwitch = document.getElementById('group-background-activity-switch');
const groupIntervalSettings = document.getElementById('group-background-interval-settings');
const groupIntervalInput = document.getElementById('group-background-interval-input');

groupActivityGroup.style.display = 'block'; // 显示设置区域
const bgSettings = chat.settings.backgroundActivity || { enabled: false, interval: 120 };
groupActivitySwitch.checked = bgSettings.enabled;
groupIntervalInput.value = bgSettings.interval;
groupIntervalSettings.style.display = bgSettings.enabled ? 'block' : 'none';

// 为开关添加实时交互
groupActivitySwitch.onchange = () => {
    // 使用requestAnimationFrame确保布局更新不会导致页面跳动
    requestAnimationFrame(() => {
        groupIntervalSettings.style.display = groupActivitySwitch.checked ? 'block' : 'none';
    });
};
    } else {
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        
        // 加载Minimax语音ID设置
        document.getElementById('minimax-voice-id-input').value = chat.settings.minimaxVoiceId || '';
        
        document.getElementById('group-background-activity-group').style.display = 'none';
        // 【核心修改2】如果是单聊，就加载分组列表到下拉框
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">未分组</option>'; // 清空并设置默认选项
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            // 如果当前好友已经有分组，就默认选中它
            if (chat.groupId === group.id) {
                option.selected = true;
            }
            select.appendChild(option);
        }); 
    }
    
// ▼▼▼ 用下面这段【全新逻辑】替换掉原来简单的 forEach 循环 ▼▼▼

const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
worldBookCheckboxesContainer.innerHTML = '';
const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

// 1. 获取局部分类和世界书（角色设置中只显示局部世界书的分类）
const allCategories = await db.worldBookCategories.toArray();
const categories = allCategories
    .filter(cat => cat.isGlobal === false)
    .sort((a, b) => a.name.localeCompare(b.name));
const allBooks = state.worldBooks;

// 2. 只显示局部世界书（全局世界书已经有独立的开关控制，不需要在角色设置中显示）
const localBooks = allBooks.filter(book => !book.isGlobal);

// 4. 然后显示局部世界书（需要手动勾选）
if (localBooks.length > 0) {
    // 添加局部世界书标题
    const localHeader = document.createElement('div');
    localHeader.className = 'wb-section-header';
    localHeader.innerHTML = `<span> 局部世界书 </span>`;
    worldBookCheckboxesContainer.appendChild(localHeader);

// 【核心改造】如果存在未分类的书籍，就创建一个“虚拟分类”
const hasUncategorized = localBooks.some(book => !book.categoryId);
if (hasUncategorized) {
    categories.push({ id: 'uncategorized', name: '未分类' });
}

// 2. 将书籍按分类ID进行分组
const booksByCategoryId = localBooks.reduce((acc, book) => {
    const categoryId = book.categoryId || 'uncategorized';
    if (!acc[categoryId]) {
        acc[categoryId] = [];
    }
    acc[categoryId].push(book);
    return acc;
}, {});

// 3. 遍历分类，创建带折叠功能的列表
categories.forEach(category => {
    const booksInCategory = booksByCategoryId[category.id] || [];
    if (booksInCategory.length > 0) {
        const allInCategoryChecked = booksInCategory.every(book => linkedIds.has(book.id));
        
        const header = document.createElement('div');
        header.className = 'wb-category-header';
        header.innerHTML = `
            <span class="arrow">▼</span>
            <input type="checkbox" class="wb-category-checkbox" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
            <span>${category.name}</span>
        `;
        
        const bookContainer = document.createElement('div');
        bookContainer.className = 'wb-book-container';
        bookContainer.dataset.containerFor = category.id;

        booksInCategory.forEach(book => {
            const isChecked = linkedIds.has(book.id);
            const label = document.createElement('label');
            // 【核心修复】给书名包一个span，方便CSS做省略号处理
            label.innerHTML = `<input type="checkbox" class="wb-book-checkbox" value="${book.id}" data-parent-category="${category.id}" ${isChecked ? 'checked' : ''}> <span class="wb-book-name">${book.name}</span>`;
            bookContainer.appendChild(label);
        });

        // 默认将所有文件夹设置为折叠状态，保持界面整洁
        header.classList.add('collapsed');
        bookContainer.classList.add('collapsed');

        worldBookCheckboxesContainer.appendChild(header);
        worldBookCheckboxesContainer.appendChild(bookContainer);
    }
});
} // 结束 if (localBooks.length > 0)

updateWorldBookSelectionDisplay(); // 更新顶部的已选数量显示

// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 updateWorldBookSelectionDisplay(); 的下一行，粘贴这整块新代码 ▼▼▼


    // 加载并更新所有预览相关控件
    const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
    if (themeRadio) themeRadio.checked = true;
    const fontSizeSlider = document.getElementById('font-size-slider');
    fontSizeSlider.value = chat.settings.fontSize || 13;
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    const customCssInput = document.getElementById('custom-css-input');
    customCssInput.value = chat.settings.customCss || '';
    
    updateSettingsPreview(); 

// 【这三行就是我们新加的，现在已经放在正确的位置了】
renderBubblePresetSelector();
document.getElementById('bubble-style-preset-select').addEventListener('change', handlePresetSelectChange);
document.getElementById('manage-bubble-presets-btn').addEventListener('click', openBubblePresetManager);
    document.getElementById('chat-settings-modal').classList.add('visible');
});
// ▲▲▲ 替换结束 ▲▲▲
            
function renderGroupMemberSettings(members) { 
    const container = document.getElementById('group-members-settings'); 
    container.innerHTML = ''; 
    members.forEach(member => { 
        const div = document.createElement('div'); 
        div.className = 'member-editor'; 
        div.dataset.memberId = member.id; 
        // ★★★【核心重构】★★★
        // 显示的是 groupNickname
        div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`; 
        div.addEventListener('click', () => openMemberEditor(member.id)); 
        container.appendChild(div); 
    }); 
}

function openMemberEditor(memberId) { 
    editingMemberId = memberId; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === memberId); 
    document.getElementById('member-name-input').value = member.groupNickname; 
    document.getElementById('member-persona-input').value = member.persona; 
    document.getElementById('member-avatar-preview').src = member.avatar; 
    document.getElementById('member-settings-modal').classList.add('visible'); 
}
            document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
            document.getElementById('save-member-settings-btn').addEventListener('click', () => { 
    if (!editingMemberId) return; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === editingMemberId); 
    
    // ★★★【核心重构】★★★
    const newNickname = document.getElementById('member-name-input').value.trim();
    if (!newNickname) {
        alert("群昵称不能为空！");
        return;
    }
    member.groupNickname = newNickname; // 只修改群昵称
    member.persona = document.getElementById('member-persona-input').value; 
    member.avatar = document.getElementById('member-avatar-preview').src; 
    
    renderGroupMemberSettings(chat.members); 
    document.getElementById('member-settings-modal').classList.remove('visible'); 
});
            document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
            document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('备注名/群名不能为空！');
    chat.name = newName;
    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';

    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();

    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input.wb-book-checkbox:checked');
    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);

    if (chat.isGroup) {
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
        // 保存群聊后台活动设置
const groupActivityEnabled = document.getElementById('group-background-activity-switch').checked;
const groupActivityInterval = parseInt(document.getElementById('group-background-interval-input').value) || 120;

// 确保 lastActivityTimestamp 字段存在
const lastTimestamp = chat.settings.backgroundActivity ? chat.settings.backgroundActivity.lastActivityTimestamp : 0;

chat.settings.backgroundActivity = {
    enabled: groupActivityEnabled,
    interval: groupActivityInterval,
    lastActivityTimestamp: lastTimestamp // 保留上次的时间戳
};

    } else {
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        
        // 保存Minimax语音ID设置
        chat.settings.minimaxVoiceId = document.getElementById('minimax-voice-id-input').value.trim();
        
        // ▼▼▼ 在 save-chat-settings-btn 的 click 事件的 else 块内，粘贴这段代码 ▼▼▼
// 保存视频通话设置
chat.settings.visualVideoCallEnabled = document.getElementById('visual-video-call-switch').checked;
chat.settings.charVideoImage = document.getElementById('char-video-image-preview').src;
chat.settings.userVideoImage = document.getElementById('user-video-image-preview').src;
// ▲▲▲ 粘贴结束 ▲▲▲

        // ▼▼▼ 保存NAI出图设置 ▼▼▼
        const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
        if (novelaiEnabled) {
            if (!chat.settings.naiSettings) {
                chat.settings.naiSettings = {};
            }
            
            // 根据是否为群聊选择不同的radio按钮组
            const isGroup = chat.isGroup;
            const promptSourceRadio = document.querySelector(
                isGroup ? 'input[name="group-nai-prompt-source"]:checked' : 'input[name="nai-prompt-source"]:checked'
            );
            
            chat.settings.naiSettings.promptSource = promptSourceRadio ? promptSourceRadio.value : 'system';
            console.log('💾 保存NAI设置 - promptSource:', chat.settings.naiSettings.promptSource);
            console.log('💾 保存NAI设置 - characterPositivePrompt:', chat.settings.naiSettings.characterPositivePrompt);
            console.log('💾 保存NAI设置 - characterNegativePrompt:', chat.settings.naiSettings.characterNegativePrompt);
            // 角色专属提示词已经在专属弹窗中保存，这里只保存来源选择
        }
        // ▲▲▲ NAI出图设置保存结束 ▲▲▲
        
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
        
        // ▼▼▼ 保存群聊记忆设置 ▼▼▼
        chat.settings.groupMemoryEnabled = document.getElementById('group-memory-switch').checked;
        chat.settings.groupMemoryRounds = parseInt(document.getElementById('group-memory-rounds').value) || 5;
        
        // 保存选中的群聊ID列表
        const checkedGroupMemoryBoxes = document.querySelectorAll('#group-memory-checkboxes-container input:checked');
        chat.settings.selectedGroupChats = Array.from(checkedGroupMemoryBoxes).map(cb => cb.value);
        // ▲▲▲ 群聊记忆设置保存结束 ▲▲▲
    }
    
    // ▼▼▼ 保存群聊私聊记忆设置 ▼▼▼
    if (chat.isGroup) {
        chat.settings.groupPrivateMemoryEnabled = document.getElementById('group-private-memory-switch').checked;
        chat.settings.groupPrivateMemoryRounds = parseInt(document.getElementById('group-private-memory-rounds').value) || 8;
    }
    // ▲▲▲ 群聊私聊记忆设置保存结束 ▲▲▲

    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    // ▼▼▼ 在 chat.settings.maxMemory = ... 的下一行添加 ▼▼▼
chat.settings.timePerceptionEnabled = document.getElementById('time-perception-toggle').checked;
chat.settings.customTime = document.getElementById('custom-time-input').value;
// ▲▲▲ 添加结束 ▲▲▲
    await db.chats.put(chat);

    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
    
    chatSettingsModal.classList.remove('visible');
    renderChatInterface(state.activeChatId);
    renderChatList();
});
            document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('清空聊天记录', '此操作将永久删除此聊天的所有消息，无法恢复。确定要清空吗？', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
            // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 导出聊天记录按钮
document.getElementById('export-chat-history-btn').addEventListener('click', exportChatHistory);

// “导入聊天记录”这个可见的按钮
document.getElementById('import-chat-history-btn').addEventListener('click', () => {
    // 点击它时，我们去触发那个隐藏的文件选择框
    document.getElementById('import-chat-history-input').click();
});

// 隐藏的文件选择框
document.getElementById('import-chat-history-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        importChatHistory(file);
    }
    // 每次选择后清空，这样下次还能选择同一个文件
    event.target.value = null; 
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

            const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
            setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
            setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
            setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
            setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
            setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
            setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
            // ▼▼▼ 在 init() 函数的事件监听器区域，添加这两行 ▼▼▼
setupFileUpload('char-video-image-input', (base64) => document.getElementById('char-video-image-preview').src = base64);
setupFileUpload('user-video-image-input', (base64) => document.getElementById('user-video-image-preview').src = base64);
// ▲▲▲ 添加结束 ▲▲▲
            document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

            const stickerPanel = document.getElementById('sticker-panel');
            document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { renderStickerPanel(); stickerPanel.classList.add('visible'); });
            document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));
            // ▼▼▼ 将原来的 add-sticker-btn 事件监听器替换为下面这行 ▼▼▼
document.getElementById('add-sticker-btn').addEventListener('click', openBulkAddStickersModal);
// ▲▲▲ 替换结束 ▲▲▲
            document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());

            // ▼▼▼ 用下面这段【支持多选】的代码，替换旧的 sticker-upload-input 事件监听器 ▼▼▼
document.getElementById('sticker-upload-input').addEventListener('change', async (event) => {
    const files = event.target.files;
    if (!files.length) return;

    const newStickers = [];
    let canceled = false;

    // 使用 for...of 循环来逐个处理选中的文件
    for (const file of files) {
        if (canceled) break; // 如果用户中途取消了，就跳出循环

        // 为每个文件生成一个临时的本地预览URL
        const previewUrl = URL.createObjectURL(file);
        
        // 弹出带图片预览的命名框
        const name = await showCustomPrompt(
            `为表情命名 (${newStickers.length + 1}/${files.length})`,
            "请输入表情名称",
            file.name.replace(/\.[^/.]+$/, ""), // 默认使用文件名作为名字
            'text',
            // 这是 showCustomPrompt 的一个隐藏功能，可以插入额外的HTML
            `<img src="${previewUrl}" style="max-width: 100px; max-height: 100px; margin-bottom: 10px; border-radius: 8px;">`
        );
        
        // 释放临时的预览URL，避免内存泄漏
        URL.revokeObjectURL(previewUrl);
        
        if (name && name.trim()) {
            // 用户确认命名，读取文件内容并准备保存
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            
            newStickers.push({
                id: 'sticker_' + (Date.now() + newStickers.length),
                url: base64Url,
                name: name.trim()
            });
        } else if (name === null) {
            // 如果用户点击了“取消”
            const confirmCancel = await showCustomConfirm("确认取消", "确定要取消剩余表情的上传吗？");
            if (confirmCancel) {
                canceled = true;
            }
        } else {
            alert("表情名不能为空！");
        }
    }
    
    // 循环结束后，如果收集到了新表情，就批量添加到数据库
    if (newStickers.length > 0) {
        await db.userStickers.bulkAdd(newStickers);
        state.userStickers.push(...newStickers);
        renderStickerPanel();
        await showCustomAlert("上传成功", `已成功添加 ${newStickers.length} 个新表情！`);
    }

    // 清空文件选择器的值，以便下次能选择相同的文件
    event.target.value = null;
});
// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
            document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Url = e.target.result; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); }; reader.readAsDataURL(file); event.target.value = null; });
            document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const text = await showCustomPrompt("发送语音", "请输入你想说的内容："); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
            document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片："); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });

// ▼▼▼ 【全新】外卖请求功能事件绑定 ▼▼▼
const waimaiModal = document.getElementById('waimai-request-modal');
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
    waimaiModal.classList.add('visible');
});

// ▼▼▼ 【全新】购物系统事件绑定 ▼▼▼
document.getElementById('open-shopping-btn').addEventListener('click', openShoppingScreen);

document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
    waimaiModal.classList.remove('visible');
});

document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo) {
        alert('请输入商品信息！');
        return;
    }
    if (isNaN(amount) || amount <= 0) {
        alert('请输入有效的代付金额！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();

    // 【核心修正】在这里获取用户自己的昵称
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const msg = {
        role: 'user',
        // 【核心修正】将获取到的昵称，作为 senderName 添加到消息对象中
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});         
            document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
            document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
            document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
            document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);


// ▲▲▲ 替换到这里结束 ▲▲▲


            document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
            document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
            document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
            
            document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

// ▼▼▼ 【最终加强版】用这块代码替换旧的 selection-delete-btn 事件监听器 ▼▼▼
document.getElementById('selection-delete-btn').addEventListener('click', async () => {
    if (selectedMessages.size === 0) return;
    const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${selectedMessages.size} 条消息吗？这将改变AI的记忆。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 【核心加强】在删除前，检查被删除的消息中是否包含投票
        let deletedPollsInfo = [];
        for (const timestamp of selectedMessages) {
            const msg = chat.history.find(m => m.timestamp === timestamp);
            if (msg && msg.type === 'poll') {
                deletedPollsInfo.push(`关于“${msg.question}”的投票(时间戳: ${msg.timestamp})`);
            }
        }
        
        // 2. 更新后端的历史记录
        // 彻底删除消息，记录日志用于调试
        console.log(`删除前消息数量: ${chat.history.length}`);
        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
        console.log(`删除后消息数量: ${chat.history.length}`);
        
        // 3. 【核心加强】构建更具体的“遗忘指令”
        let forgetReason = "一些之前的消息已被用户删除。";
        if (deletedPollsInfo.length > 0) {
            forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join('；')}。`;
        }
        forgetReason += " 你应该像它们从未存在过一样继续对话，并相应地调整你的记忆和行为，不要再提及这些被删除的内容。";

        const forgetInstruction = {
            role: 'system',
            content: `[系统提示：${forgetReason}]`,
            timestamp: Date.now(),
            isHidden: true 
        };
        // 不再添加遗忘指令，直接清空选择状态
        selectedMessages.clear();
        
        // 4. 将包含“遗忘指令”的、更新后的chat对象存回数据库
        await db.chats.put(chat);
        console.log('消息删除已保存到数据库');
        
        // 5. 最后才更新UI
        renderChatInterface(state.activeChatId);
        renderChatList();
    }
});
// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

            // ▼▼▼ 线下模式设置相关事件监听器 ▼▼▼
            // 打开线下模式设置弹窗
            document.getElementById('offline-mode-settings-btn').addEventListener('click', () => {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                
                // 加载当前设置到弹窗
                const offlineSettings = chat.settings.offlineSettings || {};
                document.getElementById('offline-word-count').value = offlineSettings.wordCount || '';
                document.getElementById('offline-writing-style').value = offlineSettings.writingStyle || '';
                document.getElementById('offline-preset-content').value = offlineSettings.presetContent || '';
                
                // 显示弹窗
                document.getElementById('offline-mode-settings-modal').classList.add('visible');
            });
            
            // 保存线下模式设置
            document.getElementById('save-offline-settings-btn').addEventListener('click', async () => {
                if (!state.activeChatId) return;
                const chat = state.chats[state.activeChatId];
                
                // 获取用户输入的设置
                const wordCount = document.getElementById('offline-word-count').value.trim();
                const writingStyle = document.getElementById('offline-writing-style').value.trim();
                const presetContent = document.getElementById('offline-preset-content').value.trim();
                
                // 保存到聊天设置中
                if (!chat.settings.offlineSettings) {
                    chat.settings.offlineSettings = {};
                }
                chat.settings.offlineSettings.wordCount = wordCount;
                chat.settings.offlineSettings.writingStyle = writingStyle;
                chat.settings.offlineSettings.presetContent = presetContent;
                
                // 保存到数据库
                await db.chats.put(chat);
                
                // 关闭弹窗
                document.getElementById('offline-mode-settings-modal').classList.remove('visible');
                
                console.log('线下模式设置已保存:', chat.settings.offlineSettings);
            });
            
            // 取消线下模式设置
            document.getElementById('cancel-offline-settings-btn').addEventListener('click', () => {
                document.getElementById('offline-mode-settings-modal').classList.remove('visible');
            });
            // ▲▲▲ 线下模式设置事件监听器结束 ▲▲▲

            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("修改昵称", "请输入新的昵称", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
            document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
            document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
            document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
            document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

// ▼▼▼ 用下面这两行，替换掉旧的事件绑定 ▼▼▼

document.getElementById('create-shuoshuo-btn').addEventListener('click', () => openQZonePublisher('shuoshuo'));
document.getElementById('create-post-btn').addEventListener('click', () => openQZonePublisher('complex'));

// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
            document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

document.getElementById('album-photos-back-btn').addEventListener('click', () => {
    state.activeAlbumId = null;
    showScreen('album-screen');
});

document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

document.getElementById('album-photo-input').addEventListener('change', async (event) => {
    if (!state.activeAlbumId) return;
    const files = event.target.files;
    if (!files.length) return;

    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    
    for (const file of files) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({ 
            albumId: state.activeAlbumId, 
            url: dataUrl, 
            name: file.name || '未命名照片',
            description: '',
            timestamp: Date.now(),
            createdAt: Date.now() 
        });
    }

    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
    const updateData = { photoCount };
    
    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if(firstPhoto) updateData.coverUrl = firstPhoto.url;
    }

    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
    await renderAlbumPhotosScreen();
    await renderAlbumList();
    
    event.target.value = null;
    alert('照片上传成功！');
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

// --- ↓↓↓ 从这里开始复制，完整替换掉旧的 photos-grid-page 监听器 ↓↓↓ ---

document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.photo-delete-btn');
    const photoThumb = e.target.closest('.photo-thumb');

    if (deleteBtn) {
        e.stopPropagation(); // 阻止事件冒泡到图片上
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
            '删除照片',
            '确定要删除这张照片吗？此操作不可恢复。',
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            const deletedPhoto = await db.qzonePhotos.get(photoId);
            if (!deletedPhoto) return;
            
            await db.qzonePhotos.delete(photoId);

            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            const photoCount = (album.photoCount || 1) - 1;
            const updateData = { photoCount };
            
            if (album.coverUrl === deletedPhoto.url) {
                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }
            
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            alert('照片已删除。');
        }
    } 
    else if (photoThumb) {
        // 这就是恢复的图片点击放大功能！
        openPhotoViewer(photoThumb.src);
    }
});

// 恢复图片查看器的控制事件
document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

// 恢复键盘左右箭头和ESC键的功能
document.addEventListener('keydown', (e) => {
    if (!photoViewerState.isOpen) return; 

    if (e.key === 'ArrowRight') {
        showNextPhoto();
    } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
    } else if (e.key === 'Escape') {
        closePhotoViewer();
    }
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
         
document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("创建新相册", "请输入相册名称"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`相册 "${albumName}" 创建成功！`); } else if (albumName !== null) { alert("相册名称不能为空！"); } });

            document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
            document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
            document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
            document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("输入图片URL", "请输入网络图片的链接", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
            document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
            const imageModeBtn = document.getElementById('switch-to-image-mode');
            const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
            const imageModeContent = document.getElementById('image-mode-content');
            const textImageModeContent = document.getElementById('text-image-mode-content');
            imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
            textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });
            
            // === 【新增】分组可见性选择事件监听器 ===
            document.addEventListener('change', (event) => {
                if (event.target.name === 'post-visibility') {
                    const groupSelector = document.getElementById('group-selector');
                    if (event.target.value === 'selected') {
                        groupSelector.style.display = 'block';
                        loadGroupsForVisibility(); // 显示时重新加载分组列表
                    } else {
                        groupSelector.style.display = 'none';
                    }
                }
            });

// ▼▼▼ 请用下面这一整块【修复后】的代码，替换掉刚才删除的旧代码 ▼▼▼

// ▼▼▼ 用这【一整块】代码，替换掉旧的 'confirm-create-post-btn' 事件监听器 ▼▼▼

document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
    const modal = document.getElementById('create-post-modal');
    const mode = modal.dataset.mode; // 这就是我们的智能开关！

    // ==========================================================
    //  分支一：如果当前是“微博”模式
    // ==========================================================
    if (mode === 'weibo') {
        // 就调用专门发微博的函数
        await handlePublishWeibo();
        return; // 处理完后立刻结束，不再往下执行
    }

    // ==========================================================
    //  分支二：如果不是微博模式（那就是动态模式）
    // ==========================================================
    // 这里就是您原有的、发布“好友动态(QZone)”的完整逻辑
    
    const editingId = parseInt(modal.dataset.editingPostId);
    
    // 动态功能的专属逻辑：获取评论开关状态等
    const areCommentsVisible = document.getElementById('post-comments-toggle').checked;
    
    let postData = {};

    if (mode === 'edit') {
        // 编辑动态的逻辑...
        const existingPost = await db.qzonePosts.get(editingId);
        if (!existingPost) {
            alert('错误：找不到要编辑的动态！');
            return;
        }
        const visibleGroupIds = getSelectedGroupIds(); // 获取选中的分组ID
        postData = { 
            ...existingPost, 
            areCommentsVisible: areCommentsVisible,
            visibleGroupIds: visibleGroupIds,
        };
        
        if (postData.type === 'shuoshuo') {
            postData.content = document.getElementById('post-public-text').value.trim();
        } else {
            postData.publicText = document.getElementById('post-public-text').value.trim();
            if (postData.type === 'image_post') {
                postData.imageUrl = document.getElementById('post-image-preview').src;
                postData.imageDescription = document.getElementById('post-image-description').value.trim();
            } else if (postData.type === 'text_image') {
                postData.hiddenContent = document.getElementById('post-hidden-text').value.trim();
            }
        }
        await db.qzonePosts.put(postData);

    } else {
        // 新建动态的逻辑...
        const visibleGroupIds = getSelectedGroupIds(); // 获取选中的分组ID
        const basePostData = {
            timestamp: Date.now(),
            authorId: 'user',
            areCommentsVisible: areCommentsVisible,
            visibleGroupIds: visibleGroupIds,
        };
        
        if (mode === 'shuoshuo') {
            const content = document.getElementById('post-public-text').value.trim();
            if (!content) return alert('说说内容不能为空哦！');
            postData = { ...basePostData, type: 'shuoshuo', content: content };
        } else { // complex mode (图片或文字图)
            const publicText = document.getElementById('post-public-text').value.trim();
            const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');
            if (isImageModeActive) {
                const imageUrl = document.getElementById('post-image-preview').src;
                const imageDescription = document.getElementById('post-image-description').value.trim();
                if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) return alert('请先添加一张图片再发布动态哦！');
                if (!imageDescription) return alert('请为你的图片添加一个简单的描述（必填，给AI看的）！');
                postData = { ...basePostData, type: 'image_post', publicText, imageUrl, imageDescription };
            } else {
                const hiddenText = document.getElementById('post-hidden-text').value.trim();
                if (!hiddenText) return alert('请输入文字图描述！');
                postData = { ...basePostData, type: 'text_image', publicText, hiddenContent: hiddenText };
            }
        }
        const newPost = await db.qzonePosts.add(postData);
        postData.id = newPost; // 获取新帖子的ID
    }
    
    // 通知AI的逻辑...
    let postSummary = postData.content || postData.publicText || postData.imageDescription || postData.hiddenContent || "（无文字内容）";
    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');
    for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue;
        const historyMessage = { role: 'system', content: `[系统提示：用户${editingId ? '编辑了' : '发布了'}一条动态(ID: ${editingId || postData.id})，内容摘要是：“${postSummary}”。]`, timestamp: Date.now(), isHidden: true };
        chat.history.push(historyMessage);
        await db.chats.put(chat);
    }
    
    // 收尾工作...
    await renderQzonePosts();
    modal.classList.remove('visible');
    delete modal.dataset.editingPostId;
    delete modal.dataset.mode;
    alert(`动态${editingId ? '编辑' : '发布'}成功！`);
});

// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这【一整块】包含所有滑动和点击事件的完整代码，替换掉旧的 postsList 事件监听器 ▼▼▼

const postsList = document.getElementById('qzone-posts-list');
let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

function resetAllSwipes(exceptThisOne = null) {
    document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
            container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
    });
}

const handleSwipeStart = (e) => {
    const targetContainer = e.target.closest('.qzone-post-container');
    if (!targetContainer) return;

    resetAllSwipes(targetContainer);
    swipeState.activeContainer = targetContainer;
    swipeState.isDragging = true;
    swipeState.isClick = true;
    swipeState.swipeDirection = null;
    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
};

const handleSwipeMove = (e) => {
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    const diffX = currentX - swipeState.startX;
    const diffY = currentY - swipeState.startY;
    const absDiffX = Math.abs(diffX);
    const absDiffY = Math.abs(diffY);
    const clickThreshold = 5;

    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
        swipeState.isClick = false;
    }

    if (swipeState.swipeDirection === null) {
        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
            if (absDiffX > absDiffY) {
                swipeState.swipeDirection = 'horizontal';
            } else {
                swipeState.swipeDirection = 'vertical';
            }
        }
    }
    if (swipeState.swipeDirection === 'vertical') {
        handleSwipeEnd(e);
        return;
    }
    if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = diffX;
        if (translation > 0) translation = 0;
        if (translation < -90) translation = -90;
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
    }
};

const handleSwipeEnd = (e) => {
    if (swipeState.isClick) {
        swipeState.isDragging = false;
        swipeState.activeContainer = null;
        return;
    }
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
    postItem.style.transition = 'transform 0.3s ease';

    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
    const diffX = finalX - swipeState.startX;
    const swipeThreshold = -40;

    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
        postItem.classList.add('swiped');
        postItem.style.transform = '';
    } else {
        postItem.classList.remove('swiped');
        postItem.style.transform = '';
    }

    swipeState.isDragging = false;
    swipeState.startX = 0;
    swipeState.startY = 0;
    swipeState.currentX = 0;
    swipeState.activeContainer = null;
    swipeState.swipeDirection = null;
    swipeState.isClick = true;
};

// --- 绑定所有滑动事件 ---
postsList.addEventListener('mousedown', handleSwipeStart);
document.addEventListener('mousemove', handleSwipeMove);
document.addEventListener('mouseup', handleSwipeEnd);
postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
postsList.addEventListener('touchend', handleSwipeEnd);

// ▼▼▼ 步骤3.3：用这整块代码替换旧的 qzone-posts-list 的 click 事件监听器 ▼▼▼
postsList.addEventListener('click', async (e) => {
    e.stopPropagation();
    const target = e.target;
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
const summonBtn = target.closest('.action-icon.summon-npc');
if (summonBtn) {
    const postId = parseInt(summonBtn.dataset.postId);
    const authorId = summonBtn.dataset.authorId;
    if (!isNaN(postId) && authorId) {
        handleNpcSummonClick(postId, authorId);
    }
    return; // 处理完召唤逻辑后，直接结束，不执行后续的点赞等判断
}
// ▲▲▲ 粘贴结束 ▲▲▲

    // ★★★★★【核心修改：处理点击评论本身（用于回复）】★★★★★
    const commentItem = target.closest('.comment-item');
    // 确保点击的不是删除按钮或评论里的名字链接
    if (commentItem && !target.classList.contains('comment-delete-btn') && !target.classList.contains('commenter-name') && !target.classList.contains('reply-target-name')) {
        const postContainer = commentItem.closest('.qzone-post-container');
        if (postContainer) {
            const commenterName = commentItem.dataset.commenterName;
            const myNickname = state.qzoneSettings.nickname;
            
            // 如果点击的是自己的评论，则不进入回复模式
            if (commenterName !== myNickname) {
                const commentInput = postContainer.querySelector('.comment-input');
                commentInput.placeholder = `回复 ${commenterName}:`;
                commentInput.dataset.replyTo = commenterName; // 把要回复的人的名字，临时存起来
                commentInput.focus(); // 自动聚焦到输入框
            }
        }
        return; // 处理完点击评论后，就不用往下执行了
    }

    if (target.classList.contains('comment-delete-btn')) {
        const postContainer = target.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentIndex = parseInt(target.dataset.commentIndex);
        if (isNaN(postId) || isNaN(commentIndex)) return;
        const post = await db.qzonePosts.get(postId);
        if (!post || !post.comments || !post.comments[commentIndex]) return;
        const commentText = post.comments[commentIndex].text;
        const confirmed = await showCustomConfirm('删除评论', `确定要删除这条评论吗？\n\n“${commentText.substring(0, 50)}...”`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            post.comments.splice(commentIndex, 1);
            await db.qzonePosts.update(postId, { comments: post.comments });
            await renderQzonePosts();
            alert('评论已删除。');
        }
        return;
    }

    if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) showPostActions(parseInt(container.dataset.postId));
        return;
    }

    if (target.closest('.qzone-post-delete-action')) {
        const container = target.closest('.qzone-post-delete-action').parentElement;
        if (!container) return;
        const postIdToDelete = parseInt(container.dataset.postId);
        if (isNaN(postIdToDelete)) return;
        const confirmed = await showCustomConfirm('删除动态', '确定要永久删除这条动态吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            container.style.transition = 'all 0.3s ease';
            container.style.transform = 'scale(0.8)';
            container.style.opacity = '0';
            setTimeout(async () => {
                 await db.qzonePosts.delete(postIdToDelete);
                 const notificationIdentifier = `(ID: ${postIdToDelete})`;
                 for (const chatId in state.chats) {
                     const chat = state.chats[chatId];
                     const originalHistoryLength = chat.history.length;
                     chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                     if (chat.history.length < originalHistoryLength) await db.chats.put(chat);
                 }
                 await renderQzonePosts();
                 alert('动态已删除。');
            }, 300);
        }
        return;
    }

    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        showCustomAlert("图片内容", target.dataset.hiddenText.replace(/<br>/g, '\n'));
        return;
    }
    const icon = target.closest('.action-icon');
    if (icon) {
        const postContainer = icon.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (isNaN(postId)) return;
        if (icon.classList.contains('like')) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname;
            const userLikeIndex = post.likes.indexOf(userNickname);
            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
                icon.classList.add('animate-like');
                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
            }
            await db.qzonePosts.update(postId, { likes: post.likes });
        }
        if (icon.classList.contains('favorite')) {
            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
            if (existingFavorite) {
                await db.favorites.delete(existingFavorite.id);
                await showCustomAlert('提示', '已取消收藏');
            } else {
                const postToSave = await db.qzonePosts.get(postId);
                if (postToSave) {
                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                    await showCustomAlert('提示', '收藏成功！');
                }
            }
        }
        await renderQzonePosts();
        return;
    }
    
    // ★★★★★【核心修改：处理评论发送逻辑】★★★★★
    const sendBtn = target.closest('.comment-send-btn');
    if (sendBtn) {
        const postContainer = sendBtn.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();
        if (!commentText) return alert('评论内容不能为空哦！');
        const post = await db.qzonePosts.get(postId);
        if (!post) return;
        if (!post.comments) post.comments = [];

        // 创建新的评论对象
        const newComment = { 
            commenterName: state.qzoneSettings.nickname, 
            text: commentText, 
            timestamp: Date.now() 
        };

        // 检查是不是在回复模式
        if (commentInput.dataset.replyTo) {
            newComment.replyTo = commentInput.dataset.replyTo; // 如果是，就把回复对象的名字加上
        }

        post.comments.push(newComment);
        await db.qzonePosts.update(postId, { comments: post.comments });
        for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            if (!chat.isGroup) {
                let aiNotification = `[系统提示：'${state.qzoneSettings.nickname}' 在ID为${postId}的动态下发表了评论：“${commentText}”`;
                if(newComment.replyTo) {
                    aiNotification += ` (这是对'${newComment.replyTo}'的回复)`;
                }
                aiNotification += `]`;
                chat.history.push({ role: 'system', content: aiNotification, timestamp: Date.now(), isHidden: true });
                await db.chats.put(chat);
            }
        }
        
        // 发送后，重置输入框状态
        commentInput.value = '';
        commentInput.placeholder = '友善的评论是交流的起点';
        delete commentInput.dataset.replyTo; // 清除回复状态

        await renderQzonePosts();
        return;
    }
});
// ▲▲▲ 步骤3.3替换结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这两行 ▼▼▼

            // 绑定动态页和收藏页的返回按钮
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

            // ▲▲▲ 添加结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，检查并确保你有这段完整的代码 ▼▼▼

            // 收藏页搜索功能
            const searchInput = document.getElementById('favorites-search-input');
            const searchClearBtn = document.getElementById('favorites-search-clear-btn');

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                // 控制清除按钮的显示/隐藏
                searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                if (!searchTerm) {
                    displayFilteredFavorites(allFavoriteItems); // 如果搜索框为空，显示所有
                    return;
                }

                // 筛选逻辑
                const filteredItems = allFavoriteItems.filter(item => {
                    let contentToSearch = '';
                    let authorToSearch = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                        if (post.authorId === 'user') {
                            authorToSearch = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorToSearch = state.chats[post.authorId].name;
                        }
                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        if (typeof msg.content === 'string') {
                            contentToSearch = msg.content;
                        }
                        const chat = state.chats[item.chatId];
                        if (chat) {
                           if (msg.role === 'user') {
                                authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                           } else {
                                authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                           }
                        }
                    }
                    
                    // 同时搜索内容和作者，并且不区分大小写
                    return contentToSearch.toLowerCase().includes(searchTerm) || 
                           authorToSearch.toLowerCase().includes(searchTerm);
                });

                displayFilteredFavorites(filteredItems);
            });

            // 清除按钮的点击事件
            searchClearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchClearBtn.style.display = 'none';
                displayFilteredFavorites(allFavoriteItems);
                searchInput.focus();
            });

            // ▲▲▲ 代码检查结束 ▲▲▲

            // ▼▼▼ 新增/修改的事件监听器 ▼▼▼
            
            // 为聊天界面的批量收藏按钮绑定事件
                        // 为聊天界面的批量收藏按钮绑定事件 (已修正)
            document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                if (selectedMessages.size === 0) return;
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const favoritesToAdd = [];
                const timestampsToFavorite = [...selectedMessages];

                for (const timestamp of timestampsToFavorite) {
                    // 【核心修正1】使用新的、高效的索引进行查询
                    const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                    
                    if (!existing) {
                        const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                        if (messageToSave) {
                            // ▼▼▼ 新增：为语音消息添加缓存key信息 ▼▼▼
                            const favoriteData = {
                                type: 'chat_message',
                                content: {...messageToSave}, // 浅拷贝消息
                                chatId: state.activeChatId,
                                timestamp: Date.now(), // 这是收藏操作发生的时间
                                originalTimestamp: messageToSave.timestamp // 【核心修正2】保存原始消息的时间戳到新字段
                            };
                            
                            // 如果是语音消息，保存语音缓存key
                            if (messageToSave.type === 'voice_message' && messageToSave.content) {
                                const minimaxVoiceId = chat.settings?.minimaxVoiceId;
                                if (minimaxVoiceId && window.VoiceStorageAPI) {
                                    const cacheKey = window.VoiceStorageAPI.generateCacheKey(
                                        messageToSave.content, 
                                        minimaxVoiceId
                                    );
                                    favoriteData.content.voiceCacheKey = cacheKey;
                                    favoriteData.content.voiceId = minimaxVoiceId;
                                }
                            }
                            
                            favoritesToAdd.push(favoriteData);
                            // ▲▲▲ 新增结束 ▲▲▲
                        }
                    }
                }

                if (favoritesToAdd.length > 0) {
                    await db.favorites.bulkAdd(favoritesToAdd);
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 更新全局收藏缓存
                    await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 条消息。`);
                } else {
                    await showCustomAlert('提示', '选中的消息均已收藏过。');
                }
                
                exitSelectionMode();
            });

            // 收藏页面的"编辑"按钮事件 (已修正)
            const favoritesEditBtn = document.getElementById('favorites-edit-btn');
            const favoritesView = document.getElementById('favorites-view');
            const favoritesActionBar = document.getElementById('favorites-action-bar');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏
            const favoritesList = document.getElementById('favorites-list'); // 获取收藏列表
            
            favoritesEditBtn.addEventListener('click', () => {
                isFavoritesSelectionMode = !isFavoritesSelectionMode;
                favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                if (isFavoritesSelectionMode) {
                    // --- 进入编辑模式 ---
                    favoritesEditBtn.textContent = '完成';
                    favoritesActionBar.style.display = 'block'; // 显示删除操作栏
                    document.body.classList.add('favorites-edit-mode'); // ▼ 新增：添加编辑模式CSS类
                    favoritesList.style.paddingBottom = '80px'; // ▼ 新增：给列表底部增加空间
                } else {
                    // --- 退出编辑模式 ---
                    favoritesEditBtn.textContent = '编辑';
                    favoritesActionBar.style.display = 'none'; // 隐藏删除操作栏
                    document.body.classList.remove('favorites-edit-mode'); // ▼ 新增：移除编辑模式CSS类
                    favoritesList.style.paddingBottom = ''; // ▼ 新增：恢复列表默认padding

                    // 退出时清空所有选择
                    selectedFavorites.clear();
                    document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (0)`;
                }
            });

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏列表的点击选择事件 (事件委托)
document.getElementById('favorites-list').addEventListener('click', async (e) => {
    const target = e.target;
    const card = target.closest('.favorite-item-card');

    // 【新增】处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return; // 处理完就退出，不继续执行选择逻辑
    }
    
    // ▼▼▼ 新增：处理收藏页面的语音消息点击 ▼▼▼
    const voiceBody = target.closest('.voice-message-body');
    if (voiceBody && !isFavoritesSelectionMode) {
        const card = voiceBody.closest('.favorite-item-card');
        if (!card) return;
        
        const transcriptEl = card.querySelector('.voice-transcript');
        const spinner = card.querySelector('.loading-spinner');
        
        // 如果正在加载中，不响应点击
        if (card.dataset.state === 'loading') return;
        
        // 如果已展开，则收起
        if (card.dataset.state === 'expanded') {
            transcriptEl.style.display = 'none';
            card.dataset.state = 'collapsed';
        } else {
            // 展开并显示文字
            card.dataset.state = 'loading';
            spinner.style.display = 'block';
            
            setTimeout(async () => {
                if (!document.body.contains(card)) return;
                
                const voiceText = card.dataset.voiceText || '(无法识别)';
                transcriptEl.textContent = voiceText;
                
                spinner.style.display = 'none';
                transcriptEl.style.display = 'block';
                card.dataset.state = 'expanded';
                
                // 如果有voiceId，播放语音
                const voiceId = card.dataset.voiceId;
                const minimaxGroupId = localStorage.getItem('minimaxGroupId');
                const minimaxApiKey = localStorage.getItem('minimaxApiKey');
                
                if (voiceId && voiceText && minimaxGroupId && minimaxApiKey) {
                    // 使用相同的播放逻辑
                    try {
                        await playVoiceForFavorite(card, voiceText, voiceId);
                    } catch (error) {
                        console.error('播放收藏的语音失败:', error);
                    }
                }
            }, 500);
        }
        return;
    }
    // ▲▲▲ 新增结束 ▲▲▲
    
    // 如果不在选择模式，则不执行后续的选择操作
    if (!isFavoritesSelectionMode) return;

    // --- 以下是原有的选择逻辑，保持不变 ---
    if (!card) return;

    const favId = parseInt(card.dataset.favid);
    if (isNaN(favId)) return;

    // 切换选择状态
    if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
    } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
    }
    
    // 更新底部删除按钮的计数
    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (${selectedFavorites.size})`;
});

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏页面批量删除按钮事件
document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
    if (selectedFavorites.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除', 
        `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('删除成功', '选中的收藏已被移除。');
        
        // 【核心修正1】从前端缓存中也移除被删除的项
        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
        
        // 【核心修正2】使用更新后的缓存，立即重新渲染列表
        displayFilteredFavorites(allFavoriteItems);
        
        // 最后，再退出编辑模式
        favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
    }
});

// ▼▼▼ 在 init() 函数末尾添加 ▼▼▼
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log("后台活动模拟已自动启动。");
}
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【这是最终的正确代码】请粘贴这段代码到 init() 的事件监听器区域末尾 ▼▼▼

// --- 统一处理所有影响预览的控件的事件 ---

// 1. 监听主题选择
document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
    radio.addEventListener('change', updateSettingsPreview);
});

// 2. 监听字体大小滑块
const fontSizeSlider = document.getElementById('font-size-slider');
fontSizeSlider.addEventListener('input', () => {
    // a. 实时更新数值显示
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // b. 更新预览
    updateSettingsPreview();
});

// 3. 监听自定义CSS输入框
const customCssInputForPreview = document.getElementById('custom-css-input');
customCssInputForPreview.addEventListener('input', updateSettingsPreview);

// 4. 监听重置按钮
document.getElementById('reset-theme-btn').addEventListener('click', () => {
    document.getElementById('theme-default').checked = true;
    updateSettingsPreview();
});

document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
    document.getElementById('custom-css-input').value = '';
    updateSettingsPreview();
});

// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.querySelectorAll('input[name="visibility"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
            groupsContainer.style.display = 'block';
        } else {
            groupsContainer.style.display = 'none';
        }
    });
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
document.getElementById('close-group-manager-btn').addEventListener('click', () => {
    document.getElementById('group-management-modal').classList.remove('visible');
    // 刷新聊天设置里的分组列表
    const chatSettingsBtn = document.getElementById('chat-settings-btn');
    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
       chatSettingsBtn.click(); // 再次点击以重新打开
    }
});

document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
document.getElementById('existing-groups-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
// 消息操作菜单的按钮事件
document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
// ▼▼▼ 【修正】使用新的编辑器入口 ▼▼▼
document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
// ▲▲▲ 替换结束 ▲▲▲
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// ▼▼▼ 在这里添加新代码 ▼▼▼
document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 请用这段【修正后】的代码替换旧的 select-message-btn 事件监听器 ▼▼▼
document.getElementById('select-message-btn').addEventListener('click', () => {
    // 【核心修复】在关闭菜单前，先捕获时间戳
    const timestampToSelect = activeMessageTimestamp; 
    hideMessageActions();
    // 使用捕获到的值
    if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼

// 动态操作菜单的按钮事件
document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【新增】联系人选择器事件绑定 ▼▼▼
document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
    showScreen('chat-list-screen');
});

document.getElementById('contact-picker-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    const contactId = item.dataset.contactId;
    item.classList.toggle('selected');
    
    if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
    } else {
        selectedContacts.add(contactId);
    }
    updateContactPickerConfirmButton();
});

// ▼▼▼ 【新增】绑定“管理群成员”按钮事件 ▼▼▼
document.getElementById('manage-members-btn').addEventListener('click', () => {
    // 在切换屏幕前，先隐藏当前的聊天设置弹窗
    document.getElementById('chat-settings-modal').classList.remove('visible');
    // 然后再打开成员管理屏幕
    openMemberManagementScreen();
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 【最终完整版】群成员管理功能事件绑定 ▼▼▼
document.getElementById('back-from-member-management').addEventListener('click', () => {

    showScreen('chat-interface-screen');    
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('member-management-list').addEventListener('click', (e) => {
    // 【已恢复】移除成员的事件
    if (e.target.classList.contains('remove-member-btn')) {
        removeMemberFromGroup(e.target.dataset.memberId);
    }
});

document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
    // 【已恢复】从好友列表添加的事件
    // 【关键】为“完成”按钮绑定“拉人入群”的逻辑
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点方法清除旧的事件监听器，防止重复绑定
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    await openContactPickerForAddMember();
});

document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】视频通话功能事件监听器 ▼▼▼

// 绑定单聊和群聊的发起按钮 - 现在显示选择弹窗
document.getElementById('video-call-btn').addEventListener('click', showCallTypeSelection);
document.getElementById('group-video-call-btn').addEventListener('click', showCallTypeSelection);

// 绑定通话类型选择弹窗的按钮
document.getElementById('select-video-call-btn').addEventListener('click', () => {
    hideCallTypeSelection();
    handleInitiateCall('video');
});
document.getElementById('select-voice-call-btn').addEventListener('click', () => {
    hideCallTypeSelection();
    handleInitiateCall('voice');
});
document.getElementById('cancel-call-type-selection-btn').addEventListener('click', hideCallTypeSelection);

// 绑定“挂断”按钮
document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

// 【新增】取消呼叫的处理函数
function handleCancelCall() {
    videoCallState.isAwaitingResponse = false;
    showScreen('chat-interface-screen');
}

// 绑定"取消呼叫"按钮
document.getElementById('cancel-call-btn').addEventListener('click', handleCancelCall);

// 【全新】绑定"加入通话"按钮
document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

// 【修复】绑定语音通话界面的所有按钮事件
console.log('🔧 开始绑定语音通话按钮事件...');
try {
    document.getElementById('hang-up-voice-btn').addEventListener('click', endVideoCall);
    console.log('✅ hang-up-voice-btn 绑定成功');
    
    document.getElementById('user-speak-voice-btn').addEventListener('click', async () => {
        console.log('🖤 用户点击了发言按钮');
        if (!videoCallState.isActive) return;
        const userInput = await showCustomPrompt('你说', '请输入你想说的话...');
        if (userInput && userInput.trim()) {
            await triggerAiInCallAction(userInput);
        }
    });
    console.log('✅ user-speak-voice-btn 绑定成功');
    
    document.getElementById('reroll-voice-call-btn').addEventListener('click', handleVideoCallReroll);
    console.log('✅ reroll-voice-call-btn 绑定成功');
    
    document.getElementById('join-voice-call-btn').addEventListener('click', handleUserJoinCall);
    console.log('✅ join-voice-call-btn 绑定成功');
    
    console.log('🎉 所有语音通话按钮事件绑定完成！');
} catch (error) {
    console.error('❌ 语音通话按钮绑定失败:', error);
}

// ▼▼▼ 用这个【已修复并激活旁观模式】的版本替换旧的 decline-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的“拒绝”按钮
document.getElementById('decline-call-btn').addEventListener('click', async () => {
    stopRingtone(); 
    hideIncomingCallModal();
    const callerChatId = videoCallState.activeChatId; // 【核心修正1】从专用信道获取来电者ID
    if (!callerChatId) return;

    const chat = state.chats[callerChatId];
    if (!chat) return;
    
    // 【核心修正2】根据是否群聊，执行不同的拒绝逻辑
    if (videoCallState.isGroupCall) {
        // 对于群聊，拒绝=旁观，这个逻辑不变
        videoCallState.isUserParticipating = false;
        const systemNote = {
            role: 'system',
            content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);
        await triggerAiResponse(); 
    } else { 
        // 对于单聊，我们不再打扰用户当前界面，而是静默处理
        const declineMessage = { role: 'user', content: '我拒绝了你的视频通话请求。', timestamp: Date.now(), isHidden: true };
        chat.history.push(declineMessage);
        await db.chats.put(chat);
        
        // 【核心修正3】只通知，不切换屏幕
        showNotification(callerChatId, "你已拒绝通话邀请。");
        // 【重要】在后台为对方触发一个响应，让它知道自己被拒绝了
        // 我们需要临时切换activeChatId来触发，然后再换回来
        const originalActiveChatId = state.activeChatId;
        state.activeChatId = callerChatId;
        await triggerAiResponse();
        state.activeChatId = originalActiveChatId;
    }
    
    // 清理状态
    videoCallState.isAwaitingResponse = false;
    videoCallState.activeChatId = null;
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这个【已修复重复头像BUG】的版本替换旧的 accept-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的“接听”按钮
document.getElementById('accept-call-btn').addEventListener('click', async () => {
    stopRingtone();
    hideIncomingCallModal();
    const callerChatId = videoCallState.activeChatId; // 【核心修正1】从专用信道获取ID
    if (!callerChatId) return;
    
    // 【核心修正2】在接听时，我们才真正改变全局状态，并打开通话界面
    state.activeChatId = callerChatId; // <-- 在这里，我们才授权修改全局状态！
    
    videoCallState.initiator = 'ai';
    videoCallState.isUserParticipating = true;
    
    if (videoCallState.isGroupCall) {
        const chat = state.chats[videoCallState.activeChatId];
        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
        if (requester) {
            videoCallState.participants = [requester];
        } else {
            videoCallState.participants = [];
        }
    }
    
    startVideoCall(); // 启动通话界面
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这个【已增加用户高亮】的全新版本，完整替换旧的 user-speak-btn 事件监听器 ▼▼▼
// 绑定用户在通话中发言的按钮
document.getElementById('user-speak-btn').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;

    // ★★★★★ 核心新增：在弹出输入框前，先找到并高亮用户头像 ★★★★★
    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    const userInput = await showCustomPrompt('你说', '请输入你想说的话...');
    
    // ★★★★★ 核心新增：无论用户是否输入，只要关闭输入框就移除高亮 ★★★★★
    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【新增】回忆录相关事件绑定 ▼▼▼
// 1. 将“回忆”页签和它的视图连接起来
document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
    // 在切换前，确保"收藏"页面的编辑模式已关闭
    if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click(); 
    }
    switchToChatListView('memories-view');
    showMemoriesMainSelection(); // 显示主选择界面
});

// 2. 绑定回忆录界面的返回按钮
document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

// 3. 新增：进入恋爱空间按钮
document.getElementById('enter-love-space-btn').addEventListener('click', () => {
    showLoveSpace();
});

// 4. 新增：进入私人空间按钮
document.getElementById('enter-private-space-btn').addEventListener('click', () => {
    showPrivateSpace();
});

// 4.1 新增：私人空间设置按钮
document.getElementById('private-space-settings-btn').addEventListener('click', () => {
    // 显示设置弹窗
    document.getElementById('private-settings-modal').style.display = 'flex';
    
    // 加载已保存的背景URL到输入框
    const headerBg = localStorage.getItem('private-header-bg') || '';
    const navBg = localStorage.getItem('private-nav-bg') || '';
    const contentBg = localStorage.getItem('private-content-bg') || '';
    
    document.getElementById('header-bg-input').value = headerBg;
    document.getElementById('nav-bg-input').value = navBg;
    document.getElementById('content-bg-input').value = contentBg;
    
    console.log('设置弹窗已打开，已加载保存的背景设置:', { headerBg, navBg, contentBg });
});

// 4.2 新增：关闭私人空间设置弹窗
document.getElementById('close-private-settings').addEventListener('click', () => {
    document.getElementById('private-settings-modal').style.display = 'none';
});

// 4.3 新增：私人空间标签页切换
document.querySelectorAll('.private-nav-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        const tabName = tab.getAttribute('data-tab');
        switchPrivateTab(tabName);
    });
});

    // 4.5 新增：私人空间头像点击事件
    document.getElementById('private-space-avatar-img').addEventListener('click', () => {
        console.log('点击私人空间头像，当前联系人:', currentPrivateSpaceContactId);
        window.showFriendsSelector();
});

// 4.4 新增：点击私人空间设置弹窗背景关闭
document.getElementById('private-settings-modal').addEventListener('click', (e) => {
    if (e.target === document.getElementById('private-settings-modal')) {
        document.getElementById('private-settings-modal').style.display = 'none';
    }
});

// 4.5 新增：壁纸设置功能
window.openWallpaperSettings = function() {
    document.getElementById('private-settings-modal').style.display = 'none';
    document.getElementById('wallpaper-settings-modal').style.display = 'flex';
    
    // 加载当前壁纸设置
    loadCurrentWallpaperSettings();
};

// 关闭壁纸设置弹窗
document.getElementById('close-wallpaper-settings').addEventListener('click', () => {
    document.getElementById('wallpaper-settings-modal').style.display = 'none';
});

// 点击壁纸设置弹窗背景关闭
document.getElementById('wallpaper-settings-modal').addEventListener('click', (e) => {
    if (e.target === document.getElementById('wallpaper-settings-modal')) {
        document.getElementById('wallpaper-settings-modal').style.display = 'none';
    }
});

// 加载当前壁纸设置
function loadCurrentWallpaperSettings() {
    let headerBg = '';
    let navBg = '';
    let contentBg = '';
    
    if (currentPrivateSpaceContactId) {
        const dataKey = `privateSpace_${currentPrivateSpaceContactId}`;
        const savedData = localStorage.getItem(dataKey);
        if (savedData) {
            const data = JSON.parse(savedData);
            const wallpaperSettings = data.wallpaperSettings || {};
            headerBg = wallpaperSettings.header || '';
            navBg = wallpaperSettings.nav || '';
            contentBg = wallpaperSettings.content || '';
        }
    }
    
    document.getElementById('header-bg-input').value = headerBg;
    document.getElementById('nav-bg-input').value = navBg;
    document.getElementById('content-bg-input').value = contentBg;
    
    updateWallpaperPreviews();
}

// 保存壁纸设置到当前角色数据
function saveWallpaperSetting(type, url) {
    if (!currentPrivateSpaceContactId) {
        console.error('没有当前私人空间联系人ID');
        return false;
    }
    
    const dataKey = `privateSpace_${currentPrivateSpaceContactId}`;
    let data = {};
    
    // 获取现有数据
    const existingData = localStorage.getItem(dataKey);
    if (existingData) {
        data = JSON.parse(existingData);
    }
    
    // 确保wallpaperSettings对象存在
    if (!data.wallpaperSettings) {
        data.wallpaperSettings = {};
    }
    
    // 设置或清除壁纸
    if (url && url.trim()) {
        data.wallpaperSettings[type] = url.trim();
    } else {
        delete data.wallpaperSettings[type];
    }
    
    // 保存数据
    localStorage.setItem(dataKey, JSON.stringify(data));
    console.log(`壁纸设置已保存 - ${type}:`, url);
    
    return true;
}

// 更新壁纸预览
function updateWallpaperPreviews() {
    let headerBg = '';
    let navBg = '';
    let contentBg = '';
    
    if (currentPrivateSpaceContactId) {
        const dataKey = `privateSpace_${currentPrivateSpaceContactId}`;
        const savedData = localStorage.getItem(dataKey);
        if (savedData) {
            const data = JSON.parse(savedData);
            const wallpaperSettings = data.wallpaperSettings || {};
            headerBg = wallpaperSettings.header || '';
            navBg = wallpaperSettings.nav || '';
            contentBg = wallpaperSettings.content || '';
        }
    }
    
    document.getElementById('header-bg-preview').textContent = 
        headerBg ? `当前：${headerBg.substring(0, 50)}${headerBg.length > 50 ? '...' : ''}` : '当前：默认颜色 #e0f6ff';
    
    document.getElementById('nav-bg-preview').textContent = 
        navBg ? `当前：${navBg.substring(0, 50)}${navBg.length > 50 ? '...' : ''}` : '当前：默认白色背景';
    
    document.getElementById('content-bg-preview').textContent = 
        contentBg ? `当前：${contentBg.substring(0, 50)}${contentBg.length > 50 ? '...' : ''}` : '当前：默认白色背景';
}

// 设置头部背景
window.setHeaderBackground = function() {
    const url = document.getElementById('header-bg-input').value.trim();
    if (url) {
        try {
            // 保存到当前角色数据
            if (saveWallpaperSetting('header', url)) {
            const headerBox = document.querySelector('.private-space-header-box');
            if (headerBox) {
                headerBox.style.backgroundImage = `url(${url})`;
                headerBox.style.backgroundSize = 'cover';
                headerBox.style.backgroundPosition = 'center';
                console.log('头部背景设置成功:', url);
                alert('头部背景设置成功！');
            } else {
                console.error('未找到 .private-space-header-box 元素');
                alert('错误：未找到头部区域元素');
            }
            updateWallpaperPreviews();
            } else {
                alert('保存失败：请确保已选择角色');
            }
        } catch (error) {
            console.error('设置头部背景时出错:', error);
            alert('设置失败：' + error.message);
        }
    } else {
        alert('请输入有效的图片URL');
    }
};

// 重置头部背景
window.resetHeaderBackground = function() {
    // 从当前角色数据中清除
    saveWallpaperSetting('header', '');
    const headerBox = document.querySelector('.private-space-header-box');
    if (headerBox) {
        headerBox.style.backgroundImage = '';
        headerBox.style.background = '#e0f6ff';
    }
    document.getElementById('header-bg-input').value = '';
    updateWallpaperPreviews();
};

// 设置导航栏背景
window.setNavBackground = function() {
    const url = document.getElementById('nav-bg-input').value.trim();
    if (url) {
        try {
            // 保存到当前角色数据
            if (saveWallpaperSetting('nav', url)) {
            const navBox = document.querySelector('.private-space-nav-box');
            if (navBox) {
                navBox.style.backgroundImage = `url(${url})`;
                navBox.style.backgroundSize = 'cover';
                navBox.style.backgroundPosition = 'center';
                console.log('导航栏背景设置成功:', url);
                alert('导航栏背景设置成功！');
            } else {
                console.error('未找到 .private-space-nav-box 元素');
                alert('错误：未找到导航栏区域元素');
            }
            updateWallpaperPreviews();
            } else {
                alert('保存失败：请确保已选择角色');
            }
        } catch (error) {
            console.error('设置导航栏背景时出错:', error);
            alert('设置失败：' + error.message);
        }
    } else {
        alert('请输入有效的图片URL');
    }
};

// 重置导航栏背景
window.resetNavBackground = function() {
    // 从当前角色数据中清除
    saveWallpaperSetting('nav', '');
    const navBox = document.querySelector('.private-space-nav-box');
    if (navBox) {
        navBox.style.backgroundImage = '';
        navBox.style.background = 'white';
    }
    document.getElementById('nav-bg-input').value = '';
    updateWallpaperPreviews();
};

// 设置内容区域背景
window.setContentBackground = function() {
    const url = document.getElementById('content-bg-input').value.trim();
    if (url) {
        try {
            // 保存到当前角色数据
            if (saveWallpaperSetting('content', url)) {
            const contentBox = document.querySelector('.private-space-content');
            if (contentBox) {
                contentBox.style.backgroundImage = `url(${url})`;
                contentBox.style.backgroundSize = 'cover';
                contentBox.style.backgroundPosition = 'center';
                console.log('内容区域背景设置成功:', url);
                alert('内容区域背景设置成功！');
            } else {
                console.error('未找到 .private-space-content 元素');
                alert('错误：未找到内容区域元素');
            }
            updateWallpaperPreviews();
            } else {
                alert('保存失败：请确保已选择角色');
            }
        } catch (error) {
            console.error('设置内容区域背景时出错:', error);
            alert('设置失败：' + error.message);
        }
    } else {
        alert('请输入有效的图片URL');
    }
};

// 重置内容区域背景
window.resetContentBackground = function() {
    // 从当前角色数据中清除
    saveWallpaperSetting('content', '');
    const contentBox = document.querySelector('.private-space-content');
    if (contentBox) {
        contentBox.style.backgroundImage = '';
        contentBox.style.background = 'white';
    }
    document.getElementById('content-bg-input').value = '';
    updateWallpaperPreviews();
};

// 页面加载时应用保存的壁纸设置



// 5. 新增：恋爱空间返回按钮
document.getElementById('love-space-back-btn').addEventListener('click', () => {
    showMemoriesMainSelection();
});

// 5.1 新增：恋爱空间设置功能
document.getElementById('love-space-settings-btn').addEventListener('click', () => {
    document.getElementById('love-settings-menu').style.display = 'flex';
});

// DIY开关按钮事件
document.getElementById('diy-toggle-btn').addEventListener('click', () => {
    toggleDIYMode();
});

// 切换DIY模式
function toggleDIYMode() {
    isDIYMode = !isDIYMode;
    const toggleBtn = document.getElementById('diy-toggle-btn');
    const decorationLayer = document.getElementById('diy-decoration-layer');
    
    if (isDIYMode) {
        toggleBtn.classList.add('active');
        decorationLayer.classList.add('edit-mode');
    } else {
        toggleBtn.classList.remove('active');
        decorationLayer.classList.remove('edit-mode');
        // 取消选中状态
        if (selectedDecoration) {
            selectedDecoration.classList.remove('selected');
            selectedDecoration = null;
        }
        // 保存布局
        saveDIYLayout();
    }
}

// 显示DIY上传弹窗
window.showDIYUploadModal = function() {
    document.getElementById('diy-upload-modal').style.display = 'flex';
    // 清空输入框
    document.getElementById('decoration-url').value = '';
    document.getElementById('decoration-width').value = '100';
    document.getElementById('decoration-height').value = '100';
    document.getElementById('decoration-preview').style.display = 'none';
};

// 从设置页面切换DIY模式
window.toggleDIYModeFromSettings = function() {
    toggleDIYMode();
    // 关闭设置弹窗
    document.getElementById('love-settings-modal').style.display = 'none';
    // 刷新设置页面内容
    setTimeout(() => {
        if (document.getElementById('love-settings-modal').style.display !== 'none') {
            showSettingPage('diy-decoration');
        }
    }, 100);
};

// 关闭DIY上传弹窗
document.getElementById('close-diy-upload').addEventListener('click', () => {
    document.getElementById('diy-upload-modal').style.display = 'none';
});

document.getElementById('cancel-decoration').addEventListener('click', () => {
    document.getElementById('diy-upload-modal').style.display = 'none';
});

// URL输入预览
document.getElementById('decoration-url').addEventListener('input', (e) => {
    const url = e.target.value.trim();
    const preview = document.getElementById('decoration-preview');
    const previewImg = document.getElementById('preview-image');
    
    if (url) {
        previewImg.src = url;
        previewImg.onload = () => {
            preview.style.display = 'block';
        };
        previewImg.onerror = () => {
            preview.style.display = 'none';
        };
    } else {
        preview.style.display = 'none';
    }
});

// 添加装饰图片
document.getElementById('add-decoration').addEventListener('click', async () => {
    const url = document.getElementById('decoration-url').value.trim();
    const width = parseInt(document.getElementById('decoration-width').value) || 100;
    const height = parseInt(document.getElementById('decoration-height').value) || 100;
    
    if (!url) {
        alert('请输入图片URL');
        return;
    }
    
    // 计算屏幕居中位置
    const loveSpaceView = document.getElementById('love-space-view');
    const centerX = (loveSpaceView.offsetWidth - width) / 2;
    const centerY = (loveSpaceView.offsetHeight - height) / 2;
    
    await addDecorationItem(url, width, height, centerX, centerY);
    document.getElementById('diy-upload-modal').style.display = 'none';
});

// 关闭设置菜单
document.getElementById('close-love-settings').addEventListener('click', () => {
    document.getElementById('love-settings-menu').style.display = 'none';
});

// 关闭设置弹窗
document.getElementById('close-settings-modal').addEventListener('click', () => {
    document.getElementById('love-settings-modal').style.display = 'none';
});

// 点击背景关闭菜单
document.getElementById('love-settings-menu').addEventListener('click', (e) => {
    if (e.target === document.getElementById('love-settings-menu')) {
        document.getElementById('love-settings-menu').style.display = 'none';
    }
});

// 点击背景关闭弹窗
document.getElementById('love-settings-modal').addEventListener('click', (e) => {
    if (e.target === document.getElementById('love-settings-modal')) {
        document.getElementById('love-settings-modal').style.display = 'none';
    }
});

// 设置菜单项点击
document.querySelectorAll('.settings-menu-item').forEach(item => {
    item.addEventListener('click', () => {
        const setting = item.getAttribute('data-setting');
        showSettingPage(setting);
        document.getElementById('love-settings-menu').style.display = 'none';
    });
});

// 解除关系按钮事件委托
document.addEventListener('click', (e) => {
    if (e.target && e.target.getAttribute('data-action') === 'confirm-breakup') {
        confirmBreakup();
    } else if (e.target && e.target.getAttribute('data-action') === 'close-breakup') {
        closeBreakupModal();
    }
});

// 显示设置页面
function showSettingPage(settingType) {
    const modal = document.getElementById('love-settings-modal');
    const title = document.getElementById('settings-modal-title');
    const body = document.getElementById('settings-modal-body');
    
    switch(settingType) {
        case 'avatars':
            title.textContent = '双方头像设置';
            body.innerHTML = getAvatarSettingHTML();
            break;
        case 'wallpaper':
            title.textContent = '壁纸设置';
            body.innerHTML = getWallpaperSettingHTML();
            break;
        case 'diy-decoration':
            title.textContent = 'DIY装饰管理';
            body.innerHTML = getDIYDecorationSettingHTML();
            break;
        case 'checkin':
            title.textContent = '每天想你';
            body.innerHTML = getCheckinSettingHTML();
            break;
        case 'breakup':
            title.textContent = '解除关系';
            body.innerHTML = getBreakupSettingHTML();
            break;
    }
    
    modal.style.display = 'flex';
    
    // 加载已保存的设置到预览中
    if (settingType === 'avatars' || settingType === 'wallpaper') {
        setTimeout(() => {
            loadSavedSettingsPreview();
        }, 100); // 延迟一点确保DOM已渲染
    }
    
    // 绑定相应的事件监听器
    bindSettingEvents(settingType);
}

// 获取头像设置HTML
function getAvatarSettingHTML() {
    return `
        <div class="avatar-setting-section">
            <div class="avatar-upload-group">
                <h4>我的头像</h4>
                <div class="avatar-upload-area">
                    <div class="current-avatar" id="my-current-avatar">
                        <img src="" alt="我的头像" style="display: none;">
                        <div class="upload-placeholder">输入图片URL</div>
                    </div>
                    <input type="text" id="my-avatar-url-input" placeholder="请输入图片URL地址" style="width: 100%; margin: 10px 0; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <div class="upload-actions">
                        <button class="save-btn" onclick="saveAvatarFromUrl('my')">保存</button>
                        <button class="clear-btn" onclick="clearAvatar('my')">清除</button>
                    </div>
                </div>
            </div>
            
            <div class="avatar-upload-group">
                <h4>TA的头像</h4>
                <div class="avatar-upload-area">
                    <div class="current-avatar" id="partner-current-avatar">
                        <img src="" alt="TA的头像" style="display: none;">
                        <div class="upload-placeholder">输入图片URL</div>
                    </div>
                    <input type="text" id="partner-avatar-url-input" placeholder="请输入图片URL地址" style="width: 100%; margin: 10px 0; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <div class="upload-actions">
                        <button class="save-btn" onclick="saveAvatarFromUrl('partner')">保存</button>
                        <button class="clear-btn" onclick="clearAvatar('partner')">清除</button>
                    </div>
                </div>
            </div>
        </div>
        
        <style>
        .avatar-setting-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .avatar-upload-group h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .avatar-upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .current-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px dashed #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
            position: relative;
        }
        
        .current-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .upload-placeholder {
            font-size: 12px;
            color: #999;
            text-align: center;
            padding: 5px;
        }
        

        
        .upload-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .save-btn, .clear-btn {
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .save-btn {
            background: #28a745;
            color: white;
        }
        
        .save-btn:hover {
            background: #1e7e34;
        }
        
        .clear-btn {
            background: #6c757d;
            color: white;
        }
        
        .clear-btn:hover {
            background: #545b62;
        }
        </style>
    `;
}

// 获取壁纸设置HTML
function getWallpaperSettingHTML() {
    return `
        <div class="wallpaper-setting-section">
            <div class="wallpaper-group">
                <h4>主页壁纸</h4>
                <div class="wallpaper-upload-area">
                    <div class="current-wallpaper" id="home-wallpaper-preview">
                        <img src="" alt="主页壁纸" style="display: none;">
                        <div class="wallpaper-placeholder">输入图片URL</div>
                    </div>
                    <input type="text" id="home-wallpaper-url-input" placeholder="请输入图片URL地址" style="width: 100%; margin: 10px 0; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <div class="upload-actions">
                        <button class="save-btn" onclick="saveWallpaperFromUrl('home')">保存</button>
                        <button class="clear-btn" onclick="clearWallpaper('home')">清除</button>
                    </div>
                </div>
            </div>
            
            <div class="wallpaper-group">
                <h4>底部导航栏壁纸</h4>
                <div class="wallpaper-upload-area">
                    <div class="current-wallpaper" id="nav-wallpaper-preview">
                        <img src="" alt="导航栏壁纸" style="display: none;">
                        <div class="wallpaper-placeholder">输入图片URL</div>
                    </div>
                    <input type="text" id="nav-wallpaper-url-input" placeholder="请输入图片URL地址" style="width: 100%; margin: 10px 0; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <div class="upload-actions">
                        <button class="save-btn" onclick="saveWallpaperFromUrl('nav')">保存</button>
                        <button class="clear-btn" onclick="clearWallpaper('nav')">清除</button>
                    </div>
                </div>
            </div>
        </div>
        
        <style>
        .wallpaper-setting-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .wallpaper-group h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .wallpaper-upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .current-wallpaper {
            width: 200px;
            height: 100px;
            border: 2px dashed #ddd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
            position: relative;
        }
        
        .current-wallpaper img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }
        
        .wallpaper-placeholder {
            font-size: 12px;
            color: #999;
            text-align: center;
            padding: 5px;
        }
        
        .upload-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .save-btn, .clear-btn {
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .save-btn {
            background: #28a745;
            color: white;
        }
        
        .save-btn:hover {
            background: #1e7e34;
        }
        
        .clear-btn {
            background: #6c757d;
            color: white;
        }
        
        .clear-btn:hover {
            background: #545b62;
        }
        </style>
    `;
}

// 获取DIY装饰设置HTML
function getDIYDecorationSettingHTML() {
    const decorationCount = decorationItems.length;
    
    return `
        <div class="diy-decoration-setting-section">
            <div class="diy-info-panel">
                <h4>装饰管理</h4>
                <p>当前已添加 <strong>${decorationCount}</strong> 个装饰元素</p>
                <div class="diy-actions">
                    <button class="diy-btn add-decoration-btn" onclick="showDIYUploadModal()">
                        <span>✨</span> 添加新装饰
                    </button>
                    <button class="diy-btn toggle-edit-btn" onclick="toggleDIYModeFromSettings()">
                        <span>✏️</span> ${isDIYMode ? '退出编辑' : '进入编辑'}
                    </button>
                </div>
            </div>
            
            <div class="decoration-list" id="decoration-list">
                <h4>装饰列表</h4>
                ${decorationCount === 0 ? 
                    '<p class="no-decorations">暂无装饰元素，点击上方按钮添加</p>' : 
                    generateDecorationListHTML()
                }
            </div>
            
            <div class="diy-tips">
                <h4>使用说明</h4>
                <ul>
                    <li>✨ 点击"DIY装饰模式"按钮开启编辑模式</li>
                    <li>📱 在编辑模式下可以拖拽、调整大小、旋转图片</li>
                    <li>🔄 点击图片显示的控制按钮进行层级、翻转等操作</li>
                    <li>💾 关闭编辑模式时会自动保存布局</li>
                    <li>🚫 关闭编辑模式后装饰会固定，无法操作</li>
                </ul>
            </div>
            
            <div class="diy-danger-zone">
                <h4 style="color: #dc3545;">危险操作</h4>
                <button class="diy-btn danger-btn" onclick="clearAllDecorations()">
                    <span>🗑️</span> 清空所有装饰
                </button>
            </div>
        </div>
        
        <style>
        .diy-decoration-setting-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .diy-info-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .diy-info-panel h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .diy-info-panel p {
            margin: 0 0 15px 0;
            color: #666;
        }
        
        .diy-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .diy-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .add-decoration-btn {
            background: #ff6b9d;
            color: white;
        }
        
        .add-decoration-btn:hover {
            background: #ff5a8a;
        }
        
        .toggle-edit-btn {
            background: #6c757d;
            color: white;
        }
        
        .toggle-edit-btn:hover {
            background: #545b62;
        }
        
        .decoration-list {
            background: #fff;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
        }
        
        .decoration-list h4 {
            margin: 0 0 15px 0;
            color: #333;
        }
        
        .no-decorations {
            text-align: center;
            color: #999;
            font-style: italic;
            margin: 20px 0;
        }
        
        .decoration-item-row {
            display: flex;
            align-items: center;
            padding: 10px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            margin-bottom: 8px;
            background: #f8f9fa;
        }
        
        .decoration-preview {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            object-fit: cover;
            margin-right: 12px;
        }
        
        .decoration-info {
            flex-grow: 1;
        }
        
        .decoration-url {
            font-size: 12px;
            color: #666;
            word-break: break-all;
            margin-bottom: 4px;
        }
        
        .decoration-size {
            font-size: 11px;
            color: #999;
        }
        
        .decoration-actions {
            display: flex;
            gap: 5px;
        }
        
        .decoration-action-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .select-btn {
            background: #007bff;
            color: white;
        }
        
        .delete-decoration-btn {
            background: #dc3545;
            color: white;
        }
        
        .diy-tips {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #b3d9ff;
        }
        
        .diy-tips h4 {
            margin: 0 0 10px 0;
            color: #0056b3;
        }
        
        .diy-tips ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .diy-tips li {
            margin-bottom: 5px;
            color: #333;
            font-size: 13px;
        }
        
        .diy-danger-zone {
            background: #fff5f5;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ffebee;
        }
        
        .diy-danger-zone h4 {
            margin: 0 0 10px 0;
        }
        
        .danger-btn {
            background: #dc3545;
            color: white;
        }
        
        .danger-btn:hover {
            background: #c82333;
        }
        </style>
    `;
}

// 生成装饰列表HTML
function generateDecorationListHTML() {
    return decorationItems.map((item, index) => `
        <div class="decoration-item-row">
            <img src="${item.url}" alt="装饰${index + 1}" class="decoration-preview" onerror="this.style.display='none'">
            <div class="decoration-info">
                <div class="decoration-url">${item.url.length > 50 ? item.url.substring(0, 50) + '...' : item.url}</div>
                <div class="decoration-size">${item.width}×${item.height}px</div>
            </div>
            <div class="decoration-actions">
                <button class="decoration-action-btn select-btn" onclick="selectDecorationById('${item.id}')" title="选中">👁</button>
                <button class="decoration-action-btn delete-decoration-btn" onclick="deleteDecorationById('${item.id}')" title="删除">×</button>
            </div>
        </div>
    `).join('');
}


// 通过ID选中装饰
window.selectDecorationById = function(itemId) {
    const item = document.getElementById(itemId);
    if (item) {
        if (!isDIYMode) {
            toggleDIYMode();
        }
        selectDecoration(item);
        // 关闭设置弹窗
        document.getElementById('love-settings-modal').style.display = 'none';
    }
}

// 通过ID删除装饰
window.deleteDecorationById = function(itemId) {
    const item = document.getElementById(itemId);
    const decorationData = decorationItems.find(d => d.id === itemId);
    if (item && decorationData) {
        deleteDecoration(item, decorationData);
        // 刷新设置页面
        showSettingPage('diy-decoration');
    }
}

// 清空所有装饰
async function clearAllDecorations() {
    if (confirm('确定要清空所有装饰吗？此操作不可撤销！')) {
        console.log('🗑️ [clearAllDecorations] 开始清空所有装饰...');
        
        // 清空DOM
        const decorationLayer = document.getElementById('diy-decoration-layer');
        decorationLayer.innerHTML = '';
        
        // 清空数据
        decorationItems = [];
        selectedDecoration = null;
        
        // 清空IndexedDB
        try {
            await db.diyDecorations.clear();
            console.log('✅ [clearAllDecorations] IndexedDB清空成功');
        } catch (error) {
            console.error('❌ [clearAllDecorations] IndexedDB清空失败:', error);
        }
        
        // 清空localStorage备份
        localStorage.removeItem('loveSpaceDIYLayout');
        console.log('✅ [clearAllDecorations] localStorage清空成功');
        
        // 刷新设置页面
        showSettingPage('diy-decoration');
        
        alert('所有装饰已清空');
    }
}

// 获取每天想你HTML
function getCheckinSettingHTML() {
    const checkinData = getCheckinData();
    const userConsecutiveDays = checkinData.userConsecutiveDays || 0;
    const aiConsecutiveDays = checkinData.aiConsecutiveDays || 0;
    
    // 获取恋爱空间绑定的AI角色名
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    const aiName = boundCharId && state.chats[boundCharId] ? state.chats[boundCharId].name : 'TA';
    
    return `
        <div class="checkin-setting-section">
            <div class="checkin-avatar-section">
                <div class="checkin-avatar-item">
                    <div class="avatar-container">
                        <img src="${getUserAvatar()}" alt="我的头像" class="checkin-avatar">
                        ${hasCheckedInToday(checkinData.userLastCheckin) ? '<div class="checkin-badge">✓</div>' : '<div class="checkin-badge gray">○</div>'}
                    </div>
                    <div class="avatar-label">我</div>
                </div>
                
                <div class="heart-divider">💕</div>
                
                <div class="checkin-avatar-item">
                    <div class="avatar-container">
                        <img src="${getAIAvatar()}" alt="${aiName}的头像" class="checkin-avatar">
                        ${hasCheckedInToday(checkinData.aiLastCheckin) ? '<div class="checkin-badge">✓</div>' : '<div class="checkin-badge gray">○</div>'}
                    </div>
                    <div class="avatar-label">${aiName}</div>
                </div>
            </div>
            
            <div class="checkin-stats">
                <div class="stat-row">
                    <span>我连续打卡：<strong>${userConsecutiveDays}</strong> 天</span>
                </div>
                <div class="stat-row">
                    <span>${aiName}连续打卡：<strong>${aiConsecutiveDays}</strong> 天</span>
                </div>
            </div>
            
            <div id="checkin-view-container">
                <!-- 日历默认显示在这里 -->
            </div>
        </div>
        
        <style>
        .checkin-setting-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
            text-align: center;
        }
        
        .checkin-header {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .big-heart {
            font-size: 48px;
            color: #ff6b6b;
            animation: heartbeat 1.5s ease-in-out infinite;
        }
        
        @keyframes heartbeat {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .checkin-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .stat-row {
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            color: #333;
        }
        
        .checkin-calendar h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            max-width: 280px;
            margin: 0 auto;
        }
        
        .calendar-day {
            width: 32px;
            height: 32px;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            position: relative;
        }
        
        .calendar-day.checked {
            background: linear-gradient(45deg, #4fc3f7, #29b6f6);
            color: white;
            position: relative;
            overflow: hidden;
        }
        
        .calendar-day.checked::after {
            content: '♥';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            animation: wave 2s ease-in-out infinite;
        }
        
        @keyframes wave {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
        }
        
        .calendar-day.unchecked {
            background: #f8f9fa;
            color: #999;
        }
        
        .checkin-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
        }
        
        .checkin-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 107, 107, 0.4);
        }
        
        /* 新增的头像选择区域样式 */
        .checkin-avatar-section {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
        }
        
        .checkin-avatar-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .checkin-avatar-item:hover {
            transform: scale(1.05);
        }
        
        .checkin-avatar-item.active .checkin-avatar {
            border: 3px solid #ff69b4;
            box-shadow: 0 0 10px rgba(255, 105, 180, 0.3);
        }
        
        .checkin-avatar-item.active .avatar-label {
            color: #ff69b4;
            font-weight: bold;
        }
        
        .avatar-container {
            position: relative;
            margin-bottom: 8px;
        }
        
        .checkin-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #e9ecef;
        }
        
        .checkin-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4cd964;
            color: white;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
        }
        
        .checkin-badge.gray {
            background: #ccc;
        }
        
        .avatar-label {
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }
        
        .heart-divider {
            font-size: 24px;
            animation: heartbeat 1.5s ease-in-out infinite;
        }
        
        /* 打卡详情视图样式 */
        .checkin-detail-view {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .checkin-detail-view h4 {
            margin: 0 0 15px 0;
            text-align: center;
            color: #333;
            font-size: 16px;
        }
        
        /* 日历容器样式 */
        .calendar-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: 15px;
        }
        
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 10px;
        }
        
        .calendar-nav-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            color: #666;
            transition: all 0.2s;
        }
        
        .calendar-nav-btn:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .calendar-month-year {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            text-align: center;
            min-width: 150px;
        }
        
        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .calendar-weekday {
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            padding: 8px 0;
        }
        
        .calendar-days {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
        }
        
        .calendar-day {
            width: 40px;
            height: 40px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            background: white;
        }
        
        .calendar-day:hover {
            border-color: #ff9a9e;
            background: #fff5f5;
        }
        
        .calendar-day.other-month {
            color: #ccc;
            background: #f8f9fa;
        }
        
        .calendar-day.today {
            border: 2px solid #ff4757 !important;
            font-weight: 600;
            box-shadow: 0 0 5px rgba(255, 71, 87, 0.3);
        }
        
        .calendar-day.user-checked {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
            color: white;
            border-color: #ff9a9e;
        }
        
        .calendar-day.ai-checked {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
            color: #333;
            border-color: #a8edea;
        }
        
        .calendar-day.both-checked {
            background: linear-gradient(45deg, #ffecd2, #fcb69f);
            color: #333;
            border-color: #fcb69f;
        }
        
        .calendar-day.before-start {
            background: #f8f9fa;
            color: #ccc;
            cursor: not-allowed;
        }
        
        .calendar-day::after {
            content: '';
            position: absolute;
            top: 2px;
            right: 2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .calendar-day.user-checked::after {
            background: #ff4757;
            content: '♥';
            font-size: 6px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 10px;
            height: 10px;
        }
        
        .calendar-day.ai-checked::after {
            background: #2ed573;
            content: '🤖';
            font-size: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 10px;
            height: 10px;
        }
        
        .calendar-day.both-checked::after {
            background: #ffa502;
            content: '💕';
            font-size: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 10px;
            height: 10px;
        }
        
        .calendar-legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
        
        .legend-user {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
        }
        
        .legend-ai {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
        }
        
        .legend-both {
            background: linear-gradient(45deg, #ffecd2, #fcb69f);
        }
        
        .legend-today {
            border: 2px solid #ff4757;
            background: #f8f9fa;
        }
        </style>
    `;
}

// 获取解除关系HTML
function getBreakupSettingHTML() {
    return `
        <div class="breakup-setting-section">
            <div class="breakup-warning">
                <div class="warning-icon">⚠️</div>
                <h4>解除恋爱关系</h4>
                <p>此操作将会：</p>
                <ul class="warning-list">
                    <li>清空所有打卡记录</li>
                    <li>重置连续天数</li>
                    <li>解除恋爱空间绑定</li>
                    <li>保留相册中的照片</li>
                </ul>
                <p class="warning-note">⚠️ 此操作不可撤销，请谨慎考虑</p>
            </div>
            
            <div class="breakup-actions">
                <button class="cancel-btn" data-action="close-breakup">取消</button>
                <button class="confirm-btn" data-action="confirm-breakup">确认解除</button>
            </div>
        </div>
        
        <style>
        .breakup-setting-section {
            display: flex;
            flex-direction: column;
            gap: 30px;
            text-align: center;
            padding: 20px;
        }
        
        .breakup-warning {
            background: #fff5f5;
            border: 2px solid #fed7d7;
            border-radius: 12px;
            padding: 25px;
            color: #2d3748;
        }
        
        .warning-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .breakup-warning h4 {
            color: #e53e3e;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .warning-list {
            text-align: left;
            margin: 15px 0;
            padding-left: 20px;
        }
        
        .warning-list li {
            margin: 8px 0;
            color: #4a5568;
        }
        
        .warning-note {
            background: #fed7d7;
            color: #c53030;
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: bold;
        }
        
        .breakup-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .cancel-btn {
            background: #e2e8f0;
            color: #4a5568;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
        }
        
        .cancel-btn:hover {
            background: #cbd5e0;
        }
        
        .confirm-btn {
            background: linear-gradient(45deg, #e53e3e, #c53030);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }
        
        .confirm-btn:hover {
            background: linear-gradient(45deg, #c53030, #9c2626);
            transform: translateY(-1px);
        }
        </style>
    `;
}

// 图片压缩函数
function compressImage(file, maxWidth, maxHeight, quality, callback) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    img.onload = function() {
        // 计算压缩后的尺寸
        let { width, height } = img;
        
        if (width > height) {
            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
        } else {
            if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
            }
        }
        
        // 设置canvas尺寸
        canvas.width = width;
        canvas.height = height;
        
        // 绘制压缩后的图片
        ctx.drawImage(img, 0, 0, width, height);
        
        // 转换为数据URL
        const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
        callback(compressedDataUrl);
    };
    
    img.onerror = function() {
        alert('图片加载失败，请选择其他图片');
    };
    
    // 读取文件
    const reader = new FileReader();
    reader.onload = function(e) {
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

// 绑定设置事件
function bindSettingEvents(settingType) {
    if (settingType === 'avatars') {
        // 头像设置已改为URL输入方式，不再需要文件上传事件监听器
        // 加载已有头像
        loadExistingAvatars();
    } else if (settingType === 'wallpaper') {
        // 壁纸设置已改为URL输入方式，不再需要文件上传事件监听器
        // 加载已有壁纸
        loadExistingWallpapers();
    } else if (settingType === 'checkin') {
        // 初始化每天想你弹窗，默认显示用户的打卡日历
        setTimeout(() => {
            showCheckinView('user');
        }, 100); // 延迟确保DOM已渲染
    }
}

// 加载已有头像
function loadExistingAvatars() {
    const myAvatar = localStorage.getItem(USER_AVATAR_KEY);
    const partnerAvatar = localStorage.getItem(AI_AVATAR_KEY);
    
    console.log('加载设置界面已有头像:', { myAvatar: myAvatar ? '有数据' : '无数据', partnerAvatar: partnerAvatar ? '有数据' : '无数据' });
    
    if (myAvatar) {
        const preview = document.getElementById('my-current-avatar');
        const img = preview.querySelector('img');
        const placeholder = preview.querySelector('.upload-placeholder');
        
        img.src = myAvatar;
        img.style.display = 'block';
        placeholder.style.display = 'none';
        tempAvatars['my'] = myAvatar; // 同步到临时存储
    }
    
    if (partnerAvatar) {
        const preview = document.getElementById('partner-current-avatar');
        const img = preview.querySelector('img');
        const placeholder = preview.querySelector('.upload-placeholder');
        
        img.src = partnerAvatar;
        img.style.display = 'block';
        placeholder.style.display = 'none';
        tempAvatars['partner'] = partnerAvatar; // 同步到临时存储
    }
}

// 加载已有壁纸
function loadExistingWallpapers() {
    const homeWallpaper = localStorage.getItem(HOME_WALLPAPER_KEY);
    const navWallpaper = localStorage.getItem(CHAT_WALLPAPER_KEY);
    
    if (homeWallpaper) {
        const preview = document.getElementById('home-wallpaper-preview');
        const img = preview.querySelector('img');
        const placeholder = preview.querySelector('.wallpaper-placeholder');
        
        img.src = homeWallpaper;
        img.style.display = 'block';
        placeholder.style.display = 'none';
        tempWallpapers['home'] = homeWallpaper; // 同步到临时存储
    }
    
    if (navWallpaper) {
        const preview = document.getElementById('nav-wallpaper-preview');
        const img = preview.querySelector('img');
        const placeholder = preview.querySelector('.wallpaper-placeholder');
        
        img.src = navWallpaper;
        img.style.display = 'block';
        placeholder.style.display = 'none';
        tempWallpapers['nav'] = navWallpaper; // 同步到临时存储
    }
}

// 旧的saveAvatar函数已被saveAvatarFromUrl替代，不再需要

// 清除头像
function clearAvatar(type) {
    if (confirm('确定要清除头像吗？')) {
        // 使用正确的localStorage键名 - 支持 'my' 和 'partner' 两种类型
        const storageKey = type === 'my' ? USER_AVATAR_KEY : AI_AVATAR_KEY;
        localStorage.removeItem(storageKey);
        
        // 清除临时存储
        delete tempAvatars[type];
        
        // 重置预览
        const preview = document.getElementById(`${type}-current-avatar`);
        const img = preview.querySelector('img');
        const placeholder = preview.querySelector('.upload-placeholder');
        
        img.style.display = 'none';
        placeholder.style.display = 'block';
        
        // 重置URL输入
        const urlInput = document.getElementById(`${type}-avatar-url-input`);
        if (urlInput) {
            urlInput.value = '';
        }
        
        // 更新恋爱空间显示
        loadSavedAvatars();
        
        alert('头像已清除');
    }
}

// 立即将clearAvatar函数挂载到全局作用域，确保HTML中的onclick可以访问到
window.clearAvatar = clearAvatar;

// 旧的saveWallpaper函数已被saveWallpaperFromUrl替代，不再需要

// 清除壁纸
function clearWallpaper(type) {
    if (confirm('确定要清除壁纸吗？')) {
        // 清除localStorage
        localStorage.removeItem(`${type}Wallpaper`);
        
        // 清除临时存储
        delete tempWallpapers[type];
        
        // 重置预览
        const preview = document.getElementById(`${type}-wallpaper-preview`);
        const img = preview.querySelector('img');
        const placeholder = preview.querySelector('.wallpaper-placeholder');
        
        img.style.display = 'none';
        placeholder.style.display = 'block';
        
        // 重置URL输入
        const urlInput = document.getElementById(`${type}-wallpaper-url-input`);
        if (urlInput) {
            urlInput.value = '';
        }
        
        // 移除应用的壁纸
        applyWallpaper(type, null);
        
        alert('壁纸已清除');
    }
}

// 立即将clearWallpaper函数挂载到全局作用域
window.clearWallpaper = clearWallpaper;

// 基于URL的头像保存函数
function saveAvatarFromUrl(type) {
    const inputId = `${type}-avatar-url-input`;
    const input = document.getElementById(inputId);
    const url = input.value.trim();
    const storageKey = type === 'my' ? USER_AVATAR_KEY : AI_AVATAR_KEY;
    
    // 如果输入框为空，清除头像设置
    if (!url) {
        try {
            localStorage.removeItem(storageKey);
            console.log(`头像已清除: ${storageKey} (type: ${type})`);
            
            // 更新预览为默认状态
            const preview = document.getElementById(`${type}-current-avatar`);
            const previewImg = preview.querySelector('img');
            const placeholder = preview.querySelector('.upload-placeholder');
            
            previewImg.style.display = 'none';
            placeholder.style.display = 'block';
            
            // 更新恋爱空间中的头像显示
            loadSavedAvatars();
            
            alert('头像已清除！');
        } catch (error) {
            console.error('清除头像失败:', error);
            alert('操作失败，请重试');
        }
        return;
    }
    
    // 验证URL格式
    try {
        new URL(url);
    } catch (e) {
        alert('请输入有效的URL地址');
        return;
    }
    
    // 测试图片是否可以加载
    const img = new Image();
    img.onload = function() {
        try {
            localStorage.setItem(storageKey, url);
            console.log(`头像已保存: ${storageKey} (type: ${type})`, url);
            
            // 更新预览
            const preview = document.getElementById(`${type}-current-avatar`);
            const previewImg = preview.querySelector('img');
            const placeholder = preview.querySelector('.upload-placeholder');
            
            previewImg.src = url;
            previewImg.style.display = 'block';
            placeholder.style.display = 'none';
            
            // 更新恋爱空间中的头像显示
            loadSavedAvatars();
            
            alert('头像保存成功！');
        } catch (error) {
            console.error('保存头像失败:', error);
            alert('保存失败，请重试');
        }
    };
    
    img.onerror = function() {
        alert('无法加载该图片，请检查URL是否正确');
    };
    
    img.src = url;
}

// 立即将saveAvatarFromUrl函数挂载到全局作用域
window.saveAvatarFromUrl = saveAvatarFromUrl;

// 基于URL的壁纸保存函数
function saveWallpaperFromUrl(type) {
    const inputId = `${type}-wallpaper-url-input`;
    const input = document.getElementById(inputId);
    const url = input.value.trim();
    const storageKey = type === 'home' ? HOME_WALLPAPER_KEY : CHAT_WALLPAPER_KEY;
    
    // 如果输入框为空，清除壁纸设置
    if (!url) {
        try {
            localStorage.removeItem(storageKey);
            console.log(`壁纸已清除: ${storageKey} (type: ${type})`);
            
            // 更新预览为默认状态
            const preview = document.getElementById(`${type}-wallpaper-preview`);
            const previewImg = preview.querySelector('img');
            const placeholder = preview.querySelector('.wallpaper-placeholder');
            
            previewImg.style.display = 'none';
            placeholder.style.display = 'block';
            
            // 移除壁纸应用
            applyWallpaper(type, null);
            
            alert('壁纸已清除！');
        } catch (error) {
            console.error('清除壁纸失败:', error);
            alert('操作失败，请重试');
        }
        return;
    }
    
    // 验证URL格式
    try {
        new URL(url);
    } catch (e) {
        alert('请输入有效的URL地址');
        return;
    }
    
    // 测试图片是否可以加载
    const img = new Image();
    img.onload = function() {
        try {
            localStorage.setItem(storageKey, url);
            console.log(`壁纸已保存: ${storageKey}`, url);
            
            // 更新预览
            const preview = document.getElementById(`${type}-wallpaper-preview`);
            const previewImg = preview.querySelector('img');
            const placeholder = preview.querySelector('.wallpaper-placeholder');
            
            previewImg.src = url;
            previewImg.style.display = 'block';
            placeholder.style.display = 'none';
            
            // 应用壁纸
            applyWallpaper(type, url);
            
            alert('壁纸保存成功！');
        } catch (error) {
            console.error('保存壁纸失败:', error);
            alert('保存失败，请重试');
        }
    };
    
    img.onerror = function() {
        alert('无法加载该图片，请检查URL是否正确');
    };
    
    img.src = url;
}

// 立即将saveWallpaperFromUrl函数挂载到全局作用域
window.saveWallpaperFromUrl = saveWallpaperFromUrl;

// 加载已保存的头像和壁纸到设置界面
function loadSavedSettingsPreview() {
    // 加载头像预览
    const userAvatar = localStorage.getItem(USER_AVATAR_KEY);
    const aiAvatar = localStorage.getItem(AI_AVATAR_KEY);
    
    if (userAvatar) {
        const preview = document.getElementById('my-current-avatar');
        const urlInput = document.getElementById('my-avatar-url-input');
        if (preview && urlInput) {
            const img = preview.querySelector('img');
            const placeholder = preview.querySelector('.upload-placeholder');
            
            img.src = userAvatar;
            img.style.display = 'block';
            placeholder.style.display = 'none';
            urlInput.value = userAvatar;
        }
    }
    
    if (aiAvatar) {
        const preview = document.getElementById('partner-current-avatar');
        const urlInput = document.getElementById('partner-avatar-url-input');
        if (preview && urlInput) {
            const img = preview.querySelector('img');
            const placeholder = preview.querySelector('.upload-placeholder');
            
            img.src = aiAvatar;
            img.style.display = 'block';
            placeholder.style.display = 'none';
            urlInput.value = aiAvatar;
        }
    }
    
    // 加载壁纸预览
    const homeWallpaper = localStorage.getItem(HOME_WALLPAPER_KEY);
    const navWallpaper = localStorage.getItem(CHAT_WALLPAPER_KEY);
    
    if (homeWallpaper) {
        const preview = document.getElementById('home-wallpaper-preview');
        const urlInput = document.getElementById('home-wallpaper-url-input');
        if (preview && urlInput) {
            const img = preview.querySelector('img');
            const placeholder = preview.querySelector('.wallpaper-placeholder');
            
            img.src = homeWallpaper;
            img.style.display = 'block';
            placeholder.style.display = 'none';
            urlInput.value = homeWallpaper;
        }
    }
    
    if (navWallpaper) {
        const preview = document.getElementById('nav-wallpaper-preview');
        const urlInput = document.getElementById('nav-wallpaper-url-input');
        if (preview && urlInput) {
            const img = preview.querySelector('img');
            const placeholder = preview.querySelector('.wallpaper-placeholder');
            
            img.src = navWallpaper;
            img.style.display = 'block';
            placeholder.style.display = 'none';
            urlInput.value = navWallpaper;
        }
    }
}

// 立即将loadSavedSettingsPreview函数挂载到全局作用域
window.loadSavedSettingsPreview = loadSavedSettingsPreview;

// 处理头像上传 - 保留但不再使用
// 临时存储上传的图片
let tempAvatars = {};

function handleAvatarUpload(event, type) {
    const file = event.target.files[0];
    if (file) {
        // 检查文件大小
        if (file.size > 5 * 1024 * 1024) { // 5MB
            alert('图片文件过大，请选择小于5MB的图片');
            return;
        }
        
        compressImage(file, 200, 200, 0.8, (compressedDataUrl) => {
            // 临时存储
            tempAvatars[type] = compressedDataUrl;
            
            // 更新预览
            const preview = document.getElementById(`${type}-current-avatar`);
            const img = preview.querySelector('img');
            const placeholder = preview.querySelector('.upload-placeholder');
            
            img.src = compressedDataUrl;
            img.style.display = 'block';
            placeholder.style.display = 'none';
        });
    }
}

// 处理壁纸上传
// 临时存储上传的壁纸
let tempWallpapers = {};

function handleWallpaperUpload(event, type) {
    const file = event.target.files[0];
    if (file) {
        // 检查文件大小
        if (file.size > 10 * 1024 * 1024) { // 10MB
            alert('图片文件过大，请选择小于10MB的图片');
            return;
        }
        
        // 壁纸压缩到更大尺寸但降低质量
        const maxWidth = type === 'home' ? 800 : 600;
        const maxHeight = type === 'home' ? 600 : 300;
        
        compressImage(file, maxWidth, maxHeight, 0.7, (compressedDataUrl) => {
            // 临时存储
            tempWallpapers[type] = compressedDataUrl;
            
            // 更新预览
            const preview = document.getElementById(`${type}-wallpaper-preview`);
            const img = preview.querySelector('img');
            const placeholder = preview.querySelector('.wallpaper-placeholder');
            
            img.src = compressedDataUrl;
            img.style.display = 'block';
            placeholder.style.display = 'none';
        });
    }
}

// 应用壁纸
// 更新恋爱空间头像显示
function updateLoveSpaceAvatars() {
    const myAvatar = localStorage.getItem('loveSpaceUserAvatar');
    const partnerAvatar = localStorage.getItem('loveSpaceAIAvatar');
    
    // 更新恋爱空间中的头像显示
    if (myAvatar) {
        const userAvatarEl = document.getElementById('user-avatar');
        if (userAvatarEl) {
            userAvatarEl.src = myAvatar;
        }
        
        // 同时更新音乐播放器中的用户头像
        const musicUserAvatarEl = document.getElementById('music-user-avatar');
        if (musicUserAvatarEl) {
            musicUserAvatarEl.src = myAvatar;
        }
    }
    
    if (partnerAvatar) {
        const aiAvatarEl = document.getElementById('ai-avatar');
        if (aiAvatarEl) {
            aiAvatarEl.src = partnerAvatar;
        }
    }
}

// 计算恋爱天数
function calculateLoveDays(bindDate) {
    if (bindDate === '未设置') return '未设置';
    
    const bind = new Date(bindDate);
    const now = new Date();
    const diffTime = Math.abs(now - bind);
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays + ' 天';
}

// 确认解除绑定
function confirmUnbind() {
    if (confirm('确定要解除情侣关系吗？此操作不可撤销。')) {
        localStorage.removeItem('loveBindDate');
        localStorage.removeItem('myAvatar');
        localStorage.removeItem('partnerAvatar');
        localStorage.removeItem('myCheckinDays');
        localStorage.removeItem('partnerCheckinDays');
        localStorage.removeItem('checkinHistory');
        alert('已解除情侣关系');
        document.getElementById('love-settings-modal').style.display = 'none';
    }
}

// 生成打卡日历
function generateCheckinCalendar() {
    const calendarGrid = document.getElementById('checkin-calendar-grid');
    const today = new Date();
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
    const firstDay = new Date(currentYear, currentMonth, 1);
    const lastDay = new Date(currentYear, currentMonth + 1, 0);
    const checkinHistory = JSON.parse(localStorage.getItem('checkinHistory') || '{}');
    
    // 清空日历
    calendarGrid.innerHTML = '';
    
    // 添加星期标题
    const weekDays = ['日', '一', '二', '三', '四', '五', '六'];
    weekDays.forEach(day => {
        const dayElement = document.createElement('div');
        dayElement.textContent = day;
        dayElement.style.fontWeight = 'bold';
        dayElement.style.background = '#e9ecef';
        dayElement.className = 'calendar-day';
        calendarGrid.appendChild(dayElement);
    });
    
    // 添加空白天数
    for (let i = 0; i < firstDay.getDay(); i++) {
        const emptyDay = document.createElement('div');
        emptyDay.className = 'calendar-day';
        calendarGrid.appendChild(emptyDay);
    }
    
    // 添加日期
    for (let day = 1; day <= lastDay.getDate(); day++) {
        const dayElement = document.createElement('div');
        dayElement.textContent = day;
        dayElement.className = 'calendar-day';
        
        const dateKey = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        
        if (checkinHistory[dateKey]) {
            dayElement.classList.add('checked');
        } else {
            dayElement.classList.add('unchecked');
        }
        
        calendarGrid.appendChild(dayElement);
    }
}

// 执行打卡
function doCheckin() {
    const today = new Date();
    const dateKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
    const checkinHistory = JSON.parse(localStorage.getItem('checkinHistory') || '{}');
    
    if (checkinHistory[dateKey]) {
        alert('今天已经打卡过了！');
        return;
    }
    
    checkinHistory[dateKey] = true;
    localStorage.setItem('checkinHistory', JSON.stringify(checkinHistory));
    
    // 更新总打卡天数（计算实际打卡的天数）
    const checkinHistoryData = JSON.parse(localStorage.getItem('checkinHistory') || '{}');
    const totalCheckinDays = Object.keys(checkinHistoryData).length; // 计算实际打卡的天数
    
    alert('打卡成功！');
    
    // 重新生成日历
    generateCheckinCalendar();
    
    // 更新统计显示
    const statRow = document.querySelector('.stat-row');
    if (statRow) {
        statRow.innerHTML = `我总共想他：<strong>${totalCheckinDays}</strong> 天`;
    }
}



// 6. 新增：私人空间返回按钮
document.getElementById('private-space-back-btn').addEventListener('click', () => {
    // 保存当前数据
    window.saveCurrentPrivateSpaceData();
    
    showMemoriesMainSelection();
});

// 注释：绑定角色按钮已删除，现在通过点击AI头像进行邀请
// document.getElementById('bind-char-btn').addEventListener('click', () => {
//     handleCharacterBinding();
// });

// 原有功能保留但不再使用
// document.getElementById('add-anniversary-btn').addEventListener('click', () => {
//     document.getElementById('create-countdown-modal').classList.add('visible');
// });

// ▲▲▲ 新增结束 ▲▲▲

// 【全新】约定/倒计时功能事件绑定 - 移动到私人空间
document.getElementById('private-add-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.add('visible');
});
document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.remove('visible');
});
document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
    const title = document.getElementById('countdown-title-input').value.trim();
    const dateValue = document.getElementById('countdown-date-input').value;
    
    if (!title || !dateValue) {
        alert('请填写完整的约定标题和日期！');
        return;
    }

    const targetDate = new Date(dateValue);
    if (isNaN(targetDate) || targetDate <= new Date()) {
        alert('请输入一个有效的、未来的日期！');
        return;
    }

    const newCountdown = {
        chatId: currentPrivateSpaceContactId, // 绑定到当前选择的联系人
        authorName: '我',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
    };
    
    await db.memories.add(newCountdown);
    document.getElementById('create-countdown-modal').classList.remove('visible');
    
    // 清空输入框
    document.getElementById('countdown-title-input').value = '';
    document.getElementById('countdown-date-input').value = '';
    
    // 保存到当前联系人的私人空间数据
    window.saveCurrentPrivateSpaceData();
    
    // 刷新私人空间的约定列表
    renderPrivateAgreements();
});

// 【全新】拉黑功能事件绑定
document.getElementById('block-chat-btn').addEventListener('click', async () => {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

    const chat = state.chats[state.activeChatId];
    const confirmed = await showCustomConfirm(
        '确认拉黑', 
        `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        
        // 关闭设置弹窗，并刷新聊天界面
        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);
        // 刷新聊天列表，可能会有UI变化
        renderChatList();
    }
});

document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    if (e.target.id === 'force-apply-check-btn') {
        alert("正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id); 
        return;
    }

    if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        triggerAiResponse(); // 【可选但推荐】解除后让AI主动说点什么
    }
    else if (e.target.id === 'accept-friend-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = '';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚通过了你的好友申请。你们现在又可以正常聊天了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        const msg = { role: 'user', content: '我通过了你的好友请求', timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        triggerAiResponse();
    }
    else if (e.target.id === 'reject-friend-btn') {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
    }
    // 【新增】处理申请好友按钮的点击事件
    else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
            '发送好友申请', 
            `请输入你想对“${chat.name}”说的申请理由：`,
            "我们和好吧！"
        );
        // 只有当用户输入了内容并点击“确定”后才继续
        if (reason !== null) {
            // 更新关系状态为“等待AI批准”
            chat.relationship.status = 'pending_ai_approval';
            chat.relationship.applicationReason = reason;
            await db.chats.put(chat);

            // 刷新UI，显示“等待通过”的界面
            renderChatInterface(chat.id);
            renderChatList();
            
            // 【关键】触发AI响应，让它去处理这个好友申请
            triggerAiResponse();
        }
    }
});

// ▼▼▼ 【全新】红包功能事件绑定 ▼▼▼

// 1. 将原有的转账按钮(￥)的点击事件，重定向到新的总入口函数
document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

// 2. 红包模态框内部的控制按钮
document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
    document.getElementById('red-packet-modal').classList.remove('visible');
});
document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

// 3. 红包模态框的页签切换逻辑
const rpTabGroup = document.getElementById('rp-tab-group');
const rpTabDirect = document.getElementById('rp-tab-direct');
const rpContentGroup = document.getElementById('rp-content-group');
const rpContentDirect = document.getElementById('rp-content-direct');

rpTabGroup.addEventListener('click', () => {
    rpTabGroup.classList.add('active');
    rpTabDirect.classList.remove('active');
    rpContentGroup.style.display = 'block';
    rpContentDirect.style.display = 'none';
});
rpTabDirect.addEventListener('click', () => {
    rpTabDirect.classList.add('active');
    rpTabGroup.classList.remove('active');
    rpContentDirect.style.display = 'block';
    rpContentGroup.style.display = 'none';
});

// 4. 实时更新红包金额显示
document.getElementById('rp-group-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
});
document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▼▼▼ 【全新添加】使用事件委托处理红包点击，修复失效问题 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 找到被点击的红包卡片
    const packetCard = e.target.closest('.red-packet-card');
    if (!packetCard) return; // 如果点击的不是红包，就什么也不做

    // 2. 从红包卡片的父级.message-bubble获取时间戳
    const messageBubble = packetCard.closest('.message-bubble');
    if (!messageBubble || !messageBubble.dataset.timestamp) return;

    // 3. 调用我们现有的处理函数
    const timestamp = parseInt(messageBubble.dataset.timestamp);
    handlePacketClick(timestamp);
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 【全新】投票功能事件监听器 ▼▼▼
// 在输入框工具栏添加按钮
document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

// 投票创建模态框的按钮
document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
    document.getElementById('create-poll-modal').classList.remove('visible');
});
document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

// 使用事件委托处理投票卡片内的所有点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const pollCard = e.target.closest('.poll-card');
    if (!pollCard) return;

    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
    if (isNaN(timestamp)) return;
    
    // 点击了选项
    const optionItem = e.target.closest('.poll-option-item');
    if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
    }
    
    // 点击了动作按钮（结束投票/查看结果）
    const actionBtn = e.target.closest('.poll-action-btn');
    if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        } else {
            endPoll(timestamp);
        }
        return;
    }

    // 如果是已结束的投票，点击卡片任何地方都可以查看结果
    if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
    }
});
// ▲▲▲ 新事件监听器粘贴结束 ▲▲▲

// 礼物卡片点击查看小票事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const giftCard = e.target.closest('.gift-card');
    if (!giftCard) return;
    
    const bubble = giftCard.closest('.message-bubble');
    if (bubble && bubble.dataset.timestamp) {
        showGiftReceipt(parseInt(bubble.dataset.timestamp));
    }
});

  // ▼▼▼ 【全新】AI头像库功能事件绑定 ▼▼▼
document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
document.getElementById('add-ai-avatar-btn').addEventListener('click', addAvatarToLibrary);
document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
// ▲▲▲ 新增结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听区域，粘贴这段【新代码】▼▼▼
            // ▼▼▼ 【请求4】App图标上传功能升级 (请用这整块代码替换旧的icon-settings-grid监听器) ▼▼▼
            document.getElementById('icon-settings-grid').addEventListener('click', async (e) => {
                if (e.target.classList.contains('change-icon-btn')) {
                    const item = e.target.closest('.icon-setting-item');
                    const iconId = item.dataset.iconId;
                    if (!iconId) return;

                    // 1. 弹出选择模态框
                    const choice = await showChoiceModal("更换图标", [
                        { text: '📁 从本地上传', value: 'local' },
                        { text: '🌐 使用网络URL', value: 'url' }
                    ]);

                    let newUrl = null;

                    // 2. 根据用户的选择执行不同操作
                    if (choice === 'local') {
                        newUrl = await uploadImageLocally(); // 调用我们之前写好的本地上传辅助函数
                    } else if (choice === 'url') {
                        const currentUrl = state.globalSettings.appIcons[iconId];
                        newUrl = await showCustomPrompt(`更换“${item.querySelector('.icon-preview').alt}”图标`, '请输入新的图片URL', currentUrl, 'url');
                    }

                    // 3. 处理最终结果
                    if (newUrl && newUrl.trim()) {
                        const trimmedUrl = newUrl.trim();
                        // 仅在内存中更新，等待用户点击"保存"
                        state.globalSettings.appIcons[iconId] = trimmedUrl;
                        // 实时更新设置页面的预览图
                        item.querySelector('.icon-preview').src = trimmedUrl;
                        
                        // 如果是悬浮X Logo，立即更新显示
                        if (iconId === 'floating-x-logo') {
                            updateFloatingXLogo();
                        }
                    } else if (newUrl !== null) {
                        alert("请输入一个有效的URL或选择一个文件！");
                    }
                }
            });
            // ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    document.getElementById('chat-messages').addEventListener('click', (e) => {
        // 使用 .closest() 向上查找被点击的卡片
        const linkCard = e.target.closest('.link-share-card');
        if (linkCard) {
            const timestamp = parseInt(linkCard.dataset.timestamp);
            if (!isNaN(timestamp)) {
                openBrowser(timestamp); // 调用我们的函数
            }
        }
    });

    // 浏览器返回按钮的事件监听，确保它只绑定一次
    document.getElementById('browser-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    // 1. 绑定输入框上方“分享链接”按钮的点击事件
    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);

    // 2. 绑定模态框中“取消”按钮的点击事件
    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
        document.getElementById('share-link-modal').classList.remove('visible');
    });

    // 3. 绑定模态框中“分享”按钮的点击事件
    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);

// ▼▼▼ 在 init() 的事件监听器区域，粘贴下面这几行 ▼▼▼
// 绑定消息操作菜单中的“引用”按钮
document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);

// 绑定回复预览栏中的“取消”按钮
document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
// ▲▲▲ 粘贴结束 ▲▲▲

// 在你的 init() 函数的事件监听器区域...

// ▼▼▼ 用这段代码替换旧的转账卡片点击事件 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 向上查找被点击的元素是否在一个消息气泡内
    const bubble = e.target.closest('.message-bubble');
    if (!bubble) return; // 如果不在，就退出

    // 2. 【核心修正】在这里添加严格的筛选条件
    // 必须是 AI 的消息 (.ai)
    // 必须是转账类型 (.is-transfer)
    // 必须是我们标记为“待处理”的 (data-status="pending")
    if (bubble.classList.contains('ai') && 
        bubble.classList.contains('is-transfer') && 
        bubble.dataset.status === 'pending') {
        
        // 3. 只有满足所有条件，才执行后续逻辑
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (!isNaN(timestamp)) {
            showTransferActionModal(timestamp);
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// 在 init() 的事件监听区域添加
document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);

// ▼▼▼ 用这段【新代码】替换旧的通话记录事件绑定 ▼▼▼

document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);

// 2. 绑定通话记录页面的“返回”按钮
document.getElementById('call-history-back-btn').addEventListener('click', () => {
    // 【核心修改】返回到聊天列表页面，而不是聊天界面
    showScreen('chat-list-screen');
});

// 3. 监听卡片点击的逻辑保持不变
document.getElementById('call-history-list').addEventListener('click', (e) => {
    const card = e.target.closest('.call-record-card');
    if (card && card.dataset.recordId) {
        showCallTranscript(parseInt(card.dataset.recordId));
    }
});

// 4. 关闭详情弹窗的逻辑保持不变
document.getElementById('close-transcript-modal-btn').addEventListener('click', () => {
    document.getElementById('call-transcript-modal').classList.remove('visible');
});

// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 检查点击的是否是语音条
    const voiceBody = e.target.closest('.voice-message-body');
    if (!voiceBody) return;

    // 2. 找到相关的DOM元素
    const bubble = voiceBody.closest('.message-bubble');
    if (!bubble) return;
    
    const spinner = voiceBody.querySelector('.loading-spinner');
    const transcriptEl = bubble.querySelector('.voice-transcript');

    // 如果正在加载中，则不响应点击
    if (bubble.dataset.state === 'loading') {
        return;
    }

    // ▼▼▼ 新增：语音停止播放函数 ▼▼▼
    function stopVoicePlayback(bubbleElement) {
        if (currentPlayingElement === bubbleElement) {
            voiceAudio.pause();
            voiceAudio.currentTime = 0;
            const voiceIcon = bubbleElement.querySelector('.voice-icon');
            if (voiceIcon) voiceIcon.innerHTML = createVoiceIcon();
            bubbleElement.classList.remove('playing', 'loading');
            currentPlayingElement = null;
        }
    }
    // ▲▲▲ 新增结束 ▲▲▲

    // 3. 如果文字已经展开，则收起
    if (bubble.dataset.state === 'expanded') {
        transcriptEl.style.display = 'none';
        bubble.dataset.state = 'collapsed';
        
        // ▼▼▼ 新增：收起时停止语音播放 ▼▼▼
        stopVoicePlayback(bubble);
        // ▲▲▲ 新增结束 ▲▲▲
    } 
    // 4. 如果是收起状态，则开始"转录"流程
    else {
        bubble.dataset.state = 'loading'; // 进入加载状态
        spinner.style.display = 'block';   // 显示加载动画

        // 模拟0.5秒的语音识别过程
        setTimeout(() => {
            // 检查此时元素是否还存在（可能用户已经切换了聊天）
            if (document.body.contains(bubble)) {
                const voiceText = bubble.dataset.voiceText || '(无法识别)';
                transcriptEl.textContent = voiceText; // 填充文字
                
                spinner.style.display = 'none';      // 隐藏加载动画
                transcriptEl.style.display = 'block';// 显示文字
                bubble.dataset.state = 'expanded';     // 进入展开状态
                
                // ▼▼▼ 新增：展开时开始播放语音 ▼▼▼
                // 检查是否配置了语音系统并播放语音
                // 【修复】只有角色（AI）的语音消息才使用 minimax 播放，用户的语音消息不使用
                if (voiceText && state.chats[state.activeChatId] && bubble.classList.contains('ai')) {
                    const chat = state.chats[state.activeChatId];
                    const minimaxVoiceId = chat.settings?.minimaxVoiceId;
                    const minimaxGroupId = localStorage.getItem('minimaxGroupId');
                    const minimaxApiKey = localStorage.getItem('minimaxApiKey');
                    
                    // 如果配置了语音系统，就播放语音
                    if (minimaxVoiceId && minimaxGroupId && minimaxApiKey) {
                        // 为语音条添加语音图标（如果还没有的话）
                        if (!bubble.querySelector('.voice-icon')) {
                            const voiceIcon = document.createElement('span');
                            voiceIcon.className = 'voice-icon';
                            voiceIcon.innerHTML = createVoiceIcon();
                            voiceIcon.style.cssText = `
                                position: absolute;
                                top: 8px;
                                right: 8px;
                                cursor: pointer;
                                color: rgba(255, 255, 255, 0.8);
                                transition: color 0.2s;
                                z-index: 10;
                            `;
                            
                            bubble.style.position = 'relative';
                            bubble.appendChild(voiceIcon);
                        }
                        
                        // 播放语音
                        playVoiceMessage(bubble, voiceText, minimaxVoiceId);
                    }
                }
                // ▲▲▲ 新增结束 ▲▲▲
            }
        }, 500);
    }
});

document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);

// 在 init() 的事件监听器区域添加
document.getElementById('selection-share-btn').addEventListener('click', () => {
    if (selectedMessages.size > 0) {
        openShareTargetPicker(); // 打开我们即将创建的目标选择器
    }
});

// 在 init() 的事件监听器区域添加
document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
    const sourceChat = state.chats[state.activeChatId];
    const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                   .map(cb => cb.dataset.chatId);

    if (selectedTargetIds.length === 0) {
        alert("请至少选择一个要分享的聊天。");
        return;
    }

    // 1. 打包聊天记录
    const sharedHistory = [];
    const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
    for (const timestamp of sortedTimestamps) {
        const msg = sourceChat.history.find(m => m.timestamp === timestamp);
        if (msg) {
            sharedHistory.push(msg);
        }
    }
    
    // 2. 创建分享卡片消息对象
    const shareCardMessage = {
        role: 'user',
        senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || '我') : '我',
        type: 'share_card',
        timestamp: Date.now(),
        payload: {
            sourceChatName: sourceChat.name,
            title: `来自“${sourceChat.name}”的聊天记录`,
            sharedHistory: sharedHistory
        }
    };

    // 3. 循环发送到所有目标聊天
    for (const targetId of selectedTargetIds) {
        const targetChat = state.chats[targetId];
        if (targetChat) {
            targetChat.history.push(shareCardMessage);
            await db.chats.put(targetChat);
        }
    }
    
    // 4. 收尾工作
    document.getElementById('share-target-modal').classList.remove('visible');
    exitSelectionMode(); // 退出多选模式
    await showCustomAlert("分享成功", `聊天记录已成功分享到 ${selectedTargetIds.length} 个会话中。`);
    renderChatList(); // 刷新列表，可能会有新消息提示
});

// 绑定取消按钮
document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
    document.getElementById('share-target-modal').classList.remove('visible');
});

// 在 init() 的事件监听器区域添加
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // ...你已有的其他点击事件逻辑...

    // 新增逻辑：处理分享卡片的点击
    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
    }
});

// 绑定查看器的关闭按钮
document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
    document.getElementById('shared-history-viewer-modal').classList.remove('visible');
});

// 创建新函数来处理渲染逻辑
function openSharedHistoryViewer(timestamp) {
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_card') return;

    const viewerModal = document.getElementById('shared-history-viewer-modal');
    const viewerTitle = document.getElementById('shared-history-viewer-title');
    const viewerContent = document.getElementById('shared-history-viewer-content');

    viewerTitle.textContent = message.payload.title;
    viewerContent.innerHTML = ''; // 清空旧内容

    // 【核心】复用 createMessageElement 来渲染每一条被分享的消息
    message.payload.sharedHistory.forEach(sharedMsg => {
        // 注意：这里我们传入的是 sourceChat 对象，以确保头像、昵称等正确
        const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;
        const bubbleEl = createMessageElement(sharedMsg, sourceChat);
        if (bubbleEl) {
            viewerContent.appendChild(bubbleEl);
        }
    });

    viewerModal.classList.add('visible');
}

audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);

audioPlayer.addEventListener('pause', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = false; 
        updatePlayerUI(); 
    } 
});
audioPlayer.addEventListener('play', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = true; 
        updatePlayerUI(); 
    } 
});

document.getElementById('playlist-body').addEventListener('click', async (e) => {
    const target = e.target;
    if (target.classList.contains('delete-track-btn')) {
        const index = parseInt(target.dataset.index);
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('删除歌曲', `确定要从播放列表中删除《${track.name}》吗？`);
        if (confirmed) {
            deleteTrack(index);
        }
        return;
    }
    // ▼▼▼ 在 lyrics-btn 的判断逻辑【上方】，添加这段新代码 ▼▼▼
            if (target.classList.contains('cover-btn')) {
                const index = parseInt(target.dataset.index);
                if (!isNaN(index)) {
                    handleCoverUpload(index);
                }
                return; // 处理完就退出，避免触发其他逻辑
            }
// ▲▲▲ 添加结束 ▲▲▲

            // ▼▼▼ 请用这【一整块新代码】替换旧的 lyrics-btn 点击逻辑 ▼▼▼
            if (target.classList.contains('lyrics-btn')) {
                const index = parseInt(target.dataset.index);
                if (isNaN(index)) return;

                // 1. 弹窗询问用户选择（已移除图标）
                const choice = await showChoiceModal("选择歌词来源", [
                    { text: '使用网络URL', value: 'url' },
                    { text: '从本地上传', value: 'local' }
                ]);

                let lrcContent = null;

                // 2. 根据选择执行不同操作
                if (choice === 'url') {
                    const url = await showCustomPrompt("歌词URL", "请输入.lrc歌词文件的网络链接");
                    if (url && url.trim()) {
                        try {
                            const response = await fetch(url.trim());
                            if (response.ok) {
                                lrcContent = await response.text();
                            } else {
                                alert('无法获取歌词文件，请检查URL是否正确。');
                            }
                        } catch (error) {
                            alert('获取歌词失败: ' + error.message);
                        }
                    }
                } else if (choice === 'local') {
                    lrcContent = await new Promise(resolve => {
                        const lrcInput = document.getElementById('lrc-upload-input');
                        const handler = (event) => {
                            const file = event.target.files[0];
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = (re) => resolve(re.target.result);
                                reader.readAsText(file);
                            } else {
                                resolve(null);
                            }
                            lrcInput.removeEventListener('change', handler);
                            lrcInput.value = '';
                        };
                        lrcInput.addEventListener('change', handler);
                        lrcInput.click();
                    });
                }

                // 3. 如果成功获取到歌词，就保存并更新
                if (lrcContent !== null) {
                    musicState.playlist[index].lrcContent = lrcContent;
                    await saveGlobalPlaylist();
                    alert('歌词导入成功！');
                    if (musicState.currentIndex === index) {
                        musicState.parsedLyrics = parseLRC(lrcContent);
                        renderLyrics();
                    }
                }
            }
            // ▲▲▲ 替换结束 ▲▲▲
});

document.querySelector('.progress-bar').addEventListener('click', (e) => {
    if (!audioPlayer.duration) return;
    const progressBar = e.currentTarget;
    const barWidth = progressBar.clientWidth;
    const clickX = e.offsetX;
    audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
});

// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这段新代码 ▼▼▼

// 使用事件委托来处理所有“已撤回消息”的点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 检查被点击的元素或其父元素是否是“已撤回”提示
    const placeholder = e.target.closest('.recalled-message-placeholder');
    if (!placeholder) return; // 如果不是，就退出

    // 如果是，就从聊天记录中找到对应的数据并显示
    const chat = state.chats[state.activeChatId];
    const wrapper = placeholder.closest('.message-wrapper'); // 找到它的父容器
    if (chat && wrapper) {
        // 从父容器上找到时间戳
        const timestamp = parseInt(wrapper.dataset.timestamp);
        const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
        
        if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;
            
            if (recalled.originalType === 'text') {
                originalContentText = `原文: "${recalled.originalContent}"`;
            } else {
                originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
            }
            showCustomAlert('已撤回的消息', originalContentText);
        }
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听器区域，粘贴这段新代码 ▼▼▼
// 新的世界书按钮事件监听器
// 局部世界书按钮
document.getElementById('manage-local-categories-btn').addEventListener('click', () => openCategoryManager(false));
document.getElementById('add-local-world-book-btn').addEventListener('click', async () => {
    const name = await showCustomPrompt('创建局部世界书', '请输入书名');
    if (name && name.trim()) {
        const newBook = {
            id: 'wb_' + Date.now(),
            name: name.trim(),
            content: '',
            isGlobal: false
        };
        await db.worldBooks.add(newBook);
        state.worldBooks.push(newBook);
        renderWorldBookScreen();
        openWorldBookEditor(newBook.id);
    }
});

// 全局世界书按钮
document.getElementById('manage-global-categories-btn').addEventListener('click', () => openCategoryManager(true));
document.getElementById('add-global-world-book-btn').addEventListener('click', async () => {
    const name = await showCustomPrompt('创建全局世界书', '请输入书名');
    if (name && name.trim()) {
        const newBook = {
            id: 'wb_' + Date.now(),
            name: name.trim(),
            content: '',
            isGlobal: true,
            isEnabled: true // 新创建的全局世界书默认开启
        };
        await db.worldBooks.add(newBook);
        state.worldBooks.push(newBook);
        renderWorldBookScreen();
        openWorldBookEditor(newBook.id);
    }
});

document.getElementById('close-category-manager-btn').addEventListener('click', () => {
    document.getElementById('world-book-category-manager-modal').classList.remove('visible');
    renderWorldBookScreen(); // 关闭后刷新主列表
});
document.getElementById('add-new-category-btn').addEventListener('click', () => addNewCategory(window.currentCategoryType));
document.getElementById('existing-categories-list').addEventListener('click', async (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const categoryId = parseInt(e.target.dataset.id);
        await deleteCategory(categoryId);
        // 刷新分类列表和世界书页面
        await renderCategoryListInManager(window.currentCategoryType);
        await renderWorldBookPage(window.currentCategoryType ? 'global' : 'local');
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// --- ▼▼▼ 【全新】自定义头像框功能事件绑定 ▼▼▼ ---

// 打开“选择”弹窗的按钮
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal(e.target.dataset.type);
    }
});
document.getElementById('member-settings-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('member', editingMemberId);
    }
});

// “选择”弹窗内的按钮
// “选择”弹窗内的按钮（已修正）
document.getElementById('manage-custom-frames-btn').addEventListener('click', () => {
    // 1. 先关闭当前的选择弹窗
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    
    // 2. 然后再打开管理弹窗
    openFrameManager();
});
document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => document.getElementById('avatar-frame-modal').classList.remove('visible'));
document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);

// “管理”弹窗内的按钮
document.getElementById('upload-custom-frame-btn').addEventListener('click', handleUploadCustomFrame);
document.getElementById('close-frame-manager-btn').addEventListener('click', () => {
    document.getElementById('custom-frame-manager-modal').classList.remove('visible');
    // 关闭管理后，刷新选择界面，因为列表可能变了
    openFrameSelectorModal(currentFrameSelection.type, currentFrameSelection.target);
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▼▼▼ 【全新】聊天列表左滑功能JS逻辑 ▼▼▼
const chatListEl = document.getElementById('chat-list');
let chatSwipeState = { isDragging: false, startX: 0, activeContent: null };

// 关闭所有已滑开的项
function resetAllChatSwipes(exceptThisOne = null) {
    document.querySelectorAll('.chat-list-item-content.swiped').forEach(content => {
        if (content !== exceptThisOne) {
            content.classList.remove('swiped');
        }
    });
}

chatListEl.addEventListener('mousedown', (e) => {
    const content = e.target.closest('.chat-list-item-content');
    if (content) {
        resetAllChatSwipes(content);
        chatSwipeState.isDragging = true;
        chatSwipeState.startX = e.pageX;
        chatSwipeState.activeContent = content;
        // 阻止拖动时选中文本
        e.preventDefault();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    const diffX = e.pageX - chatSwipeState.startX;
    if (diffX < 0 && diffX > -170) { // 只允许向左滑, 限制最大距离
        chatSwipeState.activeContent.style.transition = 'none'; // 滑动时禁用动画
        chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
    }
});

document.addEventListener('mouseup', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    
    chatSwipeState.activeContent.style.transition = 'transform 0.3s ease';
    const transformStyle = window.getComputedStyle(chatSwipeState.activeContent).transform;
    const currentTranslateX = new DOMMatrix(transformStyle).m41;

    if (currentTranslateX < -60) { // 滑动超过阈值
        chatSwipeState.activeContent.classList.add('swiped');
    } else {
        chatSwipeState.activeContent.classList.remove('swiped');
    }
    chatSwipeState.activeContent.style.transform = ''; // 清除内联样式，交由CSS class控制

    // 重置状态
    chatSwipeState.isDragging = false;
    chatSwipeState.activeContent = null;
});

// 移动端触摸事件的兼容
chatListEl.addEventListener('touchstart', (e) => {
     const content = e.target.closest('.chat-list-item-content');
    if (content) {
        resetAllChatSwipes(content);
        chatSwipeState.isDragging = true;
        chatSwipeState.startX = e.touches[0].pageX;
        chatSwipeState.activeContent = content;
    }
}, { passive: true });

chatListEl.addEventListener('touchmove', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    const diffX = e.touches[0].pageX - chatSwipeState.startX;
     if (diffX < 0 && diffX > -170) {
        chatSwipeState.activeContent.style.transition = 'none';
        chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
    }
}, { passive: true });

chatListEl.addEventListener('touchend', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    
    chatSwipeState.activeContent.style.transition = 'transform 0.3s ease';
    const transformStyle = window.getComputedStyle(chatSwipeState.activeContent).transform;
    const currentTranslateX = new DOMMatrix(transformStyle).m41;

    if (currentTranslateX < -60) {
        chatSwipeState.activeContent.classList.add('swiped');
    } else {
        chatSwipeState.activeContent.classList.remove('swiped');
    }
    chatSwipeState.activeContent.style.transform = '';

    chatSwipeState.isDragging = false;
    chatSwipeState.activeContent = null;
});
// ▲▲▲ 新JS逻辑粘贴结束 ▲▲▲

// ▼▼▼ 【全新】聊天列表操作按钮点击事件 ▼▼▼
chatListEl.addEventListener('click', async (e) => {
    const target = e.target;
    if (target.classList.contains('swipe-action-btn')) {
        const container = target.closest('.chat-list-item-swipe-container');
        if (!container) return;

        const chatId = container.dataset.chatId;
        const chat = state.chats[chatId];
        if (!chat) return;

        if (target.classList.contains('pin') || target.classList.contains('unpin')) {
            // 置顶或取消置顶
            chat.isPinned = !chat.isPinned;
            await db.chats.put(chat);
            await renderChatList(); // 重新渲染列表以更新排序
        } else if (target.classList.contains('delete')) {
            // 删除
            const confirmed = await showCustomConfirm('删除对话', `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
                delete state.chats[chat.id];
                if (state.activeChatId === chat.id) state.activeChatId = null;
                await db.chats.delete(chat.id);
                await renderChatList();
            } else {
                // 如果取消删除，则把滑块收回去
                const content = container.querySelector('.chat-list-item-content');
                if (content) content.classList.remove('swiped');
            }
        }
    }
});
// ▲▲▲ 新事件监听粘贴结束 ▲▲▲
// ▼▼▼ 从这里开始，把下面这两块完整的 eventListener 代码【剪切】掉 ▼▼▼

// 使用事件委托来处理所有点击和勾选事件，效率更高
worldBookCheckboxesContainer.addEventListener('click', (e) => {
    const header = e.target.closest('.wb-category-header');
    // 如果点击的是文件夹头部，并且不是点在复选框上
    if (header && !e.target.matches('input[type="checkbox"]')) {
        const categoryId = header.querySelector('.wb-category-checkbox')?.dataset.categoryId;
        if (categoryId) {
            const bookContainer = worldBookCheckboxesContainer.querySelector(`.wb-book-container[data-container-for="${categoryId}"]`);
            if (bookContainer) {
                header.classList.toggle('collapsed');
                bookContainer.classList.toggle('collapsed');
            }
        }
    }
});

worldBookCheckboxesContainer.addEventListener('change', (e) => {
    const target = e.target;
    
    // 如果点击的是分类的“全选”复选框
    if (target.classList.contains('wb-category-checkbox')) {
        const categoryId = target.dataset.categoryId;
        const isChecked = target.checked;
        // 找到这个分类下的所有书籍复选框，并将它们的状态设置为与分类复选框一致
        const bookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        bookCheckboxes.forEach(cb => cb.checked = isChecked);
    }
    
    // 如果点击的是单个书籍的复选框
    if (target.classList.contains('wb-book-checkbox')) {
        const categoryId = target.dataset.parentCategory;
        if (categoryId) { // 检查它是否属于一个分类
            const categoryCheckbox = worldBookCheckboxesContainer.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
            const allBookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
            // 检查该分类下是否所有书籍都被选中了
            const allChecked = Array.from(allBookCheckboxes).every(cb => cb.checked);
            // 同步分类“全选”复选框的状态
            if(categoryCheckbox) categoryCheckbox.checked = allChecked;
        }
    }
    
    // 每次变更后都更新顶部的已选数量显示
    updateWorldBookSelectionDisplay();
});

// ▲▲▲ 把上面这两块完整的 eventListener 代码【剪切】掉 ▲▲▲


    // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这一整块新代码 ▼▼▼

    // --- 美化功能事件绑定 ---
    const themeEditor = document.getElementById('theme-css-editor');
    
    // 页面加载时，加载主题列表并显示模板
    await loadThemesToDropdown();
    themeEditor.value = THEME_CSS_TEMPLATE;

    // 绑定下拉框选择事件
    document.getElementById('theme-selector').addEventListener('change', handleThemeSelection);
    
    // 绑定所有操作按钮
    document.getElementById('apply-theme-btn').addEventListener('click', () => applyThemeCss(themeEditor.value));
    document.getElementById('save-theme-btn').addEventListener('click', saveCurrentTheme);
    document.getElementById('save-as-new-theme-btn').addEventListener('click', saveAsNewTheme);
    document.getElementById('rename-theme-btn').addEventListener('click', renameSelectedTheme);
    document.getElementById('delete-theme-btn').addEventListener('click', deleteSelectedTheme);
    document.getElementById('export-theme-btn').addEventListener('click', exportTheme);
    
    // 绑定导入按钮和隐藏的文件选择器
    document.getElementById('import-theme-btn').addEventListener('click', () => {
        document.getElementById('import-theme-input').click();
    });
    document.getElementById('import-theme-input').addEventListener('change', (e) => {
        importTheme(e.target.files[0]);
        e.target.value = null; // 清空，以便下次能选择同一个文件
    });
    
    // ▲▲▲ 新事件绑定结束 ▲▲▲

document.getElementById('api-preset-select').addEventListener('change', handleApiPresetSelectChange);
document.getElementById('manage-api-presets-btn').addEventListener('click', openApiPresetManager);

            // ▼▼▼ 【全新】锁屏功能事件监听器 ▼▼▼

            // 1. 锁屏壁纸上传
            document.getElementById('lockscreen-wallpaper-upload-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if(file) {
                    const dataUrl = await new Promise((res, rej) => {
                        const reader = new FileReader();
                        reader.onload = () => res(reader.result);
                        reader.onerror = () => rej(reader.error);
                        reader.readAsDataURL(file);
                    });
                    newLockscreenWallpaperBase64 = dataUrl;
                    renderWallpaperScreen(); // 上传后实时预览
                }
            });

            // 2. 密码输入框按钮
            document.getElementById('password-confirm-btn').addEventListener('click', checkPassword);
            document.getElementById('password-cancel-btn').addEventListener('click', hidePasswordModal);
            // 允许在输入框内按回车键确认
            document.getElementById('password-input-field').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    checkPassword();
                }
            });

            // 3. 【全新】带有动画效果的上滑解锁手势
            const lockScreen = document.getElementById('lock-screen');
            const unlockHint = document.getElementById('unlock-hint');
            let touchStartY = 0;
            let isSwiping = false;

// 统一的开始处理函数
const handleUnlockStart = (e) => {
    if (document.getElementById('password-modal-overlay').classList.contains('visible')) return;
    
    // (你原来的其他逻辑保持不变)
    const blurBg = document.getElementById('lock-screen-background-blur');
    if (state.globalSettings.password) {
        blurBg.style.backgroundImage = lockScreen.style.backgroundImage;
        blurBg.style.display = 'block';
    } else {
        document.getElementById('home-screen').classList.add('active');
    }
    
    touchStartY = getEventCoords(e).y; // 使用辅助函数获取Y坐标
    isSwiping = true;
    lockScreen.style.transition = 'none';
    unlockHint.style.transition = 'none';
};

// 统一的移动处理函数
const handleUnlockMove = (e) => {
    if (!isSwiping) return;
    const currentY = getEventCoords(e).y; // 使用辅助函数
    let diffY = currentY - touchStartY;
    // (你原来的其他逻辑保持不变)
    if (diffY > 0) diffY = 0;
    lockScreen.style.transform = `translateY(${diffY}px)`;
    unlockHint.style.opacity = Math.max(0, 1 - Math.abs(diffY) / 100);
    if (state.globalSettings.password) {
        const blurBg = document.getElementById('lock-screen-background-blur');
        blurBg.style.opacity = Math.min(1, Math.abs(diffY) / 80);
    }
};

// 统一的结束处理函数
const handleUnlockEnd = (e) => {
    if (!isSwiping) return;
    isSwiping = false;

    // (你原来的其他逻辑保持不变)
    lockScreen.style.transition = 'transform 0.3s ease-out';
    unlockHint.style.transition = 'opacity 0.3s ease-out';
    const blurBg = document.getElementById('lock-screen-background-blur');
    
    // 注意：touchend事件的坐标在 e.changedTouches[0]
    const touchEndY = e.changedTouches ? e.changedTouches[0].clientY : e.pageY;
    const swipeDistance = touchStartY - touchEndY;
    
    if (swipeDistance > 80) {
        lockScreen.style.transform = 'translateY(-100%)';
        setTimeout(() => {
            if (state.globalSettings.password) {
                showPasswordModal();
            } else {
                unlockPhone();
            }
        }, 300);
    } else {
        lockScreen.style.transform = 'translateY(0)';
        unlockHint.style.opacity = '1';
        if (state.globalSettings.password) {
            blurBg.style.opacity = '0';
            setTimeout(() => { blurBg.style.display = 'none'; }, 300);
        } else {
            document.getElementById('home-screen').classList.remove('active');
        }
    }
};

// 2. 绑定两种事件到同一套处理逻辑上
lockScreen.addEventListener('touchstart', handleUnlockStart, { passive: true });
lockScreen.addEventListener('touchmove', handleUnlockMove, { passive: true });
lockScreen.addEventListener('touchend', handleUnlockEnd, { passive: true });

lockScreen.addEventListener('mousedown', handleUnlockStart);
// 注意：mousemove和mouseup最好绑定在document上，防止鼠标拖出范围后失效
document.addEventListener('mousemove', handleUnlockMove);
document.addEventListener('mouseup', handleUnlockEnd);
            
            // ▲▲▲ 新事件监听器粘贴结束 ▲▲▲

// 【全新】为聊天底部工具栏添加鼠标拖动滚动功能
const actionsTopBar = document.getElementById('chat-input-actions-top');
let isDown = false;
let startX;
let scrollLeft;

actionsTopBar.addEventListener('mousedown', (e) => {
    isDown = true;
    actionsTopBar.classList.add('grabbing'); // 添加一个class来改变鼠标样式
    startX = e.pageX - actionsTopBar.offsetLeft;
    scrollLeft = actionsTopBar.scrollLeft;
});

actionsTopBar.addEventListener('mouseleave', () => {
    isDown = false;
    actionsTopBar.classList.remove('grabbing');
});

actionsTopBar.addEventListener('mouseup', () => {
    isDown = false;
    actionsTopBar.classList.remove('grabbing');
});

actionsTopBar.addEventListener('mousemove', (e) => {
    if (!isDown) return;
    e.preventDefault();
    const x = e.pageX - actionsTopBar.offsetLeft;
    const walk = (x - startX) * 2; // 乘以2可以增加拖动速度，感觉更灵敏
    actionsTopBar.scrollLeft = scrollLeft - walk;
});

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼
document.getElementById('location-cancel-btn').addEventListener('click', () => {
    document.getElementById('send-location-modal').classList.remove('visible');
});
document.getElementById('location-confirm-btn').addEventListener('click', sendUserLocation);
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 【全新】为定位模态框的“添加途经点”按钮绑定事件
document.getElementById('add-trajectory-point-btn').addEventListener('click', () => {
    // 限制最多添加3个途经点，防止UI过于拥挤
    if (document.querySelectorAll('.trajectory-point-input').length < 3) {
        addTrajectoryPointInput();
    } else {
        alert("最多只能添加3个途经点哦！");
    }
});

// 【新增】打开定位模态框时，清空旧的途经点
document.getElementById('send-location-btn').addEventListener('click', () => {
    document.getElementById('trajectory-points-container').innerHTML = '';
    document.getElementById('send-location-modal').classList.add('visible');
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在这里粘贴下面这行新代码 ▼▼▼
document.getElementById('reroll-btn').addEventListener('click', handleRerollClick);
// ▲▲▲ 粘贴结束 ▲▲▲

// 表情按钮事件监听器
document.getElementById('emoji-btn').addEventListener('click', function() {
    document.getElementById('emoji-modal').style.display = 'flex';
});

// 关闭表情弹窗
document.getElementById('close-emoji-modal').addEventListener('click', function() {
    document.getElementById('emoji-modal').style.display = 'none';
});

// 点击表情弹窗外部关闭
document.getElementById('emoji-modal').addEventListener('click', function(e) {
    if (e.target === this) {
        this.style.display = 'none';
    }
});

// 订单预览弹窗关闭事件
document.getElementById('order-preview-close-btn').addEventListener('click', function() {
    document.getElementById('order-preview-modal').classList.remove('visible');
});

// 点击订单预览弹窗背景关闭
document.getElementById('order-preview-modal').addEventListener('click', function(e) {
    if (e.target === this) {
        this.classList.remove('visible');
    }
});

// 分类切换功能
document.querySelectorAll('.category-tab').forEach(function(tab) {
    tab.addEventListener('click', function() {
        const category = this.getAttribute('data-category');
        
        // 移除所有分类的active状态
        document.querySelectorAll('.category-tab').forEach(function(t) {
            t.classList.remove('active');
        });
        document.querySelectorAll('.emoji-category').forEach(function(c) {
            c.classList.remove('active');
        });
        
        // 激活当前分类
        this.classList.add('active');
        document.querySelector('.emoji-category[data-category="' + category + '"]').classList.add('active');
    });
});

// 表情选择功能
document.querySelectorAll('.emoji-item').forEach(function(emojiItem) {
    emojiItem.addEventListener('click', function() {
        const emoji = this.getAttribute('data-emoji');
        const chatInput = document.getElementById('chat-input');
        
        // 在输入框当前光标位置插入表情
        const cursorPos = chatInput.selectionStart;
        const textBefore = chatInput.value.substring(0, cursorPos);
        const textAfter = chatInput.value.substring(chatInput.selectionEnd);
        
        chatInput.value = textBefore + emoji + textAfter;
        
        // 设置光标位置到表情后面
        const newCursorPos = cursorPos + emoji.length;
        chatInput.setSelectionRange(newCursorPos, newCursorPos);
        
        // 聚焦到输入框
        chatInput.focus();
        
        // 不再自动关闭表情弹窗，让用户可以连续选择表情
    });
});

// ▼▼▼ 【全新】粘贴这整块事件监听代码到 init() 末尾 ▼▼▼

// --- 悬浮歌词栏设置功能 ---
document.getElementById('lyrics-settings-btn').addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡触发拖动或打开播放器
    document.getElementById('lyrics-settings-modal').classList.add('visible');
});

document.getElementById('close-lyrics-settings-btn').addEventListener('click', async () => {
    // 保存设置到全局状态并写入数据库
    state.globalSettings.lyricsBarSettings = lyricsBarSettings;
    await db.globalSettings.put(state.globalSettings);
    document.getElementById('lyrics-settings-modal').classList.remove('visible');
    alert('设置已保存！');
});

document.getElementById('reset-lyrics-settings-btn').addEventListener('click', () => {
    // 恢复到默认值
    lyricsBarSettings = { fontSize: 14, bgOpacity: 0, fontColor: '#FFFFFF', showOnClose: true };
    applyLyricsSettings(); // 应用默认设置
});

// 实时更新样式
document.getElementById('lyrics-font-size-slider').addEventListener('input', (e) => {
    lyricsBarSettings.fontSize = e.target.value;
    applyLyricsSettings();
});
document.getElementById('lyrics-bg-opacity-slider').addEventListener('input', (e) => {
    lyricsBarSettings.bgOpacity = e.target.value;
    applyLyricsSettings();
});
document.getElementById('lyrics-font-color-picker').addEventListener('input', (e) => {
    lyricsBarSettings.fontColor = e.target.value;
    applyLyricsSettings();
});

// 歌词栏上的关闭按钮
document.querySelector('#floating-lyrics-bar .close-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('floating-lyrics-bar').style.display = 'none';
});

// 播放器里的“悬浮/隐藏”开关
document.getElementById('toggle-lyrics-bar-btn').addEventListener('click', async (e) => {
    lyricsBarSettings.showOnClose = !lyricsBarSettings.showOnClose;
    e.target.textContent = lyricsBarSettings.showOnClose ? '悬浮' : '隐藏';
    e.target.style.opacity = lyricsBarSettings.showOnClose ? '1' : '0.5';
    // 立即保存这个设置
    state.globalSettings.lyricsBarSettings = lyricsBarSettings;
    await db.globalSettings.put(state.globalSettings);
});

// 【重要】在页面加载时，就应用一次已保存的设置
applyLyricsSettings();

// ▲▲▲ 新代码粘贴结束 ▲▲▲

            // ▼▼▼ 【全新】“查角色手机”功能事件监听器 ▼▼▼

            // 1. 绑定主屏幕上的“查手机”APP图标
            const checkPhoneAppIcon = document.querySelector('.app-icon[data-app-id="check-phone"]');
            if (checkPhoneAppIcon) {
                checkPhoneAppIcon.onclick = openCharacterSelectionScreen; // 修改onclick事件
            }

            // 2. 角色选择列表的点击事件 (事件委托)
            document.getElementById('character-selection-list').addEventListener('click', (e) => {
                const item = e.target.closest('.character-select-item');
                if (item && item.dataset.chatId) {
                    openCharacterPhone(item.dataset.chatId);
                }
            });
// ▼▼▼ 请用这整块代码替换 ▼▼▼
// 【V3版】角色手机聊天列表的点击事件 (事件委托)
document.getElementById('character-chat-list').addEventListener('click', (e) => {
    const item = e.target.closest('.chat-list-item');
    if (item && item.dataset.contactName) {
        // ▼▼▼ 在这里粘贴探针 #2 ▼▼▼
        const isUserChat = item.dataset.isUserChat === 'true';
        console.log("【诊断日志 2】: 点击了聊天列表项", {
            contactName: item.dataset.contactName,
            isUserChat: isUserChat
        });
        // ▲▲▲ 探针结束 ▲▲▲
        
        // 将联系人名字和“身份证”一起传递给渲染函数
        renderCharacterChatHistory(item.dataset.contactName, isUserChat);
        showCharacterPhonePage('character-chat-history-screen');
    }
});
// ▲▲▲ 替换结束 ▲▲▲



            // 3. 角色手机顶部的“刷新”和“清空”按钮
            document.getElementById('generate-character-data-btn').addEventListener('click', generateCharacterPhoneData);
            document.getElementById('clear-character-data-btn').addEventListener('click', clearCharacterPhoneData);

            // ▲▲▲ 事件监听器添加结束 ▲▲▲

            // ▼▼▼ 【全新】角色手机内部统一返回事件监听器 ▼▼▼
            document.getElementById('character-phone-container').addEventListener('click', (e) => {
                const backBtn = e.target.closest('.back-btn');
                if (!backBtn) return;

                // 检查是返回到角色手机内部页面，还是返回到主屏幕
                if (backBtn.dataset.targetPage) {
                    showCharacterPhonePage(backBtn.dataset.targetPage);
                } else if (backBtn.dataset.targetScreen) {
                    showScreen(backBtn.dataset.targetScreen);
                }
            });
            // ▲▲▲ 新代码粘贴结束 ▲▲▲

            // ▼▼▼ 【全新】角色手机日记APP事件监听器 ▼▼▼
            document.getElementById('character-app-grid').addEventListener('click', (e) => {
                const icon = e.target.closest('.app-icon');
                if (icon && icon.querySelector('.label').textContent === '日记') {
                    renderCharacterDiary();
                }
            });
            document.getElementById('generate-diary-entry-btn').addEventListener('click', generateNewDiaryEntry);
            // ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】“查手机”内容单条删除功能事件绑定 ▼▼▼
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.item-delete-btn');
    if (deleteBtn) {
        // 【新增】处理微信消息删除
        if (deleteBtn.classList.contains('message-delete-btn')) {
            const contactName = deleteBtn.dataset.contactName;
            const index = parseInt(deleteBtn.dataset.index);
            if (contactName && !isNaN(index)) {
                handleCharacterChatMessageDeletion(contactName, index);
            }
        } 
        // 处理其他列表删除
        else {
            const dataType = deleteBtn.dataset.type;
            const index = parseInt(deleteBtn.dataset.index);
            if (dataType && !isNaN(index)) {
                handleCharacterDataDeletion(dataType, index);
            }
        }
    }
});
// ▲▲▲ 删除功能事件绑定结束 ▲▲▲

// ▼▼▼ 【全新】NPC库管理功能事件绑定 ▼▼▼

// 聊天设置里的“管理NPC库”按钮
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.id === 'manage-npcs-btn') {
        // 先关闭聊天设置，再打开NPC管理
        document.getElementById('chat-settings-modal').classList.remove('visible');
        openNpcManager();
    }
});

// NPC管理界面的返回按钮
document.getElementById('back-from-npc-management').addEventListener('click', () => {
    // 返回时，重新打开聊天设置
    showScreen('chat-interface-screen');
    document.getElementById('chat-settings-btn').click();
});

// NPC管理界面的“+”按钮
document.getElementById('add-new-npc-btn').addEventListener('click', () => openNpcEditor(null));



// ▼▼▼ 【全新】粘贴这整块事件监听器代码 ▼▼▼
// --- 后台活动设置界面的事件绑定 ---

// 1. 总开关的事件
document.getElementById('background-activity-switch').addEventListener('change', () => {
    // 每次点击总开关，都重新渲染一次详细设置区（它会根据开关状态自动显示或隐藏）
    renderBackgroundFrequencySelector();
});

// 2. 全选按钮
document.getElementById('bg-select-all-chars').addEventListener('click', () => {
    document.querySelectorAll('.bg-char-checkbox').forEach(checkbox => {
        checkbox.checked = true;
    });
});

// 3. 全不选按钮
document.getElementById('bg-deselect-all-chars').addEventListener('click', () => {
    document.querySelectorAll('.bg-char-checkbox').forEach(checkbox => {
        checkbox.checked = false;
    });
});

// 这是修复后的新代码块，用它替换掉旧的
document.querySelector('#background-activity-details').addEventListener('click', async (e) => { // 注意这里加了 async
    if (e.target.classList.contains('bg-freq-btn')) {
        const freq = e.target.dataset.freq;
        const selectedCheckboxes = document.querySelectorAll('.bg-char-checkbox:checked');
        
        if (selectedCheckboxes.length === 0) {
            alert('请先选择至少一个角色！');
            return;
        }

        const config = state.globalSettings.backgroundActivityConfig || {};
        selectedCheckboxes.forEach(checkbox => {
            const chatId = checkbox.dataset.chatId;
            if (freq === 'none') {
                delete config[chatId];
            } else {
                config[chatId] = freq;
            }
        });
        
        state.globalSettings.backgroundActivityConfig = config;
        
        // ★★★★★ 这就是我们新加的关键代码！★★★
        await db.globalSettings.put(state.globalSettings);
        // ★★★★★ 添加结束 ★★★★★
        
        renderBackgroundFrequencySelector();

        const freqTextMap = {low:'低', medium:'中', high:'高', none: '关闭'};
        const freqText = freqTextMap[freq];
        alert(`已为 ${selectedCheckboxes.length} 个角色将后台活动频率设为 "${freqText}"`);
    }
});

// ▼▼▼ NovelAI 图像生成系统事件监听器 ▼▼▼

// NovelAI开关控制
document.getElementById('novelai-switch').addEventListener('change', (e) => {
    const detailsDiv = document.getElementById('novelai-details');
    detailsDiv.style.display = e.target.checked ? 'block' : 'none';
});

// NovelAI API Key显示/隐藏切换
document.getElementById('novelai-key-toggle').addEventListener('click', function() {
    const input = document.getElementById('novelai-api-key');
    if (input.type === 'password') {
        input.type = 'text';
        this.textContent = '😌';
    } else {
        input.type = 'password';
        this.textContent = '🧐';
    }
});

// 打开NovelAI设置弹窗
document.getElementById('novelai-settings-btn').addEventListener('click', () => {
    loadNovelAISettings();
    document.getElementById('novelai-settings-modal').style.display = 'flex';
});

// CORS代理选择器变化事件
document.getElementById('nai-cors-proxy').addEventListener('change', (e) => {
    const customProxyGroup = document.getElementById('nai-custom-proxy-group');
    if (e.target.value === 'custom') {
        customProxyGroup.style.display = 'block';
    } else {
        customProxyGroup.style.display = 'none';
    }
});

// 关闭NovelAI设置弹窗
document.getElementById('close-novelai-settings').addEventListener('click', () => {
    document.getElementById('novelai-settings-modal').style.display = 'none';
});

// 保存NovelAI设置
document.getElementById('save-nai-settings-btn').addEventListener('click', () => {
    saveNovelAISettings();
    document.getElementById('novelai-settings-modal').style.display = 'none';
    alert('NovelAI设置已保存！');
});

// 恢复默认设置
document.getElementById('reset-nai-settings-btn').addEventListener('click', () => {
    if (confirm('确定要恢复默认设置吗？')) {
        resetNovelAISettings();
    }
});

// 打开NovelAI测试弹窗
document.getElementById('novelai-test-btn').addEventListener('click', () => {
    const apiKey = document.getElementById('novelai-api-key').value.trim();
    if (!apiKey) {
        alert('请先填写NovelAI API Key！');
        return;
    }
    document.getElementById('novelai-test-modal').style.display = 'flex';
    document.getElementById('nai-test-result').style.display = 'none';
    document.getElementById('nai-test-error').style.display = 'none';
});

// 关闭NovelAI测试弹窗
document.getElementById('close-novelai-test').addEventListener('click', () => {
    document.getElementById('novelai-test-modal').style.display = 'none';
});

document.getElementById('close-nai-test-btn').addEventListener('click', () => {
    document.getElementById('novelai-test-modal').style.display = 'none';
});

// NovelAI生成图像按钮
document.getElementById('nai-generate-btn').addEventListener('click', async () => {
    await generateNovelAIImage();
});

// NovelAI下载图像按钮
document.getElementById('nai-download-btn').addEventListener('click', () => {
    const img = document.getElementById('nai-result-image');
    const link = document.createElement('a');
    link.href = img.src;
    link.download = 'novelai-generated-' + Date.now() + '.png';
    link.click();
});

// ▼▼▼ 角色专属NAI提示词弹窗事件监听器 ▼▼▼

// 打开角色专属NAI提示词配置弹窗
document.getElementById('character-nai-prompts-btn').addEventListener('click', () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // 加载当前角色的NAI提示词配置
    const naiSettings = chat.settings.naiSettings || {
        promptSource: 'system',
        characterPositivePrompt: '',
        characterNegativePrompt: ''
    };
    
    // ★★★ 严格加载角色配置，不与系统配置混淆 ★★★
    // 填了就有，没填就为空，绝不使用系统配置填充
    document.getElementById('character-nai-positive').value = naiSettings.characterPositivePrompt || '';
    document.getElementById('character-nai-negative').value = naiSettings.characterNegativePrompt || '';
    
    document.getElementById('character-nai-prompts-modal').style.display = 'flex';
});

// 关闭角色专属NAI提示词弹窗
document.getElementById('close-character-nai-prompts').addEventListener('click', () => {
    document.getElementById('character-nai-prompts-modal').style.display = 'none';
});

// 保存角色专属NAI提示词
document.getElementById('save-character-nai-prompts-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    if (!chat.settings.naiSettings) {
        chat.settings.naiSettings = {
            promptSource: 'system'
        };
    }
    
    chat.settings.naiSettings.characterPositivePrompt = document.getElementById('character-nai-positive').value.trim();
    chat.settings.naiSettings.characterNegativePrompt = document.getElementById('character-nai-negative').value.trim();
    
    console.log('💾 [专属弹窗] 保存角色NAI提示词');
    console.log('   characterPositivePrompt:', chat.settings.naiSettings.characterPositivePrompt);
    console.log('   characterNegativePrompt:', chat.settings.naiSettings.characterNegativePrompt);
    console.log('   promptSource:', chat.settings.naiSettings.promptSource);
    
    // 保存到数据库
    await db.chats.put(chat);
    
    document.getElementById('character-nai-prompts-modal').style.display = 'none';
    alert('角色专属NAI提示词已保存！');
});

// 清空角色专属NAI提示词配置
document.getElementById('reset-character-nai-prompts-btn').addEventListener('click', () => {
    if (confirm('确定要清空当前角色的NAI提示词配置吗？')) {
        document.getElementById('character-nai-positive').value = '';
        document.getElementById('character-nai-negative').value = '';
    }
});

// ▲▲▲ 角色专属NAI提示词弹窗事件监听器结束 ▲▲▲

// ▼▼▼ 群聊角色专属NAI提示词弹窗事件监听器 ▼▼▼
document.getElementById('group-character-nai-prompts-btn').addEventListener('click', () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // 加载当前角色的NAI提示词配置
    const naiSettings = chat.settings.naiSettings || {
        promptSource: 'system',
        characterPositivePrompt: '',
        characterNegativePrompt: ''
    };
    
    // ★★★ 严格加载角色配置，不与系统配置混淆 ★★★
    // 填了就有，没填就为空，绝不使用系统配置填充
    document.getElementById('character-nai-positive').value = naiSettings.characterPositivePrompt || '';
    document.getElementById('character-nai-negative').value = naiSettings.characterNegativePrompt || '';
    
    document.getElementById('character-nai-prompts-modal').style.display = 'flex';
});
// ▲▲▲ 群聊角色专属NAI提示词弹窗事件监听器结束 ▲▲▲

// NovelAI设置相关函数
function loadNovelAISettings() {
    const settings = getNovelAISettings();
    document.getElementById('nai-resolution').value = settings.resolution;
    document.getElementById('nai-steps').value = settings.steps;
    document.getElementById('nai-cfg-scale').value = settings.cfg_scale;
    document.getElementById('nai-sampler').value = settings.sampler;
    document.getElementById('nai-seed').value = settings.seed;
    document.getElementById('nai-uc-preset').value = settings.uc_preset;
    document.getElementById('nai-quality-toggle').checked = settings.quality_toggle;
    document.getElementById('nai-smea').checked = settings.smea;
    document.getElementById('nai-smea-dyn').checked = settings.smea_dyn;
    document.getElementById('nai-default-positive').value = settings.default_positive;
    document.getElementById('nai-default-negative').value = settings.default_negative;
    document.getElementById('nai-cors-proxy').value = settings.cors_proxy;
    document.getElementById('nai-custom-proxy-url').value = settings.custom_proxy_url || '';
    
    // 显示/隐藏自定义代理输入框
    const customProxyGroup = document.getElementById('nai-custom-proxy-group');
    customProxyGroup.style.display = settings.cors_proxy === 'custom' ? 'block' : 'none';
}

function saveNovelAISettings() {
    // 保存API Key和模型等基础配置
    const novelaiEnabled = document.getElementById('novelai-switch').checked;
    const novelaiModel = document.getElementById('novelai-model').value;
    const novelaiApiKey = document.getElementById('novelai-api-key').value.trim();
    
    localStorage.setItem('novelai-enabled', novelaiEnabled);
    localStorage.setItem('novelai-model', novelaiModel);
    localStorage.setItem('novelai-api-key', novelaiApiKey);
    
    // 保存高级参数配置
    const settings = {
        resolution: document.getElementById('nai-resolution').value,
        steps: parseInt(document.getElementById('nai-steps').value),
        cfg_scale: parseFloat(document.getElementById('nai-cfg-scale').value),
        sampler: document.getElementById('nai-sampler').value,
        seed: parseInt(document.getElementById('nai-seed').value),
        uc_preset: parseInt(document.getElementById('nai-uc-preset').value),
        quality_toggle: document.getElementById('nai-quality-toggle').checked,
        smea: document.getElementById('nai-smea').checked,
        smea_dyn: document.getElementById('nai-smea-dyn').checked,
        default_positive: document.getElementById('nai-default-positive').value,
        default_negative: document.getElementById('nai-default-negative').value,
        cors_proxy: document.getElementById('nai-cors-proxy').value,
        custom_proxy_url: document.getElementById('nai-custom-proxy-url').value
    };
    localStorage.setItem('novelai-settings', JSON.stringify(settings));
}

function resetNovelAISettings() {
    localStorage.removeItem('novelai-settings');
    loadNovelAISettings();
    alert('已恢复默认设置！');
}

/**
 * 为指定角色生成NovelAI图像（将来聊天调用时使用）
 * @param {string} chatId - 聊天/角色ID
 * @param {string} customPrompt - 可选的自定义正面提示词（如果提供则追加到配置的提示词后）
 * @returns {Promise<string>} 返回生成的图像Base64数据URL
 */
async function generateNovelAIImageForCharacter(chatId, customPrompt = '') {
    const apiKey = document.getElementById('novelai-api-key').value.trim();
    const model = document.getElementById('novelai-model').value;
    
    if (!apiKey) {
        throw new Error('请先配置NovelAI API Key！');
    }
    
    // 获取角色的提示词配置
    const prompts = getCharacterNAIPrompts(chatId);
    
    // 构建最终的提示词（如果有自定义提示词则追加）
    let finalPrompt = prompts.positive;
    if (customPrompt) {
        finalPrompt = customPrompt + ', ' + prompts.positive;
    }
    
    const negativePrompt = prompts.negative;
    
    console.log(`📝 使用${prompts.source === 'character' ? '角色专属' : '系统'}提示词配置`);
    console.log('正面提示词:', finalPrompt);
    console.log('负面提示词:', negativePrompt);
    
    const settings = getNovelAISettings();
    
    // 后续的图像生成逻辑将在这里实现
    // 这个函数预留给将来聊天中调用NAI出图功能使用
    return null;
}
// ▲▲▲ 角色NAI提示词配置辅助函数结束 ▲▲▲

async function generateNovelAIImage() {
    const apiKey = document.getElementById('novelai-api-key').value.trim();
    const model = document.getElementById('novelai-model').value;
    const prompt = document.getElementById('nai-test-prompt').value.trim();
    
    if (!apiKey) {
        alert('请先配置NovelAI API Key！');
        return;
    }
    
    if (!prompt) {
        alert('请输入提示词！');
        return;
    }
    
    const settings = getNovelAISettings();
    const negativePrompt = document.getElementById('nai-test-negative').value.trim();
    
    const statusDiv = document.getElementById('nai-test-status');
    const resultDiv = document.getElementById('nai-test-result');
    const errorDiv = document.getElementById('nai-test-error');
    const generateBtn = document.getElementById('nai-generate-btn');
    
    statusDiv.style.display = 'block';
    resultDiv.style.display = 'none';
    errorDiv.style.display = 'none';
    generateBtn.disabled = true;
    generateBtn.textContent = '生成中...';
    
    try {
        const [width, height] = settings.resolution.split('x').map(Number);
        
        // ★★★ V4/V4.5 和 V3 使用不同的请求体格式 ★★★
        let requestBody;
        
        if (model.includes('nai-diffusion-4')) {
            // V4/V4.5 使用新格式 (params_version: 3)
            requestBody = {
                input: prompt,
                model: model,
                action: 'generate',
                parameters: {
                    params_version: 3,  // V4必须使用版本3
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    autoSmea: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: true,
                    cfg_rescale: 0,
                    noise_schedule: 'karras',  // V4使用karras
                    legacy_v3_extend: false,
                    skip_cfg_above_sigma: null,
                    use_coords: false,
                    legacy_uc: false,
                    normalize_reference_strength_multiple: true,
                    inpaintImg2ImgStrength: 1,
                    characterPrompts: [],
                    // V4专用提示词格式
                    v4_prompt: {
                        caption: {
                            base_caption: prompt,
                            char_captions: []
                        },
                        use_coords: false,
                        use_order: true
                    },
                    // V4专用负面提示词格式
                    v4_negative_prompt: {
                        caption: {
                            base_caption: negativePrompt,
                            char_captions: []
                        },
                        legacy_uc: false
                    },
                    negative_prompt: negativePrompt,
                    deliberate_euler_ancestral_bug: false,
                    prefer_brownian: true
                    // 注意：不包含 stream 参数，使用标准ZIP响应而非msgpack流
                }
            };
        } else {
            // V3 及更早版本使用旧格式
            requestBody = {
                input: prompt,
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    sm: settings.smea,
                    sm_dyn: settings.smea_dyn,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: negativePrompt
                }
            };
        }
        
        console.log('📤 发送请求到 NovelAI API');
        console.log('📊 使用模型:', model);
        console.log('📋 请求体:', JSON.stringify(requestBody, null, 2));
        
        // ★★★ 根据模型选择不同的API端点 ★★★
        let apiUrl;
        
        // V4/V4.5 模型使用流式端点
        if (model.includes('nai-diffusion-4')) {
            // V4/V4.5 默认使用流式端点
            apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
        } else {
            // V3 及更早版本使用标准端点
            apiUrl = 'https://image.novelai.net/ai/generate-image';
        }
        
        let corsProxy = settings.cors_proxy;
        
        // 如果选择了自定义代理，使用自定义URL
        if (corsProxy === 'custom') {
            corsProxy = settings.custom_proxy_url || '';
        }
        
        // 如果有代理，添加到URL前面
        if (corsProxy && corsProxy !== '') {
            apiUrl = corsProxy + encodeURIComponent(apiUrl);
        }
        
        // ★★★ Chrome浏览器专用处理：避免headers中包含非ISO-8859-1字符 ★★★
        const isChrome = /Chrome/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);
        let fetchOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify(requestBody)
        };
        
        // 针对Chrome浏览器：确保所有header值都是纯ASCII
        if (isChrome) {
            console.log('🔧 检测到Chrome浏览器，启用headers兼容性处理');
            const cleanHeaders = {};
            for (const [key, value] of Object.entries(fetchOptions.headers)) {
                // 确保header值只包含ASCII字符（ISO-8859-1兼容）
                cleanHeaders[key] = value.replace(/[^\x00-\xFF]/g, '');
            }
            fetchOptions.headers = cleanHeaders;
        }
        
        const response = await fetch(apiUrl, fetchOptions);
        
        console.log('Response status:', response.status);
        console.log('Response headers:', [...response.headers.entries()]);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('API错误响应:', errorText);
            throw new Error(`API请求失败 (${response.status}): ${errorText}`);
        }
        
        // NovelAI API返回的是ZIP文件，需要解压
        const contentType = response.headers.get('content-type');
        console.log('Content-Type:', contentType);
        
        // 检查是否为 SSE 流式响应
        let zipBlob;
        if (contentType && contentType.includes('text/event-stream')) {
            console.log('检测到 SSE 流式响应，开始解析...');
            statusDiv.textContent = '正在接收流式数据...';
            
            // 读取整个流
            const text = await response.text();
            console.log('收到 SSE 数据，大小:', text.length);
            
            // 解析 SSE 格式，提取最后的 data: 行
            const lines = text.trim().split('\n');
            let base64Data = null;
            
            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6); // 移除 'data: ' 前缀
                    
                    // 尝试解析 JSON
                    try {
                        const jsonData = JSON.parse(dataContent);
                        
                        // V4.5 流式端点：event_type 为 "final" 时包含最终图片
                        if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('✅ 找到 final 事件的图片数据');
                            break;
                        }
                        
                        // 兼容其他格式
                        if (jsonData.data) {
                            base64Data = jsonData.data;
                            console.log('从 JSON.data 中提取图片数据');
                            break;
                        }
                        if (jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('从 JSON.image 中提取图片数据');
                            break;
                        }
                    } catch (e) {
                        // 如果不是 JSON，直接作为 base64 数据
                        base64Data = dataContent;
                        console.log('直接使用 base64 数据');
                        break;
                    }
                }
            }
            
            if (!base64Data) {
                throw new Error('无法从 SSE 响应中提取图片数据');
            }
            
            // V4.5 流式端点返回的是 PNG base64，不是 ZIP
            // 检查是否为 PNG (以 iVBORw0KGgo 开头) 或 JPEG (以 /9j/ 开头)
            const isPNG = base64Data.startsWith('iVBORw0KGgo');
            const isJPEG = base64Data.startsWith('/9j/');
            
            if (isPNG || isJPEG) {
                console.log('✅ 检测到直接的图片 base64 数据 (PNG/JPEG)');
                // 将 base64 转为 Blob
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const imageBlob = new Blob([bytes], { type: isPNG ? 'image/png' : 'image/jpeg' });
                console.log('图片 Blob 创建成功，大小:', imageBlob.size);
                
                // 直接显示图片
                const imageUrl = URL.createObjectURL(imageBlob);
                document.getElementById('nai-result-image').src = imageUrl;
                statusDiv.style.display = 'none';
                resultDiv.style.display = 'block';
                console.log('✅ 图片显示成功！🎨');
                return;
            }
            
            // 否则当作 ZIP 处理
            console.log('当作 ZIP 文件处理...');
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            zipBlob = new Blob([bytes]);
            console.log('ZIP Blob 大小:', zipBlob.size);
            
        } else {
            // 非流式响应，直接读取
            zipBlob = await response.blob();
            console.log('收到数据，类型:', zipBlob.type, '大小:', zipBlob.size);
        }
        
        // NovelAI始终返回ZIP格式，需要解压
        try {
            // 检查JSZip是否已加载
            if (typeof JSZip === 'undefined') {
                throw new Error('JSZip库未加载，请刷新页面重试');
            }
            
            statusDiv.textContent = '正在解压图片...';
            
            // 解压ZIP文件
            const zip = await JSZip.loadAsync(zipBlob);
            console.log('ZIP文件内容:', Object.keys(zip.files));
            
            // 查找第一个图片文件（通常是image_0.png）
            let imageFile = null;
            for (let filename in zip.files) {
                if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                    imageFile = zip.files[filename];
                    console.log('找到图片文件:', filename);
                    break;
                }
            }
            
            if (!imageFile) {
                throw new Error('ZIP文件中未找到图片');
            }
            
            // 提取图片数据
            const imageBlob = await imageFile.async('blob');
            console.log('提取的图片大小:', imageBlob.size);
            
            // 创建图片URL并显示
            const imageUrl = URL.createObjectURL(imageBlob);
            console.log('生成的图片URL:', imageUrl);
            
            document.getElementById('nai-result-image').src = imageUrl;
            statusDiv.style.display = 'none';
            resultDiv.style.display = 'block';
            
        } catch (zipError) {
            console.error('ZIP解压失败:', zipError);
            // 如果解压失败，尝试直接作为图片显示
            console.log('尝试直接作为图片显示...');
            
            if (zipBlob.type.startsWith('image/')) {
                const imageUrl = URL.createObjectURL(zipBlob);
                document.getElementById('nai-result-image').src = imageUrl;
                statusDiv.style.display = 'none';
                resultDiv.style.display = 'block';
            } else {
                throw new Error('图片格式处理失败: ' + zipError.message);
            }
        }
        
    } catch (error) {
        console.error('NovelAI生成失败:', error);
        statusDiv.style.display = 'none';
        errorDiv.style.display = 'block';
        errorDiv.textContent = '生成失败: ' + error.message;
    } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = '生成图像';
    }
}

// ▲▲▲ NovelAI 图像生成系统事件监听器结束 ▲▲▲

// 使用事件委托，为所有可编辑元素统一绑定点击事件
document.getElementById('home-screen').addEventListener('click', (e) => {
    const target = e.target;
    
    // 检查点击的是否是可编辑的文字（包括子元素）
    const editableTextElement = target.classList.contains('editable-text') 
        ? target 
        : target.closest('.editable-text');
    
    if (editableTextElement) {
        handleEditText(editableTextElement);
        return;
    }
    
    // 检查点击的是否是可编辑的图片（包括子元素）
    const editableImageElement = target.classList.contains('editable-image') 
        ? target 
        : target.closest('.editable-image');
    
    if (editableImageElement) {
        handleEditImage(editableImageElement);
        return;
    }
});
// ▼▼▼ 步骤 2.2：在 init() 函数的最末尾，粘贴这整块全新的滑动逻辑 ▼▼▼

const homeScreenSlider = document.querySelector('.home-screen-slider');
const dots = document.querySelectorAll('.pagination-dots .dot');
if (homeScreenSlider && dots.length > 0) {
    let currentPage = 0;
    let touchStartX = 0;
    let isDragging = false;

    function updateDots() {
        dots.forEach((dot, index) => {
            dot.classList.toggle('active', index === currentPage);
        });
    }

    function slideToPage(pageIndex) {
        currentPage = pageIndex;
        const offset = - (currentPage * 100);
        homeScreenSlider.style.transform = `translateX(${offset}%)`;
        updateDots();
    }
    
    function getEventX(e) {
        return e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    }

    function handleTouchStart(e) {
        isDragging = true;
        touchStartX = getEventX(e);
        homeScreenSlider.style.transition = 'none';
    }

    function handleTouchMove(e) {
        if (!isDragging) return;
        const currentX = getEventX(e);
        const diffX = currentX - touchStartX;
        const baseOffset = - (currentPage * 100);
        homeScreenSlider.style.transform = `translateX(calc(${baseOffset}% + ${diffX}px))`;
    }

    function handleTouchEnd(e) {
        if (!isDragging) return;
        isDragging = false;
        homeScreenSlider.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
        
        const touchEndX = e.type.includes('touch') ? e.changedTouches[0].clientX : e.clientX;
        const diffX = touchEndX - touchStartX;
        const threshold = 50;

        if (diffX < -threshold && currentPage < dots.length - 1) {
            currentPage++;
        } else if (diffX > threshold && currentPage > 0) {
            currentPage--;
        }
        slideToPage(currentPage);
    }
    
    const homeScreenContainer = document.getElementById('home-screen');
    homeScreenContainer.addEventListener('touchstart', handleTouchStart, { passive: true });
    homeScreenContainer.addEventListener('touchmove', handleTouchMove, { passive: true });
    homeScreenContainer.addEventListener('touchend', handleTouchEnd);
    homeScreenContainer.addEventListener('mousedown', handleTouchStart);
    document.addEventListener('mousemove', handleTouchMove);
    document.addEventListener('mouseup', handleTouchEnd);
}

// ▲▲▲ 滑动逻辑粘贴结束 ▲▲▲
// ▼▼▼ 【全新】“查手机”内容单条删除功能 ▼▼▼
/**
 * 处理角色手机内数据删除的通用函数
 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要删除的数据在数组中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 【核心修改】处理像 bank.transactions 这样的嵌套数据
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条记录吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根据删除的类型，重新渲染对应的APP界面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break; // 新增
            case 'trajectory': renderCharacterTrajectory(); break;   // 新增
            case 'appUsage': renderCharacterAppUsage(); break;       // 新增
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;   // 新增
        }
        alert('记录已删除。');
    }
}
// 使用事件委托来处理所有删除按钮的点击
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    if (e.target.classList.contains('item-delete-btn')) {
        const dataType = e.target.dataset.type;
        const index = parseInt(e.target.dataset.index);
        if (dataType && !isNaN(index)) {
            handleCharacterDataDeletion(dataType, index);
        }
    }
});
// ▲▲▲ 删除功能结束 ▲▲▲
// ▼▼▼ 【全新】“查手机”内容单条删除功能 ▼▼▼
/**
 * 处理角色手机内数据删除的通用函数
 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要删除的数据在数组中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 处理像 bank.transactions 这样的嵌套数据
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条记录吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根据删除的类型，重新渲染对应的APP界面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
        }
        alert('记录已删除。');
    }
}
// ▲▲▲ 删除功能结束 ▲▲▲
startGroupSimulation(); // 启动群聊专属的后台时钟
// ▲▲▲ 新事件绑定结束 ▲▲▲
    // ▼▼▼ 步骤3.3：在 init() 的前面粘贴这段新代码 ▼▼▼
    // 使用事件委托，监听整个动态列表的“焦点移出”事件
    document.getElementById('qzone-posts-list').addEventListener('focusout', (e) => {
        // 如果是评论输入框失去了焦点
        if (e.target.classList.contains('comment-input')) {
            const commentInput = e.target;
            // 并且输入框是空的
            if (commentInput.value.trim() === '') {
                // 就重置它的状态，取消回复
                commentInput.placeholder = '友善的评论是交流的起点';
                delete commentInput.dataset.replyTo;
            }
        }
    });
    // ▲▲▲ 步骤3.3粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块代码，粘贴到 init(); 的正上方 ▼▼▼
// 【全新】为时间感知开关添加实时交互事件
document.getElementById('time-perception-toggle').addEventListener('change', (e) => {
    const customTimeContainer = document.getElementById('custom-time-container');
    customTimeContainer.style.display = e.target.checked ? 'none' : 'block';
});
// ▲▲▲ 粘贴结束 ▲▲▲
// 请用这段新代码替换上面的错误代码
document.getElementById('char-heart-btn').addEventListener('click', openInnerVoiceModal);

document.getElementById('close-inner-voice-modal').addEventListener('click', () => {
    document.getElementById('inner-voice-modal').classList.remove('visible');
});
document.getElementById('inner-voice-history-btn').addEventListener('click', toggleInnerVoiceHistory);
document.getElementById('back-from-history-btn').addEventListener('click', toggleInnerVoiceHistory);
// ▲▲▲ 心声功能事件监听器结束 ▲▲▲
// ▼▼▼ 把下面这一整块新函数，粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】导出当前角色的聊天记录
 */
async function exportChatHistory() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 1. 创建一个只包含聊天记录和角色名的对象
    const exportData = {
        characterName: chat.name,
        exportedAt: new Date().toISOString(),
        history: chat.history
    };

    // 2. 将这个对象转换为格式化的JSON字符串
    const jsonString = JSON.stringify(exportData, null, 2);
    
    // 3. 创建一个Blob对象
    const blob = new Blob([jsonString], { type: 'application/json' });
    
    // 4. 创建一个临时的下载链接
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    // 5. 设置下载链接的属性，包括文件名
    const dateStr = new Date().toISOString().split('T')[0];
    link.href = url;
    link.download = `[${chat.name}]-聊天记录-${dateStr}.json`;
    
    // 6. 模拟点击链接来触发下载
    document.body.appendChild(link);
    link.click();
    
    // 7. 清理临时创建的元素和URL
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    await showCustomAlert('导出成功', `与“${chat.name}”的聊天记录已开始下载！`);
}

/**
 * 【全新】导入聊天记录到当前角色
 */
async function importChatHistory(file) {
    if (!file) return;
    if (!state.activeChatId) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);

            // 关键验证：检查导入的文件是否包含一个名为 'history' 的数组
            if (!data.history || !Array.isArray(data.history)) {
                throw new Error("文件格式不正确，缺少有效的'history'数据。");
            }

            const chat = state.chats[state.activeChatId];
            
            // 安全警告：提醒用户这将覆盖现有记录
            const confirmed = await showCustomConfirm(
                '确认导入',
                `这将会【覆盖】你与“${chat.name}”的当前所有聊天记录。此操作无法撤销，确定要继续吗？`,
                { confirmButtonClass: 'btn-danger' }
            );

            if (confirmed) {
                // 替换历史记录
                chat.history = data.history;
                // 保存到数据库
                await db.chats.put(chat);
                // 刷新界面
                renderChatInterface(state.activeChatId);
                renderChatList(); // 刷新列表以更新最后一条消息
                await showCustomAlert('导入成功', '聊天记录已成功导入并覆盖！');
            }
        } catch (error) {
            console.error("导入聊天记录失败:", error);
            await showCustomAlert('导入失败', `无法导入文件，请检查文件是否为正确的聊天记录备份文件。\n\n错误: ${error.message}`);
        }
    };
    reader.readAsText(file, 'UTF-8');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】气泡样式预设导入/导出功能 ▼▼▼

/**
 * 导出当前选中的气泡样式预设
 */
async function exportSelectedBubblePreset() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (!selectedId) {
        alert("请先从下拉框中选择一个要导出的预设。");
        return;
    }

    const preset = await db.bubbleStylePresets.get(selectedId);
    if (!preset) {
        alert("找不到选中的预设。");
        return;
    }

    // 准备要导出的数据
    const exportData = {
        presetName: preset.name,
        presetCss: preset.css
    };

    // 创建并触发下载
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `[EPhone气泡]${preset.name}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * 处理导入的气泡样式预设文件
 * @param {File} file - 用户选择的.json文件
 */
function importBubblePreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            // 验证文件内容是否正确
            if (data.presetName && typeof data.presetCss !== 'undefined') {
                const newPreset = {
                    name: `${data.presetName} (导入)`,
                    css: data.presetCss
                };
                const newId = await db.bubbleStylePresets.add(newPreset);

                if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
                state.bubbleStylePresets.push({ id: newId, ...newPreset });

                // 刷新下拉框并自动选中新导入的预设
                renderBubblePresetSelector();
                document.getElementById('bubble-style-preset-select').value = newId;
                handlePresetSelectChange();
                await showCustomAlert('导入成功', `气泡预设 "${newPreset.name}" 已成功导入！`);
            } else {
                alert("导入失败：文件格式不正确。");
            }
        } catch (error) {
            alert(`导入失败：文件解析错误。 ${error.message}`);
        }
    };
    reader.readAsText(file);
}

// ▲▲▲ 新增功能函数结束 ▲▲▲

// ▼▼▼ 用这【一整块】代码，替换掉所有旧的、和微博相关的事件监听器 ▼▼▼

// ▼▼▼ 请用下面这【一整块】代码，完整替换掉上面那段旧代码 ▼▼▼
document.getElementById('weibo-app-icon').addEventListener('click', () => {
    renderWeiboProfile(); // 渲染个人资料
    renderMyWeiboFeed(); // <-- 就是新增了这一行！主动渲染“我的微博”列表
    switchToWeiboView('weibo-my-profile-view'); // 默认显示“我的微博”
    showScreen('weibo-screen');
});
// ▲▲▲ 替换结束 ▲▲▲


// 2. 绑定微博页面内的各种点击事件 (使用事件委托)
document.getElementById('weibo-screen').addEventListener('click', async (e) => {
    const target = e.target;
    const postItem = target.closest('.weibo-post-item');
    const postId = postItem ? parseInt(postItem.dataset.postId) : null;

    // --- 处理“删除评论”按钮 ---
    const deleteCommentBtn = target.closest('.comment-delete-btn');
    if (deleteCommentBtn) {
        const commentItem = deleteCommentBtn.closest('.weibo-comment-item');
        if (postId && commentItem && commentItem.dataset.commentId) {
            deleteWeiboComment(postId, commentItem.dataset.commentId);
        }
        return;
    }

    // --- 处理“生成评论”按钮 ---
    const generateBtn = target.closest('.generate-comments-btn');
    if (generateBtn) {
        if (postId) {
            generateWeiboComments(postId);
        }
        return; 
    }

    // --- 处理底部导航栏切换 ---
    const navItem = target.closest('.weibo-nav-item');
    if (navItem && navItem.dataset.view) {
        switchToWeiboView(navItem.dataset.view);
        return;
    }

    // --- 处理旧的“…”删除按钮 ---
    const actionsBtn = target.closest('.post-actions-btn');
    if (actionsBtn) {
        const confirmed = await showCustomConfirm('删除微博', '确定要永久删除这条微博吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' });
        if (confirmed && postId) {
            await db.weiboPosts.delete(postId);
            await renderMyWeiboFeed();
            await renderFollowingWeiboFeed();
            await renderWeiboProfile();
            alert('微博已删除。');
        }
        return;
    }
    
    // --- 处理点赞、评论、回复 ---
    if (target.closest('.like-btn')) { if (postId) handleWeiboLike(postId); return; }
    if (target.closest('.weibo-comment-send-btn')) { const input = postItem.querySelector('.weibo-comment-input'); if (postId && input) handleWeiboComment(postId, input); return; }
    
    const commentItem = target.closest('.weibo-comment-item');
    if (commentItem) {
        const commenterName = commentItem.dataset.commenterName;
        const commentId = commentItem.dataset.commentId;
        const input = postItem.querySelector('.weibo-comment-input');
        if (input.dataset.replyToId === commentId) {
            input.placeholder = '留下你的精彩评论吧...';
            delete input.dataset.replyToId; delete input.dataset.replyToNickname;
        } else {
            input.placeholder = `回复 @${commenterName}:`;
            input.dataset.replyToId = commentId; input.dataset.replyToNickname = commenterName;
            input.focus();
        }
        return;
    }
});

// 3. 【核心】为微博个人主页的所有可编辑元素，绑定专属的编辑函数
document.getElementById('weibo-profile-page').addEventListener('click', (e) => {
    const target = e.target;
    if (target.id === 'weibo-avatar-img' || target.closest('.weibo-avatar-container')) {
        editWeiboAvatar();
    } else if (target.id === 'weibo-nickname') {
        editWeiboNickname();
    } else if (target.id === 'weibo-background-img') {
        editWeiboBackground();
    } else if (target.closest('#weibo-fans-item')) {
        editWeiboFansCount();
    }
});

// 4. 【核心】为“关注”数字和“发布微博”按钮绑定事件
document.getElementById('weibo-following-btn').addEventListener('click', showFollowingList);
document.getElementById('create-weibo-post-btn').addEventListener('click', openWeiboPublisherClean);
document.getElementById('close-following-list-btn').addEventListener('click', () => {
    document.getElementById('weibo-following-modal').classList.remove('visible');
});
document.getElementById('clear-following-feed-btn').addEventListener('click', clearFollowingFeed);

// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【微博专属 V2 - 干净版】打开微博发布模态框
 * 这个版本不再依赖任何动态(QZone)的HTML元素，彻底分家。
 */
function openWeiboPublisherClean() {
    // 1. 重置并获取模态框
    resetCreatePostModal(); 
    const modal = document.getElementById('create-post-modal');
    
    // 2. 设置为“微博”模式，并修改标题和提示语
    modal.dataset.mode = 'weibo';
    document.getElementById('create-post-modal-title').textContent = '发微博';
    document.getElementById('post-public-text').placeholder = '有什么新鲜事想分享给大家？';

    // 3. 【核心修复】确保所有“动态”专属的HTML元素都被隐藏
    // 我们现在不再去获取它们的style，而是直接找到它们并设置display: 'none'
    const imageDescGroup = document.getElementById('post-image-desc-group');
    if (imageDescGroup) imageDescGroup.style.display = 'none';
    
    const commentsToggleGroup = document.getElementById('post-comments-toggle-group');
    if (commentsToggleGroup) commentsToggleGroup.style.display = 'none';

    // 4. 显示微博需要的控件
    const modeSwitcher = document.getElementById('post-mode-switcher');
    if (modeSwitcher) modeSwitcher.style.display = 'flex';
    
    // 确保模式内容区域的display样式被重置（微博也需要这些区域）
    const imageModeContent = document.getElementById('image-mode-content');
    const textImageModeContent = document.getElementById('text-image-mode-content');
    if (imageModeContent) imageModeContent.style.display = '';
    if (textImageModeContent) textImageModeContent.style.display = '';
    
    // 5. 显示弹窗
    modal.classList.add('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

document.getElementById('close-following-list-btn').addEventListener('click', () => {
    document.getElementById('weibo-following-modal').classList.remove('visible');
});
document.getElementById('clear-following-feed-btn').addEventListener('click', clearFollowingFeed);

// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ===================================================================
// 5. 启动！

// 应用壁纸并更新所有时钟
applyLockscreenWallpaper();
updateLockClock();

// ▼▼▼ 【最终修复版】请用这整块代码，替换掉你 init() 函数中旧的锁屏和状态栏开关逻辑 ▼▼▼

// 1. 读取、应用并监听“启用锁屏”设置
const enableLockScreenToggle = document.getElementById('enable-lock-screen-toggle');
const lockScreenEnabled = localStorage.getItem('lockScreenEnabled') !== 'false';
enableLockScreenToggle.checked = lockScreenEnabled;

// 2. 读取、应用并监听“显示状态栏”设置
const showStatusBarToggle = document.getElementById('show-status-bar-toggle');
const statusBar = document.getElementById('status-bar');
// 读取保存的状态，如果没保存过，默认是 true (显示)
const showStatusBar = localStorage.getItem('showStatusBar') !== 'false'; 
// 让开关的状态和保存的状态同步
showStatusBarToggle.checked = showStatusBar; 
// 根据保存的状态，决定一加载进来时是否显示状态栏
if (showStatusBar) {
    statusBar.style.display = 'flex';
} else {
    statusBar.style.display = 'none';
}

// 3. 【关键】给开关添加“变化”监听器，这样你每次点击它都会保存状态
showStatusBarToggle.addEventListener('change', (e) => {
    const isEnabled = e.target.checked;
    // a. 将新的开关状态 (true 或 false) 保存到浏览器的 localStorage 里
    localStorage.setItem('showStatusBar', isEnabled);
    // b. 立刻根据新的状态来显示或隐藏状态栏
    statusBar.style.display = isEnabled ? 'flex' : 'none';
});

// 4. 根据最终的锁屏设置，决定应用启动时第一个显示的屏幕
if (lockScreenEnabled) {
    lockPhone(); // 如果设置是“启用”，就锁定手机
} else {
    showScreen('home-screen'); // 否则，直接进入主屏幕
}
// ▲▲▲ 替换结束 ▲▲▲

        }

        init();
 // ▼▼▼ 把这【一整块】全新的代码，粘贴到 <script> 标签内的【变量定义区域】的末尾 ▼▼▼

const avatarFrames = [
    { id: 'none', url: '', name: '无' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif', name: '14' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif', name: '14' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif', name: '14' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif', name: '14' },
    { id: 'frame_12', url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif', name: '12' },
    { id: 'frame_13', url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif', name: '14' },
];

// ▲▲▲ 粘贴结束 ▲▲▲       
    });

    // 页面加载完成后初始化恋爱空间（如果当前在恋爱空间）
    setTimeout(() => {
        const loveSpaceView = document.getElementById('love-space-view');
        if (loveSpaceView && loveSpaceView.style.display === 'flex') {
            initLoveSpace();
        }
    }, 1000);

// ===== 恋爱空间邀请功能 =====
// 简化的模态框函数
function simpleAlert(title, message) {
    return new Promise((resolve) => {
        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');
        
        modalTitle.textContent = title;
        modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
        modalCancelBtn.style.display = 'none';
        modalConfirmBtn.textContent = '好的';
        
        const confirmHandler = () => {
            modalCancelBtn.style.display = 'block';
            modalConfirmBtn.textContent = '确定';
            modalOverlay.classList.remove('visible');
            modalConfirmBtn.removeEventListener('click', confirmHandler);
            resolve(true);
        };
        
        modalConfirmBtn.addEventListener('click', confirmHandler);
        modalOverlay.classList.add('visible');
    });
}

async function changeAIAvatar() {
    try {
        // 检查是否已经绑定了角色
        const boundCharId = localStorage.getItem('loveSpaceBoundChar');
        if (boundCharId && state.chats[boundCharId]) {
            // 已绑定角色，显示提示信息，不再允许邀请
            const boundCharName = state.chats[boundCharId].name;
            await simpleAlert('恋爱空间', `💕 您已与 ${boundCharName} 绑定了恋爱空间！\n\n✨ 头像显示您们的恋爱状态~`);
            return;
        }
        
        // 未绑定角色，显示角色选择
        await showCharacterSelection();
    } catch (error) {
        console.error('changeAIAvatar error:', error);
        await simpleAlert('错误', '功能暂时不可用，请稍后再试。');
    }
}

// 显示角色选择界面
async function showCharacterSelection() {
    const availableChars = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    if (availableChars.length === 0) {
        await simpleAlert('提示', '您还没有创建任何AI角色，请先在聊天页面创建AI角色后再进行选择。');
        return;
    }
    
    // 创建选择列表
    let optionsHtml = availableChars.map(chat => {
        // 使用聊天设置中的AI头像（和恋爱空间邀请卡片保持一致）
        const aiAvatar = chat.settings.aiAvatar || 'img/default_avatar.png';
        return '<div class="char-option" data-char-id="' + chat.id + '" style="cursor: pointer; padding: 12px; display: flex; align-items: center; border-radius: 8px; transition: background-color 0.2s; margin-bottom: 8px;">' +
            '<img src="' + aiAvatar + '" alt="' + chat.name + '" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 12px;">' +
            '<span>' + chat.name + '</span>' +
        '</div>';
    }).join('');
    
    // 使用现有的modal系统
    const selectedCharId = await new Promise((resolve) => {
        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalFooter = document.querySelector('.custom-modal-footer');
        
        modalTitle.textContent = '选择AI角色';
        modalBody.innerHTML = optionsHtml;
        modalFooter.style.display = 'none'; // 隐藏默认按钮
        
        modalBody.querySelectorAll('.char-option').forEach(option => {
            option.addEventListener('mouseenter', () => {
                option.style.backgroundColor = '#f0f0f0';
            });
            option.addEventListener('mouseleave', () => {
                option.style.backgroundColor = '';
            });
            
            option.addEventListener('click', () => {
                resolve(option.dataset.charId);
                modalOverlay.classList.remove('visible');
                modalFooter.style.display = 'flex';
            });
        });
        
        // 点击背景关闭
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                resolve(null);
                modalOverlay.classList.remove('visible');
                modalFooter.style.display = 'flex';
            }
        });
        
        modalOverlay.classList.add('visible');
    });
    
    if (selectedCharId) {
        await showInviteMenu(selectedCharId);
    }
}

// 显示邀请菜单
async function showInviteMenu(charId) {
    const selectedChar = state.chats[charId];
    if (!selectedChar) return;
    
    // 再次检查绑定状态（防止重复绑定）
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (boundCharId) {
        const boundCharName = state.chats[boundCharId]?.name || '该角色';
        await simpleAlert('提示', `您已与 ${boundCharName} 绑定了恋爱空间！`);
        return;
    }
    
    // 创建邀请界面
    const realTimeAvatar = selectedChar.settings?.aiAvatar || selectedChar.avatar || 'img/default_avatar.png';
    const inviteHtml = 
        '<div style="text-align: center; padding: 20px;">' +
            '<img src="' + realTimeAvatar + '" alt="' + selectedChar.name + '" ' +
                 'style="width: 80px; height: 80px; border-radius: 50%; margin-bottom: 15px;">' +
            '<h3 style="margin: 10px 0; color: #333;">' + selectedChar.name + '</h3>' +
            '<p style="color: #666; margin-bottom: 20px;">邀请TA成为您的恋爱空间伴侣</p>' +
            '<button id="send-invite-btn" style="' +
                'background: linear-gradient(135deg, #ff6b9d, #c44569);' +
                'color: white;' +
                'border: none;' +
                'padding: 12px 30px;' +
                'border-radius: 25px;' +
                'font-size: 16px;' +
                'font-weight: 600;' +
                'cursor: pointer;' +
                'box-shadow: 0 4px 15px rgba(255, 107, 157, 0.3);' +
                'transition: all 0.3s ease;' +
            '" onmouseover="this.style.transform=\'scale(1.05)\'" onmouseout="this.style.transform=\'scale(1)\'">' +
                '💕 发送邀请' +
            '</button>' +
        '</div>';
    
    // 使用现有的modal系统
    const result = await new Promise((resolve) => {
        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalFooter = document.querySelector('.custom-modal-footer');
        
        modalTitle.textContent = '恋爱空间邀请';
        modalBody.innerHTML = inviteHtml;
        modalFooter.style.display = 'none';
        
        // 绑定发送邀请按钮事件
        document.getElementById('send-invite-btn').addEventListener('click', async () => {
            console.log('邀请按钮被点击');
            resolve('invite');
            modalOverlay.classList.remove('visible');
            modalFooter.style.display = 'flex';
        });
        
        // 点击背景关闭
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                resolve(null);
                modalOverlay.classList.remove('visible');
                modalFooter.style.display = 'flex';
            }
        });
        
        modalOverlay.classList.add('visible');
    });
    
    if (result === 'invite') {
        await sendLoveSpaceInvite(charId);
    }
}

// 发送恋爱空间邀请
async function sendLoveSpaceInvite(charId) {
    console.log('发送恋爱空间邀请:', charId);
    const selectedChar = state.chats[charId];
    if (!selectedChar) {
        console.error('找不到角色:', charId);
        return;
    }
    
    // 检查是否已经绑定
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (boundCharId) {
        await simpleAlert('提示', '您已经与其他角色绑定了恋爱空间！');
        return;
    }
    
    // 检查是否已有待处理的邀请
        if (!selectedChar.history) {
            selectedChar.history = [];
        }
        
    const pendingInvite = selectedChar.history.find(msg => 
        msg.cardType === 'love_space_invite' && 
        msg.role === 'user' && 
        msg.cardData?.status === 'pending'
    );
    
    if (pendingInvite) {
        await simpleAlert('提示', '您已向该角色发送过邀请，请耐心等待对方回应~');
        return;
    }
    
    try {
        // 创建邀请卡片消息
        selectedChar.history.push({
            id: 'invite_' + Date.now(),
            role: 'user',
            content: '💕 我向你发送了恋爱空间邀请！我想邀请你成为我的恋爱空间伴侣，在这里我们可以一起打卡、分享照片、记录美好时光~ 你愿意接受吗？',
            timestamp: Date.now(),
            cardType: 'love_space_invite',
            cardData: {
                title: '恋爱空间邀请',
                subtitle: '邀请您成为我的恋爱空间伴侣',
                description: '在这里我们可以一起打卡、分享照片、记录美好时光~',
                userAvatar: document.getElementById('user-avatar').src,
                userName: '{{user}}',
                status: 'pending',
                fromAI: false
            }
        });
        
        // 保存状态
        await db.chats.put(selectedChar);
        console.log('邀请消息已添加到历史记录');
        
        // 触发AI自动回复邀请
        const delay = 2000 + Math.random() * 3000; // 2-5秒随机延迟，让回复看起来更自然
        console.log(`将在 ${Math.round(delay/1000)} 秒后触发AI自动回复邀请`);
        setTimeout(async () => {
            console.log('开始执行AI自动回复邀请...');
            const success = await aiAutoRespondToInvite(charId);
            console.log('AI自动回复邀请结果:', success);
        }, delay);
        
        // 短暂延迟确保之前的modal完全关闭
        setTimeout(async () => {
            // 显示成功提示
            console.log('显示成功弹窗...');
            await simpleAlert('发送成功', '已向 ' + selectedChar.name + ' 发送恋爱空间邀请！\n\n正在等待对方回应...');
            
            // 自动跳转到聊天页面
            console.log('跳转到聊天页面...');
            if (typeof openChat === 'function') {
                await openChat(charId);
            } else {
                console.error('openChat function not found, using alternative method');
                // 备用方案：直接显示聊天界面
                state.activeChatId = charId;
                renderChatInterface(charId);
                showScreen('chat-interface-screen');
            }
        }, 300);
        
    } catch (error) {
        console.error('发送邀请失败:', error);
        await simpleAlert('错误', '发送邀请失败，请稍后再试。');
    }
}

// AI自动回复用户邀请的函数
async function aiAutoRespondToInvite(chatId) {
    console.log('AI自动回复用户邀请:', chatId);
    const chat = state.chats[chatId];
    if (!chat || chat.isGroup) return;
    
    try {
        // 找到最新的待处理邀请
        const inviteMessage = chat.history.slice().reverse().find(msg => 
            msg.cardType === 'love_space_invite' && 
            msg.role === 'user' && 
            msg.cardData?.status === 'pending'
        );
        
        if (!inviteMessage) {
            console.log('没有找到待处理的用户邀请');
            return;
        }
        
        // 构建AI决策的上下文
        const recentMessages = chat.history.filter(msg => !msg.isHidden).slice(-40);
        const conversationContext = recentMessages.map(msg => 
            `${msg.role === 'user' ? '用户' : chat.name}: ${msg.content}`
        ).join('\n');
        
        // 创建AI决策提示消息
        const decisionPrompt = `【系统指令】用户刚才发送了恋爱空间邀请，你现在必须回应这个邀请。

对话历史：
${conversationContext}

【强制要求】你必须选择以下两种回复之一，完全按照格式复制：

选项1（接受）：[love_space_accept]我接受了你的恋爱空间邀请 💕[/love_space_accept]

选项2（拒绝）：[love_space_reject]我婉拒了你的恋爱空间邀请 💔[/love_space_reject]

请根据你们的聊天历史选择其中一个选项，完整复制回复，包括所有标签和符号。`;
        
        // 将决策提示作为系统消息添加到聊天历史中（不隐藏，让AI能看到）
        const systemDecisionMessage = {
            id: 'system_decision_' + Date.now(),
            role: 'system',
            content: decisionPrompt,
            timestamp: Date.now(),
            isSystemDecision: true // 标记为系统决策消息，用于特殊处理
        };
        
        chat.history.push(systemDecisionMessage);
        await db.chats.put(chat);
        console.log('已添加AI决策提示消息到聊天历史:', systemDecisionMessage.id);
        console.log('决策提示内容:', decisionPrompt);
        
        // 触发AI回复（让AI通过正常流程回复）
        // 修复：确保AI能回应邀请，即使用户不在当前聊天界面
        const wasActiveChatId = state.activeChatId;
        state.activeChatId = chatId; // 临时设置为当前聊天ID以确保AI回复
        
        try {
            console.log('开始调用triggerAiResponse，当前activeChatId:', state.activeChatId);
            await triggerAiResponse(true); // 传入true表示这是回应邀请模式
            console.log('triggerAiResponse调用完成');
        } finally {
            // 恢复原来的活跃聊天ID
            if (wasActiveChatId && wasActiveChatId !== chatId) {
                console.log('恢复原来的activeChatId:', wasActiveChatId);
                state.activeChatId = wasActiveChatId;
            }
        }
        
        console.log('AI邀请回复流程启动');
        return true;
        
    } catch (error) {
        console.error('AI回复邀请失败:', error);
        return false;
    }
}

// AI主动发送恋爱空间邀请的函数
async function sendLoveSpaceInviteFromAI(chatId) {
    console.log('AI主动发送恋爱空间邀请给:', chatId);
    const chat = state.chats[chatId];
    if (!chat) {
        console.error('找不到聊天:', chatId);
        return;
    }
    
    try {
        // 创建AI发出的邀请卡片消息
        if (!chat.history) {
            chat.history = [];
        }
        
        const inviteMessage = {
            id: 'ai_invite_' + Date.now(),
            role: 'assistant',
            content: '💕 恋爱空间邀请',
            timestamp: Date.now(),
            cardType: 'love_space_invite',
            cardData: {
                title: '恋爱空间邀请',
                subtitle: '我想邀请你成为我的恋爱空间伴侣',
                description: '让我们一起在恋爱空间打卡、分享照片、记录美好时光吧~',
                aiAvatar: chat.avatar || 'img/default_avatar.png',
                aiName: chat.name,
                status: 'pending',
                fromAI: true  // 标记这是AI发出的邀请
            }
        };
        
        chat.history.push(inviteMessage);
        
        // 保存到数据库
        await db.chats.put(chat);
        console.log('AI邀请消息已添加到历史记录');
        
        // 如果当前正在查看这个聊天，重新渲染
        if (state.activeChatId === chatId) {
            renderChatInterface(chatId);
        }
        
        return true;
    } catch (error) {
        console.error('AI发送邀请失败:', error);
        return false;
    }
}

// 修改响应邀请函数，支持AI发起的邀请
// 立即更新DOM中邀请卡片的状态显示
function updateInviteCardStatusInDOM(messageId, status) {
    try {
        console.log('开始更新邀请卡片状态:', { messageId, status });
        
        // 查找对应的消息元素
        const messageElements = document.querySelectorAll('.message-bubble');
        let updated = false;
        
        for (const element of messageElements) {
            // 检查是否是目标消息（通过data-message-id）
            const messageIdAttr = element.getAttribute('data-message-id');
            if (messageIdAttr && messageIdAttr === messageId) {
                const inviteCard = element.querySelector('[data-invite-card="true"]');
                if (inviteCard) {
                    const statusElement = inviteCard.querySelector('.invite-card-status');
                    if (statusElement) {
                        // 更新状态显示
                        statusElement.className = `invite-card-status ${status}`;
                        if (status === 'accepted') {
                            statusElement.textContent = '✅ 已接受';
                        } else if (status === 'rejected') {
                            statusElement.textContent = '❌ 已拒绝';
                        }
                        
                        console.log('DOM状态更新成功:', { messageId, status, element });
                        updated = true;
                        break; // 找到并更新后退出
                    }
                }
            }
        }
        
        // 如果没有找到特定消息，尝试更新最新的pending状态邀请
        if (!updated) {
            console.log('未找到特定消息，尝试更新最新的pending邀请');
            const messageElementsReversed = Array.from(messageElements).reverse();
            
            for (const element of messageElementsReversed) {
                const inviteCard = element.querySelector('[data-invite-card="true"]');
                if (inviteCard) {
                    const statusElement = inviteCard.querySelector('.invite-card-status.pending');
                    if (statusElement) {
                        statusElement.className = `invite-card-status ${status}`;
                        if (status === 'accepted') {
                            statusElement.textContent = '✅ 已接受';
                        } else if (status === 'rejected') {
                            statusElement.textContent = '❌ 已拒绝';
                        }
                        console.log('更新了最新的pending邀请状态');
                        updated = true;
                        break;
                    }
                }
            }
        }
        
        if (!updated) {
            console.warn('未找到任何可更新的邀请卡片');
        }
        
    } catch (error) {
        console.warn('更新邀请卡片状态失败:', error);
    }
}

async function respondToAIInvite(decision) {
    // 关闭模态框
    const modalOverlay = document.getElementById('custom-modal-overlay');
    modalOverlay.classList.remove('visible');
    
    const chatId = state.activeChatId;
    if (!chatId) return;
    
    // 找到最新的AI邀请消息并更新状态
    const chat = state.chats[chatId];
    if (chat && chat.history) {
        const inviteMessage = chat.history.slice().reverse().find(msg => 
            msg.cardType === 'love_space_invite' && 
            msg.cardData?.status === 'pending' && 
            msg.cardData?.fromAI === true
        );
        
        if (inviteMessage) {
            // 更新邀请状态
            inviteMessage.cardData.status = decision === 'accept' ? 'accepted' : 'rejected';
            
            // 立即更新DOM中的邀请卡片状态显示
            updateInviteCardStatusInDOM(inviteMessage.id, decision === 'accept' ? 'accepted' : 'rejected');
            
            // 如果接受，建立恋爱空间绑定
            if (decision === 'accept') {
                localStorage.setItem('loveSpaceBoundChar', chatId);
                
                // 更新恋爱空间的AI头像
                updateLoveSpaceAvatarsAfterBind(chatId);
                
                // 添加用户回复消息
                const userReplyMessage = {
                    id: 'user_reply_' + Date.now(),
                    role: 'user',
                    content: '我接受了恋爱空间邀请 💕',
                    timestamp: Date.now(),
                    cardType: 'love_space_invite_reply',
                    cardData: {
                        decision: decision,
                        status: 'accepted',
                        fromUser: true,  // 标记这是用户的回复
                        message: '我接受了恋爱空间邀请 💕'
                    }
                };
                
                chat.history.push(userReplyMessage);
                
                // 系统发送庆祝消息
                setTimeout(async () => {
                    const systemMessage = {
                        id: 'system_celebration_' + Date.now(),
                        role: 'system',
                        type: 'pat_message',
                        content: `🎉 恭喜！您接受了 ${chat.name} 的恋爱空间邀请！\n💕 你们现在是恋爱空间的伴侣了！\n📅 打卡将从今天开始计算~`,
                        timestamp: Date.now()
                    };
                    chat.history.push(systemMessage);
                    await db.chats.put(chat);
                    if (state.activeChatId === chatId) {
                        renderChatInterface(chatId);
                    }
                }, 1000);
            } else {
                // 如果拒绝，添加用户回复消息
                const userReplyMessage = {
                    id: 'user_reply_' + Date.now(),
                    role: 'user',
                    content: '我婉拒了恋爱空间邀请',
                    timestamp: Date.now(),
                    cardType: 'love_space_invite_reply',
                    cardData: {
                        decision: decision,
                        status: 'rejected',
                        fromUser: true,
                        message: '我婉拒了恋爱空间邀请'
                    }
                };
                chat.history.push(userReplyMessage);
                
                // 系统发送安慰消息
                setTimeout(async () => {
                    const systemMessage = {
                        id: 'system_comfort_' + Date.now(),
                        role: 'system',
                        type: 'pat_message',
                        content: `💔 您拒绝了 ${chat.name} 的恋爱空间邀请\n🤝 不过没关系，友谊同样珍贵！`,
                        timestamp: Date.now()
                    };
                    chat.history.push(systemMessage);
                    await db.chats.put(chat);
                    if (state.activeChatId === chatId) {
                        renderChatInterface(chatId);
                    }
                }, 1000);
            }
            
            await db.chats.put(chat);
            
            // 立即重新渲染聊天界面以显示用户的回复卡片
            if (state.activeChatId === chatId) {
                renderChatInterface(chatId);
                
                // 滚动到最新消息
                setTimeout(() => {
                    const messagesContainer = document.getElementById('chat-messages');
                    if (messagesContainer) {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }
                }, 100);
            }
            
            // 显示结果提示
            if (decision === 'accept') {
                await simpleAlert('恋爱空间', '🎉 恭喜！你们现在是恋爱空间的伴侣了！\n\n恋爱空间头像已更新，快去看看吧~');
            } else {
                await simpleAlert('恋爱空间', '已拒绝邀请，你们仍然是很好的朋友~');
            }
        }
    }
}

// 更新恋爱空间头像的函数（绑定后）
function updateLoveSpaceAvatarsAfterBind(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;
    
    // 使用聊天设置中的头像（和恋爱空间邀请卡片保持一致）
    const aiAvatar = chat.settings.aiAvatar || 'img/default_avatar.png';
    const userAvatar = chat.settings.myAvatar || 'img/default_avatar.png';
    
    // 更新AI头像
    const aiAvatarImg = document.getElementById('ai-avatar');
    if (aiAvatarImg) {
        aiAvatarImg.src = aiAvatar;
    }
    
    // 更新用户头像
    const userAvatarImg = document.getElementById('user-avatar');
    if (userAvatarImg) {
        userAvatarImg.src = userAvatar;
    }
    
    // 同时更新音乐播放器中的用户头像
    const musicUserAvatarEl = document.getElementById('music-user-avatar');
    if (musicUserAvatarEl) {
        musicUserAvatarEl.src = userAvatar;
    }
    
    // 显示头像状态（想你X天）
    const aiStatus = document.getElementById('ai-status');
    const userStatus = document.getElementById('user-status');
    
    if (aiStatus) {
        aiStatus.style.display = 'block';
        // 从绑定时间开始计算天数
        const bindTime = Date.now();
        localStorage.setItem('loveSpaceBindTime', bindTime.toString());
        document.getElementById('ai-days').textContent = '0';
    }
    
    if (userStatus) {
        userStatus.style.display = 'block';
        document.getElementById('user-days').textContent = '0';
    }
}

// 检查并发送恋爱空间邀请的函数
async function checkAndSendLoveSpaceInvite(chatId) {
    const chat = state.chats[chatId];
    if (!chat || chat.isGroup) return; // 跳过群聊
    
    try {
        // 检查是否已经绑定恋爱空间
        const boundCharId = localStorage.getItem('loveSpaceBoundChar');
        if (boundCharId) return; // 已经有绑定的角色，不再发送邀请
        
        // 检查是否已经发送过邀请（包括用户发起的和AI发起的）
        const hasInvitation = chat.history.some(msg => 
            msg.cardType === 'love_space_invite' || 
            msg.cardType === 'love_space_invite_reply'
        );
        if (hasInvitation) return; // 已经有邀请相关的消息，不再发送
        
        // 检查聊天历史长度和互动质量
        const messageCount = chat.history.filter(msg => !msg.isHidden).length;
        if (messageCount < 10) return; // 消息太少，关系还不够深
        
        // 检查最近的聊天情况
        const recentMessages = chat.history.filter(msg => !msg.isHidden).slice(-10);
        const userMessages = recentMessages.filter(msg => msg.role === 'user').length;
        const aiMessages = recentMessages.filter(msg => msg.role === 'assistant').length;
        
        // 需要有足够的互动
        if (userMessages < 3 || aiMessages < 3) return;
        
        // 检查是否有亲密的关键词
        const recentContent = recentMessages.map(msg => String(msg.content)).join(' ').toLowerCase();
        const intimateKeywords = ['喜欢', '爱', '想你', '亲爱', '宝贝', '心动', '恋爱', '在一起', '约会', '表白'];
        const hasIntimateContent = intimateKeywords.some(keyword => recentContent.includes(keyword));
        
        // 随机触发机制：有亲密内容时30%概率，无亲密内容时5%概率
        const triggerChance = hasIntimateContent ? 0.3 : 0.05;
        const shouldTrigger = Math.random() < triggerChance;
        
        if (!shouldTrigger) return;
        
        // 发送AI邀请
        console.log(`AI主动向用户发送恋爱空间邀请 (聊天ID: ${chatId})`);
        
        // 延迟一会儿再发送，让它看起来更自然
        setTimeout(async () => {
            const success = await sendLoveSpaceInviteFromAI(chatId);
            if (success) {
                console.log('AI恋爱空间邀请发送成功');
            }
        }, 2000 + Math.random() * 3000); // 2-5秒随机延迟
        
    } catch (error) {
        console.error('检查恋爱空间邀请时出错:', error);
    }
}

// 将函数挂载到全局作用域
window.changeAIAvatar = changeAIAvatar;
window.showCharacterSelection = showCharacterSelection;
window.showInviteMenu = showInviteMenu;
window.sendLoveSpaceInvite = sendLoveSpaceInvite;
window.showLoveSpacePreview = showLoveSpacePreview;
window.respondToInvite = respondToInvite;
window.sendLoveSpaceInviteFromAI = sendLoveSpaceInviteFromAI;
window.respondToAIInvite = respondToAIInvite;
window.updateLoveSpaceAvatarsAfterBind = updateLoveSpaceAvatarsAfterBind;
window.checkAndSendLoveSpaceInvite = checkAndSendLoveSpaceInvite;
window.updateBoundCharacterAvatar = updateBoundCharacterAvatar;

// ★★★ 暴露打卡调试函数到全局，方便控制台调试 ★★★
window.getCheckinStatus = getCheckinStatus;

// ★★★ 创建打卡卡片消息的函数 ★★★
window.createCheckinCard = function(senderType, consecutiveDays) {
    const senderName = senderType === 'user' ? '我' : (state.chats[state.activeChatId] ? state.chats[state.activeChatId].name : 'AI');
    return {
        id: Date.now() + Math.random(),
        content: `今日${senderName}已成功打卡~ 连续打卡 ${consecutiveDays} 天！💕`,
        timestamp: Date.now(),
        role: senderType === 'user' ? 'user' : 'assistant',
        type: 'checkin-card',
        senderName: senderName
    };
};

// ★★★ 强制重置所有打卡数据的调试函数 ★★★
window.forceResetCheckinData = function() {
    console.log('=== 强制重置所有打卡数据 ===');
    
    // 清除所有打卡相关数据
    localStorage.removeItem('loveSpaceCheckinData');
    localStorage.removeItem('checkinHistory');
    localStorage.removeItem('myCheckinDays');
    localStorage.removeItem('partnerCheckinDays');
    
    // 清除所有AI活动记录
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('aiActivity_')) {
            keysToRemove.push(key);
        }
    }
    keysToRemove.forEach(key => {
        console.log(`清除活动数据: ${key}`);
        localStorage.removeItem(key);
    });
    
    // 强制重置打卡数据到初始状态
    const resetData = {
        userLastCheckin: null,
        userConsecutiveDays: 0,
        userTotalCheckins: 0,
        aiLastCheckin: null,
        aiConsecutiveDays: 0,
        aiTotalCheckins: 0,
        userCheckinHistory: {},
        aiCheckinHistory: {}
    };
    localStorage.setItem('loveSpaceCheckinData', JSON.stringify(resetData));
    
    console.log('✅ 所有打卡数据已强制重置到初始状态');
    console.log('当前打卡状态:', getCheckinStatus());
};

// ★★★ 调试：查看当前打卡详细状态 ★★★
window.viewCheckinStatus = function() {
    console.log('=== 📊 当前打卡详细状态 ===');
    
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (!boundCharId) {
        console.log('❌ 未绑定恋爱空间角色');
        return;
    }
    
    const chat = state.chats[boundCharId];
    if (!chat) {
        console.log('❌ 找不到绑定的角色数据');
        return;
    }
    
    console.log(`🔗 绑定角色: ${chat.name} (${boundCharId})`);
    console.log(`💬 当前聊天角色: ${state.activeChatId}`);
    console.log(`🎯 是否为绑定角色聊天: ${state.activeChatId === boundCharId ? '✅是' : '❌否'}`);
    
    // 主打卡数据
    const checkinData = getCheckinData();
    console.log('📊 主打卡数据:', {
        AI总打卡次数: checkinData.aiTotalCheckins,
        AI连续打卡天数: checkinData.aiConsecutiveDays,
        AI最后打卡时间: checkinData.aiLastCheckin ? new Date(checkinData.aiLastCheckin).toLocaleString() : '从未打卡',
        今天是否打卡: hasCheckedInToday(checkinData.aiLastCheckin) ? '✅已打卡' : '❌未打卡'
    });
    
    // 今日活动数据
    const today = new Date().toDateString();
    const activityKey = `aiActivity_${today}`;
    const activityData = JSON.parse(localStorage.getItem(activityKey) || '{"count": 0, "hasCheckedIn": false}');
    console.log('📈 今日活动数据:', {
        活动数据显示已打卡: activityData.hasCheckedIn ? '✅是' : '❌否',
        活动打卡时间: activityData.checkinTime ? new Date(activityData.checkinTime).toLocaleString() : '无记录'
    });
    
    // 数据一致性检查
    const mainCheckedIn = hasCheckedInToday(checkinData.aiLastCheckin);
    const activityCheckedIn = activityData.hasCheckedIn;
    console.log('🔍 数据一致性检查:', {
        主数据今日打卡: mainCheckedIn ? '✅已打卡' : '❌未打卡',
        活动数据今日打卡: activityCheckedIn ? '✅已打卡' : '❌未打卡',
        数据是否一致: mainCheckedIn === activityCheckedIn ? '✅一致' : '❌不一致',
        总结: mainCheckedIn && activityCheckedIn ? '今天已完成打卡' : (!mainCheckedIn && !activityCheckedIn ? '今天尚未打卡' : '数据不一致需要检查')
    });
};

// ★★★ 调试：测试AI通过API打卡功能 ★★★
window.testAICheckinAPI = function() {
    console.log('=== 🧪 测试AI通过API打卡功能 ===');
    const boundCharId = localStorage.getItem('loveSpaceBoundChar');
    if (!boundCharId) {
        console.log('❌ 未绑定恋爱空间角色，无法测试');
        return;
    }
    
    console.log(`🔗 当前绑定角色: ${boundCharId}`);
    console.log(`💬 当前活动角色: ${state.activeChatId}`);
    
    const chat = state.chats[boundCharId];
    if (!chat) {
        console.log('❌ 找不到绑定的角色数据');
        return;
    }
    
    // 显示当前打卡状态
    const currentStatus = getCheckinStatus();
    console.log('📊 当前打卡状态:', currentStatus);
    
    // 检查今日活动数据
    const today = new Date().toDateString();
    const activityKey = `aiActivity_${today}`;
    const activityData = JSON.parse(localStorage.getItem(activityKey) || '{"count": 0, "hasCheckedIn": false}');
    console.log('📈 测试前活动数据:', {
        是否已打卡: activityData.hasCheckedIn ? '✅是' : '❌否',
        活动数据: activityData
    });
    
    // 设置正确的聊天状态用于测试
    const originalActiveChatId = state.activeChatId;
    state.activeChatId = boundCharId;
    
    // ★★★ 简化的AI打卡执行逻辑 ★★★
    console.log('🤖 执行AI打卡指令...');
    
    const data = getCheckinData();
    const now = new Date();
    
    // 检查是否连续打卡
    if (data.aiLastCheckin) {
        const lastCheckin = new Date(data.aiLastCheckin);
        const yesterday = new Date(now);
        yesterday.setDate(yesterday.getDate() - 1);
        
        if (lastCheckin.toDateString() === yesterday.toDateString()) {
            data.aiConsecutiveDays += 1;
        } else {
            data.aiConsecutiveDays = 1;
        }
    } else {
        data.aiConsecutiveDays = 1;
    }
    
    data.aiLastCheckin = now.toISOString();
    data.aiTotalCheckins += 1;
    
    // 保存到打卡历史记录
    const dateStr = getLocalDateString(now);
    if (!data.aiCheckinHistory) {
        data.aiCheckinHistory = {};
    }
    data.aiCheckinHistory[dateStr] = true;
    
    saveCheckinData(data);
    
    // 更新UI显示
    updateAvatarStatus();
    
    // 更新日历显示
    if (typeof updateCalendarDisplay === 'function') {
        updateCalendarDisplay();
    }
    
    console.log(`🎉 AI成功打卡！连续打卡 ${data.aiConsecutiveDays} 天！`);
    
    // 创建打卡消息
    const aiMessage = { 
        role: 'assistant', 
        content: `今日${chat.name}已成功打卡~ 连续打卡 ${data.aiConsecutiveDays} 天！💕`, 
        timestamp: Date.now(),
        type: 'checkin-card',
        senderName: chat.name
    };
    console.log('📮 创建的打卡消息:', aiMessage);
    console.log('📊 更新后的打卡状态:', getCheckinStatus());
    
    // 恢复原来的聊天状态
    state.activeChatId = originalActiveChatId;
};

/*
★★★★★ 恋爱空间打卡功能实现总结 ★★★★★

实现的功能：
1. 用户打卡后自动发送打卡卡片消息到聊天记录
   - 用户在恋爱空间点击打卡球
   - 立即发送带有连续打卡天数的卡片消息
   - 消息显示格式：今日我已成功打卡~ 连续打卡 X 天！💕

2. AI自动打卡机制（已简化）
   - 只有绑定的恋爱空间角色才能触发打卡
   - 每天只要未打卡就会持续提醒，直到打卡成功
   - 打卡数据立即更新并保存到localStorage
   - 发送打卡卡片消息到聊天记录

3. 打卡检测机制（已简化）
   - 只能通过API调用出消息，确保真实活动
   - 严格检查当前活动角色是否为绑定角色
   - 每日打卡状态存储，不再限制活动次数
   - 自动清理过期的活动数据

4. 解除绑定关系功能完善
   - 彻底清空所有打卡记录（用户+AI）
   - 清空聊天记录中的所有打卡卡片消息
   - 清空AI活动打卡数据
   - 重新绑定时确保是全新的记录开始

关键技术点：
- 使用localStorage存储打卡数据
- 每日活动计数使用日期作为key
- 打卡卡片使用特殊的消息类型 'checkin-card'
- 严格的角色绑定检查确保只有绑定角色能打卡
- 数据库同步确保数据持久化

调试工具：
- getCheckinStatus(): 查看当前打卡状态
- testAICheckin(): 测试AI打卡功能
- forceResetCheckinData(): 强制重置所有打卡数据

★★★ 2024年最新修复 ★★★
完全重构了AI打卡逻辑，修复了"绑定后立即打卡"的严重问题：

**🔧 核心修复**：
1. 🚫 **移除自动打卡**：AI回复时不再自动执行打卡，只检测是否需要提醒
2. 💌 **正确流程**：只有AI发送了 `{"type": "love_space_checkin"}` 消息才真正打卡
3. 📊 **简化机制**：不再限制活动次数，只要未打卡就持续提醒
4. 🔒 **严格验证**：仅对绑定的恋爱空间角色生效，其他角色完全跳过

**🎯 简化的工作流程**：
1. **AI回复** → 检测是否需要提醒打卡（不执行打卡）
2. **需要提醒** → 在AI系统提示中显示强烈的打卡提醒信息
3. **AI发送打卡消息** → 调用 `executeAICheckin()` 真正执行打卡
4. **执行打卡** → 直接执行打卡 + 更新打卡数据 + 发送打卡卡片

**✅ 完全解决的问题**：
- ❌ 绑定后立即就显示"已打卡"
- ❌ 没发送打卡格式但后台就完成打卡
- ❌ 活动次数计算错误
- ❌ 未绑定角色也触发检测

**🎮 现在的正确行为**：
- 🟢 **未绑定角色**：不会有任何打卡相关的检测或日志
- 🟢 **绑定角色但未发送打卡消息**：只显示提醒，不执行打卡
- 🟢 **绑定角色发送打卡消息**：直接执行打卡，发送卡片

AI打卡现在和红包、转账等功能一样，必须明确发送指定格式才会执行！
*/

// AI根据人设决定是否接受邀请的函数




// 将其他恋爱空间相关函数挂载到全局作用域
window.updateLoveSpaceAvatars = updateLoveSpaceAvatars;

// 确保modal函数也在全局可用
if (typeof showCustomAlert !== 'undefined') {
    window.showCustomAlert = showCustomAlert;
}
if (typeof showCustomConfirm !== 'undefined') {
    window.showCustomConfirm = showCustomConfirm;
}

// 页面加载完成后初始化恋爱空间
document.addEventListener('DOMContentLoaded', function() {
    // 确保DOM完全加载后再初始化头像和壁纸
    setTimeout(() => {
        console.log('开始初始化恋爱空间头像和壁纸...');
        
        // 检查DOM元素是否存在
        const userAvatarEl = document.getElementById('user-avatar');
        const aiAvatarEl = document.getElementById('ai-avatar');
        const loveSpaceView = document.getElementById('love-space-view');
        
        // ★★★ 注意：DIY装饰只在恋爱空间显示时加载，不在页面初始化时加载 ★★★
        // 因为恋爱空间默认是隐藏的，装饰应该在showLoveSpace()函数中加载
        
        // ★★★ 检查用户上次访问的空间，如果是恋爱空间则自动进入 ★★★
        const lastActiveSpace = localStorage.getItem('lastActiveSpace');
        console.log('🔍 检查上次访问的空间:', lastActiveSpace);
        if (lastActiveSpace === 'love-space') {
            console.log('🎨 检测到用户上次在恋爱空间，自动进入恋爱空间...');
            setTimeout(() => {
                showLoveSpace();
            }, 500); // 延迟确保DOM完全加载
        }
        
        console.log('DOM元素检查:', {
            userAvatar: userAvatarEl ? '存在' : '不存在',
            aiAvatar: aiAvatarEl ? '存在' : '不存在',
            loveSpaceView: loveSpaceView ? '存在' : '不存在'
        });
        
        // 检查localStorage中的数据
        const savedUserAvatar = localStorage.getItem(USER_AVATAR_KEY);
        const savedAIAvatar = localStorage.getItem(AI_AVATAR_KEY);
        const savedHomeWallpaper = localStorage.getItem(HOME_WALLPAPER_KEY);
        const savedNavWallpaper = localStorage.getItem(CHAT_WALLPAPER_KEY);
        
        console.log('localStorage数据检查:', {
            userAvatar: savedUserAvatar ? '有数据' : '无数据',
            aiAvatar: savedAIAvatar ? '有数据' : '无数据',
            homeWallpaper: savedHomeWallpaper ? '有数据' : '无数据',
            navWallpaper: savedNavWallpaper ? '有数据' : '无数据'
        });
        
        loadSavedAvatars();
        
        // 初始化打卡状态显示
        if (typeof updateAvatarStatus === 'function') {
            updateAvatarStatus();
        }
        
        // 延迟初始化壁纸，确保DOM完全加载
        setTimeout(() => {
            console.log('页面加载时初始化壁纸...');
            
            // 直接应用保存的壁纸
            const homeWallpaper = localStorage.getItem(HOME_WALLPAPER_KEY);
            const navWallpaper = localStorage.getItem(CHAT_WALLPAPER_KEY);
            
            console.log('页面加载壁纸检查:', { 
                homeWallpaper: homeWallpaper ? homeWallpaper.substring(0, 50) + '...' : null, 
                navWallpaper: navWallpaper ? navWallpaper.substring(0, 50) + '...' : null 
            });
            
            if (homeWallpaper) {
                console.log('页面加载：应用主页壁纸');
                addOrUpdateWallpaperStyle('home', homeWallpaper);
            }
            
            if (navWallpaper) {
                console.log('页面加载：应用导航栏壁纸');
                addOrUpdateWallpaperStyle('nav', navWallpaper);
            }
            
            console.log('页面加载壁纸初始化完成');
        }, 200);
        
        // 添加页面退出时自动保存DIY装饰布局
        window.addEventListener('beforeunload', function() {
            if (typeof saveDIYLayout === 'function' && decorationItems && decorationItems.length > 0) {
                saveDIYLayout();
                console.log('页面退出时已自动保存DIY装饰布局');
            }
        });
        
        // 添加页面隐藏时自动保存（用于移动设备）
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && typeof saveDIYLayout === 'function' && decorationItems && decorationItems.length > 0) {
                saveDIYLayout();
                console.log('页面隐藏时已自动保存DIY装饰布局');
            }
        });
        
        // 添加定期自动保存机制（每30秒保存一次，仅在有装饰数据时）
        setInterval(function() {
            if (typeof saveDIYLayout === 'function' && decorationItems && decorationItems.length > 0) {
                saveDIYLayout();
                console.log('定期自动保存DIY装饰布局');
            }
        }, 30000); // 30秒
        
    }, 100);
});
// 私人空间背景初始化
document.addEventListener('DOMContentLoaded', function() {
    console.log('开始初始化私人空间背景设置...');
    
    // 延迟一段时间确保DOM完全加载
    setTimeout(() => {
        // 检查是否在私人空间页面
        const privateSpaceView = document.getElementById('private-space-view');
        if (privateSpaceView && privateSpaceView.style.display === 'flex') {
            console.log('检测到私人空间已显示，应用背景设置');
            applyStoredWallpapers();
        }
    }, 200);
    
    // 再次延迟确保应用
    setTimeout(() => {
        const privateSpaceView = document.getElementById('private-space-view');
        if (privateSpaceView && privateSpaceView.style.display === 'flex') {
            console.log('再次确保私人空间背景设置');
            applyStoredWallpapers();
        }
    }, 1000);
});

// 初始化物品管理器
window.itemsManager = null;
document.addEventListener('DOMContentLoaded', () => {
    // 初始化私人相册
    initPrivateAlbum();
    
    // 延迟初始化，确保DOM完全加载
    setTimeout(() => {
        if (document.getElementById('add-item-btn') && !window.itemsManager) {
            window.itemsManager = new ItemsManager();
        }
        
        // 初始化私人空间联系人选择功能
        console.log('私人空间联系人选择功能已初始化');
        
        // 不再在页面加载时初始化母婴产品数据
        // 改为在首次打开商城时才初始化
    }, 100);
});

// ==================== 购物系统JavaScript逻辑 ====================

// 全局变量定义
var shoppingCart = []; // 统一购物车数据结构: [{ productId: 123, quantity: 1, type: 'personal'|'system' }, ...]
var systemCart = []; // 保持兼容性，但实际使用统一的 shoppingCart
var isProductManagementMode = false; // 商品管理状态

/**
 * 初始化母婴产品数据到个人商城数据库
 */
async function initMaternityProducts() {
    try {
        // 检查是否已经初始化过母婴产品
        const existingMaternityProducts = await db.shoppingProducts.where('category').equals('maternity').toArray();
        if (existingMaternityProducts.length > 0) {
            console.log('母婴产品已存在，跳过初始化');
            return;
        }

        console.log('开始初始化母婴产品数据...');
        
        const maternityProducts = [
            {
                name: '帮宝适纸尿裤',
                description: '超薄透气，12小时长效吸收，给宝宝最舒适的呵护',
                price: 51,
                category: 'maternity'
            },
            {
                name: '美赞臣奶粉',
                description: 'DHA+ARA配方，支持宝宝大脑和视力发育',
                price: 167,
                category: 'maternity'
            },
            {
                name: '苏菲卫生巾',
                description: '产妇专用加长型，超强吸收，柔软亲肤',
                price: 26,
                category: 'maternity'
            },
            {
                name: '贝亲奶瓶套装',
                description: '医用级硅胶，仿母乳实感，宝宝更容易接受',
                price: 73,
                category: 'maternity'
            },
            {
                name: '强生婴儿洗护套装',
                description: '无泪配方，温和清洁，保护宝宝娇嫩肌肤',
                price: 44,
                category: 'maternity'
            },
            {
                name: '好奇拉拉裤',
                description: '360度弹性腰围，宝宝活动更自由，妈妈更省心',
                price: 67,
                category: 'maternity'
            },
            {
                name: '小白熊温奶器',
                description: '智能恒温，24小时保温，夜间喂奶更方便',
                price: 107,
                category: 'maternity'
            },
            {
                name: '妈咪宝贝湿巾',
                description: '99.9%纯水制造，无酒精无香料，敏感肌宝宝也能用',
                price: 16,
                category: 'maternity'
            },
            {
                name: '费雪摇铃玩具',
                description: '色彩鲜艳，声音柔和，锻炼宝宝手眼协调能力',
                price: 39,
                category: 'maternity'
            },
            {
                name: '十月结晶产褥垫',
                description: '医用级无菌包装，超强吸收，产后必备用品',
                price: 22,
                category: 'maternity'
            },
            {
                name: '爱得利安抚奶嘴',
                description: '仿母乳设计，食品级硅胶，帮助宝宝安然入睡',
                price: 14,
                category: 'maternity'
            },
            {
                name: '子初婴儿面霜',
                description: '山茶油精华，深层滋润，预防红屁屁和湿疹',
                price: 33,
                category: 'maternity'
            },
            {
                name: '好孩子婴儿车',
                description: '轻便折叠，双向推行，减震设计，出行必备',
                price: 507,
                category: 'maternity'
            },
            {
                name: '贝恩施早教机',
                description: '双语启蒙，儿歌故事，培养宝宝语言能力',
                price: 112,
                category: 'maternity'
            },
            {
                name: '威尔贝鲁纸尿裤',
                description: '日本进口，超薄0.1cm，透气不闷热，敏感肌专用',
                price: 94,
                category: 'maternity'
            }
        ];

        // 批量添加母婴产品到数据库
        await db.shoppingProducts.bulkAdd(maternityProducts);
        console.log('母婴产品初始化完成，共添加', maternityProducts.length, '个产品');
        
    } catch (error) {
        console.error('初始化母婴产品时出错:', error);
    }
}
var editingProductId = null; // 当前编辑的商品ID
var activeProductId = null; // 当前查看的商品ID
// 当前激活的商城类型
var currentMallType = 'personal';
// 当前激活的分类
var currentCategory = 'all';

/**
 * 创建占位图片元素
 * @param {string} text - 显示的文字
 * @param {string} color - 背景颜色（可选）
 * @returns {string} HTML字符串
 */
function createPlaceholderImage(text, color = null) {
    const colors = [
        '#007bff', '#28a745', '#dc3545', '#ffc107', '#6f42c1', 
        '#fd7e14', '#20c997', '#e83e8c', '#17a2b8', '#6c757d'
    ];
    const bgColor = color || colors[Math.floor(Math.random() * colors.length)];
    
    return `<div class="placeholder-image" style="background: linear-gradient(135deg, ${bgColor} 0%, ${bgColor}aa 100%);">
        <span>${text}</span>
    </div>`;
}

/**
 * 打开购物页面
 * 功能：切换到购物中心界面并渲染商品列表
 */
// 商城加载状态标志
var isMallDataLoaded = false;

async function openShoppingScreen() {
    // 确保进入购物页面时重置管理模式状态
    isProductManagementMode = false;
    const manageProductsBtn = document.getElementById('manage-products-btn');
    if (manageProductsBtn) {
        manageProductsBtn.style.color = 'var(--text-primary)';
    }
    
    // 切换到商城页面
    showScreen('shopping-screen');
    
    // 如果商城数据未加载，显示加载提示并加载数据
    if (!isMallDataLoaded) {
        // 显示加载提示
        showMallLoadingState();
        
        // 加载商城数据
        await loadMallData();
        
        // 标记为已加载
        isMallDataLoaded = true;
    }
    
    // 重新绑定购物页面的事件
    initShoppingSystemEvents();
}

/**
 * 显示商城加载状态
 */
function showMallLoadingState() {
    const personalGrid = document.getElementById('product-grid');
    const systemGrid = document.getElementById('system-product-grid');
    
    const loadingHTML = `
        <div style="grid-column: 1 / -1; text-align: center; padding: 60px 20px;">
            <div style="font-size: 48px; margin-bottom: 20px;">🛍️</div>
            <div style="font-size: 18px; color: var(--text-primary); margin-bottom: 10px;">正在加载商城数据...</div>
            <div style="font-size: 14px; color: var(--text-secondary);">请稍候片刻</div>
        </div>
    `;
    
    if (personalGrid) personalGrid.innerHTML = loadingHTML;
    if (systemGrid) systemGrid.innerHTML = loadingHTML;
}

/**
 * 加载商城数据
 */
async function loadMallData() {
    // 移除母婴产品初始化，避免数据库错误
    // 用户可以自己在个人商城添加商品
    
    // 添加一个小延迟以显示加载状态（可选）
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // 根据当前商城类型加载相应商品
    if (currentMallType === 'system') {
        await renderSystemMallProducts();
    } else {
        await renderShoppingProducts();
    }
    
    // 同时预加载另一个商城的数据
    if (currentMallType === 'system') {
        await renderShoppingProducts();
    } else {
        await renderSystemMallProducts();
    }
}

/**
 * 清空商城数据缓存
 */
function clearMallDataCache() {
    const personalGrid = document.getElementById('product-grid');
    const systemGrid = document.getElementById('system-product-grid');
    
    // 清空商品网格
    if (personalGrid) personalGrid.innerHTML = '';
    if (systemGrid) systemGrid.innerHTML = '';
    
    // 重置加载状态标志
    isMallDataLoaded = false;
}

/**
 * 渲染商店里的所有商品 (支持管理模式)
 * 功能：从数据库获取商品并生成商品卡片HTML
 */
async function renderShoppingProducts() {
    const gridEl = document.getElementById('product-grid');
    const shoppingScreen = document.getElementById('shopping-screen');
    gridEl.innerHTML = '';
    let products = await db.shoppingProducts.toArray();
    
    // 根据当前分类过滤商品
    if (currentCategory !== 'all') {
        products = products.filter(product => product.category === currentCategory);
    }

    // 根据是否处于管理模式，为根元素添加class
    shoppingScreen.classList.toggle('management-mode', isProductManagementMode);

    if (products.length === 0) {
        const message = '商店空空如也，点击"管理"添加商品吧！';
        gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
        return;
    }

    products.forEach(product => {
        const item = document.createElement('div');
        item.className = 'product-item text-only-card';
        item.dataset.id = product.id;
        
        // 在管理模式下，显示编辑和删除按钮
        const managementControls = isProductManagementMode ? `
            <div class="product-management-overlay">
                <button class="edit-product-btn">编辑</button>
                <button class="delete-product-btn">删除</button>
            </div>
        ` : '';

        // 检查是否使用占位图片
        const imageElement = !product.imageUrl
            ? createPlaceholderImage(product.name.substring(0, 2))
            : `<img src="${product.imageUrl}" class="product-image">`;

        item.innerHTML = `
            ${managementControls}
            ${imageElement}
            <div class="product-info">
                <div class="product-content">
                    <div class="product-name">${product.name}</div>
                    <div class="product-description">${product.description || ''}</div>
                </div>
                <div class="product-bottom">
                    <div class="product-price">¥${product.price.toFixed(2)}</div>
                    <button class="add-to-cart-btn cart-icon-btn">🛒+</button>
                </div>
            </div>
        `;
        gridEl.appendChild(item);
    });
    
    // 更新个人商城头部总金额显示
    updatePersonalCartTotal();
    
    // 强制重新计算布局，解决添加商品后间距消失的问题
    setTimeout(() => {
        const gridEl = document.getElementById('product-grid');
        if (gridEl) {
            // 确保网格样式正确应用 - 响应式布局，和系统商城保持一致
            gridEl.style.display = 'grid';
            gridEl.style.gridTemplateColumns = 'repeat(auto-fill, minmax(160px, 1fr))'; // 响应式布局
            gridEl.style.gap = '20px';
            gridEl.style.rowGap = '25px'; // 行间距，和系统商城一致
            gridEl.style.columnGap = '15px'; // 列间距，和系统商城一致
            gridEl.style.padding = '15px';
            gridEl.style.gridAutoRows = 'minmax(auto, max-content)';
            
            // 强制重新计算布局
            gridEl.offsetHeight;
            
            // 确保所有商品卡片的样式正确
            const productItems = gridEl.querySelectorAll('.product-item');
            productItems.forEach(item => {
                item.style.margin = '0';
                item.style.marginBottom = '5px';
                item.style.width = '100%';
                item.style.boxSizing = 'border-box';
                item.style.height = '200px'; // 固定高度，和系统商城一致
                item.style.minHeight = 'auto';
                item.style.maxHeight = 'auto';
            });
        }
    }, 10);
}

/**
 * 将商品加入购物车
 * @param {number} productId - 商品ID
 * @param {number} quantity - 数量，默认为1
 */
async function addToCart(productId, quantity = 1) {
    // 确保购物车已初始化
    if (!shoppingCart) {
        shoppingCart = [];
    }
    
    const existingItem = shoppingCart.find(item => item.productId === productId && item.type === 'personal');
    if (existingItem) {
        // 如果商品已存在，增加数量
        existingItem.quantity += quantity;
    } else {
        // 如果是新商品，添加到购物车
        const product = await db.shoppingProducts.get(productId);
        if (product) {
            shoppingCart.push({ productId: product.id, quantity: quantity, type: 'personal' });
        }
    }
    updateCartCount();
    updatePersonalCartTotal(); // 更新个人商城头部总金额显示
    await updateSystemCartDisplay(); // 同步更新系统商城显示
}

/**
 * 更新购物车商品数量
 * @param {number} productId - 商品ID
 * @param {number} change - 数量变化（正数增加，负数减少）
 */
async function updateCartItemQuantity(productId, change, type = 'personal') {
    // 确保购物车已初始化
    if (!shoppingCart) {
        shoppingCart = [];
        return;
    }
    
    const itemIndex = shoppingCart.findIndex(item => item.productId === productId && item.type === type);
    if (itemIndex > -1) {
        shoppingCart[itemIndex].quantity += change;
        if (shoppingCart[itemIndex].quantity <= 0) {
            // 数量为0时从购物车移除
            shoppingCart.splice(itemIndex, 1);
        }
        updateCartCount();
        updatePersonalCartTotal(); // 更新个人商城头部总金额显示
        await updateSystemCartDisplay(); // 同步更新系统商城显示
        renderCartItems();
    }
}

/**
 * 更新购物车图标和结算按钮上的数量显示
 */
function updateCartCount() {
    // 确保购物车已初始化
    if (!shoppingCart) {
        shoppingCart = [];
    }
    
    // 计算所有商品的总数量（包括个人商城和系统商城）
    const totalItems = shoppingCart.reduce((sum, item) => sum + item.quantity, 0);
    
    // 更新个人商城的购物车显示
    const cartCountEl = document.getElementById('cart-count');
    const cartTitleEl = document.getElementById('cart-title');
    const checkoutBtnEl = document.getElementById('checkout-btn');
    
    if (cartCountEl) cartCountEl.textContent = totalItems;
    if (cartTitleEl) cartTitleEl.textContent = `购物车(${totalItems})`;
    if (checkoutBtnEl) checkoutBtnEl.textContent = `结算(${totalItems})`;
}

/**
 * 打开购物车页面
 */
function openCartScreen() {
    renderCartItems();
    showScreen('cart-screen');
    // 重新绑定购物车页面的事件
    initShoppingSystemEvents();
}

/**
 * 渲染购物车内的商品列表
 */
async function renderCartItems() {
    // 确保购物车已初始化
    if (!shoppingCart) {
        shoppingCart = [];
    }
    
    const listEl = document.getElementById('cart-items-list');
    listEl.innerHTML = '';

    if (shoppingCart.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">购物车是空的哦~</p>';
    } else {
        // 分别处理个人商城和系统商城的商品
        const personalItems = shoppingCart.filter(item => item.type === 'personal');
        const systemItems = shoppingCart.filter(item => item.type === 'system');
        
        // 处理个人商城商品
        if (personalItems.length > 0) {
            const personalProductIds = personalItems.map(item => item.productId);
            const personalProducts = await db.shoppingProducts.where('id').anyOf(personalProductIds).toArray();
            const personalProductMap = new Map(personalProducts.map(p => [p.id, p]));

            personalItems.forEach(item => {
                const product = personalProductMap.get(item.productId);
            if (product) {
                const itemEl = document.createElement('div');
                itemEl.className = 'cart-item';
                itemEl.innerHTML = `
                        <input type="checkbox" class="cart-item-checkbox" data-id="${product.id}" data-type="personal" checked>
                    <img src="${product.imageUrl}" class="cart-item-image">
                    <div class="cart-item-info">
                            <div class="cart-item-name">${product.name} <span class="item-source">[个人商城]</span></div>
                        <div class="cart-item-footer">
                            <div class="cart-item-price">¥${product.price.toFixed(2)}</div>
                            <div class="quantity-control">
                                    <button class="quantity-btn decrease-qty-btn" data-id="${product.id}" data-type="personal">-</button>
                                <span class="quantity-display">${item.quantity}</span>
                                    <button class="quantity-btn increase-qty-btn" data-id="${product.id}" data-type="personal">+</button>
                            </div>
                        </div>
                    </div>
                `;
                listEl.appendChild(itemEl);
            }
            });
        }
        
        // 获取商品分类对应的emoji
        function getCategoryEmoji(category) {
            const categoryEmojis = {
                'electronics': '✨',
                'fashion': '🎀',
                'home': '🏡',
                'food': '🍓',
                'snacks': '🍿',
                'pets': '🐶',
                'maternity': '👶',
                'adult': '🔞',
                'beauty': '💄',
                'toys': '🧸',
                'medicine': '💊',
                'other': '📦'
            };
            return categoryEmojis[category] || '📦';
        }

        // 处理系统商城商品
        systemItems.forEach(item => {
            const itemEl = document.createElement('div');
            itemEl.className = 'cart-item';
            const categoryEmoji = getCategoryEmoji(item.category);
            itemEl.innerHTML = `
                <input type="checkbox" class="cart-item-checkbox" data-id="${item.productId}" data-type="system" checked>
                <div class="cart-item-image" style="display: flex; align-items: center; justify-content: center; font-size: 32px;">${categoryEmoji}</div>
                <div class="cart-item-info">
                    <div class="cart-item-name">${item.name} <span class="item-source">[系统商城]</span></div>
                    <div class="cart-item-footer">
                        <div class="cart-item-price">¥${item.price.toFixed(2)}</div>
                        <div class="quantity-control">
                            <button class="quantity-btn decrease-qty-btn" data-id="${item.productId}" data-type="system">-</button>
                            <span class="quantity-display">${item.quantity}</span>
                            <button class="quantity-btn increase-qty-btn" data-id="${item.productId}" data-type="system">+</button>
                        </div>
                    </div>
                </div>
            `;
            listEl.appendChild(itemEl);
        });
    }
    updateCartTotal();
}

/**
 * 更新购物车总价显示
 */
async function updateCartTotal() {
    let total = 0;
    const selectedCheckboxes = document.querySelectorAll('.cart-item-checkbox:checked');
    
    if (selectedCheckboxes.length > 0) {
        // 分别处理个人商城和系统商城的选中商品
        const selectedPersonalIds = [];
        const selectedSystemIds = [];
        
        selectedCheckboxes.forEach(cb => {
            const type = cb.dataset.type || 'personal';
            const id = cb.dataset.id;
            if (type === 'personal') {
                selectedPersonalIds.push(parseInt(id));
            } else if (type === 'system') {
                selectedSystemIds.push(id);
            }
        });
        
        // 计算个人商城商品价格
        if (selectedPersonalIds.length > 0) {
            const personalProducts = await db.shoppingProducts.where('id').anyOf(selectedPersonalIds).toArray();
            const personalProductMap = new Map(personalProducts.map(p => [p.id, p]));
        
        shoppingCart.forEach(cartItem => {
                if (cartItem.type === 'personal' && selectedPersonalIds.includes(cartItem.productId)) {
                    const product = personalProductMap.get(cartItem.productId);
                if (product) {
                    total += product.price * cartItem.quantity;
                }
            }
        });
    }
        
        // 计算系统商城商品价格
        if (selectedSystemIds.length > 0) {
            shoppingCart.forEach(cartItem => {
                if (cartItem.type === 'system' && selectedSystemIds.includes(cartItem.productId)) {
                    total += cartItem.price * cartItem.quantity;
                }
            });
        }
    }
    
    const cartTotalEl = document.getElementById('cart-total');
    if (cartTotalEl) {
        cartTotalEl.textContent = `合计: ¥${total.toFixed(2)}`;
    }
}

/**
 * 更新个人商城头部的购物车总金额显示
 */
async function updatePersonalCartTotal() {
    let total = 0;
    
    if (shoppingCart && shoppingCart.length > 0) {
        // 计算个人商城商品的金额
        const personalItems = shoppingCart.filter(item => item.type === 'personal');
        if (personalItems.length > 0) {
            const productIds = personalItems.map(item => item.productId);
            const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
            const productMap = new Map(products.map(p => [p.id, p]));
            
            personalItems.forEach(cartItem => {
                const product = productMap.get(cartItem.productId);
                if (product) {
                    total += product.price * cartItem.quantity;
                }
            });
        }
        
        // 计算系统商城商品的金额
        const systemItems = shoppingCart.filter(item => item.type === 'system');
        systemItems.forEach(cartItem => {
            if (cartItem.price) {
                total += cartItem.price * cartItem.quantity;
            }
        });
    }
    
    const personalCartTotalEl = document.getElementById('personal-cart-total');
    if (personalCartTotalEl) {
        personalCartTotalEl.textContent = `¥${total.toFixed(2)}`;
    }
}

/**
 * 获取购物车中选中的商品
 * @returns {Array} 选中的商品数组
 */
function getSelectedCartItems() {
    return shoppingCart.filter(item => 
        document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
    );
}

/**
 * 处理结算按钮点击，开始新的两步下单流程
 */
async function handleCheckout() {
    const selectedItems = getSelectedCartItems();
    
    if (selectedItems.length === 0) {
        alert("请先在购物车中选择要结算的商品。");
        return;
    }

    // 开始第一步：选择为谁下单
    openOrderRecipientPicker();
}

/**
 * 统一结算弹窗 - 第一步：选择为谁下单
 */
async function openOrderRecipientPicker(previousSelection = null) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('unified-checkout-modal');
    const titleEl = document.getElementById('checkout-title');
    const contentEl = document.getElementById('checkout-content');
    const confirmBtn = document.getElementById('checkout-confirm-btn');
    
    // 设置标题和按钮文本
    titleEl.textContent = '选择为谁下单';
    confirmBtn.textContent = '下一步';
    
    
    contentEl.innerHTML = '';

    // 选项1：为自己下单
    const selfOption = document.createElement('div');
    selfOption.className = 'order-option-item';
    selfOption.dataset.recipientType = 'self';
    selfOption.innerHTML = `
        <img src="${chat.settings.myAvatar || '/api/placeholder/45/45'}" class="avatar">
        <div class="order-option-info">
            <div class="name">为自己下单</div>
            <div class="description">商品将归属于我</div>
        </div>
    `;
    contentEl.appendChild(selfOption);

    // 选项2：为角色下单
    if (chat.isGroup) {
        // 群聊：可以选择群里的角色
        const myNickname = chat.settings.myNickname || '我';
        const members = chat.members.filter(m => m.groupNickname !== myNickname);

        members.forEach(member => {
            const characterOption = document.createElement('div');
            characterOption.className = 'order-option-item';
            characterOption.dataset.recipientType = 'character';
            characterOption.dataset.recipientName = member.originalName;
            characterOption.innerHTML = `
                <img src="${member.avatar || defaultGroupMemberAvatar}" class="avatar">
                <div class="order-option-info">
                    <div class="name">为 ${member.groupNickname} 下单</div>
                    <div class="description">商品将归属于 ${member.groupNickname}</div>
                </div>
            `;
            contentEl.appendChild(characterOption);
        });
    } else {
        // 私聊：为当前角色下单
        const characterOption = document.createElement('div');
        characterOption.className = 'order-option-item';
        characterOption.dataset.recipientType = 'character';
        characterOption.dataset.recipientName = chat.name; // 使用聊天名称作为角色名
        characterOption.innerHTML = `
            <img src="${chat.settings.aiAvatar || '/api/placeholder/45/45'}" class="avatar">
            <div class="order-option-info">
                <div class="name">为 ${chat.name} 下单</div>
                <div class="description">商品将归属于 ${chat.name}</div>
            </div>
        `;
        contentEl.appendChild(characterOption);
    }

    // 为动态生成的选择项绑定点击事件
    contentEl.querySelectorAll('.order-option-item').forEach(item => {
        item.addEventListener('click', () => {
            console.log('选择项被点击:', item.dataset.recipientType, item.dataset.recipientName);
            // 清除其他选中状态
            contentEl.querySelectorAll('.order-option-item').forEach(el => el.classList.remove('selected'));
            // 选中当前项
            item.classList.add('selected');
            console.log('选中状态已设置');
        });
    });

    // 恢复之前的选中状态
    if (previousSelection) {
        const targetItem = contentEl.querySelector(`[data-recipient-type="${previousSelection.recipientType}"]${previousSelection.recipientName ? `[data-recipient-name="${previousSelection.recipientName}"]` : ''}`);
        if (targetItem) {
            targetItem.classList.add('selected');
        }
    }

    modal.classList.add('visible');
    
    // 绑定按钮事件（每次打开弹窗时重新绑定，确保事件正常工作）
    const cancelBtnEl = document.getElementById('checkout-cancel-btn');
    const confirmBtnEl = document.getElementById('checkout-confirm-btn');
    
    // 移除旧的事件监听器（如果存在）
    if (cancelBtnEl) {
        cancelBtnEl.replaceWith(cancelBtnEl.cloneNode(true));
        const newCancelBtn = document.getElementById('checkout-cancel-btn');
        newCancelBtn.addEventListener('click', () => {
            console.log('取消按钮被点击');
            modal.classList.remove('visible');
        });
    } else {
        console.log('找不到取消按钮');
    }
    
    if (confirmBtnEl) {
        confirmBtnEl.replaceWith(confirmBtnEl.cloneNode(true));
        const newConfirmBtn = document.getElementById('checkout-confirm-btn');
        newConfirmBtn.addEventListener('click', () => {
            console.log('下一步按钮被点击');
            const selectedOption = document.querySelector('#checkout-content .order-option-item.selected');
            console.log('选中的选项:', selectedOption);
            
            if (!selectedOption) {
                alert("请选择为谁下单。");
                return;
            }
            
            const recipientType = selectedOption.dataset.recipientType;
            const recipientName = selectedOption.dataset.recipientName || null;
            console.log('recipientType:', recipientType, 'recipientName:', recipientName);
            
            // 打开第二步弹窗
            openPaymentMethodPicker(recipientType, recipientName);
        });
    } else {
        console.log('找不到下一步按钮');
    }
}

/**
 * 统一结算弹窗 - 第二步：选择付款方式（支持美化层级显示）
 * @param {string} recipientType - 下单对象类型 ('self' 或 'character')
 * @param {string|null} recipientName - 下单对象名称（角色时使用）
 */
async function openPaymentMethodPicker(recipientType, recipientName) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('unified-checkout-modal');
    const titleEl = document.getElementById('checkout-title');
    const contentEl = document.getElementById('checkout-content');
    const confirmBtn = document.getElementById('checkout-confirm-btn');
    
    // 设置标题和按钮文本
    titleEl.textContent = '选择付款方式';
    confirmBtn.textContent = '确认下单';
    
    // 设置取消按钮为"上一步"
    const cancelBtnForText = document.getElementById('checkout-cancel-btn');
    if (cancelBtnForText) {
        cancelBtnForText.textContent = '上一步';
    }
    
    contentEl.innerHTML = '';

    // 选项1：自己付钱
    const selfPayOption = document.createElement('div');
    selfPayOption.className = 'payment-option-item';
    selfPayOption.dataset.paymentType = 'self';
    
    // 获取用户头像
    const userAvatar = chat.isGroup ? 
        (chat.settings.myAvatar || defaultMyGroupAvatar) : 
        (chat.settings.myAvatar || defaultAvatar);
    
    selfPayOption.innerHTML = `
        <img src="${userAvatar}" class="avatar" style="width: 45px; height: 45px; border-radius: 50%;">
        <div class="payment-option-info">
            <div class="name">自己付钱</div>
            <div class="description">我来支付这笔订单</div>
        </div>
    `;
    contentEl.appendChild(selfPayOption);

    // 选项2：请角色付钱
    if (chat.isGroup) {
        // 群聊：可以选择群里的角色付钱
        const myNickname = chat.settings.myNickname || '我';
        const members = chat.members.filter(m => m.groupNickname !== myNickname);

        members.forEach(member => {
            const characterPayOption = document.createElement('div');
            characterPayOption.className = 'payment-option-item';
            characterPayOption.dataset.paymentType = 'character';
            characterPayOption.dataset.payerName = member.originalName;
            characterPayOption.innerHTML = `
                <img src="${member.avatar || defaultGroupMemberAvatar}" class="avatar" style="width: 45px; height: 45px; border-radius: 50%;">
                <div class="payment-option-info">
                    <div class="name">请 ${member.groupNickname} 付钱</div>
                    <div class="description">${member.groupNickname} 来支付这笔订单</div>
                </div>
            `;
            contentEl.appendChild(characterPayOption);
        });
    } else {
        // 私聊：请当前角色付钱
        const characterPayOption = document.createElement('div');
        characterPayOption.className = 'payment-option-item';
        characterPayOption.dataset.paymentType = 'character';
        characterPayOption.dataset.payerName = chat.name;
        characterPayOption.innerHTML = `
            <img src="${chat.settings.aiAvatar || '/api/placeholder/45/45'}" class="avatar" style="width: 45px; height: 45px; border-radius: 50%;">
            <div class="payment-option-info">
                <div class="name">请 ${chat.name} 付钱</div>
                <div class="description">${chat.name} 来支付这笔订单</div>
            </div>
        `;
        contentEl.appendChild(characterPayOption);
    }

    // 为动态生成的付款方式选择项绑定点击事件
    contentEl.querySelectorAll('.payment-option-item').forEach(item => {
        item.addEventListener('click', () => {
            // 清除其他选中状态
            contentEl.querySelectorAll('.payment-option-item').forEach(el => el.classList.remove('selected'));
            // 选中当前项
            item.classList.add('selected');
            
        });
    });

    // 存储第一步的选择结果
    modal.dataset.recipientType = recipientType;
    modal.dataset.recipientName = recipientName || '';

    modal.classList.add('visible');
    
    // 绑定按钮事件（每次打开弹窗时重新绑定，确保事件正常工作）
    const cancelBtnEl = document.getElementById('checkout-cancel-btn');
    const confirmBtnEl = document.getElementById('checkout-confirm-btn');
    
    // 移除旧的事件监听器（如果存在）
    if (cancelBtnEl) {
        cancelBtnEl.replaceWith(cancelBtnEl.cloneNode(true));
        const newCancelBtn = document.getElementById('checkout-cancel-btn');
        newCancelBtn.addEventListener('click', () => {
            console.log('上一步按钮被点击');
            // 关闭第二步弹窗
            modal.classList.remove('visible');
            
            // 获取之前的选中状态并重新打开第一步弹窗
            const previousSelection = {
                recipientType: modal.dataset.recipientType,
                recipientName: modal.dataset.recipientName || null
            };
            
            openOrderRecipientPicker(previousSelection);
        });
    } else {
        console.log('找不到上一步按钮');
    }
    
    if (confirmBtnEl) {
        confirmBtnEl.replaceWith(confirmBtnEl.cloneNode(true));
        const newConfirmBtn = document.getElementById('checkout-confirm-btn');
        newConfirmBtn.addEventListener('click', async () => {
            console.log('确认下单按钮被点击');
            const selectedPaymentOption = document.querySelector('#checkout-content .payment-option-item.selected');
            
            if (!selectedPaymentOption) {
                alert("请选择付款方式。");
                return;
            }
            
            const paymentType = selectedPaymentOption.dataset.paymentType;
            const payerName = selectedPaymentOption.dataset.payerName || null;
            
            // 获取第一步的选择结果
            const recipientType = modal.dataset.recipientType;
            const recipientName = modal.dataset.recipientName || null;
            
            // 获取购物车中选中的商品
            const selectedItems = getSelectedCartItems();
            
            // 直接执行下单逻辑
            await sendOrderMessage(selectedItems, recipientType, recipientName, paymentType, payerName);
            modal.classList.remove('visible');
        });
    } else {
        console.log('找不到确认下单按钮');
    }
}

/**
 * 生成唯一订单编号
 * @returns {string} 格式为 ORD-YYYYMMDD-XXXXXX 的订单编号
 */
function generateOrderNumber() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const dateStr = `${year}${month}${day}`;
    
    // 生成6位随机数字
    const randomNum = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');
    
    return `ORD-${dateStr}-${randomNum}`;
}

/**
 * 发送订单消息
 * @param {Array} itemsToSend - 要发送的商品数组
 * @param {string} recipientType - 下单对象类型 ('self' 或 'character')
 * @param {string|null} recipientName - 下单对象名称（角色时使用）
 * @param {string} paymentType - 付款类型 ('self' 或 'character')
 * @param {string|null} payerName - 付款人名称（角色付钱时使用）
 */
async function sendOrderMessage(itemsToSend, recipientType, recipientName, paymentType, payerName) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // 分别处理个人商城和系统商城商品
    const personalItems = itemsToSend.filter(item => item.type === 'personal');
    const systemItems = itemsToSend.filter(item => item.type === 'system');
    
    // 获取个人商城商品信息
    const personalProductIds = personalItems.map(item => item.productId);
    const personalProducts = personalProductIds.length > 0 ? 
        await db.shoppingProducts.where('id').anyOf(personalProductIds).toArray() : [];
    const personalProductMap = new Map(personalProducts.map(p => [p.id, p]));
    
    const itemsForMessage = itemsToSend.map(cartItem => {
        if (cartItem.type === 'system') {
            // 系统商城商品，使用存储在购物车中的信息
            return {
                name: cartItem.name, 
                price: cartItem.price,
                imageUrl: cartItem.imageUrl || '/api/placeholder/100/100', 
                quantity: cartItem.quantity,
                description: cartItem.description || '',
                style: cartItem.style || '',
                type: 'system',  // 保留系统商品标识
                category: cartItem.category || 'other'  // 保留商品分类
            };
        } else {
            // 个人商城商品，从数据库获取信息
            const product = personalProductMap.get(cartItem.productId);
            return {
                name: product ? product.name : '未知商品', 
                price: product ? product.price : 0,
                imageUrl: product ? product.imageUrl : '/api/placeholder/100/100', 
                quantity: cartItem.quantity,
                description: product ? (product.description || '') : '',
                style: product ? (product.style || '') : ''
            };
        }
    });
    
    // 生成唯一订单编号
    const orderNumber = generateOrderNumber();
    
    // 计算订单总金额
    const totalAmount = itemsForMessage.reduce((sum, item) => sum + item.price * item.quantity, 0);
    
    // 如果用户选择自己付钱，先检查余额并扣费
    if (paymentType === 'self') {
        try {
            // 获取所有商品名称作为描述
            const itemNames = itemsForMessage && itemsForMessage.length > 0 
                ? itemsForMessage.map(item => item.name).join('、') 
                : '商品';
            
            // 使用更安全的方式调用钱包函数
            let deductSuccess = false;
            
            // 尝试多种方式调用函数
            if (typeof window.checkAndDeductWalletBalance === 'function') {
                deductSuccess = await window.checkAndDeductWalletBalance(totalAmount, `商城购物：${itemNames}`, 'shopping_order');
            } else if (typeof checkAndDeductWalletBalance === 'function') {
                deductSuccess = await checkAndDeductWalletBalance(totalAmount, `商城购物：${itemNames}`, 'shopping_order');
            } else {
                // 如果函数不存在，使用简化的钱包扣费逻辑
                try {
                    // 简化版余额不足弹窗
                    function showInsufficientBalanceModal() {
                        const existingModal = document.getElementById('insufficient-balance-modal');
                        if (existingModal) {
                            existingModal.remove();
                        }
                        
                        const modalHtml = `
                            <div id="insufficient-balance-modal" class="modal visible">
                                <div class="modal-content" style="width: 300px; text-align: center;">
                                    <div class="modal-header">
                                        <span>余额不足</span>
                                    </div>
                                    <div class="modal-body" style="padding: 20px;">
                                        <p style="margin-bottom: 20px;">钱包余额不足，无法完成此操作</p>
                                        <p style="color: #666; font-size: 14px;">建议：</p>
                                        <p style="color: #666; font-size: 14px;">1. 通过游戏充值增加余额</p>
                                        <p style="color: #666; font-size: 14px;">2. 向朋友乞讨一些零花钱</p>
                                    </div>
                                    <div class="modal-footer">
                                        <button class="cancel" onclick="document.getElementById('insufficient-balance-modal').remove()">知道了</button>
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        document.body.insertAdjacentHTML('beforeend', modalHtml);
                    }
                    
                    // 检查并初始化钱包数据库
                    if (!window.walletDB || !window.walletInitialized) {
                        console.log('钱包数据库未初始化，正在安全初始化...');
                        
                        // 添加防重复初始化标记
                        if (window.walletInitializing) {
                            console.log('钱包正在初始化中，跳过重复初始化');
                            return;
                        }
                        window.walletInitializing = true;
                        
                        try {
                            // 尝试初始化钱包数据库
                            if (typeof window.initWalletDB === 'function') {
                                await window.initWalletDB();
                            } else if (typeof initWalletDB === 'function') {
                                await initWalletDB();
                            } else {
                                // 安全的数据库初始化 - 修复余额消失问题
                                if (!window.Dexie) {
                                    console.error('Dexie库未加载');
                                    alert('数据库库未加载，请刷新页面重试');
                                    return;
                                }
                                
                                // 如果数据库已存在，不要重新创建
                                if (!window.walletDB) {
                                    window.walletDB = new Dexie('WalletDB');
                                    window.walletDB.version(1).stores({
                                        wallet: '++id, balance, lastGameTime, gameChances, nextChanceTime, currentPeriod, morningChances, afternoonChances, lastResetDate',
                                        gameHistory: '++id, timestamp, gameType, result, score',
                                        transactions: '++id, timestamp, type, amount, description, source'
                                    });
                                    
                                    await window.walletDB.open();
                                }
                                
                                // 安全检查：只有在确实没有任何钱包记录时才创建新记录
                                try {
                                    const walletRecords = await window.walletDB.wallet.toArray();
                                    if (walletRecords.length === 0) {
                                        console.log('创建新的钱包记录（首次使用）');
                                        await window.walletDB.wallet.add({
                                            balance: 0,
                                            lastGameTime: 0,
                                            gameChances: 2,
                                            nextChanceTime: 0,
                                            currentPeriod: 'morning',
                                            morningChances: 2,
                                            afternoonChances: 2,
                                            lastResetDate: new Date().toDateString()
                                        });
                                    } else {
                                        console.log('发现已有钱包记录，保留现有数据');
                                        // 记录当前余额，确保不丢失
                                        const existingBalance = walletRecords[0].balance || 0;
                                        console.log(`保护现有余额: ¥${existingBalance}`);
                                    }
                                } catch (error) {
                                    console.error('钱包记录检查失败:', error);
                                }
                                
                                window.walletInitialized = true;
                                console.log('钱包数据库安全初始化完成');
                            }
                            
                            // 清理初始化标记
                            window.walletInitializing = false;
                            
                        } catch (initError) {
                            console.error('钱包数据库初始化失败:', initError);
                            alert('钱包系统初始化失败，请刷新页面重试');
                            
                            // 即使失败也要清理标记
                            window.walletInitializing = false;
                            return;
                        }
                    }
                    
                    // 再次检查数据库是否可用
                    if (!window.walletDB) {
                        console.error('钱包数据库仍未可用');
                        alert('钱包系统不可用，请刷新页面重试');
                        return;
                    }
                    
                    const walletRecord = await window.walletDB.wallet.orderBy('id').first();
                    if (!walletRecord) {
                        console.error('钱包记录不存在');
                        showInsufficientBalanceModal();
                        return;
                    }
                    
                    const currentBalance = walletRecord.balance || 0;
                    
                    // 检查余额是否足够
                    if (currentBalance < totalAmount) {
                        showInsufficientBalanceModal();
                        return;
                    }
                    
                    // 扣除余额
                    const newBalance = currentBalance - totalAmount;
                    await window.walletDB.wallet.update(walletRecord.id, {
                        balance: newBalance
                    });
                    
                    // 添加交易记录
                    await window.walletDB.transactions.add({
                        timestamp: Date.now(),
                        type: 'expense',
                        amount: totalAmount,
                        description: `商城购物订单 ${orderNumber}`,
                        source: 'shopping_order'
                    });
                    
                    console.log(`钱包扣费成功：${totalAmount}元，剩余余额：${newBalance}元`);
                    deductSuccess = true;
                    
                } catch (evalError) {
                    console.error('钱包扣费失败:', evalError);
                    alert('钱包操作失败，请重试');
                    return;
                }
            }
            
            if (!deductSuccess) {
                return; // 余额不足或扣费失败，终止下单
            }
        } catch (error) {
            console.error('钱包扣费过程中出错:', error);
            alert('钱包操作失败，请重试');
            return;
        }
    }
    
    // 构建订单消息
    const orderMessage = {
        role: 'user', 
        type: 'order', 
        timestamp: Date.now(),
        orderNumber: orderNumber, // 添加订单编号
        items: itemsForMessage,
        total: totalAmount,
        recipientType: recipientType,
        recipientName: recipientName,
        paymentType: paymentType,
        payerName: payerName,
        // 【修复】请对方买单时，订单初始状态为未支付
        isPaid: paymentType === 'self', // 自己付钱时为true，请对方付钱时为false
        payerResponse: paymentType === 'character' ? 'pending' : 'paid' // 请对方付钱时状态为pending
    };
    
    chat.history.push(orderMessage);

    // 为AI生成订单信息的隐藏提示
    let orderDescription = '';
    const myNickname = chat.settings.myNickname || '我';
    
    // 构建下单信息
    if (recipientType === 'self') {
        orderDescription += `${myNickname} 为自己下单了`;
    } else {
        const recipientDisplayName = chat.isGroup ? 
            getDisplayNameInGroup(chat, recipientName) : recipientName;
        orderDescription += `${myNickname} 为 ${recipientDisplayName} 下单了`;
    }
    
    // 构建付款信息
    if (paymentType === 'self') {
        orderDescription += `，由 ${myNickname} 付钱`;
    } else {
        const payerDisplayName = chat.isGroup ? 
            getDisplayNameInGroup(chat, payerName) : payerName;
        orderDescription += `，请 ${payerDisplayName} 付钱`;
    }
    

    await db.chats.put(chat);
    
    // 使用 try-catch 安全调用 appendMessage
    try {
        // 尝试多种方式调用 appendMessage
        if (typeof window.appendMessage === 'function') {
            window.appendMessage(orderMessage, chat);
        } else if (typeof appendMessage === 'function') {
            appendMessage(orderMessage, chat);
        } else {
            // 直接实现 appendMessage 的逻辑
            const messagesContainer = document.getElementById('chat-messages');
            if (messagesContainer) {
                let messageEl = null;
                
                // 尝试调用 createMessageElement
                if (typeof window.createMessageElement === 'function') {
                    messageEl = window.createMessageElement(orderMessage, chat);
                } else if (typeof createMessageElement === 'function') {
                    messageEl = createMessageElement(orderMessage, chat);
                }
                
                if (messageEl) {
                    messageEl.classList.add('animate-in');
                    const typingIndicator = document.getElementById('typing-indicator');
                    messagesContainer.insertBefore(messageEl, typingIndicator);
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                } else {
                    console.warn('createMessageElement function not available, message not displayed');
                }
            }
        }
    } catch (error) {
        console.warn('Message display failed:', error);
    }
    
    // 使用 try-catch 安全调用 renderChatList
    try {
        if (typeof window.renderChatListProxy === 'function') {
            await window.renderChatListProxy();
        } else if (typeof window.renderChatList === 'function') {
            await window.renderChatList();
        } else if (typeof renderChatList === 'function') {
            await renderChatList();
        } else {
            console.warn('renderChatList function not found, skipping');
        }
    } catch (error) {
        console.warn('renderChatList failed:', error);
    }
    
    // 从购物车中移除已结算的商品
    shoppingCart = shoppingCart.filter(item => !itemsToSend.some(sent => sent.productId === item.productId));
    
    // 使用 try-catch 安全调用 updateCartCount
    try {
        if (typeof window.updateCartCount === 'function') {
            window.updateCartCount();
        } else if (typeof updateCartCount === 'function') {
            updateCartCount();
        } else {
            console.warn('updateCartCount function not found, skipping');
        }
    } catch (error) {
        console.warn('updateCartCount failed:', error);
    }
    
    // 先显示成功消息，让用户确认后再切换界面
    // await showCustomAlert('成功', '订单已成功提交！'); // 删除弹窗，直接切换界面
    
    // 切换回聊天界面
    showScreen('chat-interface-screen');
}

/**
 * 显示购物小票
 * @param {number} timestamp - 消息时间戳
 */
function showGiftReceipt(timestamp) {
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || (message.type !== 'gift' && message.type !== 'order')) return;
    
    const receiptBody = document.getElementById('gift-receipt-body');
    
    // 获取商品分类对应的emoji
    function getCategoryEmoji(category) {
        const categoryEmojis = {
            'electronics': '✨',
            'fashion': '🎀',
            'home': '🏡',
            'food': '🍓',
            'snacks': '🍿',
            'pets': '🐶',
            'maternity': '👶',
            'adult': '🔞',
            'beauty': '💄',
            'toys': '🧸',
            'medicine': '💊',
            'other': '📦'
        };
        return categoryEmojis[category] || '📦';
    }
    
    let itemsHtml = '';
    message.items.forEach((item, index) => {
        // 判断是否为系统商品，如果是则显示emoji，否则显示图片
        const isSystemItem = item.type === 'system';
        // 判断是否是AI发送的消息
        const isAIMessage = message.role === 'assistant';
        
        let imageHtml;
        if (isAIMessage) {
            // 检查是否是等待付款状态
            if (message.status === 'pending') {
                // 等待付款状态：黑白交替显示爱心（第一个黑色，第二个白色，以此类推）
                const heartEmoji = index % 2 === 0 ? '🖤' : '🤍';
                imageHtml = `<div style="display: flex; align-items: center; justify-content: center; width: 50px; height: 50px; font-size: 28px; background: #f8f9fa; border-radius: 8px; margin-right: 10px;">${heartEmoji}</div>`;
            } else {
                // 其他状态：统一显示🖤
                imageHtml = `<div style="display: flex; align-items: center; justify-content: center; width: 50px; height: 50px; font-size: 28px; background: #f8f9fa; border-radius: 8px; margin-right: 10px;">🖤</div>`;
            }
        } else {
            // 用户发送的消息：保持原逻辑（系统商品显示emoji，自定义商品显示图片）
            imageHtml = isSystemItem ? 
                `<div style="display: flex; align-items: center; justify-content: center; width: 50px; height: 50px; font-size: 28px; background: #f8f9fa; border-radius: 8px; margin-right: 10px;">${getCategoryEmoji(item.category)}</div>` :
                (item.imageUrl ? `<img src="${item.imageUrl}" alt="${item.name}" class="receipt-item-image">` : '');
        }
        
        const descriptionHtml = item.description ? 
            `<div class="receipt-item-description">${item.description}</div>` : '';
        const styleHtml = item.style ? 
            `<div class="receipt-item-style">${item.style}</div>` : '';
        
        itemsHtml += `<tr>
            <td class="item-info">
                <div class="item-info-container">
                    ${imageHtml}
                    <div class="item-details">
                        <div class="item-name">${item.name}</div>
                        ${styleHtml}
                        ${descriptionHtml}
                    </div>
                </div>
            </td>
            <td class="item-qty">${item.quantity}</td>
            <td class="item-price">¥${item.price.toFixed(2)}</td>
            <td class="item-subtotal">¥${(item.price * item.quantity).toFixed(2)}</td>
        </tr>`;
    });
    
    // 根据消息类型构建不同的小票内容
    let receiptTitle = '';
    let additionalInfo = '';
    
    if (message.type === 'gift') {
        receiptTitle = '礼物小票';
        if (message.recipients && message.recipients.length > 0) {
            const recipientNames = message.recipients.map(originalName => {
                const member = chat.members.find(m => m.originalName === originalName);
                return member ? member.groupNickname : originalName;
            }).join('、');
            additionalInfo = `<p>收礼人: ${recipientNames}</p>`;
        }
    } else if (message.type === 'order') {
        receiptTitle = '订单小票';
        
        // 下单对象信息
        const senderName = chat.settings.myNickname || '我';
        let recipientInfo = '';
        if (message.recipientType === 'self') {
            recipientInfo = senderName;
        } else {
            recipientInfo = chat.isGroup ? 
                getDisplayNameInGroup(chat, message.recipientName) : message.recipientName;
        }
        
        // 付款人信息
        let payerInfo = '';
        if (message.paymentType === 'self') {
            payerInfo = senderName;
        } else {
            payerInfo = chat.isGroup ? 
                getDisplayNameInGroup(chat, message.payerName) : message.payerName;
        }
        
        additionalInfo = `
            <div class="receipt-info-section">
                <p><span class="info-label">订单编号:</span> ${message.orderNumber || 'N/A'}</p>
                <p><span class="info-label">下单对象:</span> ${recipientInfo}</p>
                <p><span class="info-label">付款人:</span> ${payerInfo}</p>
            </div>
        `;
    }

    receiptBody.innerHTML = `
        <div class="receipt-header">
            <h3>${receiptTitle}</h3>
            <p>交易时间: ${new Date(message.timestamp).toLocaleString()}</p>
            ${additionalInfo}
        </div>
        <table class="receipt-items-table">
            <thead>
                <tr>
                    <th class="item-info">商品信息</th>
                    <th class="item-qty">数量</th>
                    <th class="item-price">单价</th>
                    <th class="item-subtotal">小计</th>
                </tr>
            </thead>
            <tbody>${itemsHtml}</tbody>
        </table>
        <div class="receipt-total">总计: ¥${message.total.toFixed(2)}</div>
        <div class="receipt-footer">感谢您的惠顾，欢迎再次光临！</div>
    `;
    
    document.getElementById('gift-receipt-modal').classList.add('visible');
    
    // 确保关闭按钮事件绑定
    const closeReceiptBtn = document.getElementById('close-receipt-btn');
    if (closeReceiptBtn) {
        closeReceiptBtn.removeEventListener('click', closeReceiptHandler);
        closeReceiptBtn.addEventListener('click', closeReceiptHandler);
    }
}

// ==================== 商品管理功能 ====================

/**
 * 打开商品编辑器
 * @param {number|null} productId - 商品ID，null表示添加新商品
 */
async function openProductEditor(productId = null) {
    editingProductId = productId;
    const modal = document.getElementById('product-editor-modal');
    const title = document.getElementById('product-editor-title');
    const nameInput = document.getElementById('product-name-input');
    const priceInput = document.getElementById('product-price-input');
    const descInput = document.getElementById('product-description-input');
    const imagePreview = document.getElementById('product-image-preview');
    
    if (productId) {
        // 编辑模式
        title.textContent = '编辑商品';
        const product = await db.shoppingProducts.get(productId);
        nameInput.value = product.name;
        priceInput.value = product.price;
        descInput.value = product.description || '';
        imagePreview.src = product.imageUrl;
    } else {
        // 添加模式
        title.textContent = '添加商品';
        nameInput.value = '';
        priceInput.value = '';
        descInput.value = '';
        imagePreview.src = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756206115802_qdqqd_0c99bh.jpeg';
    }
    modal.classList.add('visible');
}

/**
 * 保存商品信息
 */
async function saveProduct() {
    const name = document.getElementById('product-name-input').value.trim();
    const price = parseFloat(document.getElementById('product-price-input').value);
    const description = document.getElementById('product-description-input').value.trim();
    const imageUrl = document.getElementById('product-image-preview').src;
    
    // 验证输入
    if (!name) { 
        alert('商品名称不能为空！'); 
        return; 
    }
    if (isNaN(price) || price < 0) { 
        alert('请输入有效的价格！'); 
        return; 
    }
    
    const productData = { name, price, description, imageUrl };
    
    if (editingProductId) {
        // 更新现有商品
        await db.shoppingProducts.update(editingProductId, productData);
    } else {
        // 添加新商品时，自动设置当前选择的分类
        productData.category = currentCategory;
        await db.shoppingProducts.add(productData);
    }
    
    document.getElementById('product-editor-modal').classList.remove('visible');
    await renderShoppingProducts();
}

/**
 * 删除商品
 * @param {number} productId - 商品ID
 */
async function deleteProduct(productId) {
    const confirmed = await showCustomConfirm('删除商品', '确定要删除这个商品吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.shoppingProducts.delete(productId);
        await renderShoppingProducts();
    }
}

// ==================== 事件监听器绑定 ====================

/**
 * 初始化购物系统事件绑定
 * 在每次打开购物页面时调用，确保事件正确绑定
 */
function initShoppingSystemEvents() {
    // 主要页面导航事件
    const shoppingBackBtn = document.getElementById('shopping-back-btn');
    if (shoppingBackBtn) {
        shoppingBackBtn.removeEventListener('click', shoppingBackHandler); // 移除旧事件
        shoppingBackBtn.addEventListener('click', shoppingBackHandler);
    }
    
    const goToCartBtn = document.getElementById('go-to-cart-btn');
    if (goToCartBtn) {
        goToCartBtn.removeEventListener('click', openCartScreen);
        goToCartBtn.addEventListener('click', openCartScreen);
    }
    
    const cartBackBtn = document.getElementById('cart-back-btn');
    if (cartBackBtn) {
        cartBackBtn.removeEventListener('click', openShoppingScreen);
        cartBackBtn.addEventListener('click', openShoppingScreen);
    }
    
    const checkoutBtn = document.getElementById('checkout-btn');
    if (checkoutBtn) {
        checkoutBtn.removeEventListener('click', handleCheckout);
        checkoutBtn.addEventListener('click', handleCheckout);
    }

    // 小票弹窗关闭事件
    const closeReceiptBtn = document.getElementById('close-receipt-btn');
    if (closeReceiptBtn) {
        closeReceiptBtn.removeEventListener('click', closeReceiptHandler);
        closeReceiptBtn.addEventListener('click', closeReceiptHandler);
    }

    // 商品管理按钮事件
    const manageProductsBtn = document.getElementById('manage-products-btn');
    if (manageProductsBtn) {
        manageProductsBtn.removeEventListener('click', manageProductsHandler);
        manageProductsBtn.addEventListener('click', manageProductsHandler);
    }

    // 添加商品按钮事件
    const addNewProductBtn = document.getElementById('add-new-product-btn');
    if (addNewProductBtn) {
        addNewProductBtn.removeEventListener('click', addNewProductHandler);
        addNewProductBtn.addEventListener('click', addNewProductHandler);
    }

    // 购物车清空按钮事件
    const clearCartBtn = document.getElementById('clear-cart-btn');
    if (clearCartBtn) {
        clearCartBtn.removeEventListener('click', clearCartHandler);
        clearCartBtn.addEventListener('click', clearCartHandler);
    }

    // 购物车全选事件
    const selectAllCartItems = document.getElementById('select-all-cart-items');
    if (selectAllCartItems) {
        selectAllCartItems.removeEventListener('change', selectAllCartHandler);
        selectAllCartItems.addEventListener('change', selectAllCartHandler);
    }

    // 商品编辑器弹窗按钮事件
    const cancelProductEditorBtn = document.getElementById('cancel-product-editor-btn');
    if (cancelProductEditorBtn) {
        cancelProductEditorBtn.removeEventListener('click', cancelProductEditorHandler);
        cancelProductEditorBtn.addEventListener('click', cancelProductEditorHandler);
    }
    
    const saveProductBtn = document.getElementById('save-product-btn');
    if (saveProductBtn) {
        saveProductBtn.removeEventListener('click', saveProduct);
        saveProductBtn.addEventListener('click', saveProduct);
    }

    // 商品图片上传事件
    const productImageInput = document.getElementById('product-image-input');
    if (productImageInput) {
        productImageInput.removeEventListener('change', productImageInputHandler);
        productImageInput.addEventListener('change', productImageInputHandler);
    }

    // 商品列表事件委托（处理商品卡片上的各种点击事件）
    const productGrid = document.getElementById('product-grid');
    if (productGrid) {
        // 移除旧的事件监听器（如果存在）
        productGrid.removeEventListener('click', productGridClickHandler);
        productGrid.addEventListener('click', productGridClickHandler);
    }
}

// 事件处理函数定义
async function productGridClickHandler(e) {
    const productItem = e.target.closest('.product-item');
    if (!productItem) return;
    const productId = parseInt(productItem.dataset.id);

    if (e.target.classList.contains('edit-product-btn')) {
        // 编辑商品
        openProductEditor(productId);
    } else if (e.target.classList.contains('delete-product-btn')) {
        // 删除商品
        deleteProduct(productId);
    } else if (e.target.classList.contains('add-to-cart-btn')) {
        // 加入购物车
        await addToCart(productId);
        // 显示顶部提示而不是弹窗
        const product = await db.shoppingProducts.get(productId);
        showTopNotification(`${product ? product.name : '商品'}已成功添加至购物车`);
    }
}

function shoppingBackHandler() {
    // 退出商城时清空数据缓存
    clearMallDataCache();
    
    // 返回聊天界面
    showScreen('chat-interface-screen');
}

// ▼▼▼ 新增：商城切换和分类切换功能 ▼▼▼

/**
 * 切换商城类型（系统商城/个人商城）
 */
function switchMall(mallType) {
    if (currentMallType === mallType) return;
    
    currentMallType = mallType;
    
    // 隐藏所有商城页面
    document.querySelectorAll('.mall-page').forEach(page => {
        page.classList.remove('active');
    });
    
    // 显示对应的商城页面
    const targetPage = document.getElementById(`${mallType}-mall-page`);
    if (targetPage) {
        targetPage.classList.add('active');
    }
    
    // 更新底部导航状态
    document.querySelectorAll('.shopping-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    document.querySelector(`[data-mall="${mallType}"]`).classList.add('active');
    
    // 只有在数据已加载的情况下才需要刷新显示
    // 因为切换商城时数据已经在 loadMallData() 中预加载过了
    if (isMallDataLoaded) {
        // 数据已经加载，直接显示即可，不需要重新渲染
        // 因为两个商城的数据在第一次进入时都已经加载完成了
    }
}

/**
 * 切换个人商城分类
 */
function switchPersonalMallCategory(category) {
    if (currentCategory === category) return;
    
    currentCategory = category;
    
    // 更新侧边栏分类状态
    document.querySelectorAll('#personal-mall-sidebar .sidebar-category').forEach(item => {
        item.classList.remove('active');
    });
    document.querySelector(`#personal-mall-sidebar [data-category="${category}"]`).classList.add('active');
    
    // 只有在数据已加载的情况下才重新渲染
    if (isMallDataLoaded) {
        // 重新渲染个人商城商品（根据分类过滤）
        renderShoppingProducts();
        
        // 为不同分类显示特定的提示信息
        showCategoryWelcomeMessage(category);
    }
}

/**
 * 切换系统商城分类
 */
function switchSystemMallCategory(category) {
    // 更新侧边栏分类状态
    document.querySelectorAll('#system-mall-sidebar .sidebar-category').forEach(item => {
        item.classList.remove('active');
    });
    document.querySelector(`#system-mall-sidebar [data-category="${category}"]`).classList.add('active');
    
    // 只有在数据已加载的情况下才重新渲染
    if (isMallDataLoaded) {
        // 重新渲染系统商城商品（根据分类过滤）
        renderSystemMallProducts(category);
    }
}

/**
 * 显示分类欢迎信息
 */
function showCategoryWelcomeMessage(category) {
    const categoryMessages = {
        'all': '欢迎来到个人商城！这里展示所有商品分类。',
        'electronics': '✨ 数码专区：最新科技产品，引领潮流生活！',
        'fashion': '🎀 服饰专区：时尚潮流，彰显个性魅力！',
        'home': '🏡 家居专区：温馨家居，品质生活从这里开始！',
        'food': '🍓 食品专区：新鲜美味，健康生活每一天！',
        'maternity': '👶 母婴专区：呵护成长，给宝宝最温柔的爱！',
        'beauty': '💄 美妆专区：精致美妆，展现最美的自己！',
        'pets': '🐕 宠物专区：爱宠用品，给毛孩子最好的关爱！',
        'other': '📦 其他专区：更多精彩商品，等你来发现！'
    };
    
    const message = categoryMessages[category] || '欢迎来到个人商城！';
    
    // 创建临时提示消息
    const existingToast = document.querySelector('.category-toast');
    if (existingToast) {
        existingToast.remove();
    }
    
    const toast = document.createElement('div');
    toast.className = 'category-toast';
    toast.textContent = message;
    toast.style.cssText = `
        position: fixed;
        bottom: 80px;
        right: 20px;
        transform: translateX(0);
        background: linear-gradient(135deg, rgba(255, 182, 193, 0.95), rgba(173, 216, 230, 0.95));
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        color: white;
        padding: 8px 16px;
        border-radius: 15px;
        font-size: 12px;
        font-weight: 500;
        z-index: 1000;
        animation: cuteToastSlideIn 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
        max-width: 200px;
        text-align: center;
        box-shadow: 
            0 8px 24px rgba(255, 182, 193, 0.4),
            0 4px 12px rgba(173, 216, 230, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.5);
        border: 1px solid rgba(255, 182, 193, 0.3);
    `;
    
    // 添加动画样式
    if (!document.querySelector('#category-toast-style')) {
        const style = document.createElement('style');
        style.id = 'category-toast-style';
        style.textContent = `
            @keyframes cuteToastSlideIn {
                0% { 
                    opacity: 0; 
                    transform: translateX(100%) scale(0.8); 
                    filter: blur(4px);
                }
                20% { 
                    opacity: 1; 
                    transform: translateX(0) scale(1.05); 
                    filter: blur(0);
                }
                25% { 
                    transform: translateX(0) scale(1); 
                }
                75% { 
                    opacity: 1; 
                    transform: translateX(0) scale(1); 
                }
                100% { 
                    opacity: 0; 
                    transform: translateX(50%) scale(0.9); 
                    filter: blur(2px);
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    document.body.appendChild(toast);
    
    // 1.5秒后自动移除
    setTimeout(() => {
        if (toast.parentNode) {
            toast.remove();
        }
    }, 1500);
}

/**
 * 渲染系统商城商品
 */
async function renderSystemMallProducts(category = 'all') {
    const systemGrid = document.getElementById('system-product-grid');
    if (!systemGrid) return;
    
    // 获取系统商城商品数据（异步）
    const systemProducts = await getSystemProducts();
    
    systemGrid.innerHTML = '';
    
    // 根据分类过滤商品
    const filteredProducts = category === 'all' 
        ? systemProducts 
        : systemProducts.filter(product => product.category === category);
    
    // 所有分类都使用统一的网格布局
    filteredProducts.forEach(product => {
        const productElement = createSystemProductElement(product);
        systemGrid.appendChild(productElement);
    });
    
    // 更新购物车显示
    await updateSystemCartDisplay();
}

/**
 * 获取分类中文名称
 */
function getCategoryName(category) {
    const categoryNames = {
        'digital': '数码',
        'clothing': '服饰',
        'home': '家居',
        'food': '食品',
        'maternity': '母婴',
        'beauty': '美妆',
        'pets': '宠物',
        'other': '其他'
    };
    return categoryNames[category] || '其他';
}

/**
 * 创建系统商品元素
 */
function createSystemProductElement(product) {
    const productDiv = document.createElement('div');
    productDiv.className = 'product-item text-only-card system-product-card';
    
    productDiv.innerHTML = `
        <div class="product-info-full">
            <!-- 可滚动的商品名称和描述区域 -->
            <div class="product-scrollable-content">
            <div class="product-name">${product.name}</div>
                <div class="product-divider">——————</div>
            <div class="product-description">${product.description}</div>
        </div>
            
            <!-- 固定的款式选择和底部区域 -->
            <div class="product-fixed-bottom">
                <div class="product-style-selector">
                    <select class="style-select" onchange="updateProductPrice(this, '${product.id}')">
                        ${product.variants && product.variants.length > 0 ? 
                            product.variants.map((variant, index) => 
                                `<option value="variant_${index}" data-price="${variant.price}">${variant.name}</option>`
                            ).join('') 
                            : 
                            `<option value="default" data-price="${product.price}">默认款式</option>
                             <option value="premium" data-price="${(product.price * 1.2).toFixed(2)}">精装版</option>
                             <option value="deluxe" data-price="${(product.price * 1.5).toFixed(2)}">豪华版</option>`
                        }
                    </select>
                </div>
                <div class="product-bottom">
                    <div class="product-price" data-base-price="${product.price}" data-current-price="${product.variants && product.variants.length > 0 ? product.variants[0].price : product.price}">¥${product.variants && product.variants.length > 0 ? product.variants[0].price : product.price}</div>
                    <button class="add-to-cart-btn cart-icon-btn" onclick="addSystemProductToCart('${product.id}')">
                        🛒+
            </button>
                </div>
            </div>
        </div>
    `;
    
    // 禁用点击商品查看详情
    // productDiv.addEventListener('click', (e) => {
    //     if (!e.target.classList.contains('add-to-cart-btn')) {
    //         showSystemProductDetail(product);
    //     }
    // });
    
    return productDiv;
}

/**
 * 更新商品价格根据选择的款式
 */
function updateProductPrice(selectElement, productId) {
    const selectedOption = selectElement.options[selectElement.selectedIndex];
    const newPrice = selectedOption.getAttribute('data-price');
    
    // 找到对应的价格显示元素
    const productCard = selectElement.closest('.product-item');
    const priceElement = productCard.querySelector('.product-price');
    
    // 更新价格显示
    priceElement.textContent = `¥${newPrice}`;
    
    // 更新价格数据属性，用于后续购物车操作
    priceElement.setAttribute('data-current-price', newPrice);
}

/**
 * 添加系统商品到购物车
 */
async function addSystemProductToCart(productId) {
    // 确保统一购物车已初始化
    if (!shoppingCart) {
        shoppingCart = [];
    }
    
    // 获取商品价格（考虑款式选择）
    const productCard = document.querySelector(`[onclick*="${productId}"]`).closest('.product-item');
    const priceElement = productCard.querySelector('.product-price');
    const currentPrice = parseFloat(priceElement.getAttribute('data-current-price') || priceElement.getAttribute('data-base-price'));
    
    // 检查商品是否已在统一购物车中
    const existingItem = shoppingCart.find(item => item.productId === productId && item.type === 'system');
    if (existingItem) {
        existingItem.quantity += 1;
        existingItem.price = currentPrice; // 更新价格
        
        // 更新款式信息
        const styleSelect = productCard.querySelector('.style-select');
        const selectedOption = styleSelect ? styleSelect.selectedOptions[0] : null;
        const selectedStyle = selectedOption ? selectedOption.textContent : '默认款式';
        existingItem.style = selectedStyle;
        
        // 确保category字段存在
        if (!existingItem.category) {
            const systemProducts = await getSystemProducts();
            const product = systemProducts.find(p => p.id === productId);
            if (product) {
                existingItem.category = product.category || 'other';
            }
        }
    } else {
        // 获取商品信息（异步）
        const systemProducts = await getSystemProducts();
        const product = systemProducts.find(p => p.id === productId);
        if (product) {
            // 获取当前选择的款式信息
            const styleSelect = productCard.querySelector('.style-select');
            const selectedOption = styleSelect ? styleSelect.selectedOptions[0] : null;
            const selectedStyle = selectedOption ? selectedOption.textContent : '默认款式';
            
            shoppingCart.push({
                productId: productId,
                name: product.name,
                price: currentPrice,
                quantity: 1,
                type: 'system',
                description: product.description || '',
                style: selectedStyle,
                category: product.category || 'other'  // 添加商品分类
            });
        }
    }
    
    await updateSystemCartDisplay();
    updateCartCount(); // 同步更新个人商城显示
    updatePersonalCartTotal(); // 同步更新个人商城总金额
    
    // 显示顶部提示而不是弹窗
    const systemProducts = await getSystemProducts();
    const product = systemProducts.find(p => p.id === productId);
    showTopNotification(`${product ? product.name : '商品'}已成功添加至购物车`);
}

/**
 * 系统商品数据缓存
 */
var systemProductsCache = null;

/**
 * 获取系统商品数据（异步加载）
 * @returns {Promise<Array>} 商品数组
 */
async function getSystemProducts() {
    // 如果已经缓存，直接返回
    if (systemProductsCache) {
        console.log('使用缓存的系统商品数据');
        return systemProductsCache;
    }
    
    // 硬编码的商品数据（保持原有数据）
    systemProductsCache = [
        {
            id: 'sys_001',
            name: 'iPhone',
            description: '苹果智能手机，性能强劲，支持5G网络，拍照效果出色，多款型号可选。',
            price: 7234.00,
            category: 'electronics',
            variants: [
                { name: 'iPhone 16 Pro', price: 9156.00 },
                { name: 'iPhone 15 Plus', price: 7234.00 },
                { name: 'iPhone 14', price: 5672.00 }
            ]
        },
        // === 👨 男装系列 (25款) ===
        {
            id: 'fashion_001',
            name: '意式商务西装',
            description: '经典意式剪裁，100%羊毛面料，商务正装首选',
            price: 1876.00,
            category: 'fashion',
            variants: [
                { name: '经典黑色 修身版', price: 1876.00 },
                { name: '深灰色 宽松版', price: 1634.00 },
                { name: '藏青色 韩版', price: 2123.00 }
            ]
        },
        {
            id: 'fashion_002',
            name: '牛津纺衬衫',
            description: '经典牛津纺面料，商务休闲两相宜',
            price: 156.50,
            category: 'fashion',
            variants: [
                { name: '白色 经典款', price: 156.50 },
                { name: '浅蓝色 条纹款', price: 173.00 },
                { name: '粉色 免烫款', price: 184.50 }
            ]
        },
        {
            id: 'fashion_003',
            name: '潮流印花T恤',
            description: '100%纯棉，街头潮流设计，舒适透气',
            price: 67.00,
            category: 'fashion',
            variants: [
                { name: '黑色 骷髅印花', price: 67.00 },
                { name: '白色 字母印花', price: 52.50 },
                { name: '灰色 几何图案', price: 73.50 }
            ]
        },
        {
            id: 'fashion_004',
            name: '连帽卫衣',
            description: '加厚保暖，街头风格，多色可选',
            price: 124.00,
            category: 'fashion',
            variants: [
                { name: '黑色 基础款', price: 124.00 },
                { name: '灰色 拼接款', price: 136.50 },
                { name: '军绿色 工装款', price: 147.00 }
            ]
        },
        {
            id: 'fashion_005',
            name: '飞行员夹克',
            description: '经典MA-1设计，防风保暖，型男必备',
            price: 234.00,
            category: 'fashion',
            variants: [
                { name: '军绿色 经典款', price: 234.00 },
                { name: '黑色 修身款', price: 256.50 },
                { name: '卡其色 复古款', price: 273.00 }
            ]
        },
        {
            id: 'fashion_006',
            name: '修身牛仔裤',
            description: '弹力牛仔布，修身剪裁，舒适百搭',
            price: 142.50,
            category: 'fashion',
            variants: [
                { name: '深蓝色 修身款', price: 142.50 },
                { name: '黑色 破洞款', price: 167.00 },
                { name: '浅蓝色 直筒款', price: 134.00 }
            ]
        },
        {
            id: 'fashion_007',
            name: '休闲西裤',
            description: '商务休闲，免烫面料，舒适透气',
            price: 96.50,
            category: 'fashion',
            variants: [
                { name: '黑色 直筒款', price: 96.50 },
                { name: '深灰色 修身款', price: 103.00 },
                { name: '卡其色 休闲款', price: 87.50 }
            ]
        },
        {
            id: 'fashion_008',
            name: '工装短裤',
            description: '多口袋设计，耐磨面料，户外必备',
            price: 73.00,
            category: 'fashion',
            variants: [
                { name: '军绿色 多袋款', price: 73.00 },
                { name: '卡其色 简约款', price: 64.50 },
                { name: '黑色 战术款', price: 82.00 }
            ]
        },
        {
            id: 'fashion_009',
            name: '马丁靴',
            description: '真皮制作，经典8孔设计，耐穿耐用',
            price: 367.00,
            category: 'fashion',
            variants: [
                { name: '黑色 系带款', price: 367.00 },
                { name: '棕色 拉链款', price: 394.50 },
                { name: '酒红色 复古款', price: 423.00 }
            ]
        },
        {
            id: 'fashion_010',
            name: '商务皮鞋',
            description: '头层牛皮，意式工艺，商务正装必备',
            price: 456.50,
            category: 'fashion',
            variants: [
                { name: '黑色 牛津款', price: 456.50 },
                { name: '棕色 布洛克款', price: 487.00 },
                { name: '深棕色 德比款', price: 512.00 }
            ]
        },
        {
            id: 'fashion_011',
            name: '运动休闲鞋',
            description: '透气网面，轻便舒适，日常百搭',
            price: 187.50,
            category: 'fashion',
            variants: [
                { name: '白色 经典款', price: 187.50 },
                { name: '黑色 简约款', price: 174.00 },
                { name: '灰色 拼色款', price: 203.00 }
            ]
        },
        {
            id: 'fashion_012',
            name: '羊毛大衣',
            description: '100%羊毛，保暖时尚，冬季必备',
            price: 1234.00,
            category: 'fashion',
            variants: [
                { name: '黑色 长款', price: 1234.00 },
                { name: '灰色 中长款', price: 1076.00 },
                { name: '驼色 短款', price: 967.50 }
            ]
        },
        {
            id: 'fashion_013',
            name: '羊绒围巾',
            description: '100%羊绒，柔软亲肤，保暖时尚',
            price: 156.00,
            category: 'fashion',
            variants: [
                { name: '灰色 纯色款', price: 156.00 },
                { name: '驼色 格纹款', price: 173.50 },
                { name: '黑色 流苏款', price: 164.00 }
            ]
        },
        {
            id: 'fashion_014',
            name: '真皮腰带',
            description: '头层牛皮，精工制作，商务休闲皆宜',
            price: 84.50,
            category: 'fashion',
            variants: [
                { name: '黑色 自动扣', price: 84.50 },
                { name: '棕色 针扣', price: 73.00 },
                { name: '深棕色 板扣', price: 96.00 }
            ]
        },
        {
            id: 'fashion_015',
            name: '棒球帽',
            description: '纯棉面料，可调节帽围，街头潮流',
            price: 32.50,
            category: 'fashion',
            variants: [
                { name: '黑色 刺绣款', price: 32.50 },
                { name: '白色 印花款', price: 27.00 },
                { name: '灰色 简约款', price: 24.50 }
            ]
        },
        {
            id: 'fashion_016',
            name: '西部牛仔套装',
            description: '复古牛仔风格，衬衫+马甲组合，西部风情',
            price: 345.00,
            category: 'fashion',
            variants: [
                { name: '男款 经典蓝', price: 345.00 },
                { name: '女款 复古蓝', price: 326.50 },
                { name: '情侣款 双套装', price: 567.00 }
            ]
        },
        {
            id: 'fashion_017',
            name: '运动套装',
            description: '速干面料，运动休闲，舒适透气',
            price: 126.00,
            category: 'fashion',
            variants: [
                { name: '黑色 基础款', price: 126.00 },
                { name: '灰色 拼接款', price: 143.50 },
                { name: '蓝色 撞色款', price: 157.00 }
            ]
        },
        {
            id: 'fashion_018',
            name: '毛衣背心',
            description: '羊毛混纺，V领设计，商务休闲',
            price: 87.00,
            category: 'fashion',
            variants: [
                { name: '深灰色 V领款', price: 87.00 },
                { name: '藏青色 圆领款', price: 76.50 },
                { name: '驼色 高领款', price: 94.50 }
            ]
        },
        {
            id: 'fashion_019',
            name: '工装裤',
            description: '耐磨面料，多袋设计，工装风格',
            price: 134.50,
            category: 'fashion',
            variants: [
                { name: '军绿色 直筒款', price: 134.50 },
                { name: '卡其色 束脚款', price: 146.00 },
                { name: '黑色 修身款', price: 152.00 }
            ]
        },
        {
            id: 'fashion_020',
            name: '羽绒服',
            description: '90%白鸭绒，防风保暖，冬季必备',
            price: 423.50,
            category: 'fashion',
            variants: [
                { name: '黑色 长款', price: 423.50 },
                { name: '军绿色 短款', price: 367.00 },
                { name: '藏青色 中长款', price: 394.00 }
            ]
        },
        {
            id: 'fashion_021',
            name: '针织开衫',
            description: '羊毛混纺，开衫设计，温暖舒适',
            price: 167.50,
            category: 'fashion',
            variants: [
                { name: '灰色 V领款', price: 167.50 },
                { name: '驼色 圆领款', price: 154.00 },
                { name: '深蓝色 拉链款', price: 183.00 }
            ]
        },
        {
            id: 'fashion_022',
            name: '休闲夹克',
            description: '轻薄面料，防风透气，春秋必备',
            price: 142.00,
            category: 'fashion',
            variants: [
                { name: '黑色 立领款', price: 142.00 },
                { name: '军绿色 连帽款', price: 156.50 },
                { name: '深蓝色 拉链款', price: 148.00 }
            ]
        },
        {
            id: 'fashion_023',
            name: '商务袜子套装',
            description: '精梳棉面料，商务正装袜，5双装',
            price: 34.50,
            category: 'fashion',
            variants: [
                { name: '黑色 5双装', price: 34.50 },
                { name: '深灰色 5双装', price: 27.00 },
                { name: '混色 10双装', price: 56.00 }
            ]
        },
        {
            id: 'fashion_024',
            name: '内衣套装',
            description: '纯棉面料，舒适透气，贴身穿着',
            price: 47.50,
            category: 'fashion',
            variants: [
                { name: '白色 3件装', price: 47.50 },
                { name: '灰色 3件装', price: 43.00 },
                { name: '黑色 5件装', price: 67.00 }
            ]
        },
        {
            id: 'fashion_025',
            name: '商务手提包',
            description: '真皮制作，商务办公，大容量设计',
            price: 456.00,
            category: 'fashion',
            variants: [
                { name: '黑色 经典款', price: 456.00 },
                { name: '棕色 复古款', price: 487.50 },
                { name: '深棕色 商务款', price: 512.00 }
            ]
        },

        // === 👩 女装系列 (35款) ===
        {
            id: 'fashion_026',
            name: '洛丽塔连衣裙',
            description: '甜美洛丽塔风格，蕾丝装饰，公主范十足',
            price: 234.50,
            category: 'fashion',
            variants: [
                { name: '粉色 蕾丝边款', price: 234.50 },
                { name: '白色 荷叶边款', price: 216.00 },
                { name: '蓝色 蝴蝶结款', price: 267.00 }
            ]
        },
        {
            id: 'fashion_027',
            name: '职业套装',
            description: '优雅职业装，西装外套+包臀裙，职场必备',
            price: 367.50,
            category: 'fashion',
            variants: [
                { name: '黑色 经典款', price: 367.50 },
                { name: '深灰色 修身款', price: 394.00 },
                { name: '藏青色 时尚款', price: 423.00 }
            ]
        },
        {
            id: 'fashion_028',
            name: '雪纺衬衫',
            description: '轻薄雪纺面料，优雅飘逸，职场淑女风',
            price: 87.50,
            category: 'fashion',
            variants: [
                { name: '白色 蝴蝶结款', price: 87.50 },
                { name: '粉色 荷叶边款', price: 96.00 },
                { name: '米色 简约款', price: 73.00 }
            ]
        },
        {
            id: 'fashion_029',
            name: '高腰A字裙',
            description: '优雅A字版型，高腰设计，显瘦修身',
            price: 76.00,
            category: 'fashion',
            variants: [
                { name: '黑色 基础款', price: 76.00 },
                { name: '米色 百褶款', price: 84.50 },
                { name: '格纹 复古款', price: 93.00 }
            ]
        },
        {
            id: 'fashion_030',
            name: '针织毛衣',
            description: '柔软针织面料，温暖舒适，秋冬必备',
            price: 134.00,
            category: 'fashion',
            variants: [
                { name: '米色 圆领款', price: 134.00 },
                { name: '粉色 V领款', price: 147.50 },
                { name: '灰色 高领款', price: 156.00 }
            ]
        },
        {
            id: 'fashion_031',
            name: '牛仔外套',
            description: '经典牛仔面料，休闲百搭，时尚单品',
            price: 123.50,
            category: 'fashion',
            variants: [
                { name: '浅蓝色 经典款', price: 123.50 },
                { name: '深蓝色 修身款', price: 134.00 },
                { name: '白色 破洞款', price: 146.00 }
            ]
        },
        {
            id: 'fashion_032',
            name: '高跟鞋',
            description: '优雅细跟设计，舒适内垫，职场必备',
            price: 187.00,
            category: 'fashion',
            variants: [
                { name: '黑色 尖头款', price: 187.00 },
                { name: '裸色 圆头款', price: 173.50 },
                { name: '红色 漆皮款', price: 204.00 }
            ]
        },
        {
            id: 'fashion_033',
            name: '平底芭蕾鞋',
            description: '舒适平底设计，优雅蝴蝶结装饰',
            price: 94.50,
            category: 'fashion',
            variants: [
                { name: '黑色 蝴蝶结款', price: 94.50 },
                { name: '裸色 简约款', price: 86.00 },
                { name: '粉色 甜美款', price: 103.00 }
            ]
        },
        {
            id: 'fashion_034',
            name: '长筒靴',
            description: '过膝长筒设计，显腿长，秋冬时尚',
            price: 367.50,
            category: 'fashion',
            variants: [
                { name: '黑色 绒面款', price: 367.50 },
                { name: '棕色 皮质款', price: 394.00 },
                { name: '灰色 弹力款', price: 342.00 }
            ]
        },
        {
            id: 'fashion_035',
            name: '蕾丝吊带',
            description: '精致蕾丝面料，性感优雅，内搭外穿皆宜',
            price: 56.50,
            category: 'fashion',
            variants: [
                { name: '白色 蕾丝款', price: 56.50 },
                { name: '黑色 丝绸款', price: 64.00 },
                { name: '粉色 雪纺款', price: 47.00 }
            ]
        },
        {
            id: 'fashion_036',
            name: '风衣外套',
            description: '经典风衣版型，防风防雨，春秋必备',
            price: 456.00,
            category: 'fashion',
            variants: [
                { name: '卡其色 经典款', price: 456.00 },
                { name: '黑色 修身款', price: 487.50 },
                { name: '米色 长款', price: 512.00 }
            ]
        },
        {
            id: 'fashion_037',
            name: '紧身牛仔裤',
            description: '弹力牛仔面料，紧身修腿，显瘦必备',
            price: 126.50,
            category: 'fashion',
            variants: [
                { name: '深蓝色 高腰款', price: 126.50 },
                { name: '黑色 破洞款', price: 137.00 },
                { name: '浅蓝色 九分款', price: 114.00 }
            ]
        },
        {
            id: 'fashion_038',
            name: '雪纺连衣裙',
            description: '飘逸雪纺面料，优雅印花，仙女必备',
            price: 143.00,
            category: 'fashion',
            variants: [
                { name: '碎花 长袖款', price: 143.00 },
                { name: '纯色 短袖款', price: 124.50 },
                { name: '波点 无袖款', price: 132.00 }
            ]
        },
        {
            id: 'fashion_039',
            name: '羊毛呢大衣',
            description: '高档羊毛呢面料，保暖优雅，冬季必备',
            price: 1067.00,
            category: 'fashion',
            variants: [
                { name: '驼色 长款', price: 1067.00 },
                { name: '黑色 中长款', price: 934.50 },
                { name: '灰色 短款', price: 823.00 }
            ]
        },
        {
            id: 'fashion_040',
            name: '丝巾套装',
            description: '100%真丝面料，多种系法，优雅配饰',
            price: 87.00,
            category: 'fashion',
            variants: [
                { name: '印花 大方巾', price: 87.00 },
                { name: '纯色 小方巾', price: 56.50 },
                { name: '条纹 长丝巾', price: 73.50 }
            ]
        },
        {
            id: 'fashion_041',
            name: '蕾丝内衣套装',
            description: '精致蕾丝面料，舒适聚拢，性感优雅',
            price: 73.50,
            category: 'fashion',
            variants: [
                { name: '黑色 蕾丝款', price: 73.50 },
                { name: '白色 纯棉款', price: 56.00 },
                { name: '粉色 丝绸款', price: 84.00 }
            ]
        },
        {
            id: 'fashion_042',
            name: '短裤套装',
            description: '时尚短裤+上衣套装，夏季清爽穿搭',
            price: 126.00,
            category: 'fashion',
            variants: [
                { name: '白色 雪纺款', price: 126.00 },
                { name: '粉色 棉麻款', price: 113.50 },
                { name: '蓝色 牛仔款', price: 137.00 }
            ]
        },
        {
            id: 'fashion_043',
            name: '运动内衣',
            description: '高弹面料，无钢圈设计，运动舒适',
            price: 43.50,
            category: 'fashion',
            variants: [
                { name: '黑色 基础款', price: 43.50 },
                { name: '灰色 拼色款', price: 52.00 },
                { name: '粉色 网纱款', price: 56.50 }
            ]
        },
        {
            id: 'fashion_044',
            name: '包臀裙',
            description: '修身包臀设计，展现完美曲线',
            price: 67.50,
            category: 'fashion',
            variants: [
                { name: '黑色 基础款', price: 67.50 },
                { name: '红色 性感款', price: 76.00 },
                { name: '灰色 职业款', price: 72.00 }
            ]
        },
        {
            id: 'fashion_045',
            name: '开衫毛衣',
            description: '温暖开衫设计，百搭实用，秋冬必备',
            price: 134.50,
            category: 'fashion',
            variants: [
                { name: '米色 长款', price: 134.50 },
                { name: '灰色 短款', price: 116.00 },
                { name: '粉色 中长款', price: 147.00 }
            ]
        },
        {
            id: 'fashion_046',
            name: '小白鞋',
            description: '经典小白鞋设计，百搭舒适，青春活力',
            price: 94.00,
            category: 'fashion',
            variants: [
                { name: '纯白 经典款', price: 94.00 },
                { name: '白粉 拼色款', price: 103.50 },
                { name: '白银 亮片款', price: 117.00 }
            ]
        },
        {
            id: 'fashion_047',
            name: '蛋糕裙',
            description: '层层叠叠蛋糕设计，甜美可爱，公主风',
            price: 156.50,
            category: 'fashion',
            variants: [
                { name: '粉色 多层款', price: 156.50 },
                { name: '白色 蕾丝款', price: 173.00 },
                { name: '蓝色 雪纺款', price: 142.00 }
            ]
        },
        {
            id: 'fashion_048',
            name: '羽绒马甲',
            description: '轻薄保暖，无袖设计，层次搭配必备',
            price: 167.00,
            category: 'fashion',
            variants: [
                { name: '黑色 修身款', price: 167.00 },
                { name: '白色 宽松款', price: 143.50 },
                { name: '粉色 短款', price: 184.00 }
            ]
        },
        {
            id: 'fashion_049',
            name: '丝袜套装',
            description: '超薄丝袜，多色可选，优雅必备',
            price: 16.50,
            category: 'fashion',
            variants: [
                { name: '肉色 超薄款 5双', price: 16.50 },
                { name: '黑色 加厚款 3双', price: 13.00 },
                { name: '混色 时尚款 10双', price: 27.00 }
            ]
        },
        {
            id: 'fashion_050',
            name: '手提包',
            description: '时尚手提包，大容量设计，日常必备',
            price: 459.00,
            category: 'fashion',
            variants: [
                { name: '黑色 经典款', price: 459.00 },
                { name: '棕色 复古款', price: 499.00 },
                { name: '粉色 甜美款', price: 429.00 }
            ]
        },
        {
            id: 'fashion_051',
            name: '斜挎包',
            description: '时尚斜挎设计，解放双手，出街必备',
            price: 299.00,
            category: 'fashion',
            variants: [
                { name: '黑色 链条款', price: 299.00 },
                { name: '白色 简约款', price: 279.00 },
                { name: '红色 复古款', price: 329.00 }
            ]
        },
        {
            id: 'fashion_052',
            name: '晚礼服',
            description: '优雅晚礼服，精致刺绣，宴会必备',
            price: 1299.00,
            category: 'fashion',
            variants: [
                { name: '黑色 长款', price: 1299.00 },
                { name: '红色 鱼尾款', price: 1499.00 },
                { name: '蓝色 A字款', price: 1199.00 }
            ]
        },
        {
            id: 'fashion_053',
            name: '瑜伽服套装',
            description: '高弹面料，透气排汗，运动舒适',
            price: 259.00,
            category: 'fashion',
            variants: [
                { name: '黑色 基础款', price: 259.00 },
                { name: '粉色 拼接款', price: 289.00 },
                { name: '灰色 网纱款', price: 319.00 }
            ]
        },
        {
            id: 'fashion_054',
            name: '泳装',
            description: '时尚泳装，防晒面料，海边度假必备',
            price: 199.00,
            category: 'fashion',
            variants: [
                { name: '黑色 比基尼', price: 199.00 },
                { name: '红色 连体款', price: 239.00 },
                { name: '蓝色 分体款', price: 219.00 }
            ]
        },
        {
            id: 'fashion_055',
            name: '睡衣套装',
            description: '柔软睡衣，舒适透气，居家必备',
            price: 199.00,
            category: 'fashion',
            variants: [
                { name: '粉色 丝绸款', price: 199.00 },
                { name: '白色 纯棉款', price: 159.00 },
                { name: '蓝色 法兰绒款', price: 179.00 }
            ]
        },
        {
            id: 'fashion_056',
            name: '半身裙',
            description: '优雅半身裙，多种长度，百搭单品',
            price: 229.00,
            category: 'fashion',
            variants: [
                { name: '黑色 A字款', price: 229.00 },
                { name: '格纹 百褶款', price: 259.00 },
                { name: '牛仔 直筒款', price: 199.00 }
            ]
        },
        {
            id: 'fashion_057',
            name: '棉麻衬衫',
            description: '天然棉麻面料，透气舒适，文艺范十足',
            price: 259.00,
            category: 'fashion',
            variants: [
                { name: '白色 宽松款', price: 259.00 },
                { name: '米色 修身款', price: 279.00 },
                { name: '蓝色 条纹款', price: 299.00 }
            ]
        },
        {
            id: 'fashion_058',
            name: '运动鞋',
            description: '专业运动鞋，缓震透气，运动必备',
            price: 599.00,
            category: 'fashion',
            variants: [
                { name: '白粉 跑步款', price: 599.00 },
                { name: '黑白 训练款', price: 559.00 },
                { name: '彩色 休闲款', price: 639.00 }
            ]
        },
        {
            id: 'fashion_059',
            name: '帆布鞋',
            description: '经典帆布鞋，青春活力，百搭单品',
            price: 199.00,
            category: 'fashion',
            variants: [
                { name: '白色 高帮款', price: 199.00 },
                { name: '黑色 低帮款', price: 179.00 },
                { name: '红色 经典款', price: 219.00 }
            ]
        },
        {
            id: 'fashion_060',
            name: '毛呢短裙',
            description: '温暖毛呢面料，A字版型，秋冬时尚',
            price: 123.00,
            category: 'fashion',
            variants: [
                { name: '灰色 A字款', price: 123.00 },
                { name: '驼色 包臀款', price: 134.50 },
                { name: '黑色 百褶款', price: 116.00 }
            ]
        },

        // === 👶 童装系列 (15款) ===
        {
            id: 'fashion_061',
            name: '儿童连体衣',
            description: '柔软纯棉面料，可爱卡通图案，婴幼儿必备',
            price: 24.50,
            category: 'fashion',
            variants: [
                { name: '粉色 小兔款 0-6月', price: 24.50 },
                { name: '蓝色 小熊款 6-12月', price: 27.00 },
                { name: '黄色 小鸭款 12-18月', price: 31.00 }
            ]
        },
        {
            id: 'fashion_062',
            name: '儿童公主裙',
            description: '蓬蓬纱裙设计，闪亮装饰，小公主最爱',
            price: 56.00,
            category: 'fashion',
            variants: [
                { name: '粉色 蕾丝款 3-5岁', price: 56.00 },
                { name: '紫色 亮片款 5-7岁', price: 63.50 },
                { name: '白色 纱裙款 7-9岁', price: 72.00 }
            ]
        },
        {
            id: 'fashion_063',
            name: '男童西装套装',
            description: '小绅士西装，正式场合必备，帅气十足',
            price: 87.50,
            category: 'fashion',
            variants: [
                { name: '黑色 三件套 3-5岁', price: 87.50 },
                { name: '深蓝色 两件套 5-7岁', price: 73.00 },
                { name: '灰色 马甲套装 7-9岁', price: 96.00 }
            ]
        },
        {
            id: 'fashion_064',
            name: '儿童运动套装',
            description: '舒适运动面料，活泼好动儿童首选',
            price: 43.00,
            category: 'fashion',
            variants: [
                { name: '红色 足球款 3-5岁', price: 43.00 },
                { name: '蓝色 篮球款 5-7岁', price: 52.50 },
                { name: '绿色 网球款 7-9岁', price: 56.00 }
            ]
        },
        {
            id: 'fashion_065',
            name: '儿童牛仔裤',
            description: '弹力牛仔面料，耐磨耐脏，活泼儿童必备',
            price: 34.50,
            category: 'fashion',
            variants: [
                { name: '浅蓝色 直筒款 3-5岁', price: 34.50 },
                { name: '深蓝色 修身款 5-7岁', price: 37.00 },
                { name: '黑色 破洞款 7-9岁', price: 42.00 }
            ]
        },
        {
            id: 'fashion_066',
            name: '儿童羽绒服',
            description: '保暖羽绒填充，防风防寒，冬季必备',
            price: 134.00,
            category: 'fashion',
            variants: [
                { name: '红色 连帽款 3-5岁', price: 134.00 },
                { name: '蓝色 立领款 5-7岁', price: 147.50 },
                { name: '粉色 长款 7-9岁', price: 156.00 }
            ]
        },
        {
            id: 'fashion_067',
            name: '儿童睡衣套装',
            description: '柔软睡衣面料，可爱卡通印花，舒适睡眠',
            price: 27.50,
            category: 'fashion',
            variants: [
                { name: '粉色 独角兽款 3-5岁', price: 27.50 },
                { name: '蓝色 超人款 5-7岁', price: 31.00 },
                { name: '黄色 小熊款 7-9岁', price: 34.00 }
            ]
        },
        {
            id: 'fashion_068',
            name: '儿童毛衣',
            description: '温暖针织毛衣，保暖舒适，秋冬必备',
            price: 43.50,
            category: 'fashion',
            variants: [
                { name: '红色 圆领款 3-5岁', price: 43.50 },
                { name: '蓝色 高领款 5-7岁', price: 47.00 },
                { name: '绿色 开衫款 7-9岁', price: 52.00 }
            ]
        },
        {
            id: 'fashion_069',
            name: '儿童运动鞋',
            description: '透气运动鞋，防滑耐磨，活动必备',
            price: 64.00,
            category: 'fashion',
            variants: [
                { name: '红白 魔术贴款 22-24码', price: 64.00 },
                { name: '蓝白 系带款 25-27码', price: 73.50 },
                { name: '粉白 亮灯款 28-30码', price: 82.00 }
            ]
        },
        {
            id: 'fashion_070',
            name: '儿童雨靴',
            description: '防水雨靴，可爱卡通造型，雨天必备',
            price: 23.50,
            category: 'fashion',
            variants: [
                { name: '黄色 小鸭款 22-24码', price: 23.50 },
                { name: '红色 瓢虫款 25-27码', price: 27.00 },
                { name: '蓝色 鲨鱼款 28-30码', price: 31.00 }
            ]
        },
        {
            id: 'fashion_071',
            name: '亲子装套装',
            description: '温馨亲子装，增进亲子关系，全家出游必备',
            price: 94.50,
            category: 'fashion',
            variants: [
                { name: '白色 T恤款 三件套', price: 94.50 },
                { name: '蓝色 卫衣款 三件套', price: 123.00 },
                { name: '红色 连衣裙款 母女装', price: 107.50 }
            ]
        },
        {
            id: 'fashion_072',
            name: '儿童背包',
            description: '可爱卡通背包，上学必备，轻便实用',
            price: 37.50,
            category: 'fashion',
            variants: [
                { name: '粉色 公主款', price: 37.50 },
                { name: '蓝色 超人款', price: 42.00 },
                { name: '绿色 恐龙款', price: 46.50 }
            ]
        },
        {
            id: 'fashion_073',
            name: '儿童帽子',
            description: '防晒遮阳帽，可爱造型，户外必备',
            price: 16.00,
            category: 'fashion',
            variants: [
                { name: '粉色 蝴蝶结款', price: 16.00 },
                { name: '蓝色 棒球帽款', price: 13.50 },
                { name: '黄色 渔夫帽款', price: 18.50 }
            ]
        },
        {
            id: 'fashion_074',
            name: '儿童袜子套装',
            description: '纯棉袜子，透气舒适，多色可选',
            price: 12.50,
            category: 'fashion',
            variants: [
                { name: '彩色 卡通款 5双装', price: 12.50 },
                { name: '白色 纯色款 10双装', price: 17.00 },
                { name: '条纹 时尚款 8双装', price: 14.50 }
            ]
        },
        {
            id: 'fashion_075',
            name: '儿童泳装',
            description: '防晒泳装，可爱图案，夏日游泳必备',
            price: 27.00,
            category: 'fashion',
            variants: [
                { name: '粉色 美人鱼款 3-5岁', price: 27.00 },
                { name: '蓝色 鲨鱼款 5-7岁', price: 31.50 },
                { name: '黄色 小鸭款 7-9岁', price: 34.00 }
            ]
        },

        // === 💎 配饰系列 (23款) ===
        {
            id: 'fashion_076',
            name: '时尚墨镜',
            description: '防紫外线墨镜，多种镜框设计，装逼必备',
            price: 87.00,
            category: 'fashion',
            variants: [
                { name: '黑色 飞行员款', price: 87.00 },
                { name: '金色 复古圆框', price: 103.50 },
                { name: '银色 运动款', price: 76.00 }
            ]
        },
        {
            id: 'fashion_077',
            name: '时尚眼镜框',
            description: '轻便眼镜框，多色可选，知识分子必备',
            price: 56.50,
            category: 'fashion',
            variants: [
                { name: '黑色 方框款', price: 56.50 },
                { name: '金色 圆框款', price: 64.00 },
                { name: '银色 半框款', price: 47.00 }
            ]
        },
        {
            id: 'fashion_078',
            name: '鸭舌帽',
            description: '时尚鸭舌帽，多种材质和颜色，潮流必备',
            price: 24.00,
            category: 'fashion',
            variants: [
                { name: '黑色 皮质款', price: 24.00 },
                { name: '棕色 绒面款', price: 27.50 },
                { name: '白色 帆布款', price: 21.00 }
            ]
        },
        {
            id: 'fashion_079',
            name: '发卡套装',
            description: '精致发卡，多种款式，女生必备配饰',
            price: 16.50,
            category: 'fashion',
            variants: [
                { name: '珍珠款 10件套', price: 16.50 },
                { name: '水钻款 8件套', price: 23.00 },
                { name: '蝴蝶结款 12件套', price: 13.50 }
            ]
        },
        {
            id: 'fashion_080',
            name: '真皮钱包',
            description: '头层牛皮钱包，多卡位设计，商务必备',
            price: 134.50,
            category: 'fashion',
            variants: [
                { name: '黑色 长款', price: 134.50 },
                { name: '棕色 短款', price: 123.00 },
                { name: '深棕色 折叠款', price: 147.00 }
            ]
        },
        {
            id: 'fashion_081',
            name: '领带套装',
            description: '商务领带，多种图案，正装必备',
            price: 43.00,
            category: 'fashion',
            variants: [
                { name: '深蓝色 条纹款', price: 43.00 },
                { name: '红色 波点款', price: 52.50 },
                { name: '灰色 纯色款', price: 37.00 }
            ]
        },
        {
            id: 'fashion_082',
            name: '项链套装',
            description: '时尚项链，精致工艺，优雅配饰',
            price: 87.50,
            category: 'fashion',
            variants: [
                { name: '金色 锁骨链', price: 87.50 },
                { name: '银色 珍珠链', price: 73.00 },
                { name: '玫瑰金 水晶链', price: 96.00 }
            ]
        },
        {
            id: 'fashion_083',
            name: '耳环套装',
            description: '精致耳环，多种款式，女性魅力必备',
            price: 56.00,
            category: 'fashion',
            variants: [
                { name: '银色 水晶款 5对装', price: 56.00 },
                { name: '金色 珍珠款 3对装', price: 73.50 },
                { name: '玫瑰金 流苏款 4对装', price: 64.00 }
            ]
        },
        {
            id: 'fashion_084',
            name: '手镯套装',
            description: '时尚手镯，精美设计，腕间风情',
            price: 73.50,
            category: 'fashion',
            variants: [
                { name: '银色 简约款', price: 73.50 },
                { name: '金色 编织款', price: 84.00 },
                { name: '玫瑰金 镶钻款', price: 103.00 }
            ]
        },
        {
            id: 'fashion_085',
            name: '戒指套装',
            description: '精致戒指，多种尺寸，指间艺术',
            price: 199.00,
            category: 'fashion',
            variants: [
                { name: '银色 简约款 3件套', price: 199.00 },
                { name: '金色 复古款 5件套', price: 299.00 },
                { name: '玫瑰金 时尚款 4件套', price: 259.00 }
            ]
        },
        {
            id: 'fashion_086',
            name: '时尚手表',
            description: '精致手表，准确计时，品味象征',
            price: 899.00,
            category: 'fashion',
            variants: [
                { name: '黑色 皮质表带', price: 899.00 },
                { name: '银色 钢带款', price: 999.00 },
                { name: '金色 商务款', price: 1299.00 }
            ]
        },
        {
            id: 'fashion_087',
            name: '双肩包',
            description: '时尚双肩包，大容量设计，出行必备',
            price: 359.00,
            category: 'fashion',
            variants: [
                { name: '黑色 商务款', price: 359.00 },
                { name: '灰色 休闲款', price: 329.00 },
                { name: '蓝色 运动款', price: 389.00 }
            ]
        },
        {
            id: 'fashion_088',
            name: '腰包',
            description: '时尚腰包，解放双手，潮流单品',
            price: 199.00,
            category: 'fashion',
            variants: [
                { name: '黑色 皮质款', price: 199.00 },
                { name: '白色 帆布款', price: 159.00 },
                { name: '迷彩 运动款', price: 229.00 }
            ]
        },
        {
            id: 'fashion_089',
            name: '手套套装',
            description: '保暖手套，多种材质，冬季必备',
            price: 99.00,
            category: 'fashion',
            variants: [
                { name: '黑色 皮质款', price: 99.00 },
                { name: '灰色 毛线款', price: 79.00 },
                { name: '棕色 绒面款', price: 119.00 }
            ]
        },
        {
            id: 'fashion_090',
            name: '发带套装',
            description: '时尚发带，多种款式，运动时尚必备',
            price: 39.00,
            category: 'fashion',
            variants: [
                { name: '纯色款 10条装', price: 39.00 },
                { name: '印花款 8条装', price: 49.00 },
                { name: '蕾丝款 6条装', price: 59.00 }
            ]
        },
        {
            id: 'fashion_091',
            name: '胸针套装',
            description: '精致胸针，优雅装饰，品味体现',
            price: 159.00,
            category: 'fashion',
            variants: [
                { name: '花朵款 5件套', price: 159.00 },
                { name: '蝴蝶款 3件套', price: 199.00 },
                { name: '几何款 4件套', price: 179.00 }
            ]
        },
        {
            id: 'fashion_092',
            name: '袖扣套装',
            description: '商务袖扣，精工制作，绅士必备',
            price: 299.00,
            category: 'fashion',
            variants: [
                { name: '银色 经典款', price: 299.00 },
                { name: '金色 商务款', price: 359.00 },
                { name: '黑色 时尚款', price: 279.00 }
            ]
        },
        {
            id: 'fashion_093',
            name: '发夹套装',
            description: '实用发夹，固定发型，日常必备',
            price: 29.00,
            category: 'fashion',
            variants: [
                { name: '黑色 基础款 20个装', price: 29.00 },
                { name: '棕色 隐形款 15个装', price: 39.00 },
                { name: '彩色 装饰款 12个装', price: 49.00 }
            ]
        },
        {
            id: 'fashion_094',
            name: '钥匙扣套装',
            description: '创意钥匙扣，个性装饰，实用礼品',
            price: 59.00,
            category: 'fashion',
            variants: [
                { name: '卡通款 5个装', price: 59.00 },
                { name: '金属款 3个装', price: 79.00 },
                { name: '皮质款 4个装', price: 69.00 }
            ]
        },
        {
            id: 'fashion_095',
            name: '头巾套装',
            description: '时尚头巾，多种系法，优雅配饰',
            price: 129.00,
            category: 'fashion',
            variants: [
                { name: '丝质 印花款', price: 129.00 },
                { name: '棉质 纯色款', price: 99.00 },
                { name: '雪纺 蕾丝款', price: 159.00 }
            ]
        },
        {
            id: 'fashion_096',
            name: '护腕套装',
            description: '运动护腕，吸汗透气，运动必备',
            price: 49.00,
            category: 'fashion',
            variants: [
                { name: '黑色 基础款 2个装', price: 49.00 },
                { name: '白色 运动款 2个装', price: 39.00 },
                { name: '彩色 时尚款 4个装', price: 69.00 }
            ]
        },
        {
            id: 'fashion_097',
            name: '发圈套装',
            description: '弹性发圈，多色可选，扎发必备',
            price: 19.00,
            category: 'fashion',
            variants: [
                { name: '黑色 基础款 50个装', price: 19.00 },
                { name: '彩色 混装 30个装', price: 29.00 },
                { name: '透明 隐形款 20个装', price: 39.00 }
            ]
        },
        {
            id: 'fashion_098',
            name: '时尚胸包',
            description: '潮流胸包，斜挎设计，街头时尚必备',
            price: 259.00,
            category: 'fashion',
            variants: [
                { name: '黑色 皮质款', price: 259.00 },
                { name: '灰色 帆布款', price: 199.00 },
                { name: '迷彩 运动款', price: 289.00 }
            ]
        },
        {
            id: 'sys_003',
            name: '智能扫地机器人',
            description: '全自动清洁机器人，智能规划路径，支持APP远程控制，让您的家居清洁更轻松。配备先进的激光导航系统，能够精确绘制房间地图，智能规避障碍物。具有强大的吸力和多种清洁模式，包括自动模式、局部清洁、边缘清洁等。支持定时预约清洁，可通过手机APP远程操控，实时查看清洁进度。内置大容量电池，续航时间长达120分钟，自动回充功能确保持续工作。适用于各种地面材质，包括瓷砖、木地板、地毯等。',
            price: 1067.00,
            category: 'home'
        },
        {
            id: 'sys_004',
            name: '红富士苹果',
            description: '山东烟台红富士，脆甜多汁，果香浓郁，现摘现发',
            price: 8.80,
            category: 'food',
            variants: [
                { name: '散装 按斤称重', price: 8.80 },
                { name: '精装礼盒 5斤装', price: 49.90 },
                { name: '有机认证 无农药', price: 16.80 }
            ]
        },
        // 🥬 叶菜类蔬菜
        {
            id: 'veg_001',
            name: '小白菜',
            description: '本地农场直供，嫩绿新鲜，清香爽口，当日采摘',
            price: 3.50,
            category: 'food',
            variants: [
                { name: '散装 按斤', price: 3.50 },
                { name: '净菜装 已清洗', price: 4.80 },
                { name: '有机小白菜', price: 6.90 }
            ]
        },
        {
            id: 'veg_002',
            name: '菠菜',
            description: '铁质丰富，叶片肥厚，根部红润，营养价值高',
            price: 4.20,
            category: 'food',
            variants: [
                { name: '本地菠菜 按斤', price: 4.20 },
                { name: '大叶菠菜 精选', price: 5.80 },
                { name: '婴儿菠菜 嫩叶', price: 8.90 }
            ]
        },
        {
            id: 'veg_003',
            name: '生菜',
            description: '脆嫩多汁，适合沙拉凉拌，维生素含量丰富',
            price: 3.80,
            category: 'food',
            variants: [
                { name: '球生菜 1颗装', price: 3.80 },
                { name: '奶油生菜 进口', price: 7.90 },
                { name: '紫叶生菜 彩色', price: 6.50 }
            ]
        },
        {
            id: 'veg_004',
            name: '韭菜',
            description: '头茬韭菜，香味浓郁，叶片宽厚，包饺子首选',
            price: 5.60,
            category: 'food',
            variants: [
                { name: '头茬韭菜 按斤', price: 5.60 },
                { name: '韭菜花 带花苞', price: 8.90 },
                { name: '韭黄 大棚种植', price: 12.80 }
            ]
        },
        {
            id: 'veg_005',
            name: '芹菜',
            description: '本地水芹，茎杆粗壮，叶片翠绿，降压佳品',
            price: 4.50,
            category: 'food',
            variants: [
                { name: '本地芹菜 按斤', price: 4.50 },
                { name: '西芹 进口品种', price: 7.20 },
                { name: '芹菜叶 单独装', price: 2.80 }
            ]
        },
        // 🥕 根茎类蔬菜
        {
            id: 'veg_006',
            name: '胡萝卜',
            description: '沙地胡萝卜，橙红饱满，甜脆可口，维A丰富',
            price: 3.20,
            category: 'food',
            variants: [
                { name: '本地胡萝卜 按斤', price: 3.20 },
                { name: '迷你胡萝卜 进口', price: 8.90 },
                { name: '紫胡萝卜 彩色品种', price: 12.50 }
            ]
        },
        {
            id: 'veg_007',
            name: '白萝卜',
            description: '水分充足，肉质细腻，清热润燥，煲汤必备',
            price: 2.80,
            category: 'food',
            variants: [
                { name: '本地白萝卜 按斤', price: 2.80 },
                { name: '日本白萝卜 进口', price: 9.90 },
                { name: '萝卜丝 切好装', price: 5.50 }
            ]
        },
        {
            id: 'veg_008',
            name: '土豆',
            description: '内蒙古土豆，淀粉含量高，口感绵软，老少皆宜',
            price: 2.50,
            category: 'food',
            variants: [
                { name: '本地土豆 按斤', price: 2.50 },
                { name: '荷兰小土豆 进口', price: 8.90 },
                { name: '紫薯 营养丰富', price: 4.80 }
            ]
        },
        {
            id: 'veg_009',
            name: '红薯',
            description: '烟薯25号，蜜甜如糖，烤制香甜，膳食纤维丰富',
            price: 3.80,
            category: 'food',
            variants: [
                { name: '烟薯25 按斤', price: 3.80 },
                { name: '蜜薯 特甜品种', price: 5.90 },
                { name: '紫薯 花青素丰富', price: 4.50 }
            ]
        },
        // 🥒 瓜果类蔬菜
        {
            id: 'veg_010',
            name: '黄瓜',
            description: '水嫩爽脆，清香怡人，生食凉拌皆宜，美容养颜',
            price: 4.20,
            category: 'food',
            variants: [
                { name: '本地黄瓜 按斤', price: 4.20 },
                { name: '水果黄瓜 迷你', price: 8.90 },
                { name: '荷兰黄瓜 进口', price: 12.80 }
            ]
        },
        {
            id: 'veg_011',
            name: '西红柿',
            description: '自然熟透，酸甜适中，汁多肉厚，维C含量高',
            price: 5.80,
            category: 'food',
            variants: [
                { name: '本地西红柿 按斤', price: 5.80 },
                { name: '圣女果 小番茄', price: 9.90 },
                { name: '黄色番茄 彩色品种', price: 12.50 }
            ]
        },
        {
            id: 'veg_012',
            name: '茄子',
            description: '紫皮茄子，肉质细嫩，吸油性好，红烧凉拌皆美味',
            price: 4.50,
            category: 'food',
            variants: [
                { name: '长茄子 按斤', price: 4.50 },
                { name: '圆茄子 炖菜专用', price: 5.20 },
                { name: '白茄子 清淡品种', price: 7.80 }
            ]
        },
        {
            id: 'veg_013',
            name: '青椒',
            description: '脆嫩多汁，微辣清香，维生素丰富，炒菜配菜佳品',
            price: 6.80,
            category: 'food',
            variants: [
                { name: '本地青椒 按斤', price: 6.80 },
                { name: '彩椒 红黄绿混装', price: 12.90 },
                { name: '尖椒 微辣品种', price: 8.50 }
            ]
        },
        // 🧄 调料类蔬菜
        {
            id: 'veg_014',
            name: '大蒜',
            description: '紫皮大蒜，蒜味浓郁，杀菌消炎，调味必备',
            price: 8.90,
            category: 'food',
            variants: [
                { name: '紫皮蒜 按斤', price: 8.90 },
                { name: '独头蒜 营养丰富', price: 15.80 },
                { name: '蒜苗 嫩绿新鲜', price: 7.50 }
            ]
        },
        {
            id: 'veg_015',
            name: '生姜',
            description: '老姜辛辣，嫩姜清香，去腥调味，温胃散寒',
            price: 12.80,
            category: 'food',
            variants: [
                { name: '老姜 按斤', price: 12.80 },
                { name: '嫩姜 清香微辣', price: 18.90 },
                { name: '小黄姜 山东特产', price: 22.50 }
            ]
        },
        {
            id: 'veg_016',
            name: '大葱',
            description: '山东大葱，葱白粗长，辛香浓郁，北方人最爱',
            price: 4.80,
            category: 'food',
            variants: [
                { name: '山东大葱 按斤', price: 4.80 },
                { name: '小葱 香葱品种', price: 6.50 },
                { name: '葱白 精选部分', price: 8.90 }
            ]
        },
        // 🍎 苹果类水果
        {
            id: 'fruit_001',
            name: '嘎啦苹果',
            description: '早熟品种，果皮红黄相间，肉质细腻，甜脆可口',
            price: 6.80,
            category: 'food',
            variants: [
                { name: '散装 按斤', price: 6.80 },
                { name: '精选大果 礼盒装', price: 39.90 },
                { name: '进口嘎啦 新西兰', price: 18.90 }
            ]
        },
        {
            id: 'fruit_002',
            name: '青苹果',
            description: '澳洲青苹，酸甜平衡，果肉紧实，减肥首选',
            price: 12.80,
            category: 'food',
            variants: [
                { name: '澳洲青苹 按斤', price: 12.80 },
                { name: '有机青苹 无农药', price: 19.90 },
                { name: '迷你青苹 一口一个', price: 15.50 }
            ]
        },
        // 🍊 柑橘类水果
        {
            id: 'fruit_003',
            name: '橙子',
            description: '赣南脐橙，果大皮薄，汁多无籽，维C含量极高',
            price: 7.50,
            category: 'food',
            variants: [
                { name: '赣南脐橙 按斤', price: 7.50 },
                { name: '进口橙子 埃及', price: 15.90 },
                { name: '血橙 红肉品种', price: 12.80 }
            ]
        },
        {
            id: 'fruit_004',
            name: '柚子',
            description: '福建蜜柚，果肉饱满，清香甘甜，降火润燥',
            price: 4.80,
            category: 'food',
            variants: [
                { name: '白心蜜柚 按个', price: 4.80 },
                { name: '红心蜜柚 营养丰富', price: 6.90 },
                { name: '三红蜜柚 顶级品种', price: 12.50 }
            ]
        },
        {
            id: 'fruit_005',
            name: '柠檬',
            description: '安岳柠檬，酸味浓郁，香气清新，泡水美白佳品',
            price: 8.90,
            category: 'food',
            variants: [
                { name: '安岳柠檬 按斤', price: 8.90 },
                { name: '进口柠檬 意大利', price: 18.90 },
                { name: '青柠檬 东南亚', price: 15.50 }
            ]
        },
        // 🍌 热带水果
        {
            id: 'fruit_006',
            name: '香蕉',
            description: '海南香蕉，自然熟透，香甜软糯，钾含量丰富',
            price: 5.20,
            category: 'food',
            variants: [
                { name: '海南香蕉 按斤', price: 5.20 },
                { name: '进口香蕉 菲律宾', price: 8.90 },
                { name: '小米蕉 迷你品种', price: 12.80 }
            ]
        },
        {
            id: 'fruit_007',
            name: '榴莲',
            description: '泰国金枕榴莲，果肉厚实，奶香浓郁，水果之王',
            price: 35.80,
            category: 'food',
            variants: [
                { name: '泰国榴莲 按斤', price: 35.80 },
                { name: '金枕榴莲 顶级品质', price: 48.90 },
                { name: '猫山王榴莲 马来西亚', price: 88.00 }
            ]
        },
        {
            id: 'fruit_008',
            name: '芒果',
            description: '海南贵妃芒，果肉细腻，香甜如蜜，核小肉多',
            price: 12.80,
            category: 'food',
            variants: [
                { name: '贵妃芒 按斤', price: 12.80 },
                { name: '台农芒果 台湾品种', price: 18.90 },
                { name: '进口芒果 泰国', price: 25.50 }
            ]
        },
        {
            id: 'fruit_009',
            name: '菠萝',
            description: '海南金钻菠萝，酸甜适中，果香浓郁，助消化佳品',
            price: 6.80,
            category: 'food',
            variants: [
                { name: '海南菠萝 按个', price: 6.80 },
                { name: '金钻菠萝 免削皮', price: 12.90 },
                { name: '进口菠萝 菲律宾', price: 18.50 }
            ]
        },
        // 🍇 浆果类水果
        {
            id: 'fruit_010',
            name: '葡萄',
            description: '新疆马奶葡萄，颗粒饱满，皮薄肉厚，清甜多汁',
            price: 9.80,
            category: 'food',
            variants: [
                { name: '马奶葡萄 按斤', price: 9.80 },
                { name: '巨峰葡萄 大粒品种', price: 15.90 },
                { name: '进口葡萄 智利', price: 28.90 }
            ]
        },
        {
            id: 'fruit_011',
            name: '草莓',
            description: '丹东草莓，鲜红诱人，香甜可口，维C含量极高',
            price: 18.90,
            category: 'food',
            variants: [
                { name: '丹东草莓 按斤', price: 18.90 },
                { name: '奶油草莓 日本品种', price: 35.90 },
                { name: '有机草莓 无农药', price: 45.00 }
            ]
        },
        {
            id: 'fruit_012',
            name: '蓝莓',
            description: '大兴安岭野生蓝莓，花青素丰富，护眼抗氧化',
            price: 25.80,
            category: 'food',
            variants: [
                { name: '国产蓝莓 125g装', price: 25.80 },
                { name: '进口蓝莓 智利', price: 39.90 },
                { name: '有机蓝莓 无农药', price: 55.00 }
            ]
        },
        // 🍑 核果类水果
        {
            id: 'fruit_013',
            name: '桃子',
            description: '山东水蜜桃，果肉鲜美，汁多甜腻，夏日消暑佳品',
            price: 8.50,
            category: 'food',
            variants: [
                { name: '水蜜桃 按斤', price: 8.50 },
                { name: '黄桃 罐头专用', price: 6.80 },
                { name: '油桃 脆甜品种', price: 12.90 }
            ]
        },
        {
            id: 'fruit_014',
            name: '樱桃',
            description: '大连樱桃，色泽鲜艳，肉质饱满，酸甜可口',
            price: 35.00,
            category: 'food',
            variants: [
                { name: '大连樱桃 按斤', price: 35.00 },
                { name: '进口车厘子 智利', price: 68.90 },
                { name: '有机樱桃 无农药', price: 88.00 }
            ]
        },
        {
            id: 'fruit_015',
            name: '李子',
            description: '三华李，果皮紫红，肉质脆嫩，酸甜开胃',
            price: 7.80,
            category: 'food',
            variants: [
                { name: '三华李 按斤', price: 7.80 },
                { name: '黑布林 进口品种', price: 15.90 },
                { name: '青脆李 爽脆酸甜', price: 9.50 }
            ]
        },
        // 🍈 瓜类水果
        {
            id: 'fruit_016',
            name: '西瓜',
            description: '新疆8424西瓜，皮薄肉红，汁多甜脆，消暑解渴',
            price: 3.20,
            category: 'food',
            variants: [
                { name: '8424西瓜 按斤', price: 3.20 },
                { name: '无籽西瓜 方便食用', price: 4.50 },
                { name: '黄瓤西瓜 特色品种', price: 5.80 }
            ]
        },
        {
            id: 'fruit_017',
            name: '哈密瓜',
            description: '新疆哈密瓜，香甜如蜜，果肉厚实，网纹清晰',
            price: 8.90,
            category: 'food',
            variants: [
                { name: '新疆哈密瓜 按斤', price: 8.90 },
                { name: '网纹瓜 日本品种', price: 25.90 },
                { name: '小哈密瓜 迷你装', price: 15.50 }
            ]
        },
        {
            id: 'fruit_018',
            name: '香瓜',
            description: '本地香瓜，清香甘甜，水分充足，价格亲民',
            price: 4.50,
            category: 'food',
            variants: [
                { name: '本地香瓜 按斤', price: 4.50 },
                { name: '白皮香瓜 清甜品种', price: 6.80 },
                { name: '黄皮香瓜 香味浓郁', price: 5.90 }
            ]
        },
        // 🌰 坚果类
        {
            id: 'fruit_019',
            name: '山楂',
            description: '北京山楂，酸甜开胃，助消化，制作山楂糕的好原料',
            price: 6.50,
            category: 'food',
            variants: [
                { name: '新鲜山楂 按斤', price: 6.50 },
                { name: '大山楂 精选大果', price: 9.80 },
                { name: '糖葫芦专用 小果', price: 5.20 }
            ]
        },
        {
            id: 'fruit_020',
            name: '海棠果',
            description: '迷你海棠果，酸甜可口，颜值很高，适合做果脯',
            price: 8.80,
            category: 'food',
            variants: [
                { name: '新鲜海棠果 按斤', price: 8.80 },
                { name: '红海棠 颜色鲜艳', price: 12.50 },
                { name: '黄海棠 清香品种', price: 10.90 }
            ]
        },
        // 🥝 特色水果
        {
            id: 'fruit_021',
            name: '猕猴桃',
            description: '陕西徐香猕猴桃，果肉翠绿，酸甜适中，维C之王',
            price: 12.80,
            category: 'food',
            variants: [
                { name: '徐香猕猴桃 按斤', price: 12.80 },
                { name: '红心猕猴桃 营养丰富', price: 18.90 },
                { name: '进口奇异果 新西兰', price: 25.50 }
            ]
        },
        {
            id: 'fruit_022',
            name: '火龙果',
            description: '越南火龙果，果肉清甜，籽粒丰富，美容养颜',
            price: 9.80,
            category: 'food',
            variants: [
                { name: '白心火龙果 按个', price: 9.80 },
                { name: '红心火龙果 营养更丰富', price: 15.90 },
                { name: '黄皮火龙果 稀有品种', price: 28.90 }
            ]
        },
        {
            id: 'fruit_023',
            name: '牛油果',
            description: '墨西哥牛油果，营养丰富，口感顺滑，健身必备',
            price: 8.90,
            category: 'food',
            variants: [
                { name: '墨西哥牛油果 按个', price: 8.90 },
                { name: '有机牛油果 无农药', price: 15.50 },
                { name: '即食牛油果 软熟', price: 12.80 }
            ]
        },
        // 🥬 更多叶菜类
        {
            id: 'veg_017',
            name: '菜心',
            description: '广东菜心，嫩绿清香，爽脆甘甜，粤菜经典',
            price: 6.80,
            category: 'food',
            variants: [
                { name: '本地菜心 按斤', price: 6.80 },
                { name: '有机菜心 无农药', price: 9.90 },
                { name: '精装菜心 净菜装', price: 8.50 }
            ]
        },
        {
            id: 'veg_018',
            name: '油麦菜',
            description: '脆嫩多汁，略带苦味，清热解毒，凉拌炒制皆宜',
            price: 4.80,
            category: 'food',
            variants: [
                { name: '本地油麦菜 按斤', price: 4.80 },
                { name: '有机油麦菜', price: 7.50 },
                { name: '净菜装 已清洗', price: 6.20 }
            ]
        },
        {
            id: 'veg_019',
            name: '娃娃菜',
            description: '迷你大白菜，口感鲜嫩，营养丰富，一人一颗刚好',
            price: 5.90,
            category: 'food',
            variants: [
                { name: '娃娃菜 4颗装', price: 5.90 },
                { name: '有机娃娃菜 6颗装', price: 12.80 },
                { name: '迷你娃娃菜 8颗装', price: 8.50 }
            ]
        },
        // 🍄 菌菇类
        {
            id: 'veg_020',
            name: '平菇',
            description: '新鲜平菇，肉质肥厚，口感鲜美，蛋白质丰富',
            price: 7.80,
            category: 'food',
            variants: [
                { name: '本地平菇 按斤', price: 7.80 },
                { name: '有机平菇 无添加', price: 12.50 },
                { name: '袋装平菇 250g', price: 4.90 }
            ]
        },
        {
            id: 'veg_021',
            name: '香菇',
            description: '花菇香菇，菌盖厚实，香味浓郁，营养价值极高',
            price: 15.80,
            category: 'food',
            variants: [
                { name: '普通香菇 按斤', price: 15.80 },
                { name: '花菇 精选大朵', price: 28.90 },
                { name: '有机香菇 无农药', price: 35.00 }
            ]
        },
        {
            id: 'veg_022',
            name: '金针菇',
            description: '白嫩金针菇，口感爽滑，火锅必备，增强免疫力',
            price: 6.50,
            category: 'food',
            variants: [
                { name: '袋装金针菇 150g', price: 6.50 },
                { name: '有机金针菇 200g', price: 9.80 },
                { name: '家庭装 3袋装', price: 18.00 }
            ]
        },
        // 🌶️ 辣椒类
        {
            id: 'veg_023',
            name: '小米椒',
            description: '云南小米椒，个小辣度高，香辣开胃，调味佳品',
            price: 18.90,
            category: 'food',
            variants: [
                { name: '新鲜小米椒 按斤', price: 18.90 },
                { name: '干小米椒 晒干装', price: 35.00 },
                { name: '腌制小米椒 即食', price: 25.50 }
            ]
        },
        {
            id: 'veg_024',
            name: '朝天椒',
            description: '河南朝天椒，辣味纯正，色泽鲜红，制作辣椒油首选',
            price: 12.80,
            category: 'food',
            variants: [
                { name: '新鲜朝天椒 按斤', price: 12.80 },
                { name: '干朝天椒 制油专用', price: 28.90 },
                { name: '朝天椒粉 研磨装', price: 15.50 }
            ]
        },
        // 🥒 更多瓜果类
        {
            id: 'veg_025',
            name: '丝瓜',
            description: '嫩丝瓜，清香甘甜，去皮炒制，清热解毒',
            price: 5.20,
            category: 'food',
            variants: [
                { name: '嫩丝瓜 按斤', price: 5.20 },
                { name: '有机丝瓜 无农药', price: 8.90 },
                { name: '老丝瓜 制丝瓜络', price: 3.50 }
            ]
        },
        {
            id: 'veg_026',
            name: '冬瓜',
            description: '本地冬瓜，肉厚汁多，清热利水，煲汤炖菜佳品',
            price: 1.80,
            category: 'food',
            variants: [
                { name: '本地冬瓜 按斤', price: 1.80 },
                { name: '小冬瓜 2-3斤装', price: 4.50 },
                { name: '冬瓜条 切好装', price: 3.20 }
            ]
        },
        // 🍓 更多浆果类
        {
            id: 'fruit_024',
            name: '黑莓',
            description: '进口黑莓，酸甜可口，花青素含量极高，抗氧化佳品',
            price: 35.90,
            category: 'food',
            variants: [
                { name: '进口黑莓 125g装', price: 35.90 },
                { name: '有机黑莓 无农药', price: 48.00 },
                { name: '冷冻黑莓 500g装', price: 25.80 }
            ]
        },
        {
            id: 'fruit_025',
            name: '覆盆子',
            description: '树莓覆盆子，酸甜清香，维生素丰富，美容养颜',
            price: 42.00,
            category: 'food',
            variants: [
                { name: '新鲜覆盆子 125g', price: 42.00 },
                { name: '冷冻覆盆子 300g', price: 28.90 },
                { name: '有机覆盆子 精装', price: 58.00 }
            ]
        },
        // 🍊 更多柑橘类
        {
            id: 'fruit_026',
            name: '砂糖橘',
            description: '广西砂糖橘，皮薄易剥，汁多无籽，甜如砂糖',
            price: 8.90,
            category: 'food',
            variants: [
                { name: '砂糖橘 按斤', price: 8.90 },
                { name: '精装礼盒 3斤装', price: 29.90 },
                { name: '有机砂糖橘', price: 15.50 }
            ]
        },
        {
            id: 'fruit_027',
            name: '金桔',
            description: '海南金桔，果小皮薄，酸甜可口，可连皮食用',
            price: 12.80,
            category: 'food',
            variants: [
                { name: '海南金桔 按斤', price: 12.80 },
                { name: '蜜饯金桔 腌制装', price: 18.90 },
                { name: '有机金桔 无农药', price: 19.50 }
            ]
        },
        // 🥭 更多热带水果
        {
            id: 'fruit_028',
            name: '椰子',
            description: '海南椰子，椰汁清甜，椰肉香滑，天然饮品',
            price: 12.00,
            category: 'food',
            variants: [
                { name: '青椰子 按个', price: 12.00 },
                { name: '老椰子 椰肉厚实', price: 8.90 },
                { name: '椰子水 瓶装500ml', price: 15.50 }
            ]
        },
        {
            id: 'fruit_029',
            name: '百香果',
            description: '广西百香果，香味浓郁，酸甜开胃，泡水制饮佳品',
            price: 15.80,
            category: 'food',
            variants: [
                { name: '百香果 按斤', price: 15.80 },
                { name: '大果百香果 精选', price: 22.90 },
                { name: '百香果浆 瓶装', price: 18.50 }
            ]
        },
        {
            id: 'fruit_030',
            name: '莲雾',
            description: '台湾莲雾，水分充足，清甜爽脆，颜值很高',
            price: 25.90,
            category: 'food',
            variants: [
                { name: '台湾莲雾 按斤', price: 25.90 },
                { name: '黑珍珠莲雾 顶级', price: 45.00 },
                { name: '有机莲雾 无农药', price: 38.90 }
            ]
        },
        // 🍇 更多葡萄类
        {
            id: 'fruit_031',
            name: '提子',
            description: '新疆红提，颗粒饱满，皮薄肉厚，甜度极高',
            price: 12.80,
            category: 'food',
            variants: [
                { name: '新疆红提 按斤', price: 12.80 },
                { name: '进口红提 智利', price: 25.90 },
                { name: '有机红提 无农药', price: 22.50 }
            ]
        },
        // 🥥 坚果干果类
        {
            id: 'fruit_032',
            name: '板栗',
            description: '河北板栗，颗粒饱满，香甜粉糯，秋季时令',
            price: 12.50,
            category: 'food',
            variants: [
                { name: '生板栗 按斤', price: 12.50 },
                { name: '糖炒栗子 熟制', price: 18.90 },
                { name: '有机板栗 无农药', price: 18.50 }
            ]
        },
        {
            id: 'fruit_033',
            name: '柿子',
            description: '陕西火晶柿子，软糯香甜，营养丰富，秋季美味',
            price: 9.80,
            category: 'food',
            variants: [
                { name: '软柿子 按斤', price: 9.80 },
                { name: '脆柿子 爽脆品种', price: 12.50 },
                { name: '柿饼 晒干装', price: 25.90 }
            ]
        },
        // 🍋 更多特色水果
        {
            id: 'fruit_034',
            name: '杨桃',
            description: '海南杨桃，五角星形，酸甜清香，维C丰富',
            price: 8.90,
            category: 'food',
            variants: [
                { name: '海南杨桃 按斤', price: 8.90 },
                { name: '甜杨桃 精选品种', price: 15.50 },
                { name: '有机杨桃 无农药', price: 18.90 }
            ]
        },
        {
            id: 'fruit_035',
            name: '石榴',
            description: '新疆石榴，籽粒饱满，酸甜多汁，美容抗衰老',
            price: 15.80,
            category: 'food',
            variants: [
                { name: '新疆石榴 按个', price: 15.80 },
                { name: '软籽石榴 易食用', price: 25.90 },
                { name: '有机石榴 无农药', price: 32.00 }
            ]
        },
        {
            id: 'fruit_036',
            name: '无花果',
            description: '新疆无花果，果肉香甜，营养丰富，润肺止咳',
            price: 22.80,
            category: 'food',
            variants: [
                { name: '新鲜无花果 按斤', price: 22.80 },
                { name: '无花果干 晒干装', price: 35.90 },
                { name: '有机无花果 无农药', price: 38.00 }
            ]
        },
        // 🥬 最后3种蔬果
        {
            id: 'veg_027',
            name: '豆角',
            description: '嫩豆角，翠绿饱满，口感脆嫩，富含膳食纤维',
            price: 6.80,
            category: 'food',
            variants: [
                { name: '嫩豆角 按斤', price: 6.80 },
                { name: '有机豆角 无农药', price: 9.90 },
                { name: '四季豆 精选品种', price: 8.50 }
            ]
        },
        {
            id: 'fruit_037',
            name: '荔枝',
            description: '广东荔枝，果肉晶莹，甜美多汁，一骑红尘妃子笑',
            price: 18.90,
            category: 'food',
            variants: [
                { name: '妃子笑荔枝 按斤', price: 18.90 },
                { name: '桂味荔枝 香甜品种', price: 25.90 },
                { name: '糯米糍荔枝 顶级', price: 35.00 }
            ]
        },
        {
            id: 'fruit_038',
            name: '龙眼',
            description: '福建龙眼，果肉透明，甘甜如蜜，滋补养颜佳品',
            price: 12.80,
            category: 'food',
            variants: [
                { name: '新鲜龙眼 按斤', price: 12.80 },
                { name: '桂圆干 晒干装', price: 28.90 },
                { name: '有机龙眼 无农药', price: 18.50 }
            ]
        },
        
        // 🍿 零食分类商品 - 40种丰富零食
        
        // 🥔 薯片膨化类 (8种)
        {
            id: 'snack_001',
            name: '乐事薯片',
            description: '金黄薯片，酥脆爽口，聚会分享好选择',
            price: 4.50,
            category: 'snacks',
            variants: [
                { name: '原味 袋装', price: 4.50 },
                { name: '黄瓜味 清香', price: 4.50 },
                { name: '番茄味 酸甜', price: 4.80 }
            ]
        },
        {
            id: 'snack_002',
            name: '品客薯片',
            description: '罐装薯片，层次丰富，办公室零食',
            price: 9.90,
            category: 'snacks',
            variants: [
                { name: '原味 罐装', price: 9.90 },
                { name: '酸奶洋葱味', price: 9.90 },
                { name: '芝士味 浓郁', price: 10.50 }
            ]
        },
        {
            id: 'snack_003',
            name: '上好佳',
            description: '菲律宾进口，香脆美味，童年回忆',
            price: 3.50,
            category: 'snacks',
            variants: [
                { name: '鲜虾条 Q弹', price: 3.50 },
                { name: '玉米棒 香甜', price: 3.50 },
                { name: '洋葱圈 酥脆', price: 3.80 }
            ]
        },
        {
            id: 'snack_004',
            name: '可比克薯片',
            description: '国产薯片，性价比高，口味多样',
            price: 2.50,
            category: 'snacks',
            variants: [
                { name: '番茄味 酸甜', price: 2.50 },
                { name: '烧烤味 香辣', price: 2.50 },
                { name: '海苔味 清香', price: 2.80 }
            ]
        },
        {
            id: 'snack_005',
            name: '薯愿',
            description: '韩国风味，蜂蜜黄油，香甜酥脆',
            price: 4.50,
            category: 'snacks',
            variants: [
                { name: '蜂蜜黄油味', price: 4.50 },
                { name: '芝士味 浓香', price: 4.50 },
                { name: '海苔味 韩式', price: 4.80 }
            ]
        },
        {
            id: 'snack_006',
            name: '薯片三兄弟',
            description: '北海道特产，酥脆香甜，日本人气',
            price: 12.80,
            category: 'snacks',
            variants: [
                { name: '原味 北海道', price: 12.80 },
                { name: '芝士味 限定', price: 15.90 },
                { name: '海盐味 清淡', price: 13.50 }
            ]
        },
        {
            id: 'snack_007',
            name: '虾条',
            description: '鲜虾味膨化食品，入口即化，儿童最爱',
            price: 2.00,
            category: 'snacks',
            variants: [
                { name: '鲜虾味 香脆', price: 2.00 },
                { name: '蟹黄味 鲜美', price: 2.50 },
                { name: '芝士虾条 浓郁', price: 3.00 }
            ]
        },
        {
            id: 'snack_008',
            name: '爆米花',
            description: '香甜爆米花，看电影必备，多种口味',
            price: 6.50,
            category: 'snacks',
            variants: [
                { name: '焦糖味 香甜', price: 6.50 },
                { name: '奶油味 浓郁', price: 6.50 },
                { name: '巧克力味 丝滑', price: 7.50 }
            ]
        },
        
        // 🥤 饮料类 (6种)
        {
            id: 'snack_009',
            name: 'AD钙奶',
            description: '哇哈哈出品，补充维生素，酸甜可口',
            price: 1.80,
            category: 'snacks',
            variants: [
                { name: '单瓶装 便携', price: 1.80 },
                { name: '四联包 家庭', price: 6.80 },
                { name: '整箱装 实惠', price: 39.90 }
            ]
        },
        {
            id: 'snack_010',
            name: '旺仔牛奶',
            description: '香浓牛奶饮品，营养丰富，老少皆宜',
            price: 2.50,
            category: 'snacks',
            variants: [
                { name: '单罐装 便携', price: 2.50 },
                { name: '六连包 分享', price: 14.90 },
                { name: '小罐装 迷你', price: 1.50 }
            ]
        },
        {
            id: 'snack_011',
            name: '营养快线',
            description: '复合蛋白饮品，15种营养，早餐搭配',
            price: 3.50,
            category: 'snacks',
            variants: [
                { name: '原味 营养', price: 3.50 },
                { name: '草莓味 香甜', price: 3.50 },
                { name: '香蕉味 浓郁', price: 3.80 }
            ]
        },
        {
            id: 'snack_012',
            name: '绿茶',
            description: '康师傅绿茶，清香解腻，清热降火',
            price: 2.50,
            category: 'snacks',
            variants: [
                { name: '清香绿茶 淡雅', price: 2.50 },
                { name: '茉莉花茶 芬芳', price: 2.50 },
                { name: '大瓶装 实惠', price: 4.50 }
            ]
        },
        {
            id: 'snack_013',
            name: '雪碧',
            description: '柠檬味汽水，清爽解腻，夏日必备',
            price: 2.80,
            category: 'snacks',
            variants: [
                { name: '易拉罐装 冰爽', price: 2.80 },
                { name: '塑料瓶装 便携', price: 3.20 },
                { name: '大瓶装 家庭', price: 5.50 }
            ]
        },
        {
            id: 'snack_014',
            name: '红牛',
            description: '能量饮料，提神醒脑，缓解疲劳',
            price: 5.50,
            category: 'snacks',
            variants: [
                { name: '提神装 单罐', price: 5.50 },
                { name: '四连包 办公', price: 21.90 },
                { name: '大罐装 加强', price: 7.50 }
            ]
        },
        
        // 🍭 糖果类 (6种)
        {
            id: 'snack_015',
            name: '大白兔奶糖',
            description: '国产奶糖，浓郁奶香，童年回忆',
            price: 6.50,
            category: 'snacks',
            variants: [
                { name: '怀旧装 回忆', price: 6.50 },
                { name: '大包装 分享', price: 12.80 },
                { name: '礼盒装 送礼', price: 22.90 }
            ]
        },
        {
            id: 'snack_016',
            name: '棒棒糖',
            description: '阿尔卑斯棒棒糖，多种水果口味',
            price: 0.50,
            category: 'snacks',
            variants: [
                { name: '草莓味 单支', price: 0.50 },
                { name: '橙子味 单支', price: 0.50 },
                { name: '混合装 多口味', price: 25.00 }
            ]
        },
        {
            id: 'snack_017',
            name: '酥心糖',
            description: '徐福记酥心糖，入口即化，甜而不腻',
            price: 9.50,
            category: 'snacks',
            variants: [
                { name: '原味 传统', price: 9.50 },
                { name: '花生味 香脆', price: 10.50 },
                { name: '芝麻味 浓香', price: 11.20 }
            ]
        },
        {
            id: 'snack_018',
            name: '跳跳糖',
            description: '趣味糖果，入口会跳动，儿童最爱',
            price: 1.00,
            category: 'snacks',
            variants: [
                { name: '草莓味 有趣', price: 1.00 },
                { name: '可乐味 刺激', price: 1.00 },
                { name: '混合装 多味', price: 9.80 }
            ]
        },
        {
            id: 'snack_019',
            name: '彩虹糖',
            description: '彩色软糖，酸甜口感，多种水果味',
            price: 3.50,
            category: 'snacks',
            variants: [
                { name: '原味 彩色', price: 3.50 },
                { name: '酸味 刺激', price: 3.50 },
                { name: '热带味 异域', price: 3.80 }
            ]
        },
        {
            id: 'snack_020',
            name: '口香糖',
            description: '清新口气，多种薄荷口味，便携装',
            price: 2.50,
            category: 'snacks',
            variants: [
                { name: '薄荷味 清新', price: 2.50 },
                { name: '西瓜味 香甜', price: 2.50 },
                { name: '无糖装 健康', price: 3.50 }
            ]
        },
        
        // 🍪 饼干类 (5种)
        {
            id: 'snack_021',
            name: '奥利奥',
            description: '夹心饼干，香草奶油夹心，可拆可泡',
            price: 5.50,
            category: 'snacks',
            variants: [
                { name: '原味 黑白', price: 5.50 },
                { name: '草莓味 粉嫩', price: 5.50 },
                { name: '抹茶味 清香', price: 6.20 }
            ]
        },
        {
            id: 'snack_022',
            name: '趣多多',
            description: '巧克力豆曲奇，香脆可口，巧克力丰富',
            price: 7.50,
            category: 'snacks',
            variants: [
                { name: '巧克力豆 香脆', price: 7.50 },
                { name: '燕麦葡萄干 健康', price: 7.50 },
                { name: '双倍巧克力 浓郁', price: 8.50 }
            ]
        },
        {
            id: 'snack_023',
            name: '苏打饼干',
            description: '酥脆咸香，搭配牛奶，早餐好选择',
            price: 4.50,
            category: 'snacks',
            variants: [
                { name: '原味 朴素', price: 4.50 },
                { name: '芝麻味 香脆', price: 5.20 },
                { name: '海苔味 鲜美', price: 5.80 }
            ]
        },
        {
            id: 'snack_024',
            name: '威化饼干',
            description: '多层威化，奶油夹心，入口即化',
            price: 4.80,
            category: 'snacks',
            variants: [
                { name: '香草味 淡雅', price: 4.80 },
                { name: '巧克力味 浓郁', price: 4.80 },
                { name: '草莓味 香甜', price: 5.20 }
            ]
        },
        {
            id: 'snack_025',
            name: '消化饼干',
            description: '全麦饼干，粗纤维丰富，健康零食',
            price: 6.50,
            category: 'snacks',
            variants: [
                { name: '原味 健康', price: 6.50 },
                { name: '燕麦味 粗纤维', price: 7.20 },
                { name: '无糖装 低卡', price: 9.80 }
            ]
        },
        
        // 🥜 坚果类 (5种)
        {
            id: 'snack_026',
            name: '每日坚果',
            description: '三只松鼠坚果，营养丰富，办公室首选',
            price: 19.90,
            category: 'snacks',
            variants: [
                { name: '营养搭配 均衡', price: 19.90 },
                { name: '混合坚果 丰富', price: 35.80 },
                { name: '开心果 高端', price: 28.90 }
            ]
        },
        {
            id: 'snack_027',
            name: '瓜子',
            description: '香瓜子，多种口味，休闲娱乐必备',
            price: 8.80,
            category: 'snacks',
            variants: [
                { name: '五香瓜子 传统', price: 8.80 },
                { name: '焦糖瓜子 香甜', price: 9.50 },
                { name: '山核桃味 高端', price: 12.80 }
            ]
        },
        {
            id: 'snack_028',
            name: '花生米',
            description: '酥脆花生米，下酒好菜，营养丰富',
            price: 12.50,
            category: 'snacks',
            variants: [
                { name: '五香花生 下酒', price: 12.50 },
                { name: '蒜香花生 浓郁', price: 13.80 },
                { name: '酒鬼花生 过瘾', price: 15.90 }
            ]
        },
        {
            id: 'snack_029',
            name: '核桃',
            description: '新疆核桃，补脑益智，天然营养',
            price: 25.90,
            category: 'snacks',
            variants: [
                { name: '薄皮核桃 易剥', price: 25.90 },
                { name: '琥珀核桃 香甜', price: 32.80 },
                { name: '蜂蜜核桃 滋补', price: 35.00 }
            ]
        },
        {
            id: 'snack_030',
            name: '腰果',
            description: '越南腰果，香脆可口，高端坚果',
            price: 32.80,
            category: 'snacks',
            variants: [
                { name: '原味腰果 天然', price: 32.80 },
                { name: '盐焗腰果 香咸', price: 35.90 },
                { name: '蜂蜜腰果 香甜', price: 38.00 }
            ]
        },
        
        // 🍢 火锅料类 (5种)
        {
            id: 'snack_031',
            name: '火锅丸子',
            description: '各种火锅丸子，Q弹有嚼劲，火锅必备',
            price: 9.80,
            category: 'snacks',
            variants: [
                { name: '鱼丸 Q弹', price: 9.80 },
                { name: '牛肉丸 鲜美', price: 14.90 },
                { name: '综合丸子 丰富', price: 12.50 }
            ]
        },
        {
            id: 'snack_032',
            name: '火锅底料',
            description: '川味火锅底料，麻辣鲜香，在家享火锅',
            price: 12.90,
            category: 'snacks',
            variants: [
                { name: '麻辣味 正宗', price: 12.90 },
                { name: '清汤味 清淡', price: 9.80 },
                { name: '番茄味 酸甜', price: 10.50 }
            ]
        },
        {
            id: 'snack_033',
            name: '午餐肉',
            description: '罐装午餐肉，火锅涮肉好选择',
            price: 10.80,
            category: 'snacks',
            variants: [
                { name: '罐装 传统', price: 10.80 },
                { name: '低脂装 健康', price: 12.90 },
                { name: '黑椒味 香辣', price: 13.50 }
            ]
        },
        {
            id: 'snack_034',
            name: '火锅年糕',
            description: '韩式年糕条，Q弹有嚼劲，火锅好伴侣',
            price: 7.50,
            category: 'snacks',
            variants: [
                { name: '条状年糕 Q弹', price: 7.50 },
                { name: '片状年糕 方便', price: 7.50 },
                { name: '彩色年糕 好看', price: 9.80 }
            ]
        },
        {
            id: 'snack_035',
            name: '火锅粉条',
            description: '红薯粉条，久煮不烂，吸汁入味',
            price: 5.50,
            category: 'snacks',
            variants: [
                { name: '红薯粉条 Q弹', price: 5.50 },
                { name: '土豆粉条 爽滑', price: 4.80 },
                { name: '宽粉 吸汁', price: 6.50 }
            ]
        },
        
        // 🍘 传统零食 (5种)
        {
            id: 'snack_036',
            name: '辣条',
            description: '香辣过瘾，80后90后回忆，童年味道',
            price: 1.50,
            category: 'snacks',
            variants: [
                { name: '卫龙辣条 正宗', price: 1.50 },
                { name: '面筋辣条 劲道', price: 3.50 },
                { name: '大面筋 过瘾', price: 6.50 }
            ]
        },
        {
            id: 'snack_037',
            name: '山楂片',
            description: '酸甜山楂片，开胃消食，传统零食',
            price: 4.50,
            category: 'snacks',
            variants: [
                { name: '山楂片 酸甜', price: 4.50 },
                { name: '无糖山楂片 健康', price: 6.50 },
                { name: '山楂卷 软糯', price: 5.50 }
            ]
        },
        {
            id: 'snack_038',
            name: '话梅',
            description: '酸甜话梅，生津止渴，传统蜜饯',
            price: 7.50,
            category: 'snacks',
            variants: [
                { name: '九制话梅 传统', price: 7.50 },
                { name: '无核话梅 方便', price: 9.50 },
                { name: '陈皮话梅 清香', price: 10.80 }
            ]
        },
        {
            id: 'snack_039',
            name: '牛肉干',
            description: '内蒙古牛肉干，劲道有嚼劲，高蛋白',
            price: 25.90,
            category: 'snacks',
            variants: [
                { name: '原味牛肉干 纯正', price: 25.90 },
                { name: '五香牛肉干 香料', price: 25.90 },
                { name: '麻辣牛肉干 刺激', price: 28.80 }
            ]
        },
        {
            id: 'snack_040',
            name: '豆腐干',
            description: '香辣豆腐干，Q弹有嚼劲，素食零食',
            price: 3.50,
            category: 'snacks',
            variants: [
                { name: '香辣豆腐干 下饭', price: 3.50 },
                { name: '五香豆腐干 传统', price: 3.50 },
                { name: '烟熏豆腐干 特色', price: 4.20 }
            ]
        },
        
        // 🥩 生鲜分类商品 - 20种优质生鲜
        
        // 🐄 牛肉类 (4种)
        {
            id: 'fresh_001',
            name: '黄牛肉',
            description: '优质黄牛肉，肉质鲜嫩，蛋白质丰富，适合炖煮',
            price: 68.00,
            category: 'fresh',
            variants: [
                { name: '500g 前腿肉', price: 68.00 },
                { name: '500g 后腿肉', price: 72.00 },
                { name: '500g 腱子肉', price: 75.00 }
            ]
        },
        {
            id: 'fresh_002',
            name: '牛腩',
            description: '带筋牛腩，炖煮软烂，胶原蛋白丰富，煲汤首选',
            price: 58.00,
            category: 'fresh',
            variants: [
                { name: '500g 块状', price: 58.00 },
                { name: '500g 条状', price: 60.00 },
                { name: '500g 丁状', price: 62.00 }
            ]
        },
        {
            id: 'fresh_003',
            name: '牛排',
            description: '进口牛排，纹理清晰，口感鲜美，西餐必备',
            price: 128.00,
            category: 'fresh',
            variants: [
                { name: '200g 西冷', price: 128.00 },
                { name: '200g 菲力', price: 168.00 },
                { name: '200g 肋眼', price: 148.00 }
            ]
        },
        {
            id: 'fresh_004',
            name: '牛肉丝',
            description: '手工切制牛肉丝，纤维细腻，爆炒专用',
            price: 45.00,
            category: 'fresh',
            variants: [
                { name: '300g 丝状', price: 45.00 },
                { name: '300g 片状', price: 48.00 },
                { name: '300g 粒状', price: 52.00 }
            ]
        },
        
        // 🐷 猪肉类 (5种)
        {
            id: 'fresh_005',
            name: '五花肉',
            description: '肥瘦相间五花肉，层次分明，红烧回锅肉必选',
            price: 32.00,
            category: 'fresh',
            variants: [
                { name: '500g 块状', price: 32.00 },
                { name: '500g 片状', price: 34.00 },
                { name: '500g 条状', price: 36.00 }
            ]
        },
        {
            id: 'fresh_006',
            name: '里脊肉',
            description: '嫩滑里脊肉，无筋膜，适合炒制和油炸',
            price: 38.00,
            category: 'fresh',
            variants: [
                { name: '400g 条状', price: 38.00 },
                { name: '400g 片状', price: 40.00 },
                { name: '400g 丝状', price: 42.00 }
            ]
        },
        {
            id: 'fresh_007',
            name: '排骨',
            description: '新鲜猪排骨，骨髓饱满，煲汤炖煮营养丰富',
            price: 42.00,
            category: 'fresh',
            variants: [
                { name: '500g 前排', price: 42.00 },
                { name: '500g 后排', price: 45.00 },
                { name: '500g 小排', price: 48.00 }
            ]
        },
        {
            id: 'fresh_008',
            name: '猪蹄',
            description: '新鲜猪蹄，胶原蛋白丰富，美容养颜佳品',
            price: 28.00,
            category: 'fresh',
            variants: [
                { name: '1只 前蹄', price: 28.00 },
                { name: '1只 后蹄', price: 30.00 },
                { name: '500g 蹄块', price: 32.00 }
            ]
        },
        {
            id: 'fresh_009',
            name: '猪肚',
            description: '新鲜猪肚，口感Q弹，煲汤炒制两相宜',
            price: 35.00,
            category: 'fresh',
            variants: [
                { name: '1个 整只', price: 35.00 },
                { name: '300g 丝状', price: 38.00 },
                { name: '300g 片状', price: 40.00 }
            ]
        },
        
        // 🐔 鸡肉类 (4种)
        {
            id: 'fresh_010',
            name: '土鸡',
            description: '散养土鸡，肉质紧实，营养价值高，煲汤鲜美',
            price: 88.00,
            category: 'fresh',
            variants: [
                { name: '1只 整鸡', price: 88.00 },
                { name: '半只 切好', price: 45.00 },
                { name: '500g 鸡块', price: 48.00 }
            ]
        },
        {
            id: 'fresh_011',
            name: '鸡胸肉',
            description: '无骨鸡胸肉，低脂高蛋白，健身减肥首选',
            price: 25.00,
            category: 'fresh',
            variants: [
                { name: '300g 块状', price: 25.00 },
                { name: '300g 丝状', price: 28.00 },
                { name: '300g 片状', price: 30.00 }
            ]
        },
        {
            id: 'fresh_012',
            name: '鸡翅',
            description: '新鲜鸡翅，皮薄肉嫩，烧烤炖煮都美味',
            price: 22.00,
            category: 'fresh',
            variants: [
                { name: '500g 翅中', price: 22.00 },
                { name: '500g 翅根', price: 20.00 },
                { name: '500g 翅尖', price: 18.00 }
            ]
        },
        {
            id: 'fresh_013',
            name: '鸡腿',
            description: '肥美鸡腿，肉质鲜嫩，老少皆宜的美味',
            price: 18.00,
            category: 'fresh',
            variants: [
                { name: '400g 去骨', price: 18.00 },
                { name: '400g 带骨', price: 16.00 },
                { name: '400g 腿排', price: 20.00 }
            ]
        },
        
        // 🐟 鱼肉类 (3种)
        {
            id: 'fresh_014',
            name: '草鱼',
            description: '新鲜草鱼，肉质鲜美，刺少肉多，家常必备',
            price: 15.00,
            category: 'fresh',
            variants: [
                { name: '500g 鱼段', price: 15.00 },
                { name: '300g 鱼片', price: 18.00 },
                { name: '400g 鱼块', price: 16.00 }
            ]
        },
        {
            id: 'fresh_015',
            name: '鲫鱼',
            description: '野生鲫鱼，营养丰富，煲汤鲜甜，产妇首选',
            price: 12.00,
            category: 'fresh',
            variants: [
                { name: '500g 大号', price: 12.00 },
                { name: '400g 中号', price: 10.00 },
                { name: '300g 小号', price: 8.00 }
            ]
        },
        {
            id: 'fresh_016',
            name: '带鱼',
            description: '深海带鱼，肉质细嫩，DHA含量高，儿童最爱',
            price: 28.00,
            category: 'fresh',
            variants: [
                { name: '500g 鱼段', price: 28.00 },
                { name: '400g 鱼块', price: 30.00 },
                { name: '300g 鱼片', price: 32.00 }
            ]
        },
        
        // 🥚 蛋类 (4种)
        {
            id: 'fresh_017',
            name: '土鸡蛋',
            description: '农家散养土鸡蛋，蛋黄饱满，营养价值高',
            price: 1.50,
            category: 'fresh',
            variants: [
                { name: '土鸡蛋 单个', price: 1.50 },
                { name: '土鸡蛋 半打', price: 8.50 },
                { name: '土鸡蛋 一打', price: 16.00 }
            ]
        },
        {
            id: 'fresh_018',
            name: '鸭蛋',
            description: '新鲜鸭蛋，个大饱满，腌制咸鸭蛋的好选择',
            price: 2.00,
            category: 'fresh',
            variants: [
                { name: '鸭蛋 单个', price: 2.00 },
                { name: '鸭蛋 半打', price: 11.00 },
                { name: '鸭蛋 一打', price: 20.00 }
            ]
        },
        {
            id: 'fresh_019',
            name: '鹅蛋',
            description: '珍贵鹅蛋，营养丰富，孕妇儿童营养佳品',
            price: 8.00,
            category: 'fresh',
            variants: [
                { name: '鹅蛋 单个', price: 8.00 },
                { name: '鹅蛋 三个装', price: 22.00 },
                { name: '鹅蛋 六个装', price: 42.00 }
            ]
        },
        {
            id: 'fresh_020',
            name: '鹌鹑蛋',
            description: '精品鹌鹑蛋，小巧玲珑，营养浓缩，老少皆宜',
            price: 0.50,
            category: 'fresh',
            variants: [
                { name: '鹌鹑蛋 单个', price: 0.50 },
                { name: '鹌鹑蛋 一盒', price: 12.00 },
                { name: '鹌鹑蛋 两盒装', price: 22.00 }
            ]
        },
        
        {
            id: 'sys_005',
            name: '编程入门指南',
            description: '零基础学编程必备教程，从基础语法到实际项目，循序渐进的学习路径。包含HTML、CSS、JavaScript、Python、Java等多种编程语言的详细讲解，配有大量实例代码和练习题，适合初学者和有一定基础的开发者。书中还包含了最新的前端框架、后端技术、数据库操作、版本控制等实用技能，是程序员必备的参考书籍。',
            price: 59.90,
            category: 'books'
        },
        {
            id: 'sys_006',
            name: '运动跑鞋',
            description: '专业运动跑鞋，轻便透气，减震效果好，适合各种运动场景。',
            price: 399.00,
            category: 'sports'
        },
        
        // 💊 药物分类商品 - 20种常用药品
        
        // 🤧 感冒类药物 (5种)
        {
            id: 'med_001',
            name: '999感冒灵',
            description: '中成药感冒颗粒，清热解毒，缓解感冒症状',
            price: 18.50,
            category: 'medicine',
            variants: [
                { name: '10袋装 颗粒', price: 18.50 },
                { name: '20袋装 家庭', price: 32.00 },
                { name: '单袋装 便携', price: 2.20 }
            ]
        },
        {
            id: 'med_002',
            name: '板蓝根',
            description: '预防感冒良药，清热解毒，增强免疫力',
            price: 12.80,
            category: 'medicine',
            variants: [
                { name: '12袋装 冲剂', price: 12.80 },
                { name: '24袋装 经济', price: 22.00 },
                { name: '6袋装 试用', price: 7.50 }
            ]
        },
        {
            id: 'med_003',
            name: '感康',
            description: '复方氨酚烷胺片，快速缓解感冒发热头痛',
            price: 15.60,
            category: 'medicine',
            variants: [
                { name: '12片装 盒装', price: 15.60 },
                { name: '24片装 大盒', price: 28.00 },
                { name: '6片装 小盒', price: 9.80 }
            ]
        },
        {
            id: 'med_004',
            name: '白加黑',
            description: '日夜分服感冒药，白天不瞌睡，晚上睡得香',
            price: 22.90,
            category: 'medicine',
            variants: [
                { name: '12片装 日夜', price: 22.90 },
                { name: '24片装 加量', price: 38.00 },
                { name: '6片装 体验', price: 13.50 }
            ]
        },
        {
            id: 'med_005',
            name: '康泰克',
            description: '缓释胶囊，12小时长效，一日两次即可',
            price: 28.00,
            category: 'medicine',
            variants: [
                { name: '10粒装 胶囊', price: 28.00 },
                { name: '20粒装 家用', price: 48.00 },
                { name: '5粒装 旅行', price: 16.00 }
            ]
        },
        
        // 🌡️ 退烧类药物 (3种)
        {
            id: 'med_006',
            name: '布洛芬',
            description: '解热镇痛药，快速退烧止痛，成人儿童适用',
            price: 8.90,
            category: 'medicine',
            variants: [
                { name: '20片装 片剂', price: 8.90 },
                { name: '10粒装 胶囊', price: 12.50 },
                { name: '100ml 混悬液', price: 16.80 }
            ]
        },
        {
            id: 'med_007',
            name: '对乙酰氨基酚',
            description: '安全退烧药，温和有效，孕妇儿童首选',
            price: 6.50,
            category: 'medicine',
            variants: [
                { name: '24片装 片剂', price: 6.50 },
                { name: '12粒装 胶囊', price: 9.20 },
                { name: '60ml 口服液', price: 13.80 }
            ]
        },
        {
            id: 'med_008',
            name: '安瑞克',
            description: '儿童退烧药，草莓口味，宝宝爱喝妈妈放心',
            price: 24.50,
            category: 'medicine',
            variants: [
                { name: '100ml 悬浮液', price: 24.50 },
                { name: '200ml 家庭装', price: 42.00 },
                { name: '50ml 便携装', price: 15.80 }
            ]
        },
        
        // 🌿 肠胃类药物 (4种)
        {
            id: 'med_009',
            name: '藿香正气水',
            description: '中成药经典，解表化湿，理气和中，夏季必备',
            price: 2.80,
            category: 'medicine',
            variants: [
                { name: '单支装 10ml', price: 2.80 },
                { name: '10支装 盒装', price: 25.00 },
                { name: '20支装 家庭', price: 45.00 }
            ]
        },
        {
            id: 'med_010',
            name: '吗丁啉',
            description: '胃动力药，缓解胃胀恶心，促进胃肠蠕动',
            price: 18.60,
            category: 'medicine',
            variants: [
                { name: '30片装 薄膜衣', price: 18.60 },
                { name: '60片装 大包装', price: 32.00 },
                { name: '15片装 小包装', price: 11.50 }
            ]
        },
        {
            id: 'med_011',
            name: '整肠生',
            description: '活菌制剂，调节肠道菌群，治疗腹泻便秘',
            price: 26.80,
            category: 'medicine',
            variants: [
                { name: '24粒装 胶囊', price: 26.80 },
                { name: '48粒装 经济装', price: 46.00 },
                { name: '12粒装 试用装', price: 15.80 }
            ]
        },
        {
            id: 'med_012',
            name: '健胃消食片',
            description: '山楂口味，开胃消食，儿童成人都爱吃',
            price: 9.90,
            category: 'medicine',
            variants: [
                { name: '36片装 咀嚼片', price: 9.90 },
                { name: '72片装 家庭装', price: 17.50 },
                { name: '18片装 便携装', price: 6.20 }
            ]
        },
        
        // 👶 儿童专用药物 (4种)
        {
            id: 'med_013',
            name: '小葵花感冒颗粒',
            description: '儿童专用感冒药，甜橙口味，专为儿童设计',
            price: 16.80,
            category: 'medicine',
            variants: [
                { name: '12袋装 颗粒', price: 16.80 },
                { name: '24袋装 家庭装', price: 29.00 },
                { name: '6袋装 试用装', price: 9.50 }
            ]
        },
        {
            id: 'med_014',
            name: '小儿氨酚黄那敏',
            description: '儿童感冒发烧专用，安全有效，家长信赖',
            price: 12.50,
            category: 'medicine',
            variants: [
                { name: '20袋装 颗粒', price: 12.50 },
                { name: '10袋装 小包装', price: 7.80 },
                { name: '40袋装 大包装', price: 22.00 }
            ]
        },
        {
            id: 'med_015',
            name: '小儿止咳糖浆',
            description: '儿童止咳专用，草莓味道，温和不刺激',
            price: 18.90,
            category: 'medicine',
            variants: [
                { name: '100ml 糖浆', price: 18.90 },
                { name: '200ml 大瓶装', price: 32.00 },
                { name: '50ml 便携装', price: 12.80 }
            ]
        },
        {
            id: 'med_016',
            name: '小儿腹泻贴',
            description: '外用贴剂，温和止泻，避免口服药物刺激',
            price: 22.00,
            category: 'medicine',
            variants: [
                { name: '6贴装 盒装', price: 22.00 },
                { name: '12贴装 家庭装', price: 38.00 },
                { name: '3贴装 试用装', price: 13.50 }
            ]
        },
        
        // 🩹 外用药物 (4种)
        {
            id: 'med_017',
            name: '云南白药',
            description: '跌打损伤圣药，活血化瘀，消肿止痛',
            price: 35.00,
            category: 'medicine',
            variants: [
                { name: '4g装 粉剂', price: 35.00 },
                { name: '20g装 软膏', price: 28.00 },
                { name: '10片装 胶囊', price: 42.00 }
            ]
        },
        {
            id: 'med_018',
            name: '创可贴',
            description: '防水透气创可贴，小伤口大保护，居家必备',
            price: 8.50,
            category: 'medicine',
            variants: [
                { name: '20片装 标准型', price: 8.50 },
                { name: '50片装 家庭装', price: 18.00 },
                { name: '10片装 便携装', price: 5.20 }
            ]
        },
        {
            id: 'med_019',
            name: '红花油',
            description: '活血化瘀外用药，舒筋活络，跌打扭伤必备',
            price: 12.80,
            category: 'medicine',
            variants: [
                { name: '20ml装 小瓶', price: 12.80 },
                { name: '50ml装 大瓶', price: 25.00 },
                { name: '10ml装 便携', price: 8.50 }
            ]
        },
        {
            id: 'med_020',
            name: '碘伏',
            description: '皮肤消毒剂，杀菌效果好，伤口处理首选',
            price: 6.80,
            category: 'medicine',
            variants: [
                { name: '60ml装 喷雾', price: 6.80 },
                { name: '100ml装 大瓶', price: 9.50 },
                { name: '30ml装 便携', price: 4.80 }
            ]
        },
        
        {
            id: 'beauty_001',
            name: '雅诗兰黛',
            description: '将科技与奢华优雅融为一体',
            price: 975.00,
            category: 'beauty',
            variants: [
                { name: '特润修护肌活精华露（小棕瓶）/50ml', price: 975.00 },
                { name: '持妆粉底液（Double Wear）/30ml', price: 450.00 }
            ]
        },
        {
            id: 'beauty_002',
            name: '兰蔻',
            description: '以玫瑰为灵感，传递法式优雅',
            price: 320.00,
            category: 'beauty',
            variants: [
                { name: '菁纯丝绒雾面唇膏（#196）', price: 320.00 },
                { name: '清滢嫩肤柔肤水/200ml', price: 320.00 }
            ]
        },
        {
            id: 'beauty_003',
            name: '香奈儿',
            description: '追求高雅、简洁与精美',
            price: 1390.00,
            category: 'beauty',
            variants: [
                { name: 'N°5香水/100ml', price: 1390.00 },
                { name: '柔光持妆粉底液/30ml', price: 600.00 }
            ]
        },
        {
            id: 'beauty_004',
            name: '迪奥',
            description: '经典与创新的结合',
            price: 380.00,
            category: 'beauty',
            variants: [
                { name: '烈艳蓝金唇膏（#999）', price: 380.00 },
                { name: 'J\'Adore 真我香水/50ml', price: 880.00 }
            ]
        },
        {
            id: 'beauty_005',
            name: '海蓝之谜',
            description: '源于海洋修复能量',
            price: 1710.00,
            category: 'beauty',
            variants: [
                { name: '精华面霜（Creme de la Mer）/30ml', price: 1710.00 },
                { name: '臻璨焕活精华油/30ml', price: 2400.00 }
            ]
        },
        {
            id: 'beauty_006',
            name: '魅可',
            description: '拥抱多元个性',
            price: 190.00,
            category: 'beauty',
            variants: [
                { name: '时尚唇膏（Ruby Woo）', price: 190.00 },
                { name: '九色眼影盘（#VELVET TEDDY）', price: 450.00 }
            ]
        },
        {
            id: 'beauty_007',
            name: '资生堂',
            description: '融合东方美学与尖端科技',
            price: 860.00,
            category: 'beauty',
            variants: [
                { name: '红妍肌活精华露（红腰子）/50ml', price: 860.00 },
                { name: '随肌应变气垫粉底液', price: 450.00 }
            ]
        },
        {
            id: 'beauty_008',
            name: 'SK-II',
            description: '改写肌肤命运',
            price: 1540.00,
            category: 'beauty',
            variants: [
                { name: '护肤精华露（神仙水）/230ml', price: 1540.00 },
                { name: '肌源赋活修护精华霜（大红瓶）/80g', price: 1310.00 }
            ]
        },
        {
            id: 'beauty_009',
            name: '科颜氏',
            description: '秉承药学传统',
            price: 340.00,
            category: 'beauty',
            variants: [
                { name: '金盏花植萃爽肤水/250ml', price: 340.00 },
                { name: '维生素C紧肤精华乳液/50ml', price: 650.00 }
            ]
        },
        {
            id: 'beauty_010',
            name: '完美日记',
            description: '美不设限',
            price: 129.00,
            category: 'beauty',
            variants: [
                { name: '探险家十二色动物眼影盘（小猪盘）', price: 129.00 },
                { name: '丝绒唇釉（V08）', price: 69.00 }
            ]
        },
        {
            id: 'beauty_011',
            name: '安热沙',
            description: '专业防晒保护',
            price: 260.00,
            category: 'beauty',
            variants: [
                { name: '金灿倍护防晒乳（小金瓶）/60ml', price: 260.00 },
                { name: '水能户外防晒喷雾/60g', price: 178.00 }
            ]
        },
        {
            id: 'beauty_012',
            name: '溪木源',
            description: '专注自然植萃',
            price: 69.00,
            category: 'beauty',
            variants: [
                { name: '山茶花净颜洁面泡沫/150ml', price: 69.00 },
                { name: '层孔菌细致菁华露/50ml', price: 129.00 }
            ]
        },
        {
            id: 'beauty_013',
            name: '高夫',
            description: '专为男士护肤',
            price: 98.00,
            category: 'beauty',
            variants: [
                { name: '锐智多效焕肤洁面乳/120g', price: 98.00 },
                { name: '恒时水润保湿露/100ml', price: 128.00 }
            ]
        },
        {
            id: 'sys_008',
            name: '智能积木玩具',
            description: '益智积木，开发儿童创造力',
            price: 89.90,
            category: 'toys'
        },
        {
            id: 'sys_009',
            name: '🐕智能投喂器',
            description: '定时定量投喂，APP远程控制，关爱宠物健康每一餐',
            price: 299.00,
            category: 'pets',
            variants: [
                { name: '基础款 2L容量', price: 299.00 },
                { name: '升级款 4L容量+摄像头', price: 459.00 },
                { name: '豪华款 6L容量+双碗设计', price: 599.00 },
                { name: '旗舰款 8L容量+语音交互', price: 799.00 },
                { name: '专业款 10L容量+健康监测', price: 999.00 }
            ]
        },
        // === 🐶 狗狗商品系列 ===
        {
            id: 'pet_001',
            name: '🐶优质狗粮',
            description: '营养均衡，天然无添加，多种口味和品牌可选',
            price: 89.00,
            category: 'pets',
            variants: [
                { name: '皇家品牌 成犬粮 5斤装', price: 89.00 },
                { name: '冠能品牌 幼犬粮 3斤装', price: 68.00 },
                { name: '比瑞吉品牌 老年犬粮 5斤装', price: 95.00 },
                { name: '渴望品牌 全犬粮 10斤装', price: 189.00 },
                { name: '爱肯拿品牌 无谷粮 8斤装', price: 158.00 }
            ]
        },
        {
            id: 'pet_002',
            name: '🐶馋嘴零食',
            description: '狗狗最爱的美味零食，训练奖励必备',
            price: 25.00,
            category: 'pets',
            variants: [
                { name: '牛肉骨头棒 5根装', price: 25.00 },
                { name: '鸡肉条 200g袋装', price: 18.00 },
                { name: '磨牙饼干 300g盒装', price: 22.00 },
                { name: '鸭肉丝 150g袋装', price: 28.00 },
                { name: '牛肉粒 100g袋装', price: 35.00 }
            ]
        },
        {
            id: 'pet_003',
            name: '🐶玩具套装',
            description: '丰富多样的狗狗玩具，让毛孩子快乐成长',
            price: 45.00,
            category: 'pets',
            variants: [
                { name: '磨牙绳球 大号', price: 45.00 },
                { name: '橡胶飞盘 中号', price: 38.00 },
                { name: '发声玩具 小鸭子', price: 28.00 },
                { name: '拉扯绳 彩色款', price: 22.00 },
                { name: '益智球 食物漏食器', price: 55.00 }
            ]
        },
        {
            id: 'pet_004',
            name: '🐶舒适用品',
            description: '狗狗日常生活必需品，舒适温馨的家',
            price: 128.00,
            category: 'pets',
            variants: [
                { name: '保暖狗窝 中型犬适用', price: 128.00 },
                { name: '时尚围巾 多色可选', price: 35.00 },
                { name: '柔软抱枕 骨头造型', price: 48.00 },
                { name: '防水垫子 可机洗', price: 68.00 },
                { name: '温控毯子 冬季必备', price: 88.00 }
            ]
        },
        {
            id: 'pet_005',
            name: '🐶户外装备',
            description: '遛狗出行必备，安全舒适的户外装备',
            price: 68.00,
            category: 'pets',
            variants: [
                { name: '牵引绳套装 可伸缩', price: 68.00 },
                { name: '胸背带 透气网面', price: 45.00 },
                { name: '雨衣 防水透气', price: 38.00 },
                { name: '户外包 便携式', price: 85.00 },
                { name: 'LED项圈 夜间安全', price: 55.00 }
            ]
        },
        // === 🐱 猫咪商品系列 ===
        {
            id: 'pet_006',
            name: '🐱优质猫粮',
            description: '营养丰富，口感鲜美，呵护猫咪健康成长',
            price: 78.00,
            category: 'pets',
            variants: [
                { name: '皇家品牌 成猫粮 4斤装', price: 78.00 },
                { name: '希尔思品牌 幼猫粮 3斤装', price: 85.00 },
                { name: '渴望品牌 全猫粮 6斤装', price: 168.00 },
                { name: '爱肯拿品牌 无谷粮 5斤装', price: 138.00 },
                { name: '比瑞吉品牌 老年猫粮 4斤装', price: 88.00 }
            ]
        },
        {
            id: 'pet_007',
            name: '🐱馋嘴零食',
            description: '猫咪最爱的美味零食，增进感情的小惊喜',
            price: 15.00,
            category: 'pets',
            variants: [
                { name: '猫条 鸡肉味 12根装', price: 15.00 },
                { name: '猫薄荷 天然有机 1罐装', price: 25.00 },
                { name: '猫冻干 鸡肉粒 1罐装', price: 35.00 },
                { name: '猫罐头 金枪鱼味 1罐装', price: 12.00 },
                { name: '营养膏 化毛球 120g', price: 28.00 }
            ]
        },
        {
            id: 'pet_008',
            name: '🐱玩具乐园',
            description: '激发猫咪天性的趣味玩具，让生活更精彩',
            price: 32.00,
            category: 'pets',
            variants: [
                { name: '逗猫棒 羽毛款', price: 32.00 },
                { name: '仿真老鼠 会叫款', price: 18.00 },
                { name: '猫磨牙棒 木天蓼', price: 25.00 },
                { name: '激光笔 自动款', price: 45.00 },
                { name: '猫抓球 铃铛款', price: 15.00 }
            ]
        },
        {
            id: 'pet_009',
            name: '🐱温馨小窝',
            description: '为猫咪打造专属空间，舒适安全的港湾',
            price: 158.00,
            category: 'pets',
            variants: [
                { name: '猫爬架 多层豪华版', price: 158.00 },
                { name: '太空舱猫窝 透明款', price: 128.00 },
                { name: '猫咪帐篷 可折叠', price: 68.00 },
                { name: '猫树屋 实木制作', price: 268.00 },
                { name: '吊床式猫窝 窗台款', price: 88.00 }
            ]
        },
        {
            id: 'pet_010',
            name: '🐱精致配件',
            description: '猫咪生活的贴心伴侣，实用又美观',
            price: 58.00,
            category: 'pets',
            variants: [
                { name: '猫包 透气便携款', price: 58.00 },
                { name: '猫咪项圈 安全扣设计', price: 25.00 },
                { name: '自动饮水器 循环过滤', price: 88.00 },
                { name: '猫砂盆 全封闭式', price: 78.00 },
                { name: '猫抓板 瓦楞纸材质', price: 35.00 }
            ]
        },
        {
            id: 'sys_010',
            name: 'MacBook Pro',
            description: 'M3芯片，专业级性能',
            price: 13456.00,
            category: 'electronics',
            variants: [
                { name: '14英寸 M3', price: 13456.00 },
                { name: '16英寸 M3 Pro', price: 19234.00 }
            ]
        },
        {
            id: 'sys_101',
            name: 'iPad',
            description: '轻薄便携的平板电脑，支持Apple Pencil，适合学习办公娱乐。',
            price: 3127.50,
            category: 'electronics',
            variants: [
                { name: 'iPad 10.9英寸', price: 3127.50 },
                { name: 'iPad Air', price: 4563.00 },
                { name: 'iPad Pro 11英寸', price: 6834.00 }
            ]
        },
        {
            id: 'sys_102',
            name: 'AirPods',
            description: '苹果无线耳机，主动降噪，音质出色，佩戴舒适。',
            price: 1347.00,
            category: 'electronics',
            variants: [
                { name: 'AirPods 3', price: 1347.00 },
                { name: 'AirPods Pro 2', price: 1926.00 }
            ]
        },
        {
            id: 'sys_103',
            name: 'Apple Watch',
            description: '智能手表，健康监测，运动追踪，支持多种表带和表盘。',
            price: 3142.00,
            category: 'electronics',
            variants: [
                { name: 'Apple Watch SE', price: 2156.00 },
                { name: 'Apple Watch Series 9', price: 3142.00 },
                { name: 'Apple Watch Ultra 2', price: 6473.00 }
            ]
        },
        {
            id: 'sys_104',
            name: '小米手机',
            description: '性价比之王，骁龙处理器，大电池长续航，拍照效果优秀。',
            price: 2076.50,
            category: 'electronics',
            variants: [
                { name: '小米14', price: 4123.00 },
                { name: '小米13', price: 3067.00 },
                { name: 'Redmi Note 13', price: 1346.50 }
            ]
        },
        {
            id: 'sys_105',
            name: '华为手机',
            description: '国产旗舰，麒麟芯片，徕卡影像，商务人士首选。',
            price: 5234.00,
            category: 'electronics',
            variants: [
                { name: 'Mate 60 Pro', price: 7156.00 },
                { name: 'P60 Pro', price: 5234.00 }
            ]
        },
        {
            id: 'sys_106',
            name: '戴尔笔记本',
            description: '商务办公笔记本，Intel处理器，轻薄便携，续航持久。',
            price: 5167.00,
            category: 'electronics',
            variants: [
                { name: 'XPS 13', price: 8234.00 },
                { name: 'Inspiron 15', price: 5167.00 },
                { name: 'Latitude 14', price: 6123.00 }
            ]
        },
        {
            id: 'sys_107',
            name: '联想笔记本',
            description: 'ThinkPad系列，商务经典，键盘手感出色，稳定可靠。',
            price: 5673.50,
            category: 'electronics',
            variants: [
                { name: 'ThinkPad X1 Carbon', price: 10234.00 },
                { name: 'ThinkPad E14', price: 5167.00 }
            ]
        },
        {
            id: 'sys_108',
            name: '索尼相机',
            description: '专业微单相机，全画幅传感器，4K视频录制，摄影爱好者必备。',
            price: 13567.00,
            category: 'electronics',
            variants: [
                { name: 'A7R5', price: 26234.00 },
                { name: 'A7M4', price: 16456.00 },
                { name: 'A6700', price: 10234.00 }
            ]
        },
        {
            id: 'sys_109',
            name: '佳能相机',
            description: '单反相机，光学取景器，丰富镜头群，专业摄影首选。',
            price: 9234.50,
            category: 'electronics',
            variants: [
                { name: 'EOS R6 Mark II', price: 16345.00 },
                { name: 'EOS 90D', price: 9234.50 }
            ]
        },
        {
            id: 'sys_110',
            name: '任天堂Switch',
            description: '便携游戏机，独占游戏丰富，支持掌机和主机双模式。',
            price: 2156.50,
            category: 'electronics',
            variants: [
                { name: 'Switch OLED', price: 2673.00 },
                { name: 'Switch Lite', price: 1347.50 }
            ]
        },
        {
            id: 'sys_111',
            name: 'PlayStation 5',
            description: '索尼次世代游戏主机，4K游戏，光线追踪，独占大作众多。',
            price: 4023.00,
            category: 'electronics'
        },
        {
            id: 'sys_112',
            name: 'Xbox Series X',
            description: '微软游戏主机，向下兼容，Game Pass服务，性能强劲。',
            price: 3756.00,
            category: 'electronics',
            variants: [
                { name: 'Series X', price: 3756.00 },
                { name: 'Series S', price: 2367.50 }
            ]
        },
        {
            id: 'sys_113',
            name: '大疆无人机',
            description: '专业航拍无人机，4K摄像，智能避障，飞行稳定。',
            price: 5123.50,
            category: 'electronics',
            variants: [
                { name: 'Mini 4 Pro', price: 5123.50 },
                { name: 'Air 3', price: 6734.00 },
                { name: 'Mavic 3 Pro', price: 13456.00 }
            ]
        },
        {
            id: 'sys_114',
            name: '罗技鼠标',
            description: '游戏鼠标，高精度传感器，可编程按键，人体工学设计。',
            price: 423.50,
            category: 'electronics',
            variants: [
                { name: 'G Pro X', price: 734.00 },
                { name: 'G502 Hero', price: 423.50 }
            ]
        },
        {
            id: 'sys_115',
            name: '机械键盘',
            description: '樱桃轴机械键盘，手感出色，背光炫酷，游戏办公两相宜。',
            price: 634.50,
            category: 'electronics',
            variants: [
                { name: '青轴版', price: 634.50 },
                { name: '红轴版', price: 673.00 },
                { name: '茶轴版', price: 656.50 }
            ]
        },
        {
            id: 'sys_116',
            name: '显示器',
            description: '27英寸4K显示器，IPS面板，色彩准确，适合设计和游戏。',
            price: 3156.00,
            category: 'electronics',
            variants: [
                { name: '27英寸 4K', price: 3156.00 },
                { name: '32英寸 4K', price: 5234.00 }
            ]
        },
        {
            id: 'sys_117',
            name: '移动硬盘',
            description: '大容量移动存储，USB 3.0高速传输，小巧便携。',
            price: 423.50,
            category: 'electronics',
            variants: [
                { name: '1TB', price: 423.50 },
                { name: '2TB', price: 734.00 },
                { name: '4TB', price: 1356.50 }
            ]
        },
        {
            id: 'sys_118',
            name: '充电宝',
            description: '大容量移动电源，快充协议支持，多设备同时充电。',
            price: 216.50,
            category: 'electronics',
            variants: [
                { name: '10000mAh', price: 216.50 },
                { name: '20000mAh', price: 324.00 }
            ]
        },
        {
            id: 'sys_012',
            name: '智能音响',
            description: '高品质音效，智能语音控制',
            price: 423.50,
            category: 'home',
            variants: [
                { name: '蓝牙音响 经典黑', price: 423.50 },
                { name: '智能语音助手 带屏幕', price: 567.00 },
                { name: '套装 含无线充电器', price: 634.50 }
            ]
        },
        // 新增家居商品
        {
            id: 'home_001',
            name: '保温水杯',
            description: '304不锈钢内胆，24小时保温保冷，人体工学设计',
            price: 67.50,
            category: 'home',
            variants: [
                { name: '500ml 商务简约', price: 67.50 },
                { name: '600ml 带茶漏 办公专用', price: 94.00 },
                { name: '情侣对杯 刻字定制', price: 123.50 }
            ]
        },
        {
            id: 'home_002',
            name: '电热水壶',
            description: '304不锈钢材质，1.7L大容量，快速沸腾，自动断电',
            price: 143.50,
            category: 'home',
            variants: [
                { name: '1.7L 基础版', price: 143.50 },
                { name: '智能温控 LED显示', price: 216.00 },
                { name: '茶具套装 含玻璃茶壶6件套', price: 287.50 }
            ]
        },
        {
            id: 'home_003',
            name: '增压花洒',
            description: '三档出水模式，增压节水，304不锈钢材质，易安装',
            price: 134.50,
            category: 'home',
            variants: [
                { name: '手持花洒 标准版', price: 134.50 },
                { name: '顶喷+手持 双出水', price: 243.00 },
                { name: '全套装 含1.5米软管支架', price: 327.50 }
            ]
        },
        {
            id: 'home_004',
            name: '藤编收纳篮',
            description: '天然藤条编织，多功能收纳，环保耐用，北欧风格',
            price: 43.50,
            category: 'home',
            variants: [
                { name: '小号 桌面整理', price: 43.50 },
                { name: '中号 衣物收纳', price: 67.00 },
                { name: '三件套 大中小组合装', price: 134.50 }
            ]
        },
        {
            id: 'home_005',
            name: '懒人躺椅',
            description: '人体工学设计，多档调节，透气网布，午休神器',
            price: 287.50,
            category: 'home',
            variants: [
                { name: '单人折叠 午休专用', price: 287.50 },
                { name: '按摩躺椅 含颈部按摩', price: 534.50 },
                { name: '双人躺椅 情侣休闲', price: 623.50 }
            ]
        },
        {
            id: 'home_006',
            name: '四件套床品',
            description: '纯棉面料，活性印染，柔软舒适，多种花色可选',
            price: 187.50,
            category: 'home',
            variants: [
                { name: '纯色简约 多色可选', price: 187.50 },
                { name: '印花田园 小碎花系列', price: 234.50 },
                { name: '天丝面料 奢华触感', price: 423.50 }
            ]
        },
        {
            id: 'home_007',
            name: '粘毛器',
            description: '可水洗粘毛滚筒，去除衣物毛发，环保可重复使用',
            price: 18.50,
            category: 'home',
            variants: [
                { name: '手持式 便携小巧', price: 18.50 },
                { name: '伸缩杆 加长版', price: 32.00 },
                { name: '三滚筒装 家庭分享', price: 54.50 }
            ]
        },
        {
            id: 'home_008',
            name: '摇摇椅',
            description: '实木框架，舒适软垫，静音摇摆，放松身心',
            price: 1067.50,
            category: 'home',
            variants: [
                { name: '单人摇椅 经典实木', price: 1067.50 },
                { name: '亲子摇椅 含儿童安全带', price: 1234.50 },
                { name: '真皮软垫 奢华享受', price: 1456.50 }
            ]
        },
        {
            id: 'home_009',
            name: '空气净化器',
            description: 'HEPA滤网，除甲醛除异味，智能检测空气质量',
            price: 1134.50,
            category: 'home',
            variants: [
                { name: '家用版 适用30㎡', price: 1134.50 },
                { name: '加强版 适用50㎡', price: 1567.50 },
                { name: '滤网套装 含3年备用滤网', price: 1387.50 }
            ]
        },
        {
            id: 'home_010',
            name: '加湿器',
            description: '超声波雾化，静音运行，定时功能，缓解干燥',
            price: 156.50,
            category: 'home',
            variants: [
                { name: '迷你桌面 USB供电', price: 156.50 },
                { name: '大容量4L 家用静音', price: 234.00 },
                { name: '香薰加湿 含6瓶精油', price: 287.50 }
            ]
        },
        {
            id: 'home_011',
            name: '电风扇',
            description: '直流变频，静音运行，遥控操作，7档风速调节',
            price: 267.50,
            category: 'home',
            variants: [
                { name: '立式落地扇 遥控版', price: 267.50 },
                { name: '无叶塔扇 安全静音', price: 456.50 },
                { name: '循环扇套装 含小风扇', price: 634.50 }
            ]
        },
        {
            id: 'home_012',
            name: '置物架',
            description: '多层收纳，承重力强，免打孔安装，节省空间',
            price: 87.50,
            category: 'home',
            variants: [
                { name: '三层厨房 调料收纳', price: 87.50 },
                { name: '五层浴室 毛巾收纳', price: 134.50 },
                { name: '组合拼接 自由搭配', price: 187.50 }
            ]
        },
        {
            id: 'home_013',
            name: '智能垃圾桶',
            description: '感应开盖，抗菌材质，大容量设计，静音关闭',
            price: 143.50,
            category: 'home',
            variants: [
                { name: '感应开盖 12L容量', price: 143.50 },
                { name: '分类双桶 干湿分离', price: 234.50 },
                { name: '垃圾袋套装 含100个垃圾袋', price: 187.50 }
            ]
        },
        {
            id: 'home_014',
            name: '衣架套装',
            description: '防滑设计，承重力强，多功能挂衣，节省衣柜空间',
            price: 54.50,
            category: 'home',
            variants: [
                { name: '20个装 基础防滑', price: 54.50 },
                { name: '多功能 含裤架领带架', price: 87.50 },
                { name: '实木50个 高端质感', price: 234.50 }
            ]
        },
        {
            id: 'home_015',
            name: 'LED护眼台灯',
            description: 'LED护眼光源，三档调光，USB充电，触摸开关',
            price: 123.50,
            category: 'home',
            variants: [
                { name: '学习护眼 防蓝光', price: 123.50 },
                { name: '床头氛围 暖光调节', price: 156.50 },
                { name: '无线充电底座 手机充电', price: 234.50 }
            ]
        },
        {
            id: 'home_016',
            name: '透明收纳盒',
            description: '透明材质，可叠放设计，密封防尘，多规格可选',
            price: 34.50,
            category: 'home',
            variants: [
                { name: '小号 化妆品专用', price: 34.50 },
                { name: '中号 文具办公', price: 56.50 },
                { name: '6个装组合 大中小搭配', price: 134.50 }
            ]
        },
        {
            id: 'home_017',
            name: '居家拖鞋',
            description: '防滑底设计，柔软舒适，抗菌防臭，居家必备',
            price: 27.50,
            category: 'home',
            variants: [
                { name: 'EVA材质 轻便透气', price: 27.50 },
                { name: '按摩底 足底保健', price: 43.50 },
                { name: '情侣2双装 同色系', price: 67.50 }
            ]
        },
        {
            id: 'home_018',
            name: '纯棉毛巾套装',
            description: '纯棉材质，吸水性强，柔软亲肤，多种尺寸组合',
            price: 87.50,
            category: 'home',
            variants: [
                { name: '3条装 面巾+方巾', price: 87.50 },
                { name: '6条装 家庭分享', price: 134.50 },
                { name: '浴巾套装 含大浴巾2条', price: 234.50 }
            ]
        },
        // === 👶 母婴系列 (15款) ===
        {
            id: 'maternity_001',
            name: '帮宝适纸尿裤',
            description: '超薄透气，12小时长效吸收，给宝宝最舒适的呵护',
            price: 51,
            category: 'maternity',
            variants: [
                { name: 'NB码 84片装', price: 51 },
                { name: 'S码 76片装 +赠湿巾3包', price: 56 },
                { name: 'M码 68片装 +赠护臀膏', price: 59 },
                { name: 'L码 60片装 +赠婴儿洗衣液', price: 62 },
                { name: 'XL码 54片装 +赠安抚奶嘴', price: 64 }
            ]
        },
        {
            id: 'maternity_002',
            name: '美赞臣奶粉',
            description: 'DHA+ARA配方，支持宝宝大脑和视力发育',
            price: 167,
            category: 'maternity',
            variants: [
                { name: '1段 900g罐装', price: 167 },
                { name: '2段 900g +送奶瓶+奶嘴套装', price: 179 },
                { name: '3段 900g +送儿童餐具7件套', price: 184 },
                { name: '4段 900g +送保温杯+学饮杯', price: 191 }
            ]
        },
        {
            id: 'maternity_003',
            name: '苏菲卫生巾',
            description: '产妇专用加长型，超强吸收，柔软亲肤',
            price: 26,
            category: 'maternity',
            variants: [
                { name: '日用型 20片', price: 26 },
                { name: '夜用型 16片 +赠卫生棉条8支', price: 29 },
                { name: '产妇专用 12片 +赠安睡裤2条', price: 39 },
                { name: '组合装 日夜各1包+护垫1包', price: 51 }
            ]
        },
        {
            id: 'maternity_004',
            name: '贝亲奶瓶套装',
            description: '医用级硅胶，仿母乳实感，宝宝更容易接受',
            price: 73,
            category: 'maternity',
            variants: [
                { name: '单瓶装 240ml', price: 73 },
                { name: '双瓶装 120ml+240ml', price: 112 },
                { name: '新生儿套装 奶瓶+奶嘴+奶瓶刷', price: 94 },
                { name: '豪华套装 3瓶+消毒器+温奶器', price: 398.00 }
            ]
        },
        {
            id: 'maternity_005',
            name: '强生婴儿洗护套装',
            description: '无泪配方，温和清洁，保护宝宝娇嫩肌肤',
            price: 44,
            category: 'maternity',
            variants: [
                { name: '洗发沐浴露 500ml', price: 44 },
                { name: '三件套 洗发+沐浴+润肤', price: 89 },
                { name: '五件套 +爽身粉+护臀膏', price: 123 },
                { name: '旅行装 50ml*6支 便携装', price: 51 }
            ]
        },
        {
            id: 'maternity_006',
            name: '好奇拉拉裤',
            description: '360度弹性腰围，宝宝活动更自由，妈妈更省心',
            price: 67,
            category: 'maternity',
            variants: [
                { name: 'M码 58片', price: 67 },
                { name: 'L码 52片 买2送1优惠装', price: 134 },
                { name: 'XL码 46片 +赠游泳纸尿裤5片', price: 73 },
                { name: 'XXL码 42片 +赠成长裤体验装', price: 76 }
            ]
        },
        {
            id: 'maternity_007',
            name: '小白熊温奶器',
            description: '智能恒温，24小时保温，夜间喂奶更方便',
            price: 107,
            category: 'maternity',
            variants: [
                { name: '基础款 单瓶温奶', price: 107 },
                { name: '双瓶款 可同时温2瓶', price: 151 },
                { name: '多功能款 温奶+消毒+烘干', price: 201 },
                { name: '智能款 APP控制+定时预约', price: 257 }
            ]
        },
        {
            id: 'maternity_008',
            name: '妈咪宝贝湿巾',
            description: '99.9%纯水制造，无酒精无香料，敏感肌宝宝也能用',
            price: 16,
            category: 'maternity',
            variants: [
                { name: '80抽 单包装', price: 16 },
                { name: '80抽*3包 家庭装', price: 44 },
                { name: '80抽*6包 +赠便携装20抽*2', price: 84 },
                { name: '80抽*12包 整箱装 包邮', price: 268.00 }
            ]
        },
        {
            id: 'maternity_009',
            name: '费雪摇铃玩具',
            description: '色彩鲜艳，声音柔和，锻炼宝宝手眼协调能力',
            price: 39,
            category: 'maternity',
            variants: [
                { name: '单个装 经典款', price: 39 },
                { name: '3个装 不同造型', price: 89 },
                { name: '礼盒装 5个+收纳盒', price: 129 },
                { name: '豪华装 8个+音乐盒+安抚巾', price: 201 }
            ]
        },
        {
            id: 'maternity_010',
            name: '十月结晶产褥垫',
            description: '医用级无菌包装，超强吸收，产后必备用品',
            price: 22,
            category: 'maternity',
            variants: [
                { name: '60*90cm 10片装', price: 22 },
                { name: '60*90cm 20片装', price: 39 },
                { name: '80*120cm 大号 8片装', price: 33 },
                { name: '混合装 大号5片+标准10片', price: 44 }
            ]
        },
        {
            id: 'maternity_011',
            name: '爱得利安抚奶嘴',
            description: '仿母乳设计，食品级硅胶，帮助宝宝安然入睡',
            price: 14,
            category: 'maternity',
            variants: [
                { name: '0-6个月 单个装', price: 14 },
                { name: '6-18个月 2个装', price: 26 },
                { name: '夜光款 便于夜间寻找', price: 19 },
                { name: '套装 3个不同月龄+收纳盒', price: 51 }
            ]
        },
        {
            id: 'maternity_012',
            name: '子初婴儿面霜',
            description: '山茶油精华，深层滋润，预防红屁屁和湿疹',
            price: 33,
            category: 'maternity',
            variants: [
                { name: '50g 便携装', price: 33 },
                { name: '100g 家庭装', price: 51 },
                { name: '护理套装 面霜+护臀膏+润肤乳', price: 94 },
                { name: '季节装 夏季清爽+冬季滋润', price: 79 }
            ]
        },
        {
            id: 'maternity_013',
            name: '好孩子婴儿车',
            description: '轻便折叠，双向推行，减震设计，出行必备',
            price: 507,
            category: 'maternity',
            variants: [
                { name: '轻便款 5.8kg', price: 507 },
                { name: '豪华款 可平躺+餐盘', price: 731 },
                { name: '旅行款 登机箱大小', price: 899 },
                { name: '全能款 可变安全座椅', price: 1294 }
            ]
        },
        {
            id: 'maternity_014',
            name: '贝恩施早教机',
            description: '双语启蒙，儿歌故事，培养宝宝语言能力',
            price: 112,
            category: 'maternity',
            variants: [
                { name: '基础版 100首儿歌', price: 112 },
                { name: '升级版 300首+故事50个', price: 167 },
                { name: '智能版 WiFi联网+APP控制', price: 224 },
                { name: '旗舰版 视频+投影+互动游戏', price: 393 }
            ]
        },
        {
            id: 'maternity_015',
            name: '威尔贝鲁纸尿裤',
            description: '日本进口，超薄0.1cm，透气不闷热，敏感肌专用',
            price: 94,
            category: 'maternity',
            variants: [
                { name: 'NB码 90片 新生儿专用', price: 94 },
                { name: 'S码 84片 +赠婴儿洁面巾', price: 101 },
                { name: 'M码 78片 买3盒送1盒', price: 301 },
                { name: 'L码 72片 VIP专享装', price: 106 }
            ]
        },
        
        // === 🔞 成人用品系列 ===
        {
            id: 'adult_001',
            name: '🔞情趣眼罩',
            description: '柔软丝绸材质，增添神秘感，多种颜色可选',
            price: 23,
            category: 'adult',
            variants: [
                { name: '黑色丝绸款', price: 23 },
                { name: '红色蕾丝款', price: 27 },
                { name: '紫色天鹅绒款', price: 31 },
                { name: '粉色缎面款', price: 29 }
            ]
        },
        {
            id: 'adult_002',
            name: '🔞硅胶按摩棒',
            description: '医用级硅胶材质，多档震动，静音设计',
            price: 97,
            category: 'adult',
            variants: [
                { name: '经典款 7档震动', price: 97 },
                { name: '升级款 12档震动+旋转', price: 134 },
                { name: '豪华款 遥控+APP控制', price: 196 },
                { name: '迷你款 便携设计', price: 73 },
                { name: '双头款 多功能设计', price: 167 }
            ]
        },
        {
            id: 'adult_003',
            name: '🔞蕾丝情趣内衣',
            description: '精致蕾丝工艺，性感透视设计，多种尺码',
            price: 52,
            category: 'adult',
            variants: [
                { name: 'A75 黑色经典款', price: 52 },
                { name: 'B75 红色激情款', price: 56 },
                { name: 'C75 白色纯真款', price: 61 },
                { name: 'D75 紫色魅惑款', price: 64 },
                { name: 'A80 粉色甜美款', price: 54 },
                { name: 'B80 黑色网纱款', price: 63 }
            ]
        },
        {
            id: 'adult_004',
            name: '🔞飞机杯',
            description: '仿真设计，柔软材质，易清洁保养',
            price: 73,
            category: 'adult',
            variants: [
                { name: '基础款 柔软内壁', price: 73 },
                { name: '螺纹款 凸点设计', price: 91 },
                { name: '震动款 电动功能', price: 124 },
                { name: '加热款 恒温设计', price: 147 }
            ]
        },
        {
            id: 'adult_005',
            name: '🔞束精环',
            description: '柔软硅胶材质，可调节尺寸，延时效果',
            price: 26,
            category: 'adult',
            variants: [
                { name: '基础款 可调节', price: 26 },
                { name: '震动款 7档震动', price: 43 },
                { name: '双环款 增强体验', price: 37 },
                { name: '夜光款 发光设计', price: 34 }
            ]
        },
        {
            id: 'adult_006',
            name: '🔞透明内裤',
            description: '超薄透明材质，性感诱惑，舒适贴身',
            price: 19,
            category: 'adult',
            variants: [
                { name: 'S码 透明款', price: 19 },
                { name: 'M码 半透明款', price: 22 },
                { name: 'L码 蕾丝边款', price: 24 },
                { name: 'XL码 开档款', price: 27 }
            ]
        },
        {
            id: 'adult_007',
            name: '🔞皮鞭套装',
            description: '优质皮革制作，手感舒适，多种长度',
            price: 51,
            category: 'adult',
            variants: [
                { name: '短款 30cm 初学者', price: 51 },
                { name: '中款 50cm 进阶版', price: 67 },
                { name: '长款 70cm 专业版', price: 89 },
                { name: '套装 三件套', price: 134 }
            ]
        },
        {
            id: 'adult_008',
            name: '🔞跳蛋',
            description: '小巧便携，强力震动，无线遥控',
            price: 39,
            category: 'adult',
            variants: [
                { name: '经典款 有线控制', price: 39 },
                { name: '无线款 遥控设计', price: 56 },
                { name: 'APP款 手机控制', price: 79 },
                { name: '双震款 双重刺激', price: 73 },
                { name: '静音款 超静音设计', price: 61 }
            ]
        },
        {
            id: 'adult_009',
            name: '🔞男士情趣内裤',
            description: '男士专用，透气舒适，性感设计',
            price: 32,
            category: 'adult',
            variants: [
                { name: 'M码 黑色蕾丝款', price: 32 },
                { name: 'L码 红色丝绸款', price: 37 },
                { name: 'XL码 透明网纱款', price: 41 },
                { name: 'XXL码 开档设计款', price: 44 }
            ]
        },
        {
            id: 'adult_010',
            name: '🔞手铐脚铐套装',
            description: '柔软内衬，安全锁扣，可调节尺寸',
            price: 44,
            category: 'adult',
            variants: [
                { name: '基础款 绒布内衬', price: 44 },
                { name: '皮革款 真皮制作', price: 67 },
                { name: '金属款 不锈钢材质', price: 89 },
                { name: '套装款 手铐+脚铐', price: 79 }
            ]
        },
        {
            id: 'adult_011',
            name: '🔞硅胶阳具',
            description: '仿真设计，医用硅胶，多种尺寸',
            price: 79,
            category: 'adult',
            variants: [
                { name: '15cm 基础款', price: 79 },
                { name: '18cm 凸点螺纹款', price: 94 },
                { name: '20cm 加粗款', price: 112 },
                { name: '22cm 超长款', price: 127 },
                { name: '双头款 多功能设计', price: 143 }
            ]
        },
        {
            id: 'adult_012',
            name: '🔞避孕套套装',
            description: '超薄设计，多种口味，安全可靠',
            price: 16,
            category: 'adult',
            variants: [
                { name: '超薄款 12只装', price: 16 },
                { name: '螺纹款 12只装', price: 18 },
                { name: '果味款 混合装12只', price: 21 },
                { name: '夜光款 12只装', price: 22 },
                { name: '加大款 12只装', price: 24 }
            ]
        },
        {
            id: 'adult_013',
            name: '🔞项圈套装',
            description: '柔软皮革，可调节尺寸，时尚设计',
            price: 39,
            category: 'adult',
            variants: [
                { name: '基础款 黑色皮革', price: 39 },
                { name: '铆钉款 朋克风格', price: 49 },
                { name: '蕾丝款 优雅设计', price: 44 },
                { name: '带铃铛款 可爱风格', price: 42 }
            ]
        },
        {
            id: 'adult_014',
            name: '🔞口球套装',
            description: '医用硅胶材质，透气设计，多种尺寸',
            price: 33,
            category: 'adult',
            variants: [
                { name: '小号 直径4cm', price: 33 },
                { name: '中号 直径5cm', price: 37 },
                { name: '大号 直径6cm', price: 41 },
                { name: '透气款 多孔设计', price: 44 }
            ]
        },
        {
            id: 'adult_015',
            name: '🔞肛塞套装',
            description: '渐进式设计，柔软材质，初学者友好',
            price: 49,
            category: 'adult',
            variants: [
                { name: '小号 初学者款', price: 49 },
                { name: '中号 进阶款', price: 61 },
                { name: '大号 专业款', price: 73 },
                { name: '震动款 电动功能', price: 94 },
                { name: '套装 三件套', price: 123 }
            ]
        },
        {
            id: 'adult_016',
            name: '🔞贞操带',
            description: '可调节设计，舒适材质，安全锁扣',
            price: 89,
            category: 'adult',
            variants: [
                { name: '男士款 可调节', price: 89 },
                { name: '女士款 舒适版', price: 94 },
                { name: '透明款 隐蔽设计', price: 112 },
                { name: '金属款 不锈钢', price: 143 }
            ]
        },
        {
            id: 'adult_017',
            name: '🔞拉珠套装',
            description: '渐进式珠子，柔软材质，易于清洁',
            price: 44,
            category: 'adult',
            variants: [
                { name: '5珠款 初学者', price: 44 },
                { name: '7珠款 进阶版', price: 56 },
                { name: '10珠款 专业版', price: 73 },
                { name: '震动款 电动功能', price: 89 }
            ]
        },
        {
            id: 'adult_018',
            name: '🔞乳夹套装',
            description: '可调节压力，柔软硅胶垫，舒适体验',
            price: 27,
            category: 'adult',
            variants: [
                { name: '基础款 可调压力', price: 27 },
                { name: '震动款 电动功能', price: 44 },
                { name: '链条款 连接设计', price: 39 },
                { name: '羽毛款 装饰设计', price: 33 }
            ]
        },
        {
            id: 'adult_019',
            name: '🔞绳索套装',
            description: '柔软丝绸材质，多种颜色，专业束缚',
            price: 39,
            category: 'adult',
            variants: [
                { name: '5米装 红色丝绸', price: 39 },
                { name: '10米装 黑色棉绳', price: 56 },
                { name: '15米装 紫色缎带', price: 73 },
                { name: '套装 多色组合', price: 89 }
            ]
        },
        {
            id: 'adult_020',
            name: '🔞情趣蜡烛',
            description: '低温蜡烛，安全无害，浪漫氛围',
            price: 21,
            category: 'adult',
            variants: [
                { name: '红色款 玫瑰香味', price: 21 },
                { name: '白色款 茉莉香味', price: 19 },
                { name: '黑色款 薰衣草香味', price: 24 },
                { name: '套装 三色组合', price: 49 }
            ]
        }
    ];
    
    return systemProductsCache;
}

/**
 * 更新系统购物车显示
 */
async function updateSystemCartDisplay() {
    // 确保统一购物车已初始化
    if (!shoppingCart) {
        shoppingCart = [];
    }
    
    // 计算所有商品的总数量和总金额（包括个人商城和系统商城）
    const allItems = shoppingCart.reduce((sum, item) => sum + item.quantity, 0);
    
    // 计算系统商城商品的数量和金额
    const systemItems = shoppingCart.filter(item => item.type === 'system');
    const systemTotalAmount = systemItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    
    // 计算个人商城商品的金额
    const personalItems = shoppingCart.filter(item => item.type === 'personal');
    let personalTotalAmount = 0;
    if (personalItems.length > 0) {
        // 从数据库获取个人商城商品价格
        const personalProductIds = personalItems.map(item => item.productId);
        const personalProducts = await db.shoppingProducts.where('id').anyOf(personalProductIds).toArray();
        const personalProductMap = new Map(personalProducts.map(p => [p.id, p]));
        
        personalItems.forEach((item) => {
            const product = personalProductMap.get(item.productId);
    if (product) {
                personalTotalAmount += product.price * item.quantity;
            }
        });
    }
    
    const totalAmount = systemTotalAmount + personalTotalAmount;
    
    // 更新系统商城购物车数量显示（显示所有商品总数）
    const cartCountEl = document.getElementById('system-cart-count');
    if (cartCountEl) {
        cartCountEl.textContent = allItems;
        cartCountEl.style.display = allItems > 0 ? 'flex' : 'none';
    }
    
    // 更新系统商城总金额显示（显示所有商品总金额）
    const cartTotalEl = document.getElementById('system-cart-total');
    if (cartTotalEl) {
        cartTotalEl.textContent = `¥${totalAmount.toFixed(2)}`;
    }
}

/**
 * 打开系统购物车
 */
function openSystemCart() {
    // 直接跳转到购物车结算页面（与个人商城共用同一个页面）
    openCartScreen();
}

/**
 * 显示系统商品详情
 */
function showSystemProductDetail(product) {
    const detailText = `商品名称: ${product.name}\n\n价格: ¥${product.price}\n\n商品描述:\n${product.description}\n\n注意: 系统商城商品仅供展示，暂不支持购买。`;
    showCustomAlert('商品详情', detailText);
}

// ▲▲▲ 新增功能结束 ▲▲▲

function closeReceiptHandler() {
    document.getElementById('gift-receipt-modal').classList.remove('visible');
}

function manageProductsHandler() {
    isProductManagementMode = !isProductManagementMode;
    const manageProductsBtn = document.getElementById('manage-products-btn');
    if (manageProductsBtn) {
        manageProductsBtn.style.color = isProductManagementMode ? 'var(--accent-color)' : 'var(--text-primary)';
    }
    // 进入管理模式且没有商品时，自动打开编辑器
    if (isProductManagementMode && document.querySelectorAll('#product-grid .product-item').length === 0) {
        openProductEditor(null);
    }
    renderShoppingProducts();
}

function addNewProductHandler() {
    // 检查当前是否在具体分类页面（不是"全部"分类）
    if (currentCategory === 'all') {
        alert("请先选择一个具体的商品分类，然后再添加商品。");
        return;
    }
    
    // 直接打开商品编辑器，不需要管理模式
        openProductEditor(null);
}

async function clearCartHandler() {
    // 确保购物车已初始化
    if (!shoppingCart) {
        shoppingCart = [];
        return;
    }
    
    if (shoppingCart.length === 0) return;
    const confirmed = await showCustomConfirm('清空购物车', '确定要清空购物车中的所有商品吗？');
    if (confirmed) {
        shoppingCart = [];
        updateCartCount();
        renderCartItems();
    }
}

function selectAllCartHandler(e) {
    document.querySelectorAll('.cart-item-checkbox').forEach(cb => {
        cb.checked = e.target.checked;
    });
    updateCartTotal();
}

function cancelProductEditorHandler() {
    document.getElementById('product-editor-modal').classList.remove('visible');
}

function productImageInputHandler(e) {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (re) => { 
            document.getElementById('product-image-preview').src = re.target.result; 
        };
        reader.readAsDataURL(file);
    }
}

// 等待DOM加载完成后绑定一次性事件
document.addEventListener('DOMContentLoaded', function() {
    // 这里只绑定不会重复创建的元素的事件
    // 商品网格事件现在在 initShoppingSystemEvents 中绑定

    // 购物车列表事件委托（处理购物车中的各种操作）
    const cartItemsList = document.getElementById('cart-items-list');
    if (cartItemsList) {
        cartItemsList.addEventListener('click', async e => {
            const target = e.target;
            if (target.classList.contains('decrease-qty-btn')) {
                // 减少数量
                const productId = target.dataset.id;
                const type = target.dataset.type || 'personal';
                await updateCartItemQuantity(type === 'system' ? productId : parseInt(productId), -1, type);
            }
            if (target.classList.contains('increase-qty-btn')) {
                // 增加数量
                const productId = target.dataset.id;
                const type = target.dataset.type || 'personal';
                await updateCartItemQuantity(type === 'system' ? productId : parseInt(productId), 1, type);
            }
            if (target.classList.contains('cart-item-checkbox')) {
                // 选择框变化时更新总价
                updateCartTotal();
            }
        });
    }

    // 购物车清空按钮和全选事件已移至 initShoppingSystemEvents() 函数中

    // 商品编辑器弹窗按钮和图片上传事件已移至 initShoppingSystemEvents() 函数中

    // 第一步：下单对象选择弹窗事件 - 已移至 openOrderRecipientPicker 函数中

    // 第二步：付款方式选择弹窗事件 - 已移至 openPaymentMethodPicker 函数中

    // 下单对象选择列表点击事件已移至动态生成时绑定

    // 付款方式选择列表点击事件已移至动态生成时绑定
    // 保留原有的事件委托作为备用
    const paymentMethodList = document.getElementById('payment-method-list');
    if (paymentMethodList) {
        paymentMethodList.addEventListener('click', (e) => {
            const item = e.target.closest('.payment-option-item');
            if (item) {
                // 清除其他选中状态
                paymentMethodList.querySelectorAll('.payment-option-item').forEach(el => el.classList.remove('selected'));
                // 选中当前项
                item.classList.add('selected');
            }
        });
    }

    // 原来的礼物接收人列表点击事件（保留以防其他地方使用）
    const giftRecipientList = document.getElementById('gift-recipient-list');
    if (giftRecipientList) {
        giftRecipientList.addEventListener('click', (e) => {
            const item = e.target.closest('.contact-picker-item');
            if (item) {
                item.classList.toggle('selected');
            }
        });
    }

    // 礼物接收人全选事件
    const selectAllRecipients = document.getElementById('select-all-recipients');
    if (selectAllRecipients) {
        selectAllRecipients.addEventListener('change', function(e) {
            const isChecked = e.target.checked;
            document.querySelectorAll('#gift-recipient-list .contact-picker-item').forEach(item => {
                item.classList.toggle('selected', isChecked);
            });
        });
    }

    // 礼物卡片点击事件已移动到与其他卡片事件处理器相同的位置

    // 初始化购物车计数
    updateCartCount();
    
    console.log('购物系统初始化完成');
});

// ==================== 购物系统辅助函数 ====================

/**
 * 显示自定义警告对话框
 * @param {string} title - 对话框标题
 * @param {string} message - 对话框消息
 * @returns {Promise<boolean>} 用户点击确定时返回true
 */
function showCustomAlert(title, message) {
    return new Promise(resolve => {
        // 先移除可能存在的旧弹窗
        const existingModal = document.getElementById('shopping-modal-overlay');
        if (existingModal) {
            existingModal.remove();
        }
        
        // 生成唯一ID避免冲突
        const modalId = 'shopping-modal-overlay-' + Date.now();
        const confirmId = 'shopping-modal-confirm-' + Date.now();
        
        // 创建模态框HTML
        const modalHtml = `
            <div id="${modalId}" style="
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.5); z-index: 10000; display: flex; 
                align-items: center; justify-content: center;
            ">
                <div style="
                    background: var(--bg-primary); border-radius: 12px; 
                    padding: 20px; max-width: 400px; width: 90%; 
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                ">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary);">${title}</h3>
                    <p style="margin: 0 0 20px 0; color: var(--text-secondary); white-space: pre-wrap;">${message}</p>
                    <div style="text-align: right;">
                        <button id="${confirmId}" style="
                            background: var(--accent-color); color: white; border: none; 
                            padding: 8px 16px; border-radius: 6px; cursor: pointer;
                        ">好的</button>
                    </div>
                </div>
            </div>
        `;
        
        // 添加到页面
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // 绑定事件
        const overlay = document.getElementById(modalId);
        const confirmBtn = document.getElementById(confirmId);
        
        let isResolved = false; // 防止重复解析
        
        const closeModal = () => {
            if (isResolved) return; // 防止重复执行
            isResolved = true;
            
            if (overlay && overlay.parentNode) {
                overlay.remove();
            }
            resolve(true);
        };
        
        // 使用 once: true 确保事件只触发一次
        if (confirmBtn) {
            confirmBtn.addEventListener('click', closeModal, { once: true });
        }
        
        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closeModal();
            }, { once: true });
        }
        
        // 添加键盘事件支持
        const handleKeydown = (e) => {
            if (e.key === 'Enter' || e.key === 'Escape') {
                document.removeEventListener('keydown', handleKeydown);
                closeModal();
            }
        };
        document.addEventListener('keydown', handleKeydown);
    });
}

/**
 * 显示自定义确认对话框
 * @param {string} title - 对话框标题
 * @param {string} message - 对话框消息
 * @returns {Promise<boolean>} 用户点击确定时返回true，取消时返回false
 */
function showCustomConfirm(title, message) {
    return new Promise(resolve => {
        // 创建模态框HTML
        const modalHtml = `
            <div id="shopping-modal-overlay" style="
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.5); z-index: 10000; display: flex; 
                align-items: center; justify-content: center;
            ">
                <div style="
                    background: var(--bg-primary); border-radius: 12px; 
                    padding: 20px; max-width: 400px; width: 90%; 
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                ">
                    <h3 style="margin: 0 0 15px 0; color: var(--text-primary);">${title}</h3>
                    <p style="margin: 0 0 20px 0; color: var(--text-secondary); white-space: pre-wrap;">${message}</p>
                    <div style="text-align: right; display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="shopping-modal-cancel" style="
                            background: var(--bg-secondary); color: var(--text-primary); border: none; 
                            padding: 8px 16px; border-radius: 6px; cursor: pointer;
                        ">取消</button>
                        <button id="shopping-modal-confirm" style="
                            background: var(--accent-color); color: white; border: none; 
                            padding: 8px 16px; border-radius: 6px; cursor: pointer;
                        ">确定</button>
                    </div>
                </div>
            </div>
        `;
        
        // 添加到页面
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // 绑定事件
        const overlay = document.getElementById('shopping-modal-overlay');
        const confirmBtn = document.getElementById('shopping-modal-confirm');
        const cancelBtn = document.getElementById('shopping-modal-cancel');
        
        const closeModal = (result) => {
            overlay.remove();
            resolve(result);
        };
        
        confirmBtn.addEventListener('click', () => closeModal(true));
        cancelBtn.addEventListener('click', () => closeModal(false));
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) closeModal(false);
        });
    });
}

/**
 * 显示订单预览弹窗
 * @param {string} timestamp - 订单时间戳
 */
function showOrderPreviewModal(timestamp) {
    console.log('showOrderPreviewModal called with timestamp:', timestamp);
    const chat = state.chats[state.activeChatId];
    if (!chat) {
        console.log('No chat found');
        return;
    }
    
    // 查找对应的订单消息
    const orderMsg = chat.history.find(m => m.timestamp == timestamp);
    if (!orderMsg || orderMsg.type !== 'order') {
        console.log('Order message not found or not order type');
        return;
    }
    
    // 获取发送者名称
    const senderName = chat.isGroup ? 
        getDisplayNameInGroup(chat, orderMsg.senderName) || '用户' : 
        (orderMsg.senderName || '用户');
    
    // 判断是否是用户自己的订单
    const myNickname = chat.settings.myNickname || '我';
    const isMyOrder = orderMsg.senderName === myNickname || orderMsg.role === 'user';
    
    // 获取弹窗元素
    const modal = document.getElementById('order-preview-modal');
    const body = document.getElementById('order-preview-body');
    
    // 获取商品分类对应的emoji
    function getCategoryEmoji(category) {
        const categoryEmojis = {
            'electronics': '✨',
            'fashion': '🎀',
            'home': '🏡',
            'food': '🍓',
            'snacks': '🍿',
            'pets': '🐶',
            'maternity': '👶',
            'adult': '🔞',
            'beauty': '💄',
            'toys': '🧸',
            'medicine': '💊',
            'other': '📦'
        };
        return categoryEmojis[category] || '📦';
    }
    
    // 构建商品列表HTML
    let itemsHtml = '';
    orderMsg.items.forEach(item => {
        const isSystemItem = item.type === 'system';
        // 判断是否是AI发送的消息
        const isAIMessage = orderMsg.role === 'assistant';
        
        let itemImage;
        if (isAIMessage) {
            // AI发送的消息：统一显示🤍，不显示图片
            itemImage = null;
        } else {
            // 用户发送的消息：保持原逻辑
            itemImage = isSystemItem ? 
                (item.image || '') : 
                (item.imageUrl || '');
        }
        
        itemsHtml += `
            <div class="order-preview-item">
                ${itemImage ? `<img src="${itemImage}" class="order-preview-item-image" onerror="this.style.display='none'">` : 
                  `<div class="order-preview-item-image" style="display: flex; align-items: center; justify-content: center; font-size: 24px;">${isAIMessage ? '🤍' : (isSystemItem ? getCategoryEmoji(item.category) : '🛍️')}</div>`}
                <div class="order-preview-item-info">
                    <div class="order-preview-item-name">${item.name}</div>
                    ${item.description ? `<div class="order-preview-item-description">${item.description}</div>` : ''}
                    ${item.style ? `<div class="order-preview-item-style">款式: ${item.style}</div>` : ''}
                    <div class="order-preview-item-details">
                        <span class="order-preview-item-quantity">x${item.quantity}</span>
                        <span class="order-preview-item-price">¥${(item.price * item.quantity).toFixed(2)}</span>
                    </div>
                </div>
            </div>
        `;
    });
    
    // 构建弹窗内容
    body.innerHTML = `
        <div class="order-preview-sender">${senderName}的订单</div>
        <div class="order-preview-items">${itemsHtml}</div>
        <div class="order-preview-total">
            <span class="order-preview-total-label">总计</span>
            <span class="order-preview-total-value">¥${orderMsg.total.toFixed(2)}</span>
        </div>
        ${isMyOrder ? 
            '<div class="order-preview-waiting">这是您自己的订单</div>' : 
            `<div class="order-preview-actions">
                <button class="order-preview-btn order-preview-btn-reject" onclick="handleOrderReject('${timestamp}')">拒绝买单</button>
                <button class="order-preview-btn order-preview-btn-pay" onclick="handleOrderPayment('${timestamp}')">为他买单</button>
            </div>`
        }
    `;
    
    // 显示弹窗
    console.log('Showing modal, modal element:', modal);
    modal.classList.add('visible');
    console.log('Modal classes after adding visible:', modal.className);
}

/**
 * 处理订单付款（用户同意为AI买单）
 * @param {string} timestamp - 订单时间戳
 */
async function handleOrderPayment(timestamp) {
    console.log('handleOrderPayment called with timestamp:', timestamp);
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    
    // 查找对应的订单消息
    const orderMsg = chat.history.find(m => m.timestamp == timestamp);
    if (!orderMsg || orderMsg.type !== 'order') {
        console.log('Order message not found');
        return;
    }
    
    // 检查订单总金额并扣费
    const totalAmount = orderMsg.totalAmount || orderMsg.total;
    if (!totalAmount || isNaN(totalAmount)) {
        alert('订单金额无效，无法完成支付');
        return;
    }
    
    // 检查钱包余额并扣费
    let deductSuccess = false;
    
    // 获取所有商品名称作为描述
    const itemNames = orderMsg.items && orderMsg.items.length > 0 
        ? orderMsg.items.map(item => item.name).join('、') 
        : '商品';
    
    // 尝试多种方式调用函数
    if (typeof window.checkAndDeductWalletBalance === 'function') {
        deductSuccess = await window.checkAndDeductWalletBalance(totalAmount, `为${orderMsg.senderName}购物订单代付：${itemNames}`, 'shopping_order_payment');
    } else if (typeof checkAndDeductWalletBalance === 'function') {
        deductSuccess = await checkAndDeductWalletBalance(totalAmount, `为${orderMsg.senderName}购物订单代付：${itemNames}`, 'shopping_order_payment');
    } else {
        console.error('checkAndDeductWalletBalance function not found');
        alert('钱包功能暂时不可用，无法完成支付');
        return;
    }
    
    if (!deductSuccess) {
        return; // 余额不足，终止支付
    }
    
    // 更新订单状态
    orderMsg.isPaid = true;
    orderMsg.payerResponse = 'paid';
    orderMsg.actualPayer = chat.settings.myNickname || '我';
    
    console.log('Order payment accepted, updated message:', orderMsg);
    
    // 关闭弹窗
    document.getElementById('order-preview-modal').classList.remove('visible');
    
    // 重新渲染聊天界面以更新订单显示
    renderChatInterface(state.activeChatId);
    
    // 保存到数据库
    db.chats.put(chat);
    
    // 显示成功提示
    showTopNotification('已为对方买单成功！');
}

/**
 * 处理订单拒绝（用户拒绝为AI买单）
 * @param {string} timestamp - 订单时间戳
 */
function handleOrderReject(timestamp) {
    console.log('handleOrderReject called with timestamp:', timestamp);
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    
    // 查找对应的订单消息
    const orderMsg = chat.history.find(m => m.timestamp == timestamp);
    if (!orderMsg || orderMsg.type !== 'order') {
        console.log('Order message not found');
        return;
    }
    
    // 更新订单状态
    orderMsg.isPaid = false;
    orderMsg.payerResponse = 'rejected';
    
    console.log('Order payment rejected, updated message:', orderMsg);
    
    // 关闭弹窗
    document.getElementById('order-preview-modal').classList.remove('visible');
    
    // 重新渲染聊天界面以更新订单显示
    renderChatInterface(state.activeChatId);
    
    // 保存到数据库
    db.chats.put(chat);
    
    // 显示提示
    showTopNotification('已拒绝买单请求');
}

/**
 * 根据原始名称获取在群聊中的显示名称
 * @param {Object} chat - 聊天对象
 * @param {string} originalName - 原始名称
 * @returns {string} 显示名称
 */
function getDisplayNameInGroup(chat, originalName) {
    if (!chat || !chat.isGroup) return originalName;
    
    const member = chat.members.find(m => m.originalName === originalName);
    return member ? member.groupNickname : originalName;
}

/**
 * 显示顶部通知
 * @param {string} message - 通知消息
 */

function showTopNotification(message) {
    const notification = document.getElementById('top-notification');
    
    // 如果有正在显示的通知，立即替换
    if (currentNotificationTimeout) {
        clearTimeout(currentNotificationTimeout);
        notification.classList.remove('show');
    }
    
    // 设置消息内容
    notification.textContent = message;
    
    // 短暂延迟后显示通知
    setTimeout(() => {
        notification.classList.add('show');
    }, 50);
    
    // 3秒后自动隐藏
    currentNotificationTimeout = setTimeout(() => {
        notification.classList.remove('show');
        currentNotificationTimeout = null;
    }, 3000);
}

// ▼▼▼ 钱包系统JavaScript代码开始 ▼▼▼


// 游戏状态变量 - 全局声明避免作用域问题
window.currentGameRound = 1;
window.window.gameTimer = null;
window.window.gameTimeLeft = 30;
window.window.gameScore = 0;
window.window.currentMathAnswer = 0;
window.window.musicNoteCount = 0;
window.window.musicNotesClicked = 0;
window.window.moleScore = 0;
window.window.moleHits = 0;
window.window.moleInterval = null;

// 钱包数据库表 - 全局声明
window.walletDB = null;
window.walletInitialized = false;

// 获取当前时间段 ('morning' 或 'afternoon')
function getCurrentTimePeriod() {
    const now = new Date();
    const hour = now.getHours();
    const minute = now.getMinutes();
    // 0:00-12:00 为上午时段，12:01-23:59 为下午时段
    // 修复：12:01之后应该立即切换到下午时段
    return (hour < 12 || (hour === 12 && minute === 0)) ? 'morning' : 'afternoon';
}

// 获取日期字符串 (YYYY-MM-DD)
function getDateString(date) {
    return date.toISOString().split('T')[0];
}

// 获取下一个重置时间
function getNextResetTime() {
    const now = new Date();
    const currentPeriod = getCurrentTimePeriod();
    
    if (currentPeriod === 'morning') {
        // 如果是上午时段，下次重置时间是今天12:01
        const resetTime = new Date(now);
        resetTime.setHours(12, 1, 0, 0);
        return resetTime;
    } else {
        // 如果是下午时段，下次重置时间是明天0:00
        const resetTime = new Date(now);
        resetTime.setDate(resetTime.getDate() + 1);
        resetTime.setHours(0, 0, 0, 0);
        return resetTime;
    }
}

// 格式化重置时间显示
function formatResetTime(resetTime) {
    const now = new Date();
    const isToday = resetTime.toDateString() === now.toDateString();
    
    if (isToday) {
        return `今天 ${resetTime.getHours().toString().padStart(2, '0')}:${resetTime.getMinutes().toString().padStart(2, '0')}`;
    } else {
        return `明天 ${resetTime.getHours().toString().padStart(2, '0')}:${resetTime.getMinutes().toString().padStart(2, '0')}`;
    }
}

// 检查并更新时间段机会
async function checkAndUpdatePeriodChances(db, walletRecord) {
    const now = new Date();
    const currentPeriod = getCurrentTimePeriod();
    const currentDate = getDateString(now);
    
    // 检查是否需要重置（新的一天或时间段切换）
    let needsUpdate = false;
    let updateData = {};
    
    // 如果是新的一天，重置所有机会
    if (walletRecord.lastResetDate !== currentDate) {
        updateData = {
            morningChances: 2,
            afternoonChances: 2,
            currentPeriod: currentPeriod,
            lastResetDate: currentDate,
            gameChances: 2,
            nextChanceTime: 0
        };
        needsUpdate = true;
    }
    // 如果是同一天但时间段切换了
    else if (walletRecord.currentPeriod !== currentPeriod) {
        updateData = {
            currentPeriod: currentPeriod,
            gameChances: currentPeriod === 'morning' ? walletRecord.morningChances : walletRecord.afternoonChances
        };
        needsUpdate = true;
    }
    
    if (needsUpdate) {
        await db.wallet.update(walletRecord.id, updateData);
        // 返回更新后的记录
        return await db.wallet.get(walletRecord.id);
    }
    
    return walletRecord;
}

// 初始化钱包数据库
async function initWalletDB() {
    if (window.walletInitialized) return window.walletDB;
    
    // 防止重复初始化
    if (window.walletInitializing) {
        console.log('钱包正在初始化中，等待完成...');
        // 等待初始化完成
        let waitCount = 0;
        while (window.walletInitializing && waitCount < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            waitCount++;
        }
        return window.walletDB;
    }
    
    window.walletInitializing = true;
    console.log('开始安全初始化钱包数据库...');
    
    try {
        window.walletDB = new Dexie('WalletDB');
        window.walletDB.version(1).stores({
            wallet: '++id, balance, lastGameTime, gameChances, nextChanceTime, currentPeriod, morningChances, afternoonChances, lastResetDate',
            gameHistory: '++id, timestamp, gameType, result, score',
            transactions: '++id, timestamp, type, amount, description, source'
        });
        
        await window.walletDB.open();
        
        // 检查是否已有钱包记录，没有则创建默认记录
        const walletRecords = await window.walletDB.wallet.toArray();
        if (walletRecords.length === 0) {
            const now = new Date();
            const currentPeriod = getCurrentTimePeriod();
            await window.walletDB.wallet.add({
                balance: 0,
                lastGameTime: 0,
                gameChances: 2,
                nextChanceTime: 0,
                currentPeriod: currentPeriod,
                morningChances: 2,
                afternoonChances: 2,
                lastResetDate: getDateString(now)
            });
        } else {
            // 检查并更新旧数据，添加新字段
            const walletRecord = walletRecords[0];
            if (!walletRecord.hasOwnProperty('currentPeriod') || 
                !walletRecord.hasOwnProperty('morningChances') || 
                !walletRecord.hasOwnProperty('afternoonChances') || 
                !walletRecord.hasOwnProperty('lastResetDate')) {
                
                const now = new Date();
                const currentPeriod = getCurrentTimePeriod();
                await window.walletDB.wallet.update(walletRecord.id, {
                    currentPeriod: currentPeriod,
                    morningChances: walletRecord.gameChances || 2,
                    afternoonChances: 2,
                    lastResetDate: getDateString(now)
                });
            }
        }
        
        window.walletInitialized = true;
        window.walletInitializing = false;  // 清理初始化标记
        console.log('钱包数据库初始化成功');
        return window.walletDB;
    } catch (error) {
        console.error('钱包数据库初始化失败:', error);
        window.walletInitialized = false;
        window.walletInitializing = false;  // 即使失败也要清理标记
        return null;
    }
}

// 确保钱包数据库已初始化
async function ensureWalletDB() {
    if (!window.walletInitialized || !window.walletDB) {
        await initWalletDB();
    }
    return window.walletDB;
}

// 打开钱包弹窗
async function openWallet() {
    const modal = document.getElementById('wallet-modal');
    const balanceEl = document.getElementById('wallet-balance');
    const remainingChancesEl = document.getElementById('remaining-challenge-chances');
    const resetTimeEl = document.getElementById('reset-time-info');
    
    try {
        const db = await ensureWalletDB();
        if (!db) {
            balanceEl.textContent = '¥0.00';
            remainingChancesEl.textContent = '0';
            resetTimeEl.textContent = '重置时间为：--:--';
            modal.style.display = 'flex';
            return;
        }
        
        let walletRecord = await db.wallet.orderBy('id').first();
        if (walletRecord) {
            // 检查并更新时间段机会
            walletRecord = await checkAndUpdatePeriodChances(db, walletRecord);
            
            // 更新余额显示
            balanceEl.textContent = `¥${formatNumber(walletRecord.balance.toFixed(2))}`;
            
            // 更新闯关机会显示
            const currentPeriod = getCurrentTimePeriod();
            const currentChances = currentPeriod === 'morning' ? walletRecord.morningChances : walletRecord.afternoonChances;
            remainingChancesEl.textContent = currentChances;
            
            // 更新机会颜色
            if (currentChances > 0) {
                remainingChancesEl.style.color = '#4CAF50';
            } else {
                remainingChancesEl.style.color = '#f44336';
            }
            
            // 更新重置时间显示
            const nextResetTime = getNextResetTime();
            resetTimeEl.textContent = `重置时间为：${formatResetTime(nextResetTime)}`;
            
        } else {
            balanceEl.textContent = '¥0.00';
            remainingChancesEl.textContent = '2';
            remainingChancesEl.style.color = '#4CAF50';
            const nextResetTime = getNextResetTime();
            resetTimeEl.textContent = `重置时间为：${formatResetTime(nextResetTime)}`;
        }
        
        // 加载交易记录
        await loadTransactionHistory();
        
    } catch (error) {
        console.error('获取钱包信息失败:', error);
        balanceEl.textContent = '¥0.00';
        remainingChancesEl.textContent = '0';
        remainingChancesEl.style.color = '#f44336';
        resetTimeEl.textContent = '重置时间为：--:--';
    }
    
    modal.style.display = 'flex';
}

// 关闭钱包弹窗
function closeWallet() {
    document.getElementById('wallet-modal').style.display = 'none';
}

// 刷新钱包显示（仅在钱包弹窗打开时有效）
async function refreshWalletDisplay() {
    const balanceEl = document.getElementById('wallet-balance');
    if (!balanceEl) return; // 钱包弹窗未打开，无需刷新
    
    try {
        const db = await ensureWalletDB();
        if (!db) {
            balanceEl.textContent = '¥0.00';
            return;
        }
        
        // 强制等待一小段时间，确保数据库操作完成
        await new Promise(resolve => setTimeout(resolve, 50));
        
        const walletRecord = await db.wallet.orderBy('id').first();
        if (walletRecord) {
            balanceEl.textContent = `¥${formatNumber(walletRecord.balance.toFixed(2))}`;
            console.log(`钱包显示已刷新，当前余额: ¥${walletRecord.balance.toFixed(2)}`);
        } else {
            balanceEl.textContent = '¥0.00';
        }
    } catch (error) {
        console.error('刷新钱包显示失败:', error);
        balanceEl.textContent = '¥0.00';
    }
}

// 开始充值游戏
async function startRechargeGame() {
    try {
        const db = await ensureWalletDB();
        if (!db) {
            alert('钱包系统初始化失败，请刷新页面重试');
            return;
        }
        
        let walletRecord = await db.wallet.orderBy('id').first();
        if (!walletRecord) {
            alert('钱包数据获取失败，请刷新页面重试');
            return;
        }
        
        // 检查并更新时间段机会
        walletRecord = await checkAndUpdatePeriodChances(db, walletRecord);
        
        const currentPeriod = getCurrentTimePeriod();
        const currentChances = currentPeriod === 'morning' ? walletRecord.morningChances : walletRecord.afternoonChances;
        
        // 检查当前时间段的游戏机会
        if (currentChances <= 0) {
            const nextResetTime = getNextResetTime();
            const resetTimeStr = formatResetTime(nextResetTime);
            showGameFailed(`您在当前时间段的闯关机会已用完，请等待重置时间：${resetTimeStr}`, nextResetTime.getTime());
            return;
        }
        
        // 关闭钱包弹窗，打开游戏弹窗
        closeWallet();
        window.currentGameRound = 1;
        document.getElementById('current-round').textContent = window.currentGameRound;
        // 显示剩余机会
        const remainingChancesEl = document.getElementById('remaining-chances');
        remainingChancesEl.textContent = Math.max(0, currentChances - 1);
        remainingChancesEl.style.color = '#4CAF50';
        document.getElementById('game-modal').style.display = 'flex';
        
        // 开始第一轮游戏
        startMathGame();
        
    } catch (error) {
        console.error('开始游戏失败:', error);
        alert('游戏启动失败，请稍后重试');
    }
}

// 关闭游戏弹窗
function closeGameModal() {
    document.getElementById('game-modal').style.display = 'none';
    clearGameTimer();
    resetGameState();
}

// 重置游戏状态
function resetGameState() {
    window.currentGameRound = 1;
    window.window.gameScore = 0;
    window.window.gameTimeLeft = 30;
    window.window.musicNoteCount = 0;
    window.window.musicNotesClicked = 0;
    window.window.moleScore = 0;
    window.window.moleHits = 0;
    if (window.window.moleInterval) {
        clearInterval(window.window.moleInterval);
        window.window.moleInterval = null;
    }
}

// 清除游戏计时器
function clearGameTimer() {
    if (window.window.gameTimer) {
        clearInterval(window.window.gameTimer);
        window.window.gameTimer = null;
    }
}

// 第一轮：数学运算游戏
function startMathGame() {
    document.getElementById('game-title').textContent = '第一轮：数学运算';
    
    // 生成复杂的数学题目（包含加减乘除，6个数字，3个操作）
    const numbers = [];
    for (let i = 0; i < 6; i++) {
        numbers.push(Math.floor(Math.random() * 20) + 1);
    }
    
    const operations = ['+', '-', '*', '÷'];
    const selectedOps = [];
    
    // 确保包含加减乘除
    selectedOps.push('+', '-', '*');
    
    // 随机选择第四个操作
    selectedOps.push(operations[Math.floor(Math.random() * 4)]);
    
    // 打乱操作顺序
    for (let i = selectedOps.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [selectedOps[i], selectedOps[j]] = [selectedOps[j], selectedOps[i]];
    }
    
    // 构建题目和计算答案 (使用正确的运算优先级)
    let expression = numbers[0].toString();
    
    for (let i = 0; i < 3; i++) {
        const op = selectedOps[i];
        const num = numbers[i + 1];
        expression += ` ${op} ${num}`;
    }
    
    // 使用eval计算正确答案，但先替换除号为JavaScript除法
    let jsExpression = expression.replace(/÷/g, '/');
    let result = Math.floor(eval(jsExpression));
    
    window.currentMathAnswer = result;
    
    // 生成选项（包含正确答案和3个错误答案）
    const options = [result];
    while (options.length < 4) {
        const wrongAnswer = result + Math.floor(Math.random() * 20) - 10;
        if (!options.includes(wrongAnswer) && wrongAnswer !== result) {
            options.push(wrongAnswer);
        }
    }
    
    // 打乱选项顺序
    for (let i = options.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [options[i], options[j]] = [options[j], options[i]];
    }
    
    const gameContent = document.getElementById('game-content');
    gameContent.innerHTML = `
        <div class="math-question">${expression} = ?</div>
        <div class="math-options">
            ${options.map(option => `
                <div class="math-option" onclick="selectMathAnswer(${option})">${option}</div>
            `).join('')}
        </div>
        <div style="margin-top: 20px; color: #666;">
            <p>请选择正确答案</p>
        </div>
    `;
    
    startGameTimer(16, () => gameFailed('时间到！'));
}

// 选择数学答案
function selectMathAnswer(answer) {
    const options = document.querySelectorAll('.math-option');
    options.forEach(opt => opt.classList.remove('selected'));
    event.target.classList.add('selected');
    
    setTimeout(() => {
        if (answer === window.currentMathAnswer) {
            clearGameTimer();
            window.currentGameRound++;
            if (window.currentGameRound <= 3) {
                startMusicGame();
            }
        } else {
            gameFailed('答案错误！');
        }
    }, 500);
}

// 第二轮：抓音符游戏
function startMusicGame() {
    document.getElementById('game-title').textContent = '第二轮：抓音符';
    document.getElementById('current-round').textContent = window.currentGameRound;
    
    window.musicNoteCount = 0;
    window.musicNotesClicked = 0;
    window.musicComboCount = 0; // 连击计数器
    window.lastNoteClickTime = 0; // 上次点击时间
    const targetNotes = 35; // 增加需要点击的音符数量从25到35
    
    const gameContent = document.getElementById('game-content');
    gameContent.innerHTML = `
        <div class="music-game-area" id="music-game-area">
            <div class="music-score">已抓: <span id="notes-caught">0</span> / ${targetNotes}</div>
            <div id="touch-feedback" style="position: absolute; top: 10px; right: 10px; color: #4CAF50; font-weight: bold; font-size: 14px; opacity: 0; transition: opacity 0.3s;"></div>
        </div>
        <div style="margin-top: 15px; color: #666;">
            <p>在17秒内点击${targetNotes}个音符</p>
            <p style="font-size: 12px; color: #999; margin-top: 5px;">💡 提示：音符更大更好点，支持快速连击</p>
        </div>
    `;
    
    // 开始生成音符 - 无限生成直到时间结束
    const musicArea = document.getElementById('music-game-area');
    window.noteInterval = setInterval(() => {
        createMusicNote(musicArea);
        window.musicNoteCount++;
    }, 350); // 音符生成间隔优化为350ms，提高游戏流畅度
    
    startGameTimer(17, () => {
        clearInterval(window.noteInterval);
        if (window.musicNotesClicked >= targetNotes) {
            clearGameTimer();
            window.currentGameRound++;
            startWhackMoleGame();
        } else {
            gameFailed('未能在时间内抓到足够的音符！');
        }
    });
}

// 创建音符
function createMusicNote(container) {
    const note = document.createElement('div');
    note.className = 'music-note';
    
    // 更多音符样式和颜色
    const noteSymbols = ['🎵', '🎶', '♪', '♫', '🎼', '🖤', '🎧', '🎹', '🎺', '🎸', '🥁', '🎻'];
    const noteColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'];
    
    const randomSymbol = noteSymbols[Math.floor(Math.random() * noteSymbols.length)];
    const randomColor = noteColors[Math.floor(Math.random() * noteColors.length)];
    
    note.innerHTML = randomSymbol;
    note.style.color = randomColor;
    note.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
    note.style.transform = `rotate(${Math.random() * 30 - 15}deg)`;
    
    // 随机选择动画方向
    const animations = ['fallDown', 'flyRight', 'flyLeft', 'flyUp'];
    const randomAnimation = animations[Math.floor(Math.random() * animations.length)];
    
    // 根据动画方向设置初始位置
    switch(randomAnimation) {
        case 'fallDown':
            note.style.left = Math.random() * (container.offsetWidth - 50) + 'px';
            note.style.top = '-50px';
            break;
        case 'flyRight':
            note.style.left = '-50px';
            note.style.top = Math.random() * (container.offsetHeight - 50) + 'px';
            break;
        case 'flyLeft':
            note.style.left = container.offsetWidth + 'px';
            note.style.top = Math.random() * (container.offsetHeight - 50) + 'px';
            break;
        case 'flyUp':
            note.style.left = Math.random() * (container.offsetWidth - 50) + 'px';
            note.style.top = container.offsetHeight + 'px';
            break;
    }
    
    // 应用动画
    note.style.animation = `${randomAnimation} 3s linear`;
    
    // 防重复点击标记
    let noteClicked = false;
    
    // 统一的点击处理函数
    const handleNoteClick = (e) => {
        if (noteClicked) return; // 防止重复触发
        noteClicked = true;
        
        e.preventDefault();
        e.stopPropagation();
        
        // 立即提供视觉反馈，避免延迟感
        note.style.transform += ' scale(1.5)';
        note.style.filter = 'brightness(1.5)';
        note.style.zIndex = '1000';
        
        // 创建点击特效
        const clickEffect = document.createElement('div');
        clickEffect.style.position = 'absolute';
        clickEffect.style.left = note.style.left;
        clickEffect.style.top = note.style.top;
        clickEffect.style.fontSize = '40px';
        clickEffect.style.color = '#FFD700';
        clickEffect.style.fontWeight = 'bold';
        clickEffect.style.textShadow = '0 0 10px #FFD700';
        clickEffect.style.zIndex = '1001';
        clickEffect.style.pointerEvents = 'none';
        clickEffect.style.animation = 'noteClickEffect 0.6s ease-out forwards';
        clickEffect.innerHTML = '✨';
        container.appendChild(clickEffect);
        
        // 播放成功音效（如果需要的话）
        // 注释掉的音效代码，可以根据需要启用
        // try {
        //     const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgzf77w0H4uBjiAzvLWjDUINnlwIH4pA');
        //     audio.volume = 0.3;
        //     audio.play();
        // } catch (e) {}
        
        window.musicNotesClicked++;
        document.getElementById('notes-caught').textContent = window.musicNotesClicked;
        
        // 连击计算
        const currentTime = Date.now();
        if (currentTime - window.lastNoteClickTime < 1000) { // 1秒内算连击
            window.musicComboCount++;
        } else {
            window.musicComboCount = 1;
        }
        window.lastNoteClickTime = currentTime;
        
        // 显示触控反馈
        const touchFeedback = document.getElementById('touch-feedback');
        if (touchFeedback) {
            if (window.musicComboCount > 1) {
                touchFeedback.textContent = `${window.musicComboCount}连击! 🔥`;
                touchFeedback.style.color = window.musicComboCount > 5 ? '#FF5722' : '#4CAF50';
            } else {
                touchFeedback.textContent = `+1 ✨`;
                touchFeedback.style.color = '#4CAF50';
            }
            touchFeedback.style.opacity = '1';
            setTimeout(() => {
                touchFeedback.style.opacity = '0';
            }, 800);
        }
        
        // 延迟移除音符，让特效更明显
        setTimeout(() => {
            if (note.parentNode) {
                note.remove();
            }
        }, 150);
        
        // 清理特效
        setTimeout(() => {
            if (clickEffect.parentNode) {
                clickEffect.remove();
            }
        }, 600);
        
        if (window.musicNotesClicked >= 35) {
            clearGameTimer();
            clearInterval(window.noteInterval);
            window.currentGameRound++;
            startWhackMoleGame();
        }
    };
    
    // 优化事件绑定，提升点击灵敏度
    const fastClickOptions = { passive: false, capture: true };
    
    // 使用多重事件绑定，确保在所有设备上都能快速响应
    note.addEventListener('click', handleNoteClick, fastClickOptions);
    note.addEventListener('touchstart', handleNoteClick, fastClickOptions);
    note.addEventListener('touchend', handleNoteClick, fastClickOptions);
    note.addEventListener('mousedown', handleNoteClick, fastClickOptions);
    note.addEventListener('pointerdown', handleNoteClick, fastClickOptions); // 现代指针事件
    
    // 即时视觉反馈，无延迟
    const addFeedback = () => {
        if (!noteClicked) {
            note.style.transform += ' scale(1.15)';
            note.style.filter = 'brightness(1.3) drop-shadow(0 0 8px currentColor)';
        }
    };
    
    const removeFeedback = () => {
        if (!noteClicked) {
            note.style.transform = note.style.transform.replace(' scale(1.15)', '');
            note.style.filter = 'none';
        }
    };
    
    // 为所有交互事件添加即时反馈
    note.addEventListener('touchstart', addFeedback, { passive: true });
    note.addEventListener('mouseenter', addFeedback, { passive: true });
    note.addEventListener('pointerenter', addFeedback, { passive: true });
    
    note.addEventListener('touchend', removeFeedback, { passive: true });
    note.addEventListener('mouseleave', removeFeedback, { passive: true });
    note.addEventListener('pointerleave', removeFeedback, { passive: true });
    
    container.appendChild(note);
    
    // 3秒后自动移除音符（与动画时间一致，确保完全移动完才消失）
    setTimeout(() => {
        if (note.parentNode) {
            note.remove();
        }
    }, 3000);
}

// 第三轮：打地鼠游戏
function startWhackMoleGame() {
    document.getElementById('game-title').textContent = '第三轮：打地鼠';
    document.getElementById('current-round').textContent = window.currentGameRound;
    
    window.moleHits = 0;
    window.badMoleHits = 0; // 坏地鼠计数
    const targetHits = 12; // 需要打到的好地鼠数量
    const maxBadHits = 4; // 最多容错4个坏地鼠
    
    const gameContent = document.getElementById('game-content');
    gameContent.innerHTML = `
        <div class="mole-score">
            <div>好地鼠: <span id="moles-hit">0</span> / ${targetHits}</div>
            <div style="color: red;">坏地鼠: <span id="bad-moles-hit">0</span> / ${maxBadHits}</div>
        </div>
        <div class="whack-mole-grid">
            ${Array(9).fill(0).map((_, i) => `
                <div class="mole-hole" onclick="hitMole(${i})">
                    <div class="mole" id="mole-${i}">🐹</div>
                </div>
            `).join('')}
        </div>
        <div style="margin-top: 15px; color: #666;">
            <p>在25秒内打到${targetHits}只好地鼠，避免打到坏地鼠（容错${maxBadHits}个）</p>
        </div>
    `;
    
    // 开始随机显示地鼠
    window.moleInterval = setInterval(() => {
        const randomHole = Math.floor(Math.random() * 9);
        const mole = document.getElementById(`mole-${randomHole}`);
        if (mole && !mole.classList.contains('show')) {
            // 30%概率出现坏地鼠
            const isBadMole = Math.random() < 0.3;
            mole.innerHTML = isBadMole ? '🦔' : '🐹'; // 坏地鼠用刺猬表示
            mole.setAttribute('data-bad', isBadMole);
            mole.style.color = isBadMole ? '#ff4444' : '#8B4513';
            
            mole.classList.add('show');
            setTimeout(() => {
                if (mole.classList.contains('show')) {
                    mole.classList.remove('show');
                }
            }, 1000);
        }
    }, 500);
    
    startGameTimer(17, () => {
        clearInterval(window.moleInterval);
        if (window.moleHits >= targetHits && window.badMoleHits < 4) {
            gameSuccess();
        } else if (window.badMoleHits >= 4) {
            gameFailed('打中了太多坏地鼠！');
        } else {
            gameFailed('未能在时间内打到足够的好地鼠！');
        }
    });
}

// 打地鼠
function hitMole(holeIndex) {
    const mole = document.getElementById(`mole-${holeIndex}`);
    if (mole && mole.classList.contains('show')) {
        const isBadMole = mole.getAttribute('data-bad') === 'true';
        const moleHole = mole.parentElement;
        
        // 立即响应，避免延迟感
        mole.style.transform = 'scale(1.3)';
        mole.style.transition = 'all 0.2s ease';
        mole.style.filter = 'brightness(1.5)';
        
        // 创建点击特效容器
        const effectContainer = document.createElement('div');
        effectContainer.style.position = 'absolute';
        effectContainer.style.top = '50%';
        effectContainer.style.left = '50%';
        effectContainer.style.transform = 'translate(-50%, -50%)';
        effectContainer.style.zIndex = '1000';
        effectContainer.style.pointerEvents = 'none';
        moleHole.appendChild(effectContainer);
        
        mole.classList.remove('show');
        
        if (isBadMole) {
            // 打中坏地鼠 - 显示骷髅特效
            window.badMoleHits++;
            document.getElementById('bad-moles-hit').textContent = window.badMoleHits;
            
            // 创建骷髅特效
            const skullEffect = document.createElement('div');
            skullEffect.innerHTML = '💀';
            skullEffect.style.fontSize = '50px';
            skullEffect.style.animation = 'moleErrorEffect 0.8s ease-out forwards';
            skullEffect.style.textShadow = '0 0 15px #ff0000';
            effectContainer.appendChild(skullEffect);
            
            // 让地鼠显示受伤状态
            mole.innerHTML = '😵';
            mole.style.color = '#ff4444';
            mole.style.transform = 'scale(0.8) rotate(15deg)';
            
            setTimeout(() => {
                mole.innerHTML = '🐹';
                mole.style.color = '#8B4513';
                mole.style.transform = 'scale(1)';
                mole.style.filter = 'brightness(1)';
                if (effectContainer.parentNode) {
                    effectContainer.remove();
                }
            }, 800);
            
            if (window.badMoleHits >= 4) {
                clearInterval(window.moleInterval);
                clearGameTimer();
                gameFailed('打中了太多坏地鼠！');
                return;
            }
        } else {
            // 打中好地鼠 - 显示爆炸特效
            window.moleHits++;
            document.getElementById('moles-hit').textContent = window.moleHits;
            
            // 创建爆炸特效
            const explosionEffect = document.createElement('div');
            explosionEffect.innerHTML = '💥';
            explosionEffect.style.fontSize = '50px';
            explosionEffect.style.animation = 'moleSuccessEffect 0.8s ease-out forwards';
            explosionEffect.style.textShadow = '0 0 15px #FFD700';
            effectContainer.appendChild(explosionEffect);
            
            // 让地鼠显示开心状态
            mole.innerHTML = '🥳';
            mole.style.color = '#ffd700';
            mole.style.transform = 'scale(0.9)';
            
            setTimeout(() => {
                mole.innerHTML = '🐹';
                mole.style.color = '#8B4513';
                mole.style.transform = 'scale(1)';
                mole.style.filter = 'brightness(1)';
                if (effectContainer.parentNode) {
                    effectContainer.remove();
                }
            }, 800);
            
            if (window.moleHits >= 12) {
                clearInterval(window.moleInterval);
                clearGameTimer();
                gameSuccess();
            }
        }
    }
}

// 开始游戏计时器
function startGameTimer(seconds, onTimeout) {
    window.gameTimeLeft = seconds;
    document.getElementById('timer-display').textContent = window.gameTimeLeft;
    document.getElementById('game-timer').style.display = 'block';
    
    window.gameTimer = setInterval(() => {
        window.gameTimeLeft--;
        document.getElementById('timer-display').textContent = window.gameTimeLeft;
        
        if (window.gameTimeLeft <= 0) {
            clearInterval(window.gameTimer);
            onTimeout();
        }
    }, 1000);
}

// 游戏成功
async function gameSuccess() {
    closeGameModal();
    
    try {
        const db = await ensureWalletDB();
        if (db) {
            let walletRecord = await db.wallet.orderBy('id').first();
            if (walletRecord) {
                // 检查并更新时间段机会
                walletRecord = await checkAndUpdatePeriodChances(db, walletRecord);
                
                const currentPeriod = getCurrentTimePeriod();
                let updateData = {};
                
                // 扣除当前时间段的机会
                if (currentPeriod === 'morning') {
                    updateData.morningChances = Math.max(0, walletRecord.morningChances - 1);
                } else {
                    updateData.afternoonChances = Math.max(0, walletRecord.afternoonChances - 1);
                }
                
                // 更新gameChances为当前时间段的剩余机会
                updateData.gameChances = currentPeriod === 'morning' ? updateData.morningChances : updateData.afternoonChances;
                
                await db.wallet.update(walletRecord.id, updateData);
            }
        }
    } catch (error) {
        console.error('更新游戏机会失败:', error);
    }
    
    document.getElementById('recharge-success-modal').style.display = 'flex';
}

// 游戏失败
async function gameFailed(message) {
    closeGameModal();
    
    try {
        const db = await ensureWalletDB();
        if (!db) {
            showGameFailed(message, 0);
            return;
        }
        
        let walletRecord = await db.wallet.orderBy('id').first();
        if (!walletRecord) {
            showGameFailed(message, 0);
            return;
        }
        
        // 检查并更新时间段机会
        walletRecord = await checkAndUpdatePeriodChances(db, walletRecord);
        
        const currentPeriod = getCurrentTimePeriod();
        let updateData = {};
        
        // 扣除当前时间段的机会
        if (currentPeriod === 'morning') {
            updateData.morningChances = Math.max(0, walletRecord.morningChances - 1);
        } else {
            updateData.afternoonChances = Math.max(0, walletRecord.afternoonChances - 1);
        }
        
        // 更新gameChances为当前时间段的剩余机会
        updateData.gameChances = currentPeriod === 'morning' ? updateData.morningChances : updateData.afternoonChances;
        
        await db.wallet.update(walletRecord.id, updateData);
        
        // 获取下次重置时间
        const nextResetTime = getNextResetTime();
        const resetTimeStr = formatResetTime(nextResetTime);
        
        // 检查当前时间段是否还有机会
        const remainingChances = currentPeriod === 'morning' ? updateData.morningChances : updateData.afternoonChances;
        
        if (remainingChances <= 0) {
            showGameFailed(`${message}\n\n您在当前时间段的闯关机会已用完，重置时间：${resetTimeStr}`, nextResetTime.getTime());
        } else {
            showGameFailed(`${message}\n\n您在当前时间段还有 ${remainingChances} 次机会`, 0);
        }
        
    } catch (error) {
        console.error('更新游戏机会失败:', error);
        showGameFailed(message, 0);
    }
}

// 显示游戏失败弹窗
function showGameFailed(message, nextChanceTime) {
    // 处理多行消息
    const messageEl = document.getElementById('failed-message');
    messageEl.innerHTML = message.replace(/\n/g, '<br>');
    
    if (nextChanceTime > 0) {
        const recoveryTimeEl = document.getElementById('recovery-time');
        const nextChanceTimeEl = document.getElementById('next-chance-time');
        
        const updateRecoveryTime = () => {
            const now = Date.now();
            const remaining = nextChanceTime - now;
            
            if (remaining <= 0) {
                recoveryTimeEl.textContent = '现在可以重试';
                nextChanceTimeEl.style.display = 'none';
            } else {
                const seconds = Math.ceil(remaining / 1000);
                recoveryTimeEl.textContent = `${seconds}秒后`;
                nextChanceTimeEl.style.display = 'block';
                setTimeout(updateRecoveryTime, 1000);
            }
        };
        
        updateRecoveryTime();
    } else {
        document.getElementById('next-chance-time').style.display = 'none';
    }
    
    document.getElementById('game-failed-modal').style.display = 'flex';
}

// 关闭游戏失败弹窗
function closeGameFailed() {
    document.getElementById('game-failed-modal').style.display = 'none';
    // 跳转到钱包页面而不是退出
    openWallet();
}

// 测试时间段切换功能（开发用）
function testTimePeriodSwitch() {
    console.log('=== 时间段测试 ===');
    console.log('当前时间段:', getCurrentTimePeriod());
    console.log('下次重置时间:', formatResetTime(getNextResetTime()));
    
    // 模拟不同时间
    const testTimes = [
        new Date('2024-01-01 08:00:00'), // 上午
        new Date('2024-01-01 12:00:00'), // 上午最后一刻
        new Date('2024-01-01 12:01:00'), // 下午开始
        new Date('2024-01-01 18:00:00'), // 下午
        new Date('2024-01-01 23:59:00')  // 下午最后一刻
    ];
    
    testTimes.forEach(time => {
        const originalDate = Date;
        global.Date = class extends Date {
            constructor(...args) {
                if (args.length === 0) {
                    return time;
                }
                return new originalDate(...args);
            }
            static now() {
                return time.getTime();
            }
        };
        
        console.log(`时间: ${time.toLocaleString()}`);
        console.log(`  时间段: ${getCurrentTimePeriod()}`);
        console.log(`  重置时间: ${formatResetTime(getNextResetTime())}`);
        
        global.Date = originalDate;
    });
}

// 数字格式化函数（千分位逗号）
function formatNumber(num) {
    // 确保是数字类型
    const number = typeof num === 'string' ? parseFloat(num) : num;
    if (isNaN(number)) return '0.00';
    
    // 使用中文千分位格式化
    return number.toLocaleString('zh-CN', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });
}

// 确认充值
async function confirmRecharge() {
    const amount = parseFloat(document.getElementById('recharge-amount').value);
    
    if (!amount || amount <= 0) {
        alert('请输入有效的充值金额');
        return;
    }
    
    // 添加充值限制 - 单次最多5万
    if (amount > 50000) {
        alert('反贪提醒：余额越多余额越少。');
        return;
    }
    
    try {
        // 使用新的钱包余额更新函数，直接获取更新后的余额
        const result = await updateWalletBalance(amount, '游戏充值', 'recharge_game');
        if (!result.success) {
            alert('充值失败，请稍后重试');
            return;
        }
        
        // 从返回结果中获取当前余额
        const currentBalance = result.newBalance;
        
        // 更新最后游戏时间
        const db = await ensureWalletDB();
        if (db) {
            const walletRecord = await db.wallet.orderBy('id').first();
            if (walletRecord) {
                await db.wallet.update(walletRecord.id, {
                    lastGameTime: Date.now()
                });
            }
        }
        
        // 记录游戏历史
        await db.gameHistory.add({
            timestamp: Date.now(),
            gameType: 'recharge_game',
            result: 'success',
            score: amount
        });
        
        // 修复：直接更新钱包弹窗中的余额显示
        await refreshWalletDisplay();
        
        alert(`充值成功！充值金额：¥${formatNumber(amount.toFixed(2))}，当前余额：¥${formatNumber(currentBalance.toFixed(2))}`);
        closeRechargeSuccess();
        
    } catch (error) {
        console.error('充值失败:', error);
        alert('充值失败，请稍后重试');
    }
}

// 关闭充值成功弹窗
function closeRechargeSuccess() {
    document.getElementById('recharge-success-modal').style.display = 'none';
    document.getElementById('recharge-amount').value = '';
    // 跳转到钱包页面而不是退出
    openWallet();
}


// 添加交易记录
async function addTransaction(type, amount, description, source = 'system') {
    try {
        const db = await ensureWalletDB();
        if (!db) return;
        
        await db.transactions.add({
            timestamp: Date.now(),
            type: type, // 'income' 或 'expense'
            amount: amount,
            description: description,
            source: source
        });
        
        console.log(`交易记录已添加: ${type} ${amount} - ${description}`);
    } catch (error) {
        console.error('添加交易记录失败:', error);
    }
}

// 加载交易记录
async function loadTransactionHistory() {
    try {
        const db = await ensureWalletDB();
        if (!db) return;
        
        const transactions = await db.transactions
            .orderBy('timestamp')
            .reverse()
            .limit(20)
            .toArray();
        
        const transactionList = document.getElementById('transaction-list');
        if (!transactionList) return;
        
        if (transactions.length === 0) {
            transactionList.innerHTML = '<div class="no-transactions">暂无交易记录</div>';
            return;
        }
        
        transactionList.innerHTML = transactions.map(transaction => {
            const date = new Date(transaction.timestamp);
            const timeStr = `${date.getMonth() + 1}/${date.getDate()} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            const amountClass = transaction.type === 'income' ? 'income' : 'expense';
            const amountPrefix = transaction.type === 'income' ? '+' : '-';
            
            return `
                <div class="transaction-item">
                    <div class="transaction-info">
                        <div class="transaction-type">${transaction.description}</div>
                        <div class="transaction-time">${timeStr}</div>
                    </div>
                    <div class="transaction-amount ${amountClass}">
                        ${amountPrefix}¥${formatNumber(transaction.amount.toFixed(2))}
                    </div>
                </div>
            `;
        }).join('');
        
    } catch (error) {
        console.error('加载交易记录失败:', error);
        const transactionList = document.getElementById('transaction-list');
        if (transactionList) {
            transactionList.innerHTML = '<div class="no-transactions">加载失败</div>';
        }
    }
}

// 更新钱包余额并记录交易
async function updateWalletBalance(amount, description, source = 'system') {
    try {
        const db = await ensureWalletDB();
        if (!db) return { success: false, newBalance: 0 };
        
        const walletRecord = await db.wallet.orderBy('id').first();
        if (!walletRecord) return { success: false, newBalance: 0 };
        
        const newBalance = walletRecord.balance + amount;
        if (newBalance < 0) {
            console.warn('余额不足，无法完成交易');
            return { success: false, newBalance: walletRecord.balance };
        }
        
        // 更新余额
        await db.wallet.update(walletRecord.id, {
            balance: newBalance
        });
        
        // 添加交易记录
        const transactionType = amount > 0 ? 'income' : 'expense';
        await addTransaction(transactionType, Math.abs(amount), description, source);
        
        console.log(`钱包余额已更新: ${amount > 0 ? '+' : ''}${amount}, 新余额: ${newBalance}`);
        return { success: true, newBalance: newBalance };
        
    } catch (error) {
        console.error('更新钱包余额失败:', error);
        return { success: false, newBalance: 0 };
    }
}


// 初始化钱包系统
document.addEventListener('DOMContentLoaded', function() {
    initWalletDB();
    
});

// ▲▲▲ 钱包系统JavaScript代码结束 ▲▲▲

// ▼▼▼ 智谱语音识别系统JavaScript代码开始 ▼▼▼

// 智谱语音识别相关变量（全局声明）
var mediaRecorder;
var audioChunks = [];
var isRecording = false;

// 处理录音按钮点击
function handleRecordingClick() {
    console.log('handleRecordingClick 被调用');
    console.log('当前录音状态:', isRecording);
    
    try {
        if (isRecording) {
            console.log('停止录音...');
            stopRecording();
        } else {
            console.log('开始录音...');
            startRecording();
        }
    } catch (error) {
        console.error('录音操作失败:', error);
        showError('录音操作失败: ' + error.message);
    }
}

// 智谱语音识别配置保存和加载
function saveZhipuSpeechSettings() {
    const recognitionMethod = document.getElementById('voice-recognition-method').value;
    const endpoint = document.getElementById('zhipu-speech-endpoint').value;
    const apiKey = document.getElementById('zhipu-speech-api-key').value;
    const model = document.getElementById('zhipu-speech-model').value;
    
    // 保存为独立的localStorage项（向后兼容）
    localStorage.setItem('voice-recognition-method', recognitionMethod);
    localStorage.setItem('zhipu-speech-endpoint', endpoint);
    localStorage.setItem('zhipu-speech-api-key', apiKey);
    localStorage.setItem('zhipu-speech-model', model);
    
    // 同时保存为统一的配置对象（供语音识别功能使用）
    const settings = {
        recognitionMethod: recognitionMethod,
        endpoint: endpoint,
        apiKey: apiKey,
        model: model
    };
    localStorage.setItem('zhipuSpeechSettings', JSON.stringify(settings));
}

function loadZhipuSpeechSettings() {
    const recognitionMethod = localStorage.getItem('voice-recognition-method');
    const endpoint = localStorage.getItem('zhipu-speech-endpoint');
    const apiKey = localStorage.getItem('zhipu-speech-api-key');
    const model = localStorage.getItem('zhipu-speech-model');
    
    if (recognitionMethod) document.getElementById('voice-recognition-method').value = recognitionMethod;
    if (endpoint) document.getElementById('zhipu-speech-endpoint').value = endpoint;
    if (apiKey) document.getElementById('zhipu-speech-api-key').value = apiKey;
    if (model) document.getElementById('zhipu-speech-model').value = model;
}

// 打开语音识别测试弹窗
function openSpeechTestModal() {
    console.log('openSpeechTestModal 函数被调用');
    const modal = document.getElementById('zhipu-speech-test-modal');
    if (!modal) {
        console.error('找不到 zhipu-speech-test-modal 元素');
        return;
    }
    console.log('找到弹窗元素，正在显示');
    modal.style.display = 'block';
    
    // 重置状态
    document.getElementById('speech-status').textContent = '点击下方按钮开始语音识别测试';
    document.getElementById('recognition-result').style.display = 'none';
    document.getElementById('error-message').style.display = 'none';
    
    // 绑定所有弹窗按钮事件
    const recordBtn = document.getElementById('start-recording-btn');
    const closeBtn1 = document.getElementById('close-speech-test-modal');
    const closeBtn2 = document.getElementById('close-test-modal-btn');
    const clearBtn = document.getElementById('clear-result-btn');
    
    // 绑定录音按钮
    if (recordBtn) {
        recordBtn.removeEventListener('click', handleRecordingClick);
        recordBtn.addEventListener('click', handleRecordingClick);
        console.log('录音按钮事件监听器已绑定');
    } else {
        console.error('找不到录音按钮元素');
    }
    
    // 绑定关闭按钮（右上角❌）
    if (closeBtn1) {
        closeBtn1.onclick = function(e) {
            console.log('右上角关闭按钮被点击');
            e.preventDefault();
            e.stopPropagation();
            closeSpeechTestModal();
        };
        console.log('右上角关闭按钮事件已绑定');
    } else {
        console.error('找不到右上角关闭按钮元素');
    }
    
    // 绑定关闭按钮（底部关闭）
    if (closeBtn2) {
        closeBtn2.onclick = function(e) {
            console.log('底部关闭按钮被点击');
            e.preventDefault();
            e.stopPropagation();
            closeSpeechTestModal();
        };
        console.log('底部关闭按钮事件已绑定');
    } else {
        console.error('找不到底部关闭按钮元素');
    }
    
    // 绑定清空结果按钮
    if (clearBtn) {
        clearBtn.onclick = function(e) {
            console.log('清空结果按钮被点击');
            e.preventDefault();
            e.stopPropagation();
            clearSpeechTestResult();
        };
        console.log('清空结果按钮事件已绑定');
    } else {
        console.error('找不到清空结果按钮元素');
    }
    
    // 绑定点击弹窗外部关闭事件
    modal.onclick = function(e) {
        if (e.target === modal) {
            console.log('点击弹窗外部，关闭弹窗');
            closeSpeechTestModal();
        }
    };
}

// 关闭语音识别测试弹窗
function closeSpeechTestModal() {
    console.log('closeSpeechTestModal 函数被调用');
    const modal = document.getElementById('zhipu-speech-test-modal');
    if (modal) {
        modal.style.display = 'none';
        console.log('弹窗已关闭');
    } else {
        console.error('找不到弹窗元素');
    }
    
    // 如果正在录音，停止录音
    if (isRecording) {
        stopRecording();
    }
}

// 显示错误信息
function showError(message) {
    const errorEl = document.getElementById('error-message');
    errorEl.textContent = message;
    errorEl.style.display = 'block';
    
    document.getElementById('recognition-result').style.display = 'none';
}

// 显示识别结果
function showResult(text) {
    const resultEl = document.getElementById('recognition-result');
    const textEl = document.getElementById('recognition-text');
    
    textEl.textContent = text;
    resultEl.style.display = 'block';
    
    document.getElementById('error-message').style.display = 'none';
}

// 开始录音
async function startRecording() {
    try {
        const recognitionMethod = document.getElementById('voice-recognition-method').value;
        
        // 如果是谷歌识别，不需要检查API密钥
        if (recognitionMethod === 'google') {
            const startBtn = document.getElementById('start-recording-btn');
            const indicator = document.getElementById('recording-indicator');
            const status = document.getElementById('speech-status');
            
            startBtn.classList.add('recording');
            startBtn.textContent = '🖤';
            indicator.style.display = 'block';
            status.textContent = '正在使用谷歌识别语音，请说话...';
            
            await processVoiceWithGoogle();
            
            startBtn.classList.remove('recording');
            startBtn.textContent = '🖤';
            indicator.style.display = 'none';
            return;
        }
        
        // 智谱识别需要检查API密钥
        const apiKey = document.getElementById('zhipu-speech-api-key').value;
        
        if (!apiKey) {
            showError('请先在API设置中配置智谱语音识别的API密钥。\n\n测试步骤：\n1. 在上方"智谱语音识别API密钥"输入框中填入你的API密钥\n2. 点击"保存设置"\n3. 再次点击麦克风按钮开始录音');
            return;
        }
        
        if (!/^[a-zA-Z0-9._-]+$/.test(apiKey)) {
            showError('API Key格式错误：只能包含英文字母、数字、点号、下划线和连字符\n\n请检查是否包含中文字符或其他特殊符号');
            return;
        }
        
        const startBtn = document.getElementById('start-recording-btn');
        const indicator = document.getElementById('recording-indicator');
        const status = document.getElementById('speech-status');
        
        startBtn.classList.add('recording');
        startBtn.textContent = '🖤';
        indicator.style.display = 'block';
        status.textContent = '正在使用智谱API识别语音，请说话...';
        
        await processVoiceWithZhipuApi();
        
        startBtn.classList.remove('recording');
        startBtn.textContent = '🖤';
        indicator.style.display = 'none';
        
    } catch (error) {
        console.error('录音启动失败:', error);
        showError('无法启动录音，请检查麦克风权限: ' + error.message);
    }
}

// 停止录音
function stopRecording() {
    if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
        isRecording = false;
        
        // 更新UI
        const startBtn = document.getElementById('start-recording-btn');
        const indicator = document.getElementById('recording-indicator');
        const status = document.getElementById('speech-status');
        
        startBtn.classList.remove('recording');
        startBtn.textContent = '🎙️';
        indicator.style.display = 'none';
        status.textContent = '正在处理语音，请稍候...';
    }
}

// 使用Web Speech API进行实时语音识别
function startWebSpeechRecognition(language) {
    return new Promise((resolve, reject) => {
        // 检查浏览器是否支持Web Speech API
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
            reject(new Error('浏览器不支持语音识别功能，请使用Chrome、Edge或Safari浏览器'));
            return;
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        
        // 配置语音识别
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;
        
        // 设置语言
        switch(language) {
            case 'zh':
                recognition.lang = 'zh-CN';
                break;
            case 'en':
                recognition.lang = 'en-US';
                break;
            case 'ja':
                recognition.lang = 'ja-JP';
                break;
            case 'ko':
                recognition.lang = 'ko-KR';
                break;
            default:
                recognition.lang = 'zh-CN';
        }
        
        // 处理识别结果
        recognition.onresult = function(event) {
            if (event.results.length > 0) {
                const transcript = event.results[0][0].transcript;
                console.log('语音识别结果:', transcript);
                resolve(transcript);
            } else {
                reject(new Error('未识别到语音内容'));
            }
        };
        
        recognition.onerror = function(event) {
            console.error('语音识别错误:', event.error);
            reject(new Error(`语音识别错误: ${event.error}`));
        };
        
        recognition.onend = function() {
            console.log('语音识别结束');
        };
        
        // 开始识别
        try {
            recognition.start();
            console.log('开始语音识别...');
        } catch (error) {
            reject(new Error('启动语音识别失败: ' + error.message));
        }
    });
}

// 纯谷歌语音识别（不调用智谱API）
async function processVoiceWithGoogle() {
    try {
        // 使用自动检测语言（谷歌会自动识别）
        const language = 'auto';
        
        console.log('开始谷歌语音识别...');
        console.log('语言: 自动检测');
        
        const speechText = await startWebSpeechRecognition(language);
        
        if (!speechText || speechText.trim() === '') {
            throw new Error('语音识别结果为空，请重新录音');
        }
        
        console.log('谷歌语音识别结果:', speechText);
        
        // 只显示识别结果，不调用任何AI
        showResult(`🎙️ 语音识别结果:\n\n${speechText}`);
        document.getElementById('speech-status').textContent = '识别完成！点击按钮可以重新录音';
        
    } catch (error) {
        console.error('谷歌语音识别失败:', error);
        
        if (error.message.includes('不支持')) {
            showError('❌ 浏览器不支持语音识别\n\n请使用Chrome、Edge或Safari浏览器');
        } else {
            showError('语音识别失败: ' + error.message);
        }
        document.getElementById('speech-status').textContent = '识别失败，点击按钮重新录音';
    }
}

async function processVoiceWithZhipuApi() {
    try {
        const endpoint = document.getElementById('zhipu-speech-endpoint').value;
        const apiKey = document.getElementById('zhipu-speech-api-key').value;
        const model = document.getElementById('zhipu-speech-model').value;
        
        console.log('开始智谱API语音识别...');
        console.log('端点:', endpoint);
        console.log('模型:', model);
        
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // 创建音频分析器用于检测音量
        const volumeAudioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = volumeAudioContext.createAnalyser();
        const microphone = volumeAudioContext.createMediaStreamSource(stream);
        microphone.connect(analyser);
        analyser.fftSize = 512;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'audio/webm;codecs=opus'
        });
        
        const audioChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                audioChunks.push(event.data);
            }
        };
        
        mediaRecorder.start();
        
        // 🔥 智能静音检测（与主功能保持一致）
        const SILENCE_THRESHOLD = 15;      // 静音音量阈值（0-255）
        const SILENCE_DURATION = 2500;     // 连续静音多久算结束（毫秒）- 2.5秒
        const MAX_RECORDING_TIME = 60000;  // 最长录音时间（60秒）
        const MIN_RECORDING_TIME = 500;    // 最短录音时间（0.5秒）
        
        let silenceStart = null;
        let recordingStartTime = Date.now();
        let hasSpeech = false;
        
        console.log('🎤 开始智能录音，等待语音输入...');
        
        // 检测音量的循环
        await new Promise((resolve) => {
            const checkVolume = () => {
                const now = Date.now();
                const recordingTime = now - recordingStartTime;
                
                // 获取当前音量
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                
                // 检测是否有语音
                if (average > SILENCE_THRESHOLD) {
                    hasSpeech = true;
                    silenceStart = null;
                } else {
                    // 静音状态
                    if (hasSpeech && !silenceStart) {
                        silenceStart = now;
                        console.log('🤫 开始静音，音量:', average.toFixed(2));
                    }
                }
                
                // 判断是否应该停止录音
                const shouldStop = 
                    (hasSpeech && silenceStart && (now - silenceStart) >= SILENCE_DURATION) ||
                    (recordingTime >= MAX_RECORDING_TIME);
                
                if (shouldStop && recordingTime >= MIN_RECORDING_TIME) {
                    console.log('✅ 录音结束，总时长:', (recordingTime / 1000).toFixed(1), '秒');
                    resolve();
                } else {
                    setTimeout(checkVolume, 50);
                }
            };
            
            checkVolume();
        });
        
        mediaRecorder.stop();
        
        // 关闭音频分析器
        microphone.disconnect();
        analyser.disconnect();
        volumeAudioContext.close();
        
        stream.getTracks().forEach(track => track.stop());
        
        const audioBlob = await new Promise((resolve) => {
            mediaRecorder.onstop = () => {
                const blob = new Blob(audioChunks, { type: 'audio/webm' });
                resolve(blob);
            };
        });
        
        console.log('录音完成，音频大小:', audioBlob.size, 'bytes');
        
        // 将WebM转换为WAV格式（智谱API支持）
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await audioBlob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        console.log('原始音频信息 - 声道数:', audioBuffer.numberOfChannels, '采样率:', audioBuffer.sampleRate);
        
        // 转换为WAV格式（单声道16kHz）
        const wavBlob = audioBufferToWav(audioBuffer);
        console.log('音频转换为WAV完成 - 大小:', wavBlob.size, 'bytes, 格式: 单声道16kHz 16位PCM');
        
        // 判断使用哪种API方式
        let speechText = '';
        const isVoiceModel = model.toLowerCase().includes('voice');
        
        if (isVoiceModel) {
            // GLM-4-Voice: 使用 /chat/completions 端点，只让它转录不回复
            console.log('使用GLM-4-Voice模型进行语音识别（纯转录模式）');
            
            const chatEndpoint = endpoint.includes('/audio/transcriptions')
                ? endpoint.replace('/audio/transcriptions', '/chat/completions')
                : endpoint;
            
            // 将音频转为base64
            const base64Audio = await blobToBase64(wavBlob);
            
            const voiceResponse = await fetch(chatEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: model,
                    messages: [{
                        role: 'user',
                        content: [{
                            type: 'audio',
                            audio: base64Audio
                        }]
                    }],
                    // 让它只转录，不生成额外回复
                    temperature: 0.1,
                    max_tokens: 100
                })
            });
            
            console.log('GLM-4-Voice响应状态:', voiceResponse.status);
            
            if (!voiceResponse.ok) {
                let errorMessage = `GLM-4-Voice请求失败: ${voiceResponse.status}`;
                try {
                    const errorData = await voiceResponse.text();
                    console.error('API错误详情:', errorData);
                    errorMessage += `\n详细信息: ${errorData}`;
                } catch (e) {}
                throw new Error(errorMessage);
            }
            
            const voiceResult = await voiceResponse.json();
            console.log('GLM-4-Voice识别结果:', voiceResult);
            
            // 从Voice模型提取文本
            if (voiceResult.choices && voiceResult.choices[0]?.message?.content) {
                speechText = voiceResult.choices[0].message.content;
            } else {
                throw new Error('GLM-4-Voice未返回识别文本');
            }
            
        } else {
            // glm-asr 或其他: 使用 /audio/transcriptions 端点
            console.log('使用ASR模型进行语音识别:', model);
            
            const audioEndpoint = endpoint.includes('/chat/completions') 
                ? endpoint.replace('/chat/completions', '/audio/transcriptions')
                : endpoint.replace(/\/$/, '') + '/audio/transcriptions';
            
            console.log('语音识别端点:', audioEndpoint);
            
            const formData = new FormData();
            formData.append('file', wavBlob, 'audio.wav');
            formData.append('model', model || 'glm-asr');
            
            console.log('FormData内容:');
            console.log('- file: audio.wav, 大小:', wavBlob.size);
            console.log('- model:', model || 'glm-asr');
            
            const response = await fetch(audioEndpoint, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`
                },
                body: formData
            });
            
            console.log('收到响应，状态码:', response.status, response.statusText);
            
            if (!response.ok) {
                let errorMessage = `API请求失败: ${response.status} ${response.statusText}`;
                try {
                    const errorData = await response.text();
                    console.error('API错误详情:', errorData);
                    errorMessage += `\n详细信息: ${errorData}`;
                } catch (e) {
                    console.error('无法读取错误详情:', e);
                }
                throw new Error(errorMessage);
            }
            
            const result = await response.json();
            console.log('识别结果:', result);
            
            if (result.text) {
                speechText = result.text;
            } else if (result.data && result.data.text) {
                speechText = result.data.text;
            } else {
                throw new Error('无法从响应中提取识别文本');
            }
        }
        
        console.log('语音识别结果:', speechText);
        
        // 只显示识别结果，不调用AI对话
        showResult(`🎤 语音识别成功！\n\n识别内容: ${speechText}`);
        document.getElementById('speech-status').textContent = '识别完成！点击按钮可以重新录音';
        
    } catch (error) {
        console.error('智谱API语音识别失败:', error);
        
        if (error.message.includes('网络错误') || error.message.includes('500') || error.message.includes('1234') || error.message.includes('1214')) {
            showError(`❌ 智谱AI 语音识别失败\n\n📋 错误详情：${error.message}\n\n💡 可能的原因：\n1. ❌ 模型名称错误（请使用：glm-asr 或 GLM-4-Voice）\n2. ❌ API密钥无效或权限不足\n3. ❌ 账户余额不足\n4. ❌ 音频格式不支持\n5. ❌ 网络连接问题\n\n🔧 解决方法：\n1. 检查模型名称（推荐使用 glm-asr）\n2. 在智谱AI开放平台确认API密钥和余额\n3. 等待1-2分钟后重试`);
            document.getElementById('speech-status').textContent = '语音识别失败，请检查配置';
        } else if (error.message.includes('401')) {
            showError(`🔑 API密钥验证失败\n\n请检查：\n1. API密钥是否正确\n2. 密钥是否已激活\n3. 密钥格式是否完整（sk-开头）`);
            document.getElementById('speech-status').textContent = 'API密钥验证失败';
        } else if (error.message.includes('403')) {
            showError(`⛔ 没有权限访问此模型\n\n请检查：\n1. 模型名称是否正确（推荐：glm-asr）\n2. API密钥是否有权限使用此模型\n3. 账户是否已实名认证`);
            document.getElementById('speech-status').textContent = '模型访问权限不足';
        } else {
            showError('语音识别失败: ' + error.message);
            document.getElementById('speech-status').textContent = '识别失败，点击按钮重新录音';
        }
    }
}

// 将Blob转为base64字符串
async function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            // 移除data:audio/wav;base64,前缀
            const base64 = reader.result.split(',')[1];
            resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

// 将AudioBuffer转换为WAV格式的Blob（单声道16kHz）
function audioBufferToWav(buffer) {
    // 智谱API要求：单声道、16kHz、16位
    const targetSampleRate = 16000;
    const numberOfChannels = 1; // 单声道
    const format = 1; // PCM
    const bitDepth = 16;
    
    // 如果是多声道，混合为单声道
    let channelData;
    if (buffer.numberOfChannels > 1) {
        // 混合所有声道为单声道
        const left = buffer.getChannelData(0);
        const right = buffer.getChannelData(1);
        channelData = new Float32Array(left.length);
        for (let i = 0; i < left.length; i++) {
            channelData[i] = (left[i] + right[i]) / 2;
        }
    } else {
        channelData = buffer.getChannelData(0);
    }
    
    // 重采样到16kHz
    const resampledData = resampleAudio(channelData, buffer.sampleRate, targetSampleRate);
    
    const bytesPerSample = bitDepth / 8;
    const blockAlign = numberOfChannels * bytesPerSample;
    const dataLength = resampledData.length * bytesPerSample;
    const buffer_array = new ArrayBuffer(44 + dataLength);
    const view = new DataView(buffer_array);
    
    // RIFF chunk descriptor
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + dataLength, true);
    writeString(view, 8, 'WAVE');
    
    // FMT sub-chunk
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true); // fmt chunk size
    view.setUint16(20, format, true);
    view.setUint16(22, numberOfChannels, true);
    view.setUint32(24, targetSampleRate, true);
    view.setUint32(28, targetSampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);
    
    // data sub-chunk
    writeString(view, 36, 'data');
    view.setUint32(40, dataLength, true);
    
    // Write PCM samples
    floatTo16BitPCM(view, 44, resampledData);
    
    return new Blob([buffer_array], { type: 'audio/wav' });
}

// 重采样音频数据
function resampleAudio(audioData, originalSampleRate, targetSampleRate) {
    if (originalSampleRate === targetSampleRate) {
        return audioData;
    }
    
    const sampleRateRatio = originalSampleRate / targetSampleRate;
    const newLength = Math.round(audioData.length / sampleRateRatio);
    const result = new Float32Array(newLength);
    
    for (let i = 0; i < newLength; i++) {
        const position = i * sampleRateRatio;
        const index = Math.floor(position);
        const fraction = position - index;
        
        if (index + 1 < audioData.length) {
            // 线性插值
            result[i] = audioData[index] * (1 - fraction) + audioData[index + 1] * fraction;
        } else {
            result[i] = audioData[index];
        }
    }
    
    return result;
}

function interleave(channelData) {
    const length = channelData[0].length;
    const numberOfChannels = channelData.length;
    const result = new Float32Array(length * numberOfChannels);
    
    let inputIndex = 0;
    for (let i = 0; i < length; i++) {
        for (let channel = 0; channel < numberOfChannels; channel++) {
            result[inputIndex++] = channelData[channel][i];
        }
    }
    return result;
}

function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

function floatTo16BitPCM(view, offset, input) {
    for (let i = 0; i < input.length; i++, offset += 2) {
        const s = Math.max(-1, Math.min(1, input[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
}

// 清空识别结果
function clearSpeechTestResult() {
    console.log('clearSpeechTestResult 函数被调用');
    const resultEl = document.getElementById('recognition-result');
    const errorEl = document.getElementById('error-message');
    const statusEl = document.getElementById('speech-status');
    
    if (resultEl) {
        resultEl.style.display = 'none';
        console.log('识别结果已清空');
    }
    if (errorEl) {
        errorEl.style.display = 'none';
        console.log('错误信息已清空');
    }
    if (statusEl) {
        statusEl.textContent = '点击下方按钮开始语音识别测试';
        console.log('状态文本已重置');
    }
}

// 初始化智谱语音识别系统
document.addEventListener('DOMContentLoaded', function() {
    console.log('智谱语音识别系统开始初始化');
    
    
    // 注意：已改为手动输入模型名称，无需自动拉取
    console.log('智谱AI模型：使用手动输入方式（默认：GLM-4-Voice）');
    
    // 延迟绑定按钮事件，确保DOM完全加载
    setTimeout(function() {
        console.log('开始查找测试按钮...');
        const testBtn = document.getElementById('test-zhipu-speech-btn');
        if (!testBtn) {
            console.error('找不到 test-zhipu-speech-btn 按钮');
            console.log('当前页面所有按钮:', document.querySelectorAll('button'));
            return;
        }
        console.log('找到测试按钮:', testBtn);
        console.log('按钮样式:', testBtn.style.cssText);
        console.log('按钮是否可见:', testBtn.offsetWidth > 0 && testBtn.offsetHeight > 0);
        
        testBtn.addEventListener('click', function(e) {
            console.log('测试按钮被点击，事件对象:', e);
            e.preventDefault();
            e.stopPropagation();
            openSpeechTestModal();
        });
        
        // 也尝试使用onclick属性
        testBtn.onclick = function(e) {
            console.log('通过onclick属性触发');
            openSpeechTestModal();
        };
        
        console.log('事件监听器绑定完成');
    }, 100);
    
    // 添加全局调试函数
    window.debugSpeechTest = function() {
        console.log('手动调试测试');
        const btn = document.getElementById('test-zhipu-speech-btn');
        console.log('按钮元素:', btn);
        if (btn) {
            console.log('按钮位置:', btn.getBoundingClientRect());
            console.log('按钮父元素:', btn.parentElement);
            openSpeechTestModal();
        }
    };
    
    // 弹窗事件绑定已移至 openSpeechTestModal 函数中
    console.log('弹窗事件将在打开弹窗时动态绑定');
});


// 全局测试函数
window.testSpeechModal = function() {
    console.log('全局测试函数被调用');
    try {
        openSpeechTestModal();
        console.log('弹窗函数调用成功');
    } catch (error) {
        console.error('弹窗函数调用失败:', error);
    }
};


// ▲▲▲ 智谱语音识别系统JavaScript代码结束 ▲▲▲

</script>
<!-- ▼▼▼ 这是我们新加的隐藏文件选择器 ▼▼▼ -->
<input type="file" id="character-card-input" accept=".png, .json" style="display: none;">
<!-- ▲▲▲ 文件选择器结束 ▲▲▲ -->

<!-- 顶部通知 -->
<div id="top-notification" class="top-notification"></div>

<script>
// ========================================
// 🖼️ NAI图片三击下载功能（非入侵式）
// ========================================
// 功能：为所有NAI图片（realimag-image、naiimag-image）添加三击下载功能
// 适用场景：群聊、私聊、动态、测试弹窗等所有显示NAI图片的地方
// 实现方式：事件委托，不修改任何现有代码
// 触发方式：在图片上快速点击三次
// ========================================

(function() {
    'use strict';
    
    // 下载图片的核心函数
    function downloadImage(imageSrc, filename) {
        try {
            // 创建一个隐藏的下载链接
            const link = document.createElement('a');
            link.href = imageSrc;
            link.download = filename;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();  // 触发下载
            
            // 短暂延迟后移除链接
            setTimeout(() => {
                document.body.removeChild(link);
            }, 100);
            
            console.log('✅ [NAI下载] 开始下载图片:', filename);
            
            // 显示下载提示
            showDownloadToast();
        } catch (error) {
            console.error('❌ [NAI下载] 下载失败:', error);
            showDownloadToast('下载失败，请重试', 'error');
        }
    }
    
    // 显示下载提示（临时Toast）
    function showDownloadToast(message = '📥 图片下载中...', type = 'success') {
        const toast = document.createElement('div');
        toast.textContent = message;
        toast.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: ${type === 'success' ? '#4CAF50' : '#f44336'};
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
        `;
        
        document.body.appendChild(toast);
        
        // 动画进入
        setTimeout(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateY(0)';
        }, 10);
        
        // 2秒后淡出并移除
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateY(-20px)';
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 2000);
    }
    
    // 生成智能文件名
    function generateFilename(imgElement) {
        // 尝试从title属性获取prompt（用于文件名）
        const title = imgElement.getAttribute('title') || imgElement.getAttribute('alt') || '';
        
        // 清理title，提取前30个有效字符
        let cleanTitle = title
            .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_')  // 保留中英文字母数字和空格
            .replace(/\s+/g, '_')  // 空格转下划线
            .substring(0, 30);
        
        if (!cleanTitle) {
            cleanTitle = 'NAI_Image';
        }
        
        // 添加时间戳（精确到秒）
        const timestamp = new Date().toISOString()
            .replace(/[-:]/g, '')
            .replace('T', '_')
            .split('.')[0];  // 格式：20250124_123045
        
        // 生成文件名
        return `${cleanTitle}_${timestamp}.png`;
    }
    
    // 为图片添加双击时的视觉反馈
    function addVisualFeedback(imgElement) {
        const originalTransform = imgElement.style.transform || '';
        const originalTransition = imgElement.style.transition || '';
        
        // 添加缩放动画
        imgElement.style.transition = 'transform 0.15s ease';
        imgElement.style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            imgElement.style.transform = originalTransform;
            setTimeout(() => {
                imgElement.style.transition = originalTransition;
            }, 150);
        }, 150);
    }
    
    // 三击检测相关变量
    let clickCount = 0;
    let clickTimer = null;
    let lastClickedElement = null;
    
    // 全局事件监听器（事件委托 - 三击触发）
    document.addEventListener('click', function(e) {
        const target = e.target;
        
        // 检查是否是NAI图片（realimag-image 或 naiimag-image）
        if (target.tagName === 'IMG' && 
            (target.classList.contains('realimag-image') || 
             target.classList.contains('naiimag-image'))) {
            
            // 如果点击的是同一个元素，增加计数
            if (target === lastClickedElement) {
                clickCount++;
            } else {
                // 点击了不同的元素，重置计数
                clickCount = 1;
                lastClickedElement = target;
            }
            
            // 清除之前的定时器
            if (clickTimer) {
                clearTimeout(clickTimer);
            }
            
            // 如果达到三击
            if (clickCount === 3) {
                // 重置计数
                clickCount = 0;
                lastClickedElement = null;
                
                // 阻止默认行为和事件冒泡
                e.preventDefault();
                e.stopPropagation();
                
                console.log('🖼️ [NAI下载] 检测到三击NAI图片');
                
                // 添加视觉反馈
                addVisualFeedback(target);
                
                // 获取图片源（可能是base64或URL）
                const imageSrc = target.src;
                
                if (!imageSrc || imageSrc === 'about:blank') {
                    console.warn('⚠️ [NAI下载] 图片源为空，无法下载');
                    showDownloadToast('图片加载中，请稍后重试', 'error');
                    return;
                }
                
                // 生成文件名
                const filename = generateFilename(target);
                
                // 触发下载
                downloadImage(imageSrc, filename);
            } else {
                // 设置定时器，500ms后重置计数（如果用户停止点击）
                clickTimer = setTimeout(() => {
                    clickCount = 0;
                    lastClickedElement = null;
                }, 500);
            }
        }
    }, true);  // 使用捕获阶段，确保优先处理
    
    console.log('✅ [NAI下载] 三击下载功能已初始化');
    console.log('💡 [NAI下载] 提示：三击任意NAI图片即可下载');
})();

</script>

</body>
</html>

